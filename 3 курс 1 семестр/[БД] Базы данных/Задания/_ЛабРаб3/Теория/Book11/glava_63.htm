<html>
<head>
<title>15.3. Агрегатные функции и результаты запросов</title>
		    <style type="text/css">
A.noneline { font-family: Arial, Serif; text-decoration: none; }
FONT.arial { font-family: Arial, Serif; }
TD.arial   { font-family: Arial, Serif; }
TH.arial   { font-family: Arial, Serif; }
PRE        { font-family: Monospace; color: navy; }
SAMP       { font-family: Monospace; color: navy; }
TT         { font-family: Monospace; color: navy; }
VAR        { font-family: Monospace; color: navy; }
</style>
</head>
<body bgcolor="#FFF5EE" text="#000000" link="#FF0000" alink="#FF0000" vlink="#A52A2A">
<basefont size="3">
<center>
<table width=100% border=0 cellpadding=0>
<tr valign=top><td class=arial><a href="http://www.citforum.ru/"><img height=50 width=150 src="_pic_/logo3D.gif" alt="Server for Information Technologies" border=0></a><br>
</td>
<td align=right class=arial>
<font size="-2">
Сервер поддерживается<br>
<a class=noneline href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a class=noneline href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM'">info@citforum.ru</a></font>
</tr>
<tr>
<th colspan=2 class=arial>
<font color=#000080 size=2><a href="http://www.citforum.ru" class=noneline>Сервер Информационных Технологий</a> содержит море(!) аналитической информации</font>
<hr noshade>
</th>
</tr>
</table>
</center>
<h4><a name="_5_3_3">15.3. Агрегатные функции и результаты запросов</a></h4>
<p>
Агрегатные функции (в стандарте SQL/89 они называются функциями над множествами) определяются в SQL/89 следующими синтаксическими правилами:
<pre>&lt;set function specification&gt; ::=
   COUNT(*) | &lt;distinct set function&gt;
            | &lt;all set function&gt;
&lt;distinct set function&gt; ::=
   { AVG | MAX | MIN | SUM | COUNT }
    (DISTNICT &lt;column specification&gt;)
&lt;all set function&gt; ::=
   { AVG | MAX | MIN | SUM } ([ALL] &lt;value expression&gt;)</pre>
<p>
Как видно из этих правил, в стандарте SQL/89 определены пять стандартных агрегатных функций: COUNT - число строк или значений, MAX - максимальное значение, MIN - минимальное значение, SUM - суммарное значение и AVG - среднее значение.
<h5><a name="_5_3_3_1">15.3.1. Семантика агрегатных функций</a></h5>
<p>
Агрегатные функции предназначены для того, чтобы вычислять некоторое значение для заданного множества строк. Таким множеством строк может быть группа строк, если агрегатная функция применяется к сгруппированной таблице, или вся таблица. Для всех агрегатных функций, кроме COUNT(*), фактический (т.е. требуемый семантикой) порядок вычислений следующий: на основании параметров агрегатной функции из заданного множества строк производится список значений. Затем по этому списку значений производится вычисление функции. Если список оказался пустым, то значение функции COUNT для него есть 0, а значение всех остальных функций - null.
<p>
Пусть T обозначает тип значений из этого списка. Тогда результат вычисления функции COUNT - точное число с масштабом и точностью, определяемыми в реализации. Тип результата значений функций MAX и MIN совпадает с T. При вычислении функций SUM и AVG тип T не должен быть типом символьных строк, а тип результата функции - это тип точных чисел с определяемыми в реализации масштабом и точностью, если T - тип точных чисел, и тип приблизительных чисел с определяемой в реализации точностью, если T - тип приблизительных чисел.
<p>
Вычисление функции COUNT(*) производится путем подсчета числа строк в заданном множестве. Все строки считаются различными, даже если они состоят из одного столбца со значением null во всех строках.
<p>
Если агрегатная функция специфицирована с ключевым словом DISTINCT, то список значений строится из значений указанного столбца. (Подчеркнем, что в этом случае не допускается вычисление арифметических выражений!) Далее из этого списка удаляются неопределенные значения, и в нем устраняются значения-дубликаты. Затем вычисляется указанная функция.
<p>
Если агрегатная функция специфицирована без ключевого слова DISTINCT (или с ключевым словом ALL), то список значений формируется из значений арифметического выражения, вычисляемого для каждой строки заданного множества. Далее из списка удаляются неопределенные значения, и производится вычисление агрегатной функции. Обратите внимание, что в этом случае не допускается применение функции COUNT!
<p>
Замечание: оба ограничения, указанные в двух предыдущих абзацах, являются более техническими, чем принципиальными, и могут отсутствовать в конкретных реализациях. Тем не менее, это ограничения стандарта SQL/89, и их нужно придерживаться при мобильном программировании.
<h5><a name="_5_3_3_2">15.3.2. Результаты запросов</a></h5>
<p>
Агрегатные функции можно разумно использовать в спецификации курсора, операторе выборки и подзапросе после ключевого слова SELECT (будем называть в этом подразделе все такие конструкции списком выборки, не забывая о том, что в случае подзапроса этот список состоит только из одного элемента), и в условии выборки раздела HAVING. Стандарт допускает более экзотические использования агрегатных функций в подзапросах (агрегатная функция на группе кортежей внешнего запроса), но на практике они встречаются очень редко.
<p>
Рассмотрим различные случаи применения агрегатных функций в списке выборки в зависимости от вида табличного выражения.
<p>
Если результат табличного выражения R не является сгруппированной таблицей, то появление хотя бы одной агрегатной функции от множества строк R в списке выборки приводит к тому, что R неявно рассматривается как сгруппированная таблица, состоящая из одной (или нуля) групп с отсутствующими столбцами группирования. Поэтому в этом случае в списке выборки не допускается прямое использование спецификаций строк R: все они должны находиться внутри спецификаций агрегатных функций. Результатом запроса является таблица, состоящая не более чем из одной строки, полученной путем применения агрегатных функций к R.
<p>
Аналогично обстоит дело в том случае, когда R представляет собой сгруппированную таблицу, но табличное выражение не содержит раздела GROUP BY (и, следовательно, содержит раздел HAVING). Если в случае предыдущего абзаца было два варианта формирования списка выборки: только с прямым указанием столбцов R или только с указанием их внутри спецификаций агрегатных функций, то в данном случае возможен только второй вариант. Результат табличного выражения явно объявлен сгруппированной таблицей, состоящей из одной группы, и результат запроса можно формировать только путем применения агрегатных функций к этой группе строк. Опять результатом запроса является таблица, состоящая не более чем из одной строки, полученной путем применения агрегатных функций к R.
<p>
Наконец, рассмотрим случай, когда R представляет собой &quot;настоящую&quot; сгруппированную таблицу, т.е. табличное выражение содержит раздел GROUP BY и, следовательно, определен по крайней мере один столбец группирования. В этом случае правила формирования списка выборки полностью соответствуют правилам формирования условия выборки раздела HAVING: допускает прямое использование спецификации столбцов группирования, а спецификации остальных столбцов R могут появляться только внутри спецификаций агрегатных функций. Результатом запроса является таблица, число строк в которой равно числу групп в R, и каждая строка формируется на основе значений столбцов группирования и агрегатных функций для данной группы.
<p><center><a href="glava_62.htm">Предыдущая глава</a> || <a href="contents.htm">Оглавление</a> || <a href="glava_64.htm">Следующая глава</a><p>
<p></p>
<hr noshade>
<center>
<font size=1 class=arial>
Comments: <a href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM'" class=noneline>info@citmgu.ru</a><br>
Copyright &copy; <a href="http://www.citmgu.ru/" class=noneline>CIT</a>
</font></center></body></html>
