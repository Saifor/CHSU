CODE SEGMENT
  ASSUME DS:CODE
	org 100h 
Start: 
mov dx, offset fname 
mov al, 0
mov ah, 3dh  ; функция открытия файла
int 21h      ; открытие файла
mov handle_opened_file, al ; записываем дескриптор открытого файла

mov dx, offset fname_new_file
mov cx, 00h
mov al, 0
mov ah, 3ch  ; функция создания файла
int 21h      ; создание файла
mov handle_created_file, al ; записываем дескриптор созданного файла
        
mov dx, offset buffer  
mov bh, 0
mov bl, handle_opened_file
mov cx, 512        
mov al, 0
mov ah, 3fh  ; функция считывания строки из файла
int 21h      ; считывание строки из файла
mov len_str, ax   
cmp ax, 0
je record_close_files


; обработка
mov cx, len_str         ; длина всей строки
mov di, offset buffer   ; адрес буфера
mov bp, offset buffer   ; адрес начальной буквы проверяемого слова
mov al, 32              ; разделитель (пробел)

while:
cmp cx, -1              ; пока не конец строки
je record_close_files   ; 

scasb                   ; пока не найден разделитель
je treat_substr         ; 
inc len_word            ; увеличение значение длины слова
dec cx                  ; уменьшение количества проверенных символов

jmp while

treat_substr:       ; обработка подстроки
mov dx, di          ; запись индекса следующего слова
mov si, di          ; запись si на индекс следующего слова
mov di, bp          ; запись di на начало обрабатываемого слова 
 
mov ax, len_word     ; \
mov bl, 2            ;  |
idiv bl              ;  | вычисление количества проверяемых пар символов
mov ah, 0            ; /

cmp_substr:          ; сравнение букв
cmp al, 0            ; \ пока не все пары проверены
je upper_symbols     ; /
sub si, 2            ; si указывает на последний байт проверяемого слова
dec al               ; 
cmpsb                ; сравнение
je cmp_substr        ; если равны, то повторить
jmp next_word        ; иначе переход на следующее слово

upper_symbols:       ; если все пары совпали     
mov di, bp

up:
mov al, 32           ; разделитель (пробел)
scasb                ;\ 
je next_word         ;/ пока не конец слова
dec di
mov al, es:di        ; запись в al буквы
jmp cmp_al_a         ; символ в диапазоне a-z?
next_up:             ; если да, то
sub al, 32           ; изменение регистра
stosb                ; запись новой буквы
jmp up               ; повтор

next_word:           ; если не все буквы совпали или конец обрабатываемого слова
mov bp, dx           ; перезапись адреса начальной буквы проверяемого слова
mov di, bp           ; перезапись адреса проверяемого слова
mov len_word, 0      ; обнуление длины слова
dec cx               ; уменьшение количества проверенных символов
mov al, 32           ; разделитель (пробел)
jmp while            ; повтор 

cmp_al_a:            
cmp al, 97           ; \ больше a?
jge cmp_al_z         ; / если да, то проверка меньше ли z
inc di               ; \ если нет, то переход к следующему символу
jmp up               ; / повтор проверки

cmp_al_z:
cmp al, 122         ; \ меньше z?
jle next_up         ; / если да, то замена регистра
inc di              ; \ если нет, то переход к следующему символу
jmp up              ; /


record_close_files:   
mov dx, offset buffer 
mov bh, 0
mov bl, handle_created_file 
mov cx, len_str
mov al, 0
mov ah, 40h  ; функция записи в файл
int 21h      ; запись в файл

mov bh, 0
mov bl, handle_created_file
mov al, 0
mov ah, 3eh  ; функция закрытия файла
int 21h      ; закрытие созданного файла

mov bh, 0
mov bl, handle_opened_file
mov al, 0
mov ah, 3eh  ; функция закрытия файла
int 21h      ; закрытие открытого файла
          
end:  
ret

handle_opened_file db 0    ; дескриптор открытого файла
handle_created_file db 0   ; дескриптор созданного файла

fname db 'D:\fname.txt', 0h   ; имя исходного файла
fname_new_file db 'D:\new_fname.txt', 0h  ; имя нового файла
                            
buffer db 512 DUP (32)      ; буффер               
len_str dw 0                ; длина строки   
len_word dw 0               ; длина проверяемого слова

END Start