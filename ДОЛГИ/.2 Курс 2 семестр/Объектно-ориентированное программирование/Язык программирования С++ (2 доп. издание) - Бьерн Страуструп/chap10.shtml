<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 10<br>
Потоки</h3>

<p align="right"><i>"Доступно только то, что видимо"<br>
Б. Керниган</i></p>

<p>В языке С++ нет средств для ввода-вывода. Их и не нужно, поскольку
  такие средства можно просто  и  элегантно  создать  на  самом  языке.
  Описанная здесь библиотека потокового ввода-вывода реализует строгий
  типовой и вместе с тем гибкий и эффективный способ символьного ввода и
  вывода целых, вещественных чисел и символьных строк, а также является
  базой для расширения, рассчитанного на работу с пользовательскими типами
  данных. Пользовательский интерфейс библиотеки находится в файле
  &lt;iostream.h>. Эта глава посвящена самой потоковой библиотеке, некоторым
  способам работы с ней и определенным приемам реализации библиотеки.</p>

<a name='introduct'></a><h4>10.1  ВВЕДЕНИЕ</h4>

<p>Широко известна трудность задачи проектирования и реализации
  стандартных средств ввода-вывода для языков программирования.
  Традиционно средства ввода-вывода были  рассчитаны  исключительно  на
  небольшое  число встроенных типов данных. Однако, в нетривиальных
  программах на С++ есть много пользовательских типов данных, поэтому
  необходимо предоставить
  возможность ввода-вывода значений таких типов. Очевидно, что средства
  ввода-вывода должны быть простыми, удобными, надежными в использовании
  и, что важнее всего, адекватными. Пока никто не нашел решения, которое
  удовлетворило бы всех; поэтому необходимо дать возможность пользователю
  создавать иные средства ввода-вывода, а также расширять стандартные
  средства ввода-вывода в расчете на определенное применение.</p>
<p>Цель создания С++ была в том, чтобы пользователь мог определить новые
  типы данных, работа с которыми была бы столь же удобна и эффективна как
  и со встроенными типами. Таким образом, кажется разумным потребовать,
  чтобы средства ввода-вывода для С++ программировались с использованием
  возможностей С++, доступных каждому. Представленные здесь потоковые
  средства ввода-вывода появились в результате попытки удовлетворить
  этим требованиям.<p/>
<p>Основная задача потоковых средств ввода-вывода - это процесс
  преобразования объектов определенного типа в последовательность символов
  и наоборот. Существуют и другие схемы ввода-вывода, но указанная является
  основной, и если считать символ просто набором битов, игнорируя его
  естественную связь с алфавитом, то многие схемы двоичного ввода-вывода
  можно свести к ней. Поэтому программистская суть задачи сводится к
  описанию связи между объектом определенного типа и бестиповой (что
  существенно) строкой.</p>
<p>Последующие разделы описывают основные части потоковой библиотеки С++:
<ul>
<li><a href="#exit">10.2</a> Вывод: То, что для прикладной программы представляется выводом,
       на самом деле является преобразованием таких  объектов  как  int,
       char *, complex или Employee_record в последовательность символов.
       Описываются средства для записи объектов встроенных и
       пользовательских типов данных.
<li><a href="#input">10.3</a> Ввод: Описаны функции для ввода символов, строк и значений
       встроенных и пользовательских типов данных.
<li><a href='#format'>10.4</a> Форматирование: Часто существуют определенные требования к виду
       вывода, например, int должно печататься десятичными цифрами,
       указатели в шестнадцатеричной записи, а вещественные числа должны
       быть  с явно заданной точностью фиксированного размера.
       Обсуждаются функции форматирования и определенные программистские
       приемы их создания, в частности, манипуляторы.
<li><a href='#files'>10.5</a> Файлы и потоки:  Каждая программа на С++  может  использовать  по
       умолчанию три потока - стандартный вывод (cout), стандартный ввод
       (cin) и стандартный поток ошибок (cerr). Чтобы работать с какими-
       либо устройствами или файлами надо создать потоки и привязать их
       к этим устройствам или файлам. Описывается механизм открытия и
       закрытия файлов и связывания файлов с потоками.
<li><a href='#inout'>10.6</a> Ввод-вывод для С: обсуждается функция printf из файла &lt;stdio.h>
       для С а также связь между библиотекой для С и &lt;iostream.h> для
       С++.
</ul>
Укажем, что существует много независимых реализаций
  потоковой библиотеки ввода-вывода и набор средств, описанных здесь, будет
  только подмножеством средств, имеющихся в вашей библиотеке. Говорят,
  что внутри любой большой программы есть маленькая  программа,  которая
  стремится вырваться наружу. В этой главе предпринята попытка описать
  как раз маленькую потоковую библиотеку ввода-вывода, которая позволит
  оценить основные концепции потокового ввода-вывода и познакомить
  с наиболее полезными средствами. Используя только средства,
  описанные здесь,  можно написать много программ; если возникнет
  необходимость в более сложных средствах, обратитесь за деталями к вашему
  руководству по С++. Заголовочный файл &lt;iostream.h> определяет интерфейс
  потоковой библиотеки. В ранних версиях потоковой библиотеки использовался
  файл &lt;stream.h>. Если существуют оба файла, &lt;iostream.h> определяет полный
  набор средств, а &lt;stream.h> определяет подмножество, которое
  совместимо с ранними, менее богатыми потоковыми библиотеками.</p>
<p>Естественно, для пользования потоковой библиотекой вовсе не нужно
  знание техники ее реализации, тем более, что техника может быть
  различной для различных реализаций. Однако, реализация ввода-вывода
  является задачей, диктующей определенные условия, значит приемы, найденные
  в процессе ее решения, можно применить и для других задач, а само это
  решение достойно изучения.</p>

<a name='exit'></a><h4>10.2 ВЫВОД</h4>

<p>Строгую типовую  и  единообразную  работу как со встроенными,  так и с
  пользовательскими типами  можно  обеспечить,  если использовать
  единственное перегруженное имя функции для различных операций вывода.
  Например:</p>
<pre>
       put(cerr,"x = "); // cerr - выходной поток ошибок
       put(cerr,x);
       put(cerr,'\n');
</pre>
<p>Тип аргумента определяет какую функцию надо вызывать в каждом случае.
  Такой подход применяется в нескольких языках, однако, это слишком
  длинная запись. За счет перегрузки операции &lt;&lt; , чтобы она означала
  "вывести" ("put to"), можно получить более простую запись и разрешить
  программисту выводить в одном операторе последовательность объектов,
  например так:</p>
<pre>
      cerr &lt;&lt; "x = " &lt;&lt; x &lt;&lt; '\n';
</pre>
<p>Здесь cerr обозначает стандартный поток ошибок. Так, если х типа int
  со значением 123, то приведенный оператор выдаст</p>
<pre>
      x = 123
</pre>
<p>и еще символ конца строки в стандартный поток ошибок. Аналогично, если х
  имеет пользовательский тип complex со значением (1,2.4), то указанный
  оператор выдаст</p>
<pre>
      x = (1,2.4)
</pre>
<p>в поток cerr. Такой подход легко использовать пока x такого типа, для
  которого определена операция &lt;&lt;,  а пользователь может просто
  доопределить &lt;&lt; для новых типов.</p>
<p>Мы использовали операцию вывода, чтобы избежать многословности,
  неизбежной, если применять функцию вывода. Но почему именно символ &lt;&lt; ?
  Невозможно изобрести новую лексему (см. п.<a href='chap7.shtml#operfunc'>7.2</a>).  Кандидатом для ввода и
  вывода была операция присваивания, но большинство людей предпочитает,
  чтобы операции ввода и вывода были различны. Более того, порядок
  выполнения операции = неподходящий, так cout=a=b означает cout=(a=b).
  Пробовали использовать операции &lt; и >, но к ним так крепко привязано
  понятие "меньше чем" и "больше чем", что операции ввода-вывода с ними
  во всех практически случаях не поддавались прочтению.</p>
<p>Операции &lt;&lt; и >> похоже не создают таких проблем. Они асиметричны,
  что позволяет приписывать им смысл "в" и "из". Они не относятся к числу
  наиболее часто используемых операций над встроенными типами, а
  приоритет &lt;&lt; достаточно низкий, чтобы писать арифметические выражения в
  качестве операнда без скобок:</p>
<pre>
       cout &lt;&lt; "a*b+c=" &lt;&lt; a*b+c &lt;&lt; '\n';
</pre>
<p>Скобки нужны, если выражение содержит операции с более низким
  приоритетом:

       cout &lt;&lt; "a^b|c=" &lt;&lt; (a^b|c) &lt;&lt; '\n';

  Операцию сдвига влево можно использовать в операции вывода, но, конечно,
  она должна быть в скобках:
<pre>
       cout &lt;&lt; "a&lt;&lt;b=" &lt;&lt; (a&lt;&lt;b) &lt;&lt; '\n';
</pre>
<p>

<a name='buildin'></a><h5>10.2.1 Вывод встроенных типов</h5>

<p>Для управления выводом встроенных типов определяется класс ostream
  с операцией &lt;&lt; (вывести):</p>
<pre>
       class ostream : public virtual ios {
           // ...
       public:
          ostream& operator<<(const char*);    //строки
          ostream& operator<<(char);
          ostream& operator<<(short i)
            { return *this << int(i); }
          ostream& operator<<(int);
          ostream& operator<<(long);
          ostream& operator<<(double);
          ostream& operator<<(const void*);    // указатели
           // ...
    };
</pre>
<p>Естественно, в классе ostream должен быть набор функций operator&lt;&lt;()
  для работы с беззнаковыми типами.</p>
<p>Функция operator&lt;&lt; возвращает ссылку на класс ostream, из
  которого она вызывалась, чтобы к ней можно было применить еще раз
  operator&lt;&lt;. Так, если х типа int, то</p>
<pre>
         cerr &lt;&lt; "x = " &lt;&lt; x;
</pre>
<p>понимается как</p>
<pre>
         (cerr.operator&lt;&lt;("x = ")).operator&lt;&lt;(x);
</pre>
<p>В частности, это означает, что если несколько объектов выводятся с
  помощью одного оператора вывода, то они будут выдаваться в
  естественном порядке: слева - направо.</p>
<p>Функция ostream::operator&lt;&lt;(int) выводит целые значения, а
  функция ostream::operator&lt;&lt;(char) - символьные. Поэтому функция</p>
<pre>
        void val(char c)
        {
          cout << "int('"<< c <<"') = " << int(c) << '\n';
        }
</pre>
<p>печатает целые значения символов и с помощью программы</p>
<pre>
        main()
        {
          val('A');
          val('Z');
        }
</pre>
<p>будет напечатано</p>
<pre>
        int('A') = 65
        int('Z') = 90
</pre>
<p>Здесь предполагается кодировка символов ASCII, на вашей машине может быть
  иной результат. Обратите внимание, что символьная константа имеет
  тип char, поэтому cout<<'Z' напечатает букву Z, а вовсе не целое 90.</p>
<p>Функция ostream::operator<<(const void*) напечатает значение
  указателя в такой записи, которая более подходит для используемой
  системы адресации.
  Программа</p>
<pre>
        main()
        {
         int i = 0;
         int* p = new int(1);
         cout << "local " << &i
              << ", free store " << p << '\n';
        }
</pre>
<p>выдаст на машине, используемой автором,</p>
<pre>
        local 0x7fffead0, free store 0x500c
</pre>
<p>Для других систем адресации могут быть иные соглашения об изображении
  значений указателей.</p>
<p>Обсуждение базового класса ios отложим до 10.4.1.</p>

<a name='usertype'></a><h5>10.2.2 Вывод пользовательских типов</h5>

<p>Рассмотрим пользовательский тип данных:</p>
<pre>
       class complex {
          double re, im;
       public:
          complex(double r = 0, double i = 0) { re=r; im=i; }

          friend double real(complex& a) { return a.re; }
          friend double imag(complex& a) { return a.im; }

          friend complex operator+(complex, complex);
          friend complex operator-(complex, complex);
          friend complex operator*(complex, complex);
          friend complex operator/(complex, complex);
          //...
       };
</pre>
<p>Для нового типа complex операцию << можно определить так:</p>
<pre>
      ostream& operator<<(ostream&s, complex z)
      {
       return s << '(' real(z) << ',' << imag(z) << ')';
      };
</pre>
<p>и использовать  как operator<< для встроенных типов. Например,</p>
<pre>
      main()
      {
          complex x(1,2);
          cout << "x = " << x << '\n';
      }
</pre>
<p>выдаст</p>
<pre>
      x = (1,2)
</pre>
<p>Для определения операции вывода над пользовательскими типами данных
  не нужно модифицировать описание класса ostream, не требуется и доступ
  к структурам данных, скрытым в описании класса. Последнее очень кстати,
  поскольку описание класса ostream находится среди стандартных
  заголовочных файлов, доступ по записи к которым закрыт для большинства
  пользователей, и изменять которые они вряд ли захотят, даже если бы
  могли. Это важно и по той причине, что дает защиту от случайной порчи
  этих структур данных. Кроме того имеется возможность изменить
  реализацию ostream, не затрагивая пользовательских программ.</p>

<a name='input'></a><h4>10.3 ВВОД</h4>

<p>Ввод во многом сходен с выводом. Есть класс istream, который реализует
  операцию ввода >> ("ввести из" - "input from") для небольшого набора
  стандартных типов. Для пользовательских типов можно определить функцию
  operator>>.</p>

<a name='inbuild'></a><h5>10.3.1 Ввод встроенных типов</h5>

<p>Класс istream определяется следующим образом:</p>
<pre>
       class istream : public virtual ios {
           //...
       public:
           istream& operator>>(char*);     // строка
           istream& operator>>(char&);     // символ
           istream& operator>>(short&);
           istream& operator>>(int&);
           istream& operator>>(long&);
           istream& operator>>(float&);
           istream& operator>>(double&);
           //...
       };
</pre>
<p>Функции ввода operator>> определяются так:</p>
<pre>
       istream& istream::operator>>(T& tvar)
       {
        // пропускаем обобщенные пробелы
        // каким-то образом читаем T в`tvar'
         return *this;
        }
</pre>
<p>Теперь можно ввести в VECTOR последовательность целых, разделяемых
  пробелами, с помощью функции:</p>
<pre>
      int readints(Vector<int>& v)
      // возвращаем число прочитанных целых
      {
         for (int i = 0; i&lt;v.size(); i++)
         {
            if (cin>>v[i]) continue;
            return i;
         }
         // слишком много целых для размера Vector
         // нужна соответствующая обработка ошибки
       }
</pre>
<p>Появление значения с типом, отличным от int, приводит к прекращению
  операции ввода, и цикл ввода завершается. Так, если мы вводим</p>
<pre>
       1 2 3 4 5. 6 7 8.
</pre>
<p>то функция readints() прочитает пять целых чисел</p>
<pre>
       1 2 3 4 5
</pre>
<p>Символ точка останется первым символом, подлежащим вводу. Под пробелом,
  как определено в стандарте С, понимается обобщенный пробел, т.е.
  пробел, табуляция, конец строки, перевод строки или возврат каретки.
  Проверка на обобщенный пробел возможна с помощью функции isspace()
  из файла &lt;ctype.h>.</p>
<p>В качестве альтернативы можно использовать функции get():</p>
<pre>
      class istream : public virtual ios {
          //...
          istream& get(char& c);                     // символ
          istream& get(char* p, int n, char ='n');   // строка
      };
</pre>
<p>В них обобщенный пробел рассматривается как любой другой символ и
  они предназначены для таких операций ввода, когда не делается никаких
  предположений о вводимых символах.</p>
<p>Функция istream::get(char&) вводит один символ в свой параметр.
  Поэтому программу посимвольного копирования можно написать так:</p>
<pre>
       main()
       {
         char c;
         while (cin.get(c)) cout << c;
       }
</pre>
<p>Такая запись выглядит несимметрично, и у операции >> для вывода символов
  есть двойник под именем put(), так что можно писать и так:</p>
<pre>
       main()
       {
          char c;
          while (cin.get(c)) cout.put(c);
       }
</pre>
<p>Функция с тремя параметрами istream::get() вводит в символьный вектор
  не менее n символов, начиная с адреса p. При всяком обращении к get()
  все символы, помещенные в буфер (если они были), завершаются 0, поэтому
  если второй параметр равен n, то введено не более n-1 символов. Третий
  параметр определяет символ, завершающий ввод. Типичное использование
  функции get() с тремя параметрами сводится к чтению строки в буфер
  заданного размера для ее дальнейшего разбора, например так:</p>
<pre>
       void f()
       {
           char buf[100];
           cin >> buf;                 // подозрительно
           cin.get(buf,100,'\n');      // надежно
           //...
        }
</pre>
<p>Операция cin>>buf подозрительна, поскольку строка из более чем 99
  символов переполнит буфер. Если обнаружен завершающий символ, то он
  остается в потоке первым символом подлежащим вводу. Это позволяет
  проверять буфер на переполнение:</p>
<pre>
       void f()
       {
          char buf[100];

          cin.get(buf,100,'\n');   // надежно

          char c;
          if (cin.get(c) && c!='\n') {
             // входная строка больше, чем ожидалось
          }
          //...
        }
</pre>
<p>Естественно, существует версия get() для типа unsigned char.</p>
<p>В стандартном заголовочном файле &lt;ctype.h> определены несколько
  функций, полезных для обработки при вводе:</p>
<pre>
    int isalpha(char)   // 'a'..'z' 'A'..'Z'
    int isupper(char)   // 'A'..'Z'
    int islower(char)   // 'a'..'z'
    int isdigit(char)   // '0'..'9'
    int isxdigit(char)  // '0'..'9' 'a'..'f' 'A'..'F'
    int isspace(char)   // ' ' '\t' возвращает конец строки
                        // и перевод формата
    int iscntrl(char)   // управляющий символ в диапазоне
                        // (ASCII 0..31 и 127)
    int ispunct(char)   // знак пунктуации, отличен от приведенных выше
    int isalnum(char)   // isalpha() | isdigit()
    int isprint(char)   // видимый: ascii ' '..'~'
    int isgraph(char)   // isalpha() | isdigit() | ispunct()
    int isascii(char c)   { return 0<=c && c<=127; }
</pre>
<p>Все они, кроме isascii(), работают с помощью простого просмотра,
  используя символ как индекс в таблице атрибутов символов. Поэтому
  вместо выражения типа</p>
<pre>
       (('a'&lt;=c && c&lt;='z') || ('A'&lt;=c && c&lt;='Z')) // буква
</pre>
<p>которое не только утомительно писать, но оно может быть и ошибочным
  (на машине с кодировкой EBCDIC оно задает не только буквы), лучше
  использовать вызов стандартной функции isalpha(), который к тому
  же более эффективен.</p>
<p>В качестве примера приведем функцию eatwhite(), которая читает из
  потока обобщенные пробелы:</p>
<pre>
       istream& eatwhite(istream& is)
       {
            char c;
            while (is.get(c)) {
                if (isspace(c)==0) {
                    is.putback(c);
                    break;
                }
             }
             return is;
        }
</pre>
<p>В ней используется функция putback(), которая возвращает символ в
  поток, и он становится первым подлежащим чтению.</p>

<a name='state'></a><h5>10.3.2 Состояния потока</h5>

<p>С каждым потоком (istream или ostream) связано определенное состояние.
  Нестандартные ситуации и ошибки обрабатываются с помощью проверки и
  установки состояния подходящим образом.
  Узнать состояние потока можно с помощью операций над классом ios:</p>
<pre>
       class ios { //ios является базовым для ostream и istream
           //...
       public:
           int eof() const;     // дошли до конца файла
           int fail() const;    // следующая операция будет неудачна
           int bad() const;     // поток испорчен
           int good() const;    // следующая операция будет успешной
           //...
       };
</pre>
<p>Последняя операция ввода считается успешной, если состояние задается
  good() или eof(). Если состояние задается good(), то последующая
  операция ввода может быть успешной, в противном случае она будет
  неудачной. Применение операции ввода к потоку в состоянии, задаваемом
  не good(), считается пустой операцией. Если произошла неудача при
  попытке чтения в переменную v, то значение v не изменилось (оно не
  изменится, если v имеет тип, управляемый функциями члена из istream
  или ostream). Различие между состояниями, задаваемыми как fail() или
  как bad() уловить трудно, и оно имеет смысл только для разработчиков
  операций ввода. Если состояние есть fail(), то считается, что поток
  не поврежден, и никакие символы не пропали; о состоянии bad() ничего
  сказать нельзя.</p>
<p>Значения, обозначающие эти состояния, определены в классе ios:</p>
<pre>
       class ios {
           //...
       public:
           enum io_state {
               goodbit=0,
               eofbit=1,
               filebit=2,
               badbit=4,
           };
           //...
       };
</pre>
<p>Истинные значения состояний зависят от реализации, и указанные значения
  приведены только, чтобы избежать синтаксически неправильных конструкций.
   Проверять состояние потока можно следующим образом:</p>
<pre>
       switch (cin.rdstate()) {
       case ios::goodbit:
           // последняя операция с cin была успешной
           break;
       case ios::eofbit:
           // в конце файла
           break;
        case ios::filebit:
           // некоторый анализ ошибки
           // возможно неплохой
           break;
         case ios::badbit:
           //  cin возможно испорчен
           break;
         }
</pre>
<p>В более ранних реализациях для значений состояний использовались
  глобальные имена. Это приводило к нежелательному засорению
  пространства именования, поэтому новые имена доступны только в пределах
  класса ios. Если вам необходимо использовать старые имена в сочетании с
  новой библиотекой, можно воспользоваться следующими определениями:</p>
<pre>
       const int _good = ios::goodbit;
       const int _bad = ios::badbit;
       const int _file = ios::filebit;
       const int _eof = ios::eofbit;

       typedef ios::io_state state_value ;
</pre>
<p>Разработчики библиотек должны заботится о том, чтобы не добавлять
  новых имен к глобальному пространству именования. Если элементы
  перечисления входят в общий интерфейс библиотеки, они всегда
  должны использоваться в классе с префиксами, например, как ios::goodbit
  и ios::io_state.</p>
<p>Для переменной любого типа, для которого определены операции
  << и >>, цикл копирования записывается следующим образом:</p>
<pre>
        while (cin>>z) cout << z << '\n';
</pre>
<p>Если поток появляется в условии, то проверяется состояние потока, и
  условие выполняется (т.е. результат его не 0) только для состояния
  good(). Как раз в приведенном выше цикле проверяется состояние потока
  istream, что является результатом операции cin>>z. Чтобы узнать,
  почему произошла неудача в цикле или условии, надо проверить состояние.
  Такая проверка для потока реализуется с помощью операции
  приведения (п.<a href="chap7.shtml#transform">7.3.2</a>).</p>
<p>Так, если z является символьным вектором, то в приведенном цикле
  читается стандартный ввод и выдается для каждой строки стандартного
  вывода по одному слову (т.е. последовательности символов, не являющихся
  обобщенными пробелами). Если z имеет тип complex, то в этом цикле
  с помощью операций, определенных в п.<a href="#exit">10.2</a>, будут копироваться
  комплексные числа. Шаблонную функцию копирования для потоков со
  значениями произвольного типа можно написать следующим образом:</p>
<pre>
       complex z;
       iocopy(z,cin,cout);    // копирование complex

       double d;
       iocopy(d,cin,cout);    // копирование double
       char c;
       iocopy(c,cin,cout);    // копирование char
</pre>
<p>Поскольку надоедает проверять на корректность каждую операцию ввода-
  вывода, то распространенным источником ошибок являются именно те места в
  программе, где такой контроль существенен. Обычно операции вывода не
  проверяют, но иногда они могут завершиться неудачно. Потоковый ввод-
  вывод разрабатывался из того принципа, чтобы сделать исключительные
  ситуации легкодоступными, и тем самым упростить обработку ошибок
  в процессе ввода-вывода.</p>

<a name='inuser'></a><h5>10.3.3 Ввод пользовательских типов</h5>

<p>Операцию ввода для пользовательского типа можно определить в точности
  так же, как и операцию вывода, но для операции ввода существенно, чтобы
  второй параметр имел тип ссылки, например:</p>
<pre>
     istream& operator>>(istream& s, complex& a)
     /*
        формат input рассчитан на complex; "f" обозначает float:
            f
            ( f )
            ( f , f )
     */
     {
        double re = 0, im = 0;
        char   c = 0;

        s >> c;
        if (c == '(') {
            s >> re >> c;
            if (c == ',') s >> im >> c;
            if (c != ')') s.clear(ios::badbit); // установим состояние
        }
        else {
            s.putback(c);
            s >> re;
        }

        if (s) a = complex(re,im);
        return s;
     }
</pre>
<p>Несмотря на сжатость кода, обрабатывающего ошибки, на самом деле
  учитывается большая часть ошибок. Инициализация локальной переменной
  с нужна для того, чтобы в нее не попало случайное значение, например
  '(', в случае неудачной операции. Последняя проверка состояния потока
  гарантирует, что параметр a получит значение только при успешном вводе.</p>
<p>Операция, устанавливающая состояние потока, названа clear()
  (здесь clear - ясный, правильный),
  поскольку чаще всего она используется для восстановления состояния потока
  как good(); значением по умолчанию для параметра ios::clear() является
  ios::goodbit.</p>

<a name='format'></a><h4>10.4 Форматирование</h4>

<p>Все примеры из п.<a href='#exit'>10.2</a> содержали неформатированный вывод, который являлся
  преобразованием объекта в последовательность символов, задаваемую
  стандартными правилами, длина которой также определяется этими
  правилами. Часто программистам требуются более развитые возможности.
  Так, возникает потребность контролировать размер памяти, необходимой
  для операции вывода, и формат, используемый для выдачи чисел.
  Точно так же допустимо управление некоторыми аспектами ввода.</p>

<a name='ios'></a><h5>10.4.1 Класс ios</h5>

<p>Большинство средств управления вводом-выводом сосредоточены в классе
  ios, который является базовым для ostream и istream. По сути здесь
  находится управление связью между istream или ostream и буфером,
  используемым для операций ввода-вывода. Именно  класс ios контролирует:
  как символы попадают в буфер и как они выбираются оттуда. Так, в классе
  ios есть член, содержащий информацию об используемой при чтении или
  записи целых чисел системы счисления (десятичная, восьмеричная или
  шестнадцатеричная), о  точности  вещественных чисел и т.п., а также
  функции для проверки и установки значений переменных, управляющих
  потоком.</p>
<pre>
      class ios {
          //...
      public:
          ostream* tie(ostream* s);   // связать input и output
          ostream* tie();             // возвратить "tie"

      int width(int w);               // установить поле width
      int width() const;

      char fill(char);                // установить символ заполнения
      char fill() const;              // вернуть символ заполнения

      long flags(long f);
      long flags() const;

      long setf(long setbits, long field);
      long setf(long);
      long unsetf(long);

      int precision(int);             // установить точность для float
      int precision() const;
      int rdstate(); const;          // состояния потоков, см. п.<a href='#state'>10.3.2</a>
      int eof() const;
      int fail() const;
      int bad() const;
      int good() const;
      void clear(int i=0);

      //...
   };
</pre>
<p>В п.<a href='#state'>10.3.2</a> описаны функции, работающие с состоянием потока, остальные
  приведены ниже.</p>

<a name='stream'></a><h6>10.4.1.1 Связывание потоков</h6>

<p>Функция tie() может установить и разорвать связь между ostream и
  istream. Рассмотрим пример:</p>
<pre>
         main()
         {
           String s;
           cout << "Password: ";
           cin >> s;
           // ...
          }
</pre>
<p>Как можно гарантировать, что приглашение Password: появится на
  экране прежде, чем выполниться операция чтения? Вывод в cout и ввод
  из cin буферизуются, причем независимо, поэтому Password: появится
  только по завершении программы, когда закроется буфер вывода.</p>
<p>Решение состоит в том, чтобы связать cout и cin с помощью
  операции cin.tie(cout).
  Если ostream связан с потоком istream, то буфер вывода выдается при
  каждой операции ввода над istream. Тогда операции</p>
<pre>
          cout << "Password: ";
          cin >> s;
</pre>
<p>эквивалентны</p>
<pre>
          cout << "Password: ";
          cout.flush();
          cin >> s;
</pre>
<p>Обращение is.tie(0) разрывает связь между потоком is и потоком, с
  которым он был связан, если такой был. Подобно другим потоковым
  функциям, устанавливающим определенное значение, tie(s) возвращает
  предыдущее значение, т.е. значение связанного потока перед обращением
  или 0. Вызов без параметра tie() возвращает текущее значение.</p>

<a name='field'></a><h6>10.4.1.2 Поля вывода</h6>

<p>Функция width() устанавливает минимальное число символов, использующееся
  в последующей операции вывода числа или строки. Так в результате
  следующих операций</p>
<pre>
          cout.width(4);
          cout << '(' << 12 << ')';
</pre>
<p>получим число 12 в поле размером 4 символа, т.е.</p>
<pre>
          (  12)
</pre>
<p>Заполнение поля заданными символами или выравнивание можно установить с
  помощью функции fill(), например:</p>
<pre>
          cout.width(4);
          cout.fill('#');
          cout << '(' << "ab" << ')';
</pre>
<p>напечатает</p>
<pre>
          (##ab)
</pre>
<p>По умолчанию поле заполняется пробелами, а размер поля по умолчанию
  есть 0, что означает "столько символов, сколько нужно". Вернуть размеру
  поля стандартное значение можно с помощью вызова</p>
<pre>
          cout.width(0); // ``столько символов, сколько надо''
</pre>
<p>Функция width() задает минимальное число символов. Если появится больше
  символов, они будут напечатаны все, поэтому</p>
<pre>
          cout.width(4);
          cout << '(' << "121212" << ")\n";
</pre>
<p>напечатает</p>
<pre>
          (121212)
</pre>
<p>Причина, по которой разрешено переполнение поля, а не усечение вывода,
  в том, чтобы избежать зависания при выводе. Лучше получить правильную
  выдачу, выглядящую некрасиво, чем красивую выдачу, являющуюся
  неправильной.</p>
<p>Вызов width() влияет только на одну следующую за ним операцию
  вывода, поэтому</p>
<pre>
          cout.width(4);
          cout.fill('#');
          cout << '(' << 12 << "),(" << '(' <<12 << ")\n";
</pre>
<p>напечатает</p>
<pre>
          (##12),(12)
</pre>
<p>а не</p>
<pre>
          (##12),(##12)
</pre>
<p>как можно было бы ожидать. Однако, заметьте, что если бы влияние
  распространялось на все операции вывода чисел и строк, получился бы
  еще более неожиданный результат:</p>
<pre>
          (##12#),(##12#
          )
</pre>
<p>С помощью стандартного манипулятора, показанного в п.<a href='#standhand'>10.4.2.1</a>, можно более
  элегантно задавать размера поля вывода.</p>

<a name='stateform'></a><h6>10.4.1.3 Состояние формата</h6>

<p>В классе ios содержится состояние формата, которое управляется
  функциями flags() и setf(). По сути эти функции нужны, чтобы
  установить или отменить следующие флаги:</p>
<pre>
    class ios {
    public:
           // управляющие форматом флаги:
       enum {
           skipws=01,          // пропуск обобщенных пробелов для input
                               // поле выравнивания:
           left=02,            // добавление перед значением
           right=04,           // добавление после значения
           internal=010,       // добавление между знаком и значением
                               // основание целого:
           dec=020,            // восьмеричное
           oct=040,            // десятичное
           hex=0100,           // шестнадцатеричное
           showbase=0200,      // показать основание целого
           showpoint=0400,     // выдать нули в конце
           uppercase=01000,    // 'E', 'X' , а не 'e', 'x'
           showpos=02000,      //  '+' для положительных чисел
                               // запись числа типа float:
           scientific=04000,   // .dddddd Edd
           fixed=010000,       // dddd.dd
                               // сброс в выходной поток:
           unitbuf=020000,     // после каждой операции
           stdio=040000        // после каждого символа
        };
        //...
    };
</pre>
<p>Смысл флагов будет разъяснен в последующих разделах. Конкретные
  значения флагов зависят от реализации и даны здесь только для того,
  чтобы избежать синтаксически неверных конструкций.</p>
<p>Определение интерфейса как набора флагов и операций для их
  установки или отмены - это оцененный временем, хотя и несколько
  устаревший прием. Основное его достоинство в том, что пользователь
  может собрать воедино набор флагов, например, так:</p>
<pre>
         const int my_io_options =
            ios::left|ios::oct|ios::showpoint|ios::fixed;
</pre>
<p>Такое множество флагов можно задавать как параметр одной операции</p>
<pre>
         cout.flags(my_io_options);
</pre>
<p>а также просто передавать между функциями одной программы:</p>
<pre>
         void your_function(int ios_options);

         void my_function()
         {
            // ...
           your_function(my_io_options);
           // ...
         }
</pre>
<p>Множество флагов можно установить с помощью функции flags(), например:</p>
<pre>
         void your_function(int ios_options)
         {
          int old_options = cout.flags(ios_options);
          // ...
          cout.flags(old_options);  // reset options
          }
</pre>
<p>Функция flags() возвращает старое значение множества флагов. Это
  позволяет переустановить значения всех флагов, как показано выше,
  а также задать значение отдельному флагу. Например вызов</p>
<pre>
         myostream.flags(myostream.flags()|ios::showpos);
</pre>
<p>заставляет класс myostream выдавать положительные числа со знаком
  + и, в то же время, не меняет значения других флагов. Получается
  старое значение множества флагов, к которому добавляется с помощью
  операции | флаг showpos. Функция setf() делает то же самое,
  поэтому эквивалентная запись имеет вид</p>
<pre>
         myostream.setf(ios::showpos);
</pre>
<p>После установки флаг сохраняет значение до явной отмены.
         Все-таки управление вводом-выводом с помощью установки и отмены
  флагов - грубое и ведущее к ошибкам решение. Если только вы тщательно
  не изучите свое справочное руководство и не будете применять флаги
  только в простых случаях, как это делается в последующих разделах, то
  лучше использовать манипуляторы (описанные в п.<a href='#standhand'>10.4.2.1</a>). Приемы работы
  с состоянием потока лучше изучить на примере реализации класса, чем
  изучая интерфейс класса.</p>

<a name='whole'></a><h6>10.4.1.4 Вывод целых</h6>

<p>Прием задания нового значения множества флагов с помощью операции | и
  функций flags() и setf() работает только тогда, когда один бит определяет
  значение флага. Не такая ситуация при задании системы счисления целых
  или вида выдачи вещественных. Здесь значение, определяющее вид выдачи,
  нельзя задать одним битом или комбинацией отдельных битов.</p>
<p>Решение, принятое в <iostream.h>, сводится к использованию
  версии функции setf(), работающей со вторым "псевдопараметром", который
  показывает какой именно флаг мы хотим добавить к новому значению.</p>

<p>Поэтому обращения</p>
<pre>
         cout.setf(ios::oct,ios::basefield); // восьмеричное
         cout.setf(ios::dec,ios::basefield); // десятичное
         cout.setf(ios::hex,ios::basefield); // шестнадцатеричное
</pre>
<p>установят систему счисления, не затрагивая других компонентов состояния
  потока. Если система счисления установлена, она используется до явной
  переустановки, поэтому</p>
<pre>
       cout << 1234 << ' ';  // десятичное по умолчанию
       cout << 1234 << ' ';

       cout.setf(ios::oct,ios::basefield);  // восьмеричное
       cout << 1234 << ' ';
       cout << 1234 << ' ';

       cout.setf(ios::hex,ios::basefield);  // шестнадцатеричное
       cout << 1234 << ' ';
       cout << 1234 << ' ';
</pre>
<p>напечатает
<pre>
         1234 1234 2322 2322 4d2 4d2
</pre>
<p>Если появится необходимость указывать систему счисления для каждого
  выдаваемого числа, следует установить флаг showbase. Поэтому, добавив
  перед приведенными выше обращениями</p>
<pre>
         cout.setf(ios::showbase);
</pre>
<p>мы получим</p>
<pre>
         1234 1234 02322 02322 0x4d2 0x4d2
</pre>
<p>Стандартные манипуляторы, приведенные в п.<a href='#standhand'>10.4.2.1</a>, предлагают более
  элегантный способ определения системы счисления при выводе целых.</p>

<a name='align'></a><h6>10.4.1.5 Выравнивание полей</h6>

<p>С помощью обращений к setf() можно управлять расположением символов
  в пределах поля:</p>
<pre>
         cout.setf(ios::left,ios::adjustfield);     // влево
         cout.setf(ios::right,ios::adjustfield);    // вправо
         cout.setf(ios::internal,ios::adjustfield); // внутреннее
</pre>
<p>Будет установлено выравнивание в поле вывода, определяемом функцией
  ios::width(), причем не затрагивая других компонентов состояния потока.
         Выравнивание можно задать следующим образом:</p>
<pre>
       cout.width(4);
       cout << '(' << -12 << ")\n";

       cout.width(4);
       cout.setf(ios::left,ios::adjustfield);
       cout << '(' << -12 << ")\n";

       cout.width(4);
       cout.setf(ios::internal,ios::adjustfield);
       cout << '(' << -12 << "\n";
</pre>
<p>что выдаст</p>
<pre>
         ( -12)
         (-12 )
         (- 12)
</pre>
<p>Если установлен флаг выравнивания internal (внутренний), то символы
  добавляются между знаком и величиной. Как видно, стандартным является
  выравнивание вправо.</p>

<a name='floatnum'></a><h6>10.4.1.6 Вывод плавающих чисел.</h6>

<p>Вывод вещественных величин также управляется с помощью функций,
  работающих с состоянием потока. В частности, обращения:</p>
<pre>
         cout.setf(ios::scientific,ios::floatfield);
         cout.setf(ios::fixed,ios::floatfield);
         cout.setf(0,ios::floatfield);   // вернуться к стандартному
</pre>
<p>установят вид печати вещественных чисел без изменения других
  компонентов состояния потока.
  Например:</p>
<pre>
       cout << 1234.56789 << '\n';

       cout.setf(ios::scientific,ios::floatfield);
       cout << 1234.56789 << '\n';

       cout.setf(ios::fixed,ios::floatfield);
       cout << 1234.56789 << '\n';
</pre>
<p>напечатает</p>
<pre>
         1234.57
         1.234568e+03
         1234.567890
</pre>
<p>После точки печатается n цифр, как задается в обращении</p>
<pre>
         cout.precision(n)
</pre>
<p>По умолчанию n равно 6. Вызов функции precision влияет на все операции
  ввода-вывода с вещественными до следующего обращения к precision,
  поэтому</p>
<pre>
       cout.precision(8);
       cout << 1234.56789 << '\n';
       cout << 1234.56789 << '\n';

       cout.precision(4);
       cout << 1234.56789 << '\n';
       cout << 1234.56789 << '\n';
</pre>
<p>выдаст</p>
<pre>
        1234.5679
        1234.5679
        1235
        1235
</pre>
<p>Заметьте, что происходит округление, а не отбрасывание дробной части.</p>
<p>Стандартные манипуляторы, введенные в п.<a href='#standhand'>10.4.2.1</a>, предлагают
  более элегантный способ задания формата вывода вещественных.</p>

<a name='manipul'></a><h5>10.4.2 Манипуляторы</h5>

<p>К ним относятся разнообразные операции, которые приходится
  применять сразу перед или сразу после операции ввода-вывода. Например:</p>
<pre>
        cout << x;
        cout.flush();
        cout << y;

        cin.eatwhite();
        cin >> x;
</pre>
<p>Если писать отдельные операторы как выше, то логическая связь между
  операторами неочевидна, а если утеряна логическая связь, программу
  труднее понять.</p>
<p>Идея манипуляторов позволяет такие операции как flush() или
  eatwhite() прямо вставлять в список операций ввода-вывода. Рассмотрим
  операцию flush(). Можно определить класс с операцией operator<<(), в
  котором вызывается flush():</p>
<pre>
        class Flushtype { };

        ostream& operator<<(ostream& os, Flushtype)
        {
           return flush(os);
        }
</pre>
<p>определить объект такого типа</p>
<pre>
        Flushtype FLUSH;
</pre>
<p>и добиться выдачи буфера, включив FLUSH в список объектов, подлежащих
  выводу:</p>
<pre>
        cout << x << FLUSH << y << FLUSH ;
</pre>
<p>Теперь установлена явная связь между операциями вывода и сбрасывания
  буфера. Однако, довольно быстро надоест определять класс и объект для
  каждой операции, которую мы хотим применить к поточной операции вывода.
  К счастью, можно поступить лучше. Рассмотрим такую функцию:</p>
<pre>
          typedef ostream& (*Omanip) (ostream&);

          ostream& operator&lt;&lt;(ostream& os, Omanip f)
          {
            return f(os);
          }
</pre>
<p>Здесь операция вывода использует параметры типа "указатель на функцию,
  имеющую аргумент ostream& и возвращающую ostream&". Отметив, что flush()
  есть функция типа "функция с аргументом ostream& и возвращающая
  ostream&", мы можем писать</p>
<pre>
          cout &lt;&lt; x &lt;&lt; flush &lt;&lt; y &lt;&lt; flush;
</pre>
<p>получив вызов функции flush(). На самом деле в файле &lt;iostream.h>
  функция flush() описана как</p>
<pre>
          ostream& flush(ostream&);
</pre>
<p>а в классе есть операция operator<<, которая использует указатель на
  функцию, как указано выше:</p>
<pre>
          class ostream : public virtual ios {
             // ...
          public:
            ostream& operator<<(ostream& ostream& (*)(ostream&));
            // ...
          };
</pre>
<p>В приведенной ниже строке буфер выталкивается в поток cout дважды в
  подходящее время:</p>
<pre>
          cout << x << flush << y << flush;
</pre>
<p>Похожие определения существуют и для класса istream:</p>
<pre>
          istream& ws(istream& is ) { return is.eatwhite(); }

          class istream : public virtual ios {
           // ...
          public:
            istream& operator>>(istream&, istream& (*) (istream&));
            // ...
          };
</pre>
<p>поэтому в строке</p>
<pre>
          cin >> ws >> x;
</pre>
<p>действительно обобщенные пробелы будут убраны до попытки чтения в x.
  Однако, поскольку по умолчанию для операции >>  пробелы "съедаются" и
  так, данное применение ws() избыточно.</p>
<p>Находят применение и манипуляторы с параметрами. Например,
  может появиться желание с помощью</p>
<pre>
          cout << setprecision(4) << angle;
</pre>
<p>напечатать значение вещественной переменной angle с точностью до
  четырех знаков после точки.</p>
<p>Для этого нужно уметь вызывать функцию, которая установит
  значение переменной, управляющей в потоке точностью вещественных.
  Это достигается, если определить setprecision(4) как объект, который
  можно "выводить" с помощью operator<<():</p>
<pre>
       class Omanip_int {
           int i;
           ostream& (*f) (ostream&,int);
       public:
           Omanip_int(ostream& (*ff) (ostream&,int), int ii)
               : f(ff), i(ii) { }
           friend ostream& operator<<(ostream& os, Omanip& m)
               { return m.f(os,m.i); }
        };
</pre>
<p>Конструктор Omanip_int хранит свои аргументы в i и f, а с помощью
  operator<< вызывается f() с параметром i. Часто объекты таких классов
  называют объект-функция. Чтобы результат строки</p>
<pre>
           cout << setprecision(4) << angle
</pre>
<p>был таким, как мы хотели, необходимо чтобы обращение  setprecision(4)
  создавало безымянный объект класса Omanip_int, содержащий значение 4
  и указатель на функцию, которая устанавливает в потоке ostream значение
  переменной, задающей точность вещественных:</p>
<pre>
       ostream& _set_precision(ostream&,int);

       Omanip_int setprecision(int i)
       {
           return Omanip_int(&_set_precision,i);
       }
</pre>
<p>Учитывая сделанные определения, operator<<() приведет к вызову
  precision(i).</p>
<p>Утомительно определять классы наподобие Omanip_int для всех
  типов аргументов, поэтому  определим шаблон типа:</p>
<pre>
       template<class T> class OMANIP {
           T i;
           ostream& (*f) (ostream&,T);
       public:
           OMANIP(ostream (*ff) (ostream&,T), T ii)
               : f(ff), i(ii) { }

       friend ostream& operator<<(ostream& os, OMANIP& m)
           { return m.f(os,m.i) }
       };
</pre>
<p>С помощью OMANIP пример с установкой точности можно сократить так:</p>
<pre>
       ostream& precision(ostream& os,int)
       {
           os.precision(i);
           return os;
       }

       OMANIP<int> setprecision(int i)
       {
           return OMANIP<int>(&precision,i);
       }
</pre>
<p>В файле  <iomanip.h>  можно найти шаблон типа OMANIP,  его двойник для
  istream - шаблон типа SMANIP, а SMANIP - двойник для ioss.
  Некоторые из стандартных манипуляторов,  предлагаемых поточной
  библиотекой, описаны ниже. Отметим,что программист может определить новые
  необходимые ему манипуляторы, не затрагивая определений istream,
  ostream, OMANIP или SMANIP.</p>
<p>Идею манипуляторов предложил А. Кениг. Его вдохновили процедуры
  разметки (layout ) системы ввода-вывода Алгола68. Такая техника имеет
  много интересных приложений помимо ввода-вывода. Суть ее в том, что
  создается объект, который можно передавать куда угодно и который
  используется как функция. Передача объекта является более гибким
  решением, поскольку детали выполнения частично определяются создателем
  объекта, а частично тем, кто к нему обращается.</p>

<a name='standhand'></a><h6>10.4.2.1 Стандартные манипуляторы ввода-вывода</h6>

<p>Это следующие манипуляторы:</p>
<pre>
       // Simple manipulators:
       ios& oct(ios&);  // в восьмеричной записи
       ios& dec(ios&);  // в десятичной записи
       ios& hex(ios&);  // в шестнадцатеричной записи
       ostream& endl(ostream&);   // добавить '\n' и вывести
       ostream& ends(ostream&);   // добавить '\0' и вывести
       ostream& flush(ostream&);  // выдать поток

       istream& ws(istream&);     // удалить обобщенные пробелы

       // Манипуляторы имеют параметры:

       SMANIP<int>  setbase(int b);
       SMANIP<int>  setfill(int f);
       SMANIP<int>  setprecision(int p);
       SMANIP<int>  setw(int w);
       SMANIP<long> resetiosflags(long b);
       SMANIP<long> setiosflags(long b);
</pre>
<p>Например,</p>
<pre>
         cout << 1234 << ' '
              << hex  << 1234 << ' '
              << oct  << 1234 << endl;
</pre>
<p>напечатает</p>
<pre>
         1234 4d2 2322
</pre>
<p>и</p>
<pre>
         cout << setw(4) << setfill('#') << '(' << 12 << ")\n";
         cout << '(' << 12 << ")\n";
</pre>
<p>напечатает</p>
<pre>
         (##12)
         (12)
</pre>
<p>Не забудьте включить файл <iomanip.h>, если используете манипуляторы с
  параметрами.</p>

<a name='ostream'></a><h5>10.4.3 Члены ostream</h5>

<p>В классе ostream есть лишь несколько функций для управления выводом,
  большая часть таких функций находится в классе ios.</p>
<pre>
       class ostream : public virtual ios {
           //...
       public:
           ostream& flush();

           ostream&  seekp(streampos);
           ostream&  seekp(streamoff, seek_dir);
           streampos tellp();
           //...
       };
</pre>
<p>Как мы уже говорили, функция flush() опустошает буфер в выходной поток.
  Остальные функции используются для позиционирования в ostream при
  записи. Окончание на букву p указывает, что именно позиция используется
  при выдаче символов в заданный поток. Конечно эти функции имеют смысл,
  только если поток присоединен к чему-либо, что допускает
  позиционирование, например файл. Тип streampos представляет позицию символа
  в файле, а тип streamoff представляет смещение относительно позиции,
  заданной seek_dir. Все они определены в классе ios:</p>
<pre>
       class ios {
           //...
           enum seek_dir {
              beg=0,  // от начала файла
              cur=1,  // от текущей позиции в файле
              end=2   // от конца файла
           };
           //...
       };
</pre>
<p>Позиции в потоке отсчитываются от 0, как если бы файл был массивом из
  n символов:</p>
<pre>
           char file[n-1];
</pre>
<p>и если fout присоединено к file, то</p>
<pre>
           fout.seek(10);
           fout<<'#';
</pre>
<p>поместит # в file[10].</p>

<a name='istream'></a><h5>10.4.4 Члены istream</h5>

<p>Как и для ostream, большинство функций форматирования и управления
  вводом находится не в классе iostream, а в базовом классе ios.</p>
<pre>
       class istream : public virtual ios {
           //...
       public:
           int         peek()
           istream&    putback(char c);

           istream&    seekg(streampos);
           istream&    seekg(streamoff, seek_dir);
           streampos   tellg();
           //...
       };
</pre>
<p>Функции позиционирования работают как и их двойники из ostream.
  Окончание на букву g показывает, что именно позиция используется при
  вводе символов из заданного потока. Буквы p и g нужны, поскольку
  мы можем создать производный класс iostreams из классов ostream и
  istream, и в нем необходимо следить за позициями ввода и вывода.</p>
<p>С помощью функции peek() программа может узнать следующий символ,
  подлежащий вводу, не затрагивая результата последующего чтения. С
  помощью функции putback(), как показано в п.<a href='#inuser'>10.3.3</a>, можно вернуть
  ненужный символ назад в поток, чтобы он был прочитан в другое время.</p>

<a name='files'></a><h4>10.5 Файлы и потоки</h4>

<p>Ниже приведена программа копирования одного файла в другой. Имена
  файлов берутся из командной строки программы:</p>
<pre>
       #include <fstream.h>
       #include <libc.h>

       void error(char* s, char* s2 ="")
       {
          cerr << s << ' ' << s2 << '\n';
          exit(1);
       }

       int main(int argc, char* argv[])
       {
           if (argc != 3) error("wrong number of arguments");

           ifstream from(argv[1]);
           if (!from) error("cannot open input file",argv[1]);

           ostream to(argv[2]);
           if (!to) error("cannot open output file",argv[2]);

           char ch;
           while (from.get(ch)) to.put(ch);

           if (!from.eof() || to.bad())
              error("something strange happened");

           return 0;
        }
</pre>
<p>Для открытия выходного файла создается объект класса ofstream -
  выходной поток файла, использующий в качестве аргумента имя файла.
  Аналогично, для открытия входного файла создается объект класса
  ifstream - входной файловый поток, также использующий в качестве
  аргумента имя файла. В обоих случаях следует  проверить состояние
  созданного объекта, чтобы убедиться в успешном открытии файла, а
  если это не так, операции завершатся не успешно, но корректно.</p>
<p>По умолчанию ifstream всегда открывается на чтение, а ofstream
  открывается на запись. В ostream и в istream можно использовать
  необязательный второй аргумент, указывающий иные режимы открытия:</p>
<pre>
       class ios {
       public:
           //...
           enum open_mode {
              in=1,            // открыть на чтение
              out=2,           // открыть как выходной
              ate=4,           // открыть и переместиться в конец файла
              app=010,         // добавить
              trunc=020,       // сократить файл до нулевой длины
              nocreate=040,    // неудача, если файл не существует
              noreplace=0100   // неудача, если файл существует
           };
           //...
       };
</pre>
<p>Настоящие значения для open_mode и их смысл вероятно будут зависеть
  от реализации. Будьте добры, за деталями обратитесь к руководству по
  вашей библиотеке или экспериментируйте. Приведенные комментарии
  могут прояснить их назначение. Например, можно открыть файл с условием,
  что операция открытия не выполнится, если файл уже не существует:</p>
<pre>
       void f()
       {
           ofstream mystream(name,ios::out|ios::nocreate);

           if (ofstream.bad()) {
               //...
           }
           //...
       }
</pre>
<p>Также можно открыть файл сразу на чтение и запись:</p>
<pre>
         fstream dictionary("concordance", ios::in|ios::out);
</pre>
<p>Все операции, допустимые для ostream и ostream, можно применять к
  fstream. На самом деле, класс fstream является производным от iostream,
  который является, в свою очередь, производным от istream и ostream.
  Причина, по которой информация по буферизации и форматированию для
  ostream и istream находится в виртуальном базовом классе ios, в том,
  чтобы заставить действовать всю эту последовательность производных
  классов. По этой же причине операции позиционирования в istream и
  ostream имеют разные имена - seekp() и seekg(). В iostream есть
  отдельные позиции для чтения и записи.</p>

<a name='close'></a><h5>10.5.1 Закрытие потоков</h5>

<p>Файл может быть закрыт явно, если вызвать close() для его потока:</p>
<pre>
        mystream.close();
</pre>
<p>Но это неявно делает деструктор потока, так что явный вызов close()
  может понадобиться, если только файл нужно закрыть до достижения
  конца области определенности потока.</p>
<p>Здесь возникает вопрос, как реализация может обеспечить
  создание предопределенных потоков cout, cin и cerr до их первого
  использования и закрытие их только после последнего использования.
  Конечно, разные реализации библиотеки потоков из &lt;iostream.h> могут
  по-разному решать эту задачу. В конце концов, решение - это
  прерогатива реализации, и оно должно быть скрыто от пользователя. Здесь
  приводится только один способ, примененный только в одной реализации,
  но он достаточно общий, чтобы гарантировать правильный порядок
  создания и уничтожения глобальных объектов различных типов.</p>
<p>Основная идея в том, чтобы определить вспомогательный класс,
  который по сути служит счетчиком, следящим за тем, сколько раз
  &lt;iostream.h> был включен в раздельно компилировавшиеся программные
  файлы:</p>
<pre>
       class Io_init {
           static int count;
           //...
       public:
           Io_init();
           ^Io_init();
       };

       static Io_init io_init ;
</pre>
<p>Для каждого программного файла определен свой объект с именем io_init.
  Конструктор для объектов io_init использует Io_init::count как первый
  признак того, что действительная инициализация глобальных объектов
  потоковой библиотеки ввода-вывода сделана в точности один раз:</p>
<pre>
       Io_init::Io_init()
       {
          if (count++ == 0) {
              // инициализировать cout
              // инициализировать cerr
              // инициализировать cin
              // и т.д.
          }
       }
</pre>
<p>Обратно, деструктор для объектов io_init использует Io_count, как
  последнее указание на то, что все потоки закрыты:</p>
<pre>
       Io_init::^Io_init()
       {
          if (--count == 0) {
              // очистить cout (сброс, и т.д.)
              // очистить cerr (сброс, и т.д.)
              // очистить cin
              // и т.д.
          }
        }
</pre>
<p>Это общий прием работы с библиотеками, требующими инициализации и
  удаления глобальных объектов. Впервые в С++ его применил Д. Шварц.
  В системах, где при выполнении все программы размещаются в основной
  памяти, для этого приема нет помех. Если это не так, то накладные
  расходы, связанные с вызовом в память каждого программного файла
  для выполнения функций инициализации, будут заметны. Как всегда,
  лучше, по возможности, избегать глобальных объектов. Для классов,
  в которых каждая операция значительна по объему выполняемой работы,
  чтобы гарантировать инициализацию, было бы разумно проверять такие
  первые признаки (наподобие Io_init::count) при каждой операции.
  Однако, для потоков такой подход был бы излишне расточительным.</p>

<a name='strinf'></a><h5>10.5.2 Строковые потоки</h5>

<p>Как было показано, поток может быть привязан к файлу, т.е. массиву
  символов, хранящемуся не в основной памяти, а, например, на диске. Точно
  так же поток можно привязать к массиву символов в основной памяти.
  Например, можно воспользоваться выходным строковым потоком ostrstream
  для форматирования сообщений, не подлежащих немедленной печати:</p>
<pre>
       char* p = new char[message_size];
       ostrstream ost(p,message_size);
       do_something(arguments,ost);
       display(p);
</pre>
<p>С помощью стандартных операций вывода функция do_something может писать
  в поток ost, передавать ost подчиняющимся ей функциям и т.п. Контроль
  переполнения не нужен, поскольку ost знает свой размер и при заполнении
  перейдет в состояние, определяемое fail(). Затем функция display может
  послать сообщение в "настоящий" выходной поток. Такой прием наиболее
  подходит в тех случаях, когда окончательная операция вывода
  предназначена для записи на более сложное устройство, чем традиционное,
  ориентированное на последовательность строк, выводное устройство.
  Например, текст из ost может быть помещен в фиксированную область на экране.</p>
<p>Аналогично, istrstream является вводным строковым потоком,
  читающим из последовательности символов, заканчивающейся нулем:</p>
<pre>
       void word_per_line(char v[], int sz)
       /*
          печатать "v" размером "sz" по одному слову в строке
       */
       {
          istrstream ist(v,sz);  // создать istream для v
          char b2[MAX];          // длиннее самого длинного слова
          while (ist>>b2) cout &lt;&lt;b2 &lt;&lt; "\n";
        }
</pre>
<p>Завершающий нуль считается концом файла.
          Строковые потоки описаны в файле &lt;strstream.h>.</p>

<a name='buffer'></a><h5>10.5.3 Буферизация</h5>

<p>Все операции ввода-вывода были определены без всякой связи с типом
  файла, но нельзя одинаково работать со всеми устройствами без учета
  алгоритма буферизации. Очевидно, что потоку ostream, привязанному к
  строке символов, нужен не такой буфер, как ostream, привязанному к
  файлу. Такие вопросы решаются созданием во время инициализации разных
  буферов для потоков разных типов. Но существует только один набор
  операций над этими типами буферов, поэтому в ostream нет функций, код
  которых учитывает различие буферов. Однако, функции, следящие за
  переполнением и обращением к пустому буферу, являются виртуальными.
  Это хороший пример применения виртуальных функций для единообразной
  работы с эквивалентными логически, но различно реализованными
  структурами, и они вполне справляются с требуемыми алгоритмами буферизации.
  Описание буфера потока в файле <iostream.h> может выглядеть следующим
  образом:</p>
<pre>
       class streambuf {     // управление буфером потока
       protected:
           char* base;       // начало буфера
           char* pptr;       // следующий свободный байт
           char* gptr;       // следующий заполненный байт
           char* eptr;       // один из указателей на конец буфера
           char  alloc;      // буфер, размещенный с помощью "new"
           //...
           // Опустошить буфер:
           // Вернуть EOF при ошибке, 0 - удача
       virtual int overflow(int c = EOF);

           // Заполнить буфер:
           // Вернуть EOF в случае ошибки или конца входного потока,
           // иначе вернуть очередной символ
        virtual int underflow();
        //...
        public:
            streambuf();
            streambuf(char* p, int l);
            virtual ~streambuf();

            int snextc()       // получить очередной символ
            {
                return (++gptr==pptr) ? underflow() : *gptr&0377;
            }
            int allocate();    // отвести память под буфер
            //...
       };
</pre>
<p>Подробности реализации класса streambuf приведены здесь только для
  полноты представления. Не предполагается, что есть общедоступные
  реализации, использующие именно эти имена. Обратите внимание на
  определенные здесь указатели, управляющие буфером; с их помощью
  простые посимвольные операции с потоком можно определить максимально
  эффективно (и причем однократно) как функции-подстановки. Только
  функции overflow() и underflow() требует своей реализации для каждого
  алгоритма буферизации, например:</p>
<pre>
     class filebuf : public streambuf {
     protected:
         int  fd;            // дескриптор файла
         char opened;        // признак открытия файла
     public:
         filebuf() { opened = 0; }
         filebuf(int nfd, char* p, int l)
             : streambuf(p,l) { /* ... */ }
         ~filebuf() { close(); }

         int overflow(int c=EOF);
         int underflow();

         filebuf* open(char *name, ios::open_mode om);
         int close() { /* ... */ }
         //...
     };
     int filebuf::underflow()    // заполнить буфер из "fd"
     {
         if (!opened || allocate()==EOF) return EOF;

         int count = read(fd, base, eptr-base);
         if (count < 1) return EOF;

         gptr = base;
         pptr = base + count;
         return *gptr & 0377; // &0377 предотвращает размножение знака
      }
</pre>
<p>За дальнейшими подробностями обратитесь к руководству по реализации
  класса streambuf.</p>

<a name='inout'></a><h4>10.6 Ввод-вывод в С</h4>

<p>Поскольку текст программ на С и на С++ часто путают, то путают иногда
  и потоковый ввод-вывод С++ и функции ввода-вывода семейства  printf для
  языка С. Далее, т.к. С-функции можно вызывать из программы на С++, то
  многие предпочитают использовать более знакомые функции ввода-вывода С.</p>
<p>По этой причине здесь будет дана основа функций ввода-вывода С.
  Обычно операции ввода-вывода на С и на С++ могут идти по очереди на
  уровне строк. Перемешивание их на уровне посимвольного ввода-вывода
  возможно для некоторых реализаций, но такая программа может быть
  непереносимой. Некоторые реализации потоковой библиотеки С++ при допущении
  ввода-вывода на С требуют вызова статической функции-члена
  ios::sync_with_stdio().</p>
<p>В общем, потоковые функции вывода имеют перед стандартной
  функцией С printf() то преимущество, что потоковые функции обладают
  определенной типовой надежностью и единообразно определяют вывод
  объектов предопределенного и пользовательского типов.</p>
<p>Основная функция вывода С есть</p>
<pre>
          int printf(const char* format, ...)
</pre>
<p>и она выводит произвольную последовательность параметров в формате,
  задаваемом строкой форматирования format. Строка форматирования состоит
  из объектов двух типов: простые символы, которые просто копируются в
  выходной поток, и спецификации преобразований, каждая из которых
  преобразует и печатает очередной параметр.  Каждая спецификация
  преобразования начинается с символа %, например</p>
<pre>
          printf("there were %d members present.",no_of_members);
</pre>
<p>Здесь %d указывает, что no_of_members следует считать целым и печатать
  как соответствующую последовательность десятичных цифр. Если
  no_of_members==127, то будет напечатано</p>
<pre>
         there were 127 members present.
</pre>
<p>Набор спецификаций преобразований достаточно большой и обеспечивает
  большую гибкость печати. За символом % может следовать:
<p>
<table border="0" width="100%">
<tr>
<th valign=_top>-&nbsp;&nbsp;</th><td>необязательный знак минус, задающий выравнивание влево в указанном
    поле для преобразованного значения;</td>
</tr>
<tr>
<th valign=_top>d&nbsp;&nbsp;</th><td>необязательная строка цифр,  задающая ширину поля; если в
    преобразованном значении меньше символов, чем ширина строки, то оно
    дополнится до ширины поля пробелами слева (или справа, если дана
    спецификация выравнивания влево); если строка ширины поля начинается
    с нуля, то дополнение будет проводится нулями, а не пробелами;</td>
</tr>
<tr>
<th valign=_top>.&nbsp;&nbsp;</th><td>необязательный символ точка служит для отделения ширины поля от
    последующей строки цифр;</td>
</tr>
<tr>
<th valign=_top>d&nbsp;&nbsp;</th><td>необязательная строка цифр, задающая точность, которая определяет
    число цифр после десятичной точки для значений в спецификациях
    e или f, или же задает максимальное число печатаемых символов
    строки;</td>
</tr>
<tr>
<th valign=_top>*&nbsp;&nbsp;</th><td>для задания ширины поля или точности может использоваться * вместо
    строки цифр. В этом случае должен быть параметр целого типа, который
    содержит значение ширины поля или точности;</td>
</tr>
<tr>
<th valign=_top>h&nbsp;&nbsp;</th><td>необязательный символ h указывает, что последующая спецификация d,
    o, x или u относится к параметру типа короткое целое;</td>
</tr>
<tr>
<th valign=_top>l&nbsp;&nbsp;</th><td>необязательный символ l указывает, что последующая спецификация d,
    o, x или u относится к параметру типа длинное целое;</td>
</tr>
<tr>
<th valign=_top>%&nbsp;&nbsp;</th><td>обозначает, что нужно напечатать сам символ %; параметр не нужен;</td>
</tr>
<tr>
<th valign=_top>c&nbsp;&nbsp;</th><td>символ, указывающий тип требуемого преобразования. 
Символы преобразования и их смысл следующие:<br>
  <table border="0" width="100%">
  <tr>
  <th valign=_top>d&nbsp;&nbsp;</th><td>Целый параметр выдается в десятичной записи;</td>
  </tr>
  <tr>
  <th valign=_top>o&nbsp;&nbsp;</th><td>Целый параметр выдается в восьмеричной записи;</td>
  </tr>
  <tr>
  <th valign=_top>x&nbsp;&nbsp;</th><td>Целый параметр выдается в шестнадцатеричной записи;</td>
  </tr>
  <tr>
  <th valign=_top>f&nbsp;&nbsp;</th><td>Вещественный или с двойной точностью параметр выдается в
          десятичной записи  вида [-]ddd.ddd, где число цифр после
          точки равно спецификации точности для параметра. Если точность
          не задана, печатается шесть цифр; если явно задана точность 0,
          точка и цифры после нее не печатаются;</td>
  </tr>
  <tr>
  <th valign=_top>e&nbsp;&nbsp;</th><td>Вещественный или с двойной точностью параметр выдается в
          десятичной записи вида [-]d.ddde+dd; здесь одна цифра перед
          точкой, а число цифр после точки равно спецификации точности
          для параметра; если она не задана печатается шесть цифр;</td>
  </tr>
  <tr>
  <th valign=_top>g&nbsp;&nbsp;</th><td>Вещественный или с двойной точностью параметр печатается по той
          спецификации d, f или e, которая дает большую точность при
          меньшей ширине поля;</td>
  </tr>
  <tr>
  <th valign=_top>c&nbsp;&nbsp;</th><td>Символьный параметр печатается. Нулевые символы 
игнорируются;</td>
  </tr>
  <tr>
  <th valign=_top>s&nbsp;&nbsp;</th><td>Параметр считается строкой (символьный указатель), и печатаются
          символы из строки до нулевого символа или до достижения числа
          символов, равного спецификации точности; но, если точность
          равна 0 или не указана, печатаются все символы до нулевого;</td>
  </tr>
  <tr>
  <th valign=_top>p&nbsp;&nbsp;</th><td>Параметр считается указателем и его вид на печати зависит от
          реализации;</td>
  </tr>
  <tr>
  <th valign=_top>u&nbsp;&nbsp;</th><td>Беззнаковый целый параметр печатается в десятичной 
записи.</td>
  </tr>
  </table>
</td>
</tr>
</table>

<p>Несуществующее поле или поле с шириной, меньшей реальной, приведет
  к усечению поля. Дополнение пробелами происходит, если только
  спецификация ширины поля больше реальной ширины.
  Ниже приведен более сложный пример:</p>
<pre>
       char* src_file_name;
       int line;
       char* line_format = "\n#line %d \"%s\"\n";
       main()
       {
          line = 13;
          src_file_name = "C++/main.c";

          printf("int a;\n");
          printf(line_format,line,src_file_name);
          printf("int b;\n");
       }
</pre>
<p>в котором печатается</p>
<pre>
        int a;

        #line 13 "C++/main.c"
        int b;
</pre>
<p>Использование printf() ненадежно в том смысле, что нет никакого
  контроля типов. Так, ниже приведен известный способ получения
  неожиданного результата - печати мусорного значения или чего похуже:</p>
<pre>
        char x;
        // ...
        printf("bad input char: %s",x);
</pre>
<p>Однако, эти функции обеспечивают большую гибкость и знакомы
  программирующим на С.</p>
<p>Как обычно, getchar() позволяет знакомым способом читать символы из
  входного потока:</p>
<pre>
        int i;:
        while ((i=getchar())!=EOF) { // символьный ввод C
           // используем i
        }
</pre>
<p>Обратите внимание: чтобы было законным сравнение с величиной EOF типа
  int при проверке на конец файла, результат getchar() надо помещать в
  переменную типа int, а не char.</p>
<p>За подробностями о вводе-выводе на С отсылаем к вашему руководству
  по С или книге Кернигана и Ритчи "Язык программирования С".</p>

<a name='exercise'></a><h4>10.7 Упражнения</h4>
<ol>
<li>(*1.5) Читая файл вещественных чисел, составлять из пар прочитанных
     чисел комплексные числа, записать комплексные числа.
<li>(*1.5) Определить тип name_and_address (тип_и_адрес). Определить для
     него << и >>. Написать программу копирования объектов потока
     name_and_address.
<li>(*2) Разработать несколько функций для запроса и чтения данных
     разных типов. Предложения: целое, вещественное число, имя файла,
     почтовый адрес, дата, личная информация, и т.п. Попытайтесь сделать
     их устойчивыми к ошибкам.
<li>(*1.5) Напишите программу, которая печатает: (1) строчные буквы,
     (2) все буквы, (3) все буквы и цифры, (4) все символы, входящие в
     идентификатор в вашей версии С++, (5) все знаки пунктуации,
     (6) целые значения всех управляющих символов, (7) все обобщенные
     пробелы, (8) целые значения всех обобщенных пробелов, и, наконец,
     (9) все изображаемые символы.
<li>(*4) Реализуйте стандартную библиотеку ввода-вывода С (<stdio.h>)
     с помощью стандартной библиотеки ввода-вывода С++ (<iostream.h>).
<li>(*4) Реализуйте стандартную библиотеку ввода-вывода С++
     (<iostream.h>) с помощью стандартной библиотеки ввода-вывода С
     (<stdio.h>).
<li>(*4) Реализуйте библиотеки С и С++ так, чтобы их можно было
     использовать одновременно.
<li>(*2) Реализуйте класс, для которого операция [] перегружена так,
     чтобы обеспечить произвольное чтение символов из файла.
<li>(*3) Повторите упражнение 8, но добейтесь, чтобы операция [] была
     применима для чтения и для записи. Подсказка: пусть [] возвращает
     объект "дескриптор типа", для которого присваивание означает:
     присвоить через дескриптор файлу, а неявное приведение к типу char
     означает чтение файла по дескриптору.
<li>(*2) Повторите упражнение 9, позволяя операции [] индексировать
     объекты произвольных типов, а не только символы.
<li>(*3.5) Продумайте  и реализуйте операцию форматного ввода.
     Используйте для задания формата строку спецификаций как в printf().
     Должна быть возможность  попыток применения нескольких спецификаций для
     одного ввода, чтобы найти требуемый формат. Класс форматного ввода
     должен быть производным класса istream.
<li>(*4) Придумайте (и реализуйте) лучшие форматы ввода.
<li>(**2) Определите для вывода манипулятор based с двумя параметрами:
     система счисления и целое значение, и печатайте целое в
     представлении, определяемом системой счисления. Например, based(2,9)
     напечатает 1001.
<li>(**2) Напишите "миниатюрную" систему ввода-вывода, которая реализует
     классы istream, ostream, ifstream, ofstream и предоставляет функции,
     такие как operator<<() и operator>>() для целых, и операции, такие
     как open() и close() для файлов. Используйте исключительные
     ситуации, а не переменные состояния, для сообщения об ошибках.
<li>(**2) Напишите манипулятор, который включает и отключает эхо
     символа.
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap11.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>