<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 9<br>
Механизм обработки особых ситуаций</h3>

<p align="right"><i>Я прервал вас, поэтому не прерывайте меня.<br>
- Уинстон Черчилл</i></p>

<p>В этой главе описан механизм обработки особых ситуаций и некоторые,
      основывающиеся на нем, способы обработки ошибок. Механизм состоит
      в запуске особой ситуации, которую должен перехватить специальный
      обработчик. Описываются правила перехвата особых ситуаций и
      правила реакции на неперехваченные и неожиданные особые ситуации.
      Целые группы особых ситуаций можно определить как производные
      классы. Описывается способ, использующий деструкторы и обработку
      особых ситуаций, который обеспечивает надежное и скрытое от
      пользователя управление ресурсами.</p>

<a name="errorhand"></a><h4>9.1 Обработка ошибок</h4>

<p>Создатель библиотеки способен обнаружить динамические ошибки, но не
   представляет какой в общем случае должна быть реакция на них.
   Пользователь библиотеки способен написать реакцию на такие ошибки,
   но не в силах их обнаружить. Если бы он мог, то сам разобрался бы
   с ошибками в своей программе, и их не пришлось бы выявлять
   в библиотечных функциях. Для решения этой проблемы в язык введено
   понятие особой ситуации +.</p>

<p>+ Только недавно комитетом по стандартизации С++ особые ситуации были
   включены в стандарт языка, но на время написания этой книги они еще
   не вошли в большинство реализаций.</p>

<p>Суть этого понятия в том, что функция, которая обнаружила ошибку и не
   может справиться с нею, запускает особую ситуацию, рассчитывая, что
   устранить проблему можно в той функции, которая прямо или опосредованно
   вызывала первую. Если функция рассчитана на обработку ошибок некоторого
   вида, она может указать это явно, как готовность перехватить данную
   особую ситуацию.</p>
<p>Рассмотрим в качестве примера как для класса Vector можно
   представлять и обрабатывать особые ситуации, вызванные выходом за
   границу массива:</p>
<pre>
                 class Vector {
                   int* p;
                   int  sz;
                 public:
                   class Range  {  };  // класс для особой ситуации

                   int& operator[](int i);

                   // ...
                 };
</pre>  
<p>Предполагается, что объекты класса Range будут использоваться как
    особые ситуации, и запускать их можно так:</p>
<pre>
                 int& Vector::operator[](int i)
                 {
                   if (0&lt;=i && i&lt;sz) return p[i];
                   throw Range();
                 }
</pre>
<p>Если в функции предусмотрена реакция на ошибку недопустимого значения
    индекса, то ту часть функции, в которой эти ошибки будут перехватываться,
    надо поместить в оператор try. В нем должен быть и обработчик особой
    ситуации:</p>
<pre>
        void f(Vector& v)
        {
         // ...

         try {
          do_something(v);  // содержательная часть, работающая с v
         }
         catch (Vector::Range) {
         // обработчик особой ситуации Vector::Range

         // если do_something() завершится неудачно,
         // нужно как-то среагировать на это

         // сюда мы попадем только в том случае, когда
         // вызов do_something() приведет к вызову Vector::operator[]()
         // из-за недопустимого значения индекса

         }

         // ...
       }
</pre>
<p>Обработчиком особой ситуации называется конструкция</p>
<pre>
             catch ( /* ... */ ) {
               // ...
             }
</pre>
<p>Ее можно использовать только сразу после блока, начинающегося служебным
   словом try, или сразу после другого обработчика особой ситуации. Служебным
   является и слово catch. После него идет в скобках описание, которое
   используется аналогично описанию формальных параметров функции, а именно,
   в нем задается тип объектов, на которые рассчитан обработчик, и,
   возможно, имена параметров (см. п.<a href="#names">9.3</a>). Если в 
do_something() или в
   любой вызванной из нее функции произойдет ошибка индекса (на любом
   объекте Vector), то обработчик перехватит особую ситуацию и будет
   выполняться часть, обрабатывающая ошибку. Например, определения следующих
   функций приведут к запуску обработчика в f():</p>
<pre>
            void do_something()
            {
              // ...
              crash(v);
              // ...
            }

            void crash(Vector& v)
            {
               v[v.size()+10];  // искусственно вызываем ошибку индекса
            }
</pre>
<p>Процесс запуска и перехвата особой ситуации предполагает просмотр
   цепочки вызовов от точки запуска особой ситуации до функции, в которой
   она перехватывается. При этом восстанавливается состояние стека,
   соответствующее функции, перехватившей ошибку, и при проходе по всей
   цепочке вызовов для локальных объектов функций из этой цепочки вызываются
   деструкторы. Подробно это описано в п.<a href="#resurs">9.4</a>.</p>
<p>Если при просмотре всей цепочки вызовов, начиная с запустившей
   особую ситуацию функции, не обнаружится подходящий обработчик, то
   программа завершается. Подробно это описано в п.<a href="#notint">9.7</a>.</p>
<p>Если обработчик перехватил особую ситуацию, то она будет обрабатываться
   и другие, рассчитанные на эту ситуацию, обработчики не будут
   рассматриваться. Иными словами, активирован будет только тот обработчик,
   который находится в самой последней вызывавшейся функции, содержащей
   соответствующие обработчики. В нашем примере функция f() перехватит
   Vector::Range, поэтому эту особую ситуацию нельзя перехватить ни в
   какой вызывающей f() функции:</p>
<pre>
         int ff(Vector& v)
         {
           try {
                 f(v);         // в f() будет перехвачена Vector::Range
           }
           catch (Vector::Range) { // значит сюда мы никогда не попадем
              // ...
           }
         }
</pre><p>

<a name="special"></a><h5>9.1.1 Особые ситуации и традиционная обработка ошибок</h5>

<p>Наш способ обработки ошибок по многим параметрам выгодно отличается от
   более традиционных способов. Перечислим, что может сделать операция
   индексации Vector::operator[]() при обнаружении недопустимого значения
   индекса:</p>
<ol>
<li>завершить программу;
<li>возвратить значение, трактуемое как "ошибка";
<li>возвратить нормальное значение и оставить программу в
           неопределенном состоянии;
<li>вызвать функцию, заданную для реакции на такую ошибку.
</ol>
<p>Вариант [1] ("завершить программу") реализуется по умолчанию в том
   случае, когда особая ситуация не была перехвачена. Для большинства
   ошибок можно и нужно обеспечить лучшую реакцию.</p>
<p>Вариант [2] ("возвратить значение "ошибка"") можно реализовать
   не всегда, поскольку не всегда удается определить значение "ошибка".
   Так, в нашем примере любое целое является допустимым значением для
   результата операции индексации. Если можно выделить такое особое
   значение, то часто этот вариант все равно оказывается неудобным,
   поскольку проверять на это значение приходится при каждом вызове. Так
   можно легко удвоить размер программы. Поэтому для обнаружения всех
   ошибок этот вариант редко используется последовательно.</p>
<p>Вариант [3] ("оставить программу в неопределенном состоянии")
   имеет тот недостаток, что вызывавшая функция может не заметить
   ненормального состояния программы. Например, во многих функциях
   стандартной библиотеки С для сигнализации об ошибке устанавливается
   соответствующее значение  глобальной переменной errno. Однако,
   в программах пользователя обычно нет достаточно последовательного
   контроля errno, и в результате возникают наведенные ошибки,
   вызванные тем, что стандартные функции возвращают не то значение.
   Кроме того, если в программе есть параллельные вычисления,
   использование одной глобальной переменной для сигнализации о разных
   ошибках неизбежно приведет к катастрофе.</p>
<p>Обработка особых ситуаций не предназначалась для тех случаев,
   на которые рассчитан вариант [4] ( "вызвать функцию реакции на
   ошибку"). Отметим, однако, что если особые ситуации не предусмотрены,
   то вместо функции реакции на ошибку можно как раз использовать
   только один из трех перечисленных вариантов. Обсуждение функций
   реакций и особых ситуацией будет продолжено в п.<a href="#exhaust">9.4.3</a>.</p>
<p>Механизм особых ситуаций успешно заменяет традиционные
   способы обработки ошибок в тех случаях, когда последние являются
   неполным, некрасивым или чреватым ошибками решением. Этот механизм
   позволяет явно отделить часть программы, в которой обрабатываются
   ошибки, от остальной ее части, тем самым программа становится более
   понятной и с ней проще работать различным сервисным программам.
   Свойственный этому механизму регулярный способ обработки ошибок
   упрощает взаимодействие между раздельно написанными частями
   программы.</p>
<p>В этом способе обработки ошибок есть для программирующих на С
   новый момент: стандартная реакция на ошибку (особенно на ошибку
   в библиотечной функции) состоит в завершении программы. Традиционной
   была реакция продолжать программу в надежде, что она как-то
   завершится сама. Поэтому способ, базирующийся на особых ситуациях,
   делает программу более "хрупкой" в том смысле, что требуется
   больше усилий и внимания для ее нормального выполнения. Но это все-таки
   лучше, чем получать неверные результаты на более поздней стадии
   развития программы (или получать их еще позже, когда программу
   сочтут завершенной и передадут ничего не подозревающему пользователю).
   Если завершение программы является неприемлемой реакцией, можно
   смоделировать традиционную реакцию с помощью перехвата всех особых
   ситуаций или всех особых ситуаций, принадлежащих специальному
   классу (п.<a href="#dersituat">9.3.2</a>).</p>
<p>Механизм особых ситуаций можно рассматривать как динамический
   аналог механизма контроля типов и проверки неоднозначности
   на стадии трансляции. При таком подходе более важной становится
   стадия проектирования программы, и требуется большая поддержка
   процесса выполнения программы, чем для программ на С. Однако,
   в результате получится более предсказуемая программа, ее будет проще
   встроить в программную систему, она будет понятнее другим программистам и
   с ней проще будет работать различным сервисным программам. Можно
   сказать, что механизм особых ситуаций поддерживает,
   подобно другим средствам С++, "хороший" стиль программирования,
   который в таких языках, как С, можно применять только не в полном
   объеме и на неформальном уровне.</p>
<p>Все же надо сознавать, что обработка ошибок остается трудной
   задачей, и, хотя механизм особых ситуаций более строгий,
   чем традиционные способы, он все равно недостаточно структурирован
   по сравнению с конструкциями, допускающими только локальную передачу
   управления.</p>

<a name="other"></a><h5>9.1.2 Другие точки зрения на особые ситуации</h5>

<p>"Особая ситуация" - одно из тех понятий, которые имеют разный смысл
   для разных людей. В С++ механизм особых ситуаций предназначен для
   обработки ошибок. В частности, он предназначен для обработки ошибок
   в программах, состоящих из независимо создаваемых компонентов.</p>
<p>Этот механизм рассчитан на особые ситуации, возникающие только при
   последовательном выполнении программы (например, контроль границ
   массива). Асинхронные особые ситуации такие, например, как прерывания
   от клавиатуры, нельзя непосредственно обрабатывать с помощью этого
   механизма. В различных системах существуют другие механизмы,
   например, сигналы, но они здесь не рассматриваются, поскольку зависят
   от конкретной системы.</p>
<p>Механизм особых ситуаций является конструкцией с нелокальной
   передачей управления и его можно рассматривать как вариант оператора
   return. Поэтому особые ситуации можно использовать для целей, никак
   не связанных с обработкой ошибок (п.<a href="#noterror">9.5</a>). Все-таки основным
   назначением механизма особых ситуаций и темой этой главы будет
   обработка ошибок и создание устойчивых к ошибкам программ.</p>

<a name="disting"></a><h4>9.2 Различение особых ситуаций</h4>

<p>Естественно, в программе возможны несколько различных динамических
   ошибок. Эти ошибки можно сопоставить с особыми ситуациями, имеющими
   различные имена. Так, в классе Vector обычно приходится выявлять
   и сообщать об ошибках двух видов: ошибки диапазона и ошибки,
   вызванные неподходящим для конструктора параметром:</p>
<pre>
           class Vector {
             int* p;
             int sz;
           public:
             enum { max = 32000 };
             class Range { };  // особая ситуация индекса
             class Size { };   // особая ситуация "неверный размер"
             Vector(int sz);
             int& operator[](int i);

             // ...
          };
</pre>
<p>Как было сказано, операция индексации запускает особую ситуацию
   Range, если ей задан выходящий из диапазона значений индекс.
   Конструктор запускает особую ситуацию Size, если ему задан
   недопустимый размер вектора:</p>
<pre>
          Vector::Vector(int sz)
          {
            if (sz&lt;0 || max&lt;sz) throw Size();
            // ...
          }
</pre>
<p>Пользователь класса Vector может различить эти две особые ситуации,
   если в проверяемом блоке (т.е. в блоке оператора try) укажет
   обработчики для обеих ситуаций:</p>
<pre>
          void f()
          {
            try {
                use_vectors();
            }
            catch (Vector::Range) {
                // ...
            }
            catch (Vector::Size) {
                // ...
            }
          }
</pre>
<p>В зависимости от особой ситуации будет выполняться соответствующий
   обработчик. Если управление дойдет до конца операторов обработчика,
   следующим будет выполняться оператор, который идет после списка
   обработчиков:</p>
<pre>
          void f()
          {
            try {
               use_vectors();
            }
            catch (Vector::Range) {
               // исправить индекс и
               // попробовать опять:
               f();
            }
            catch (Vector::Size) {
               cerr << "Ошибка в конструкторе Vector::Size";
               exit(99);
            }
            // сюда мы попадем, если вообще не было особых ситуаций
            // или после обработки особой ситуации Range
         }
</pre>
<p>Список обработчиков напоминает переключатель, но здесь в теле
   обработчика операторы break не нужны. Синтаксис списка обработчиков
   отличен от синтаксиса вариантов case переключателя частично по
   этой причине, частично потому, чтобы показать, что каждый
   обработчик определяет свою область видимости (см. п.<a href="#method">9.8</a>).</p>
<p>Не обязательно все особые ситуации перехватывать в одной функции:</p>
<pre>
         void f1()
         {
           try {
             f2(v);
           }
           catch (Vector::Size) {
           // ...
           }
         }

         void f2(Vector& v)
         {
           try {
              use_vectors();
           }
           catch (Vector::Range) {
           // ...
           }
         }
</pre>
<p>Здесь f2() перехватит особую ситуацию Range, возникающую в
   use_vectors(), а особая ситуация Size будет оставлена для f1().</p>
<p>     С точки зрения языка особая ситуация считается обработанной сразу
   при входе в тело ее обработчика. Поэтому все особые ситуации,
   запускаемые при выполнении этого обработчика, должны обрабатываться
   в функциях, вызвавших ту функцию, которая содержит проверяемый блок.
   Значит в следующем примере не возникнет бесконечного цикла:</p>
<pre>
          try {
              // ...
          }
          catch (input_overflow) {
             // ...
             throw input_overflow();
          }
</pre>
<p>Здесь input_overflow (переполнение при вводе) - имя глобального класса.
     Обработчики особых ситуаций могут быть вложенными:</p>
<pre>
          try {
             // ...
          }
          catch (xxii) {
            try {
               // сложная реакция
            }
            catch (xxii) {
               // ошибка в процессе сложной реакции
            }
          }
</pre>
<p>Однако, такая вложенность редко бывает нужна в обычных программах,
   и чаще всего она является свидетельством плохого стиля.</p>

<a name="names"></a><h4>9.3 Имена особых ситуаций</h4>

<p>Особая ситуация перехватывается благодаря своему типу. Однако,
   запускается ведь не тип, а объект. Если нам нужно передать некоторую
   информацию из точки запуска в обработчик, то для этого ее следует
   поместить в запускаемый объект. Например, допустим нужно знать
   значение индекса, выходящее за границы диапазона:</p>
<pre>
          class Vector {
             // ...
          public:
             class Range {
             public:
               int index;
               Range(int i) : index(i) { }
            };
            // ...
            int& operator[](int i)
            // ...
         };

         int Vector::operator[](int i)
         {
           if (o&Lt;=i && i &lt;sz) return p[i];
           throw Range(i);
         }
</pre>
<p>Чтобы исследовать недопустимое значение индекса, в обработчике
   нужно дать имя объекту, представляющему особую ситуацию:</p>
<pre>
         void  f(Vector& v)
         {
           // ...

          try {
              do_something(v);
          }
          catch (Vector::Range r ) {
             cerr << "недопустимый индекс" << r.index << '\n';
             // ...
          }
          // ...
        }
</pre>
<p>Конструкция в скобках после служебного слова catch является по сути
   описанием и она аналогична описанию формального параметра функции.
   В ней указывается каким может быть тип параметра (т.е. особой
   ситуации) и может задаваться имя для фактической, т.е. запущенной,
   особой ситуации. Вспомним, что в шаблонах типов у нас был выбор
   для именования особых ситуаций. В каждом созданном по шаблону классе
   был свой класс особой ситуации:</p>
<pre>
         template<class T> class Allocator {
            // ...
            class Exhausted { }
            // ...
            T* get();
        };

        void f(Allocator<int>& ai, Allocator<double>& ad)
        {
           try {
               // ...
           }
           catch (Allocator<int>::Exhausted) {
              // ...
           }
           catch (Allocator<double>::Exhausted) {
             // ...
           }
         }
</pre>
<p>С другой стороны, особая ситуация может быть общей для всех
   созданных по шаблону классов:</p>
<pre>
         class Allocator_Exhausted { };

         template<class T> class Allocator {
            // ...
            T* get();
         };

         void f(Allocator<int>& ai, Allocator<double>& ad)
         {
           try {
              // ...
           }
           catch (Allocator_Exhausted) {
              // ...
           }
         }
</pre>
<p>Какой способ задания особой ситуации предпочтительней, сказать трудно.
   Выбор зависит от назначения рассматриваемого шаблона.</p>

<a name="group"></a><h5>9.3.1 Группирование особых ситуаций</h5>

<p>Особые ситуации естественным образом разбиваются на семейства.
   Действительно, логично представлять семейство Matherr, в которое
   входят Overflow (переполнение), Underflow (потеря значимости) и
   некоторые другие особые ситуации. Семейство Matherr образуют
   особые ситуации, которые могут запускать математические функции
   стандартной библиотеки.</p>
<p>Один из способов задания такого семейства сводится к определению
   Matherr как типа, возможные значения которого включают Overflow и
   все остальные:</p>
<pre>
           enum { Overflow, Underflow, Zerodivide, /* ... */ };

           try {
               // ...
           }
           catch (Matherr m) {
               switch (m) {
               case Overflow:
                    // ...
               case Underflow:
                    // ...
               // ...
               }
               // ...
           }
</pre>
<p>Другой способ предполагает использование наследования и виртуальных
   функций, чтобы не вводить переключателя по значению поля типа.
   Наследование помогает описать семейства особых ситуаций:</p>
<pre>
            class Matherr { };
            class Overflow: public Matherr { };
            class Underflow: public Matherr { };
            class Zerodivide: public Matherr { };
            // ...
</pre>
<p>Часто бывает так, что нужно обработать особую ситуацию Matherr
   не зависимо от того, какая именно ситуация из этого семейства
   произошла. Наследование позволяет сделать это просто:</p>
<pre>
            try {
               // ...
            }
            catch (Overflow) {
               // обработка Overflow или любой производной ситуации
            }
            catch (Matherr) {
                // обработка любой отличной от Overflow ситуации
            }
</pre>
<p>В этом примере Overflow разбирается отдельно, а все другие особые
   ситуации из Matherr разбираются как один общий случай. Конечно,
   функция, содержащая catch (Matherr), не будет знать какую именно
   особую ситуацию она перехватывает. Но какой бы она ни была, при
   входе в обработчик передаваемая ее копия будет Matherr. Обычно это
   как раз то, что нужно. Если это не так, особую ситуацию можно
   перехватить по ссылке (см. п.<a href="#dersituat">9.3.2</a>).</p>
<p>Иерархическое упорядочивание особых ситуаций может играть важную
   роль для создания ясной структуры программы. Действительно, пусть
   такое упорядочивание отсутствует, и нужно обработать все особые
   ситуации стандартной библиотеки математических функций. Для этого
   придется до бесконечности перечислять все возможные особые ситуации:</p>
<pre>
            try {
                // ...
            }
            catch (Overflow) { /* ... */ }
            catch (Underflow) { /* ... */ }
            catch (Zerodivide) { /* ... */ }
            // ...
</pre>
<p>Это не только утомительно, но и опасно, поскольку можно забыть
   какую-нибудь особую ситуацию. Кроме того, необходимость перечислить
   в проверяемом блоке все особые ситуации практически гарантирует,
   что, когда семейство особых ситуаций библиотеки расширится, в
   программе пользователя возникнет ошибка. Это значит, что при
   введении новой особой ситуации в библиотеки математических функций
   придется перетранслировать все части программы, которые содержат
   обработчики всех особых ситуаций из Matherr. В общем случае такая
   перетрансляция неприемлема. Часто даже нет возможности найти
   все требующие перетрансляции части программы. Если такая
   возможность есть, нельзя требовать, чтобы всегда был
   доступен исходной текст любой части большой программы, или чтобы у нас
   были права изменять любую часть большой программы, исходный текст
   которой мы имеем. На самом деле, пользователь не должен думать
   о внутреннем устройстве библиотек. Все эти проблемы перетрансляции
   и сопровождения могут привести к тому, что после создания
   первой версии библиотеки будет нельзя вводить в ней новые
   особые ситуации. Но такое решение не подходит практически для всех
   библиотек.</p>
<p>Все эти доводы говорят за то, что особые ситуации нужно
   определять как иерархию классов (см. также п.<a href="#unexpect">9.6.1</a>). Это, в свою
   очередь, означает, что особые ситуации могут быть членами нескольких
   групп:</p>
<pre>
           class network_file_err  // ошибки файловой системы в сети
             : public network_err, // ошибки сети
               public file_system_err { // ошибки файловой системы
               // ...
           };
</pre>
<p>Особую ситуацию network_file_err можно перехватить в функциях,
   обрабатывающих особые ситуации сети:</p>
<pre>
           void f()
           {
             try {
                 // какие-то операторы
             }
             catch (network_err) {
                 // ...
             }
           }
</pre>
<p>Ее также можно перехватить в функциях, обрабатывающих особые ситуации
   файловой системы:</p>
<pre>
           void g()
           {
              try {
                  // какие-то другие операторы
              }
              catch (file_system_err) {
                  // ...
              }
            }
</pre>
<p>Это важный момент, поскольку такой системный сервис как работа в
   сети должен быть прозрачен, а это означает, что создатель функции
   g() может даже и не знать, что эта функция будет выполняться
   в сетевом режиме.</p>
<p>Отметим, что в настоящее время нет стандартного множества
   особых ситуаций для стандартной математической библиотеки и
   библиотеки ввода-вывода. Задача комитетов ANSI и ISO по стандартизации
   С++ решить нужно ли такое множество и какие в нем следует использовать
   имена и классы.</p>
<p>Поскольку можно сразу перехватить все особые ситуации
   (см. п.<a href="#dersituat">9.3.2</a>), нет настоятельной необходимости создавать для этой
   цели общий, базовый для всех особых ситуаций, класс. Однако, если
   все особые ситуации являются производными от пустого класса
   Exception (особая ситуация), то в интерфейсах их использование
   становится более регулярным (см. п.<a href="#interf">9.6</a>). Если вы используете общий
   базовый класс Exception, убедитесь, что в нем ничего нет кроме
   виртуального деструктора. В противном случае такой класс может
   вступить в противоречие с предполагаемым стандартом.</p>

<a name="dersituat"></a><h5>9.3.2 Производные особые ситуации</h5>

<p>Если для обработки особых ситуаций мы используем иерархию классов,
   то, естественно, каждый обработчик должен разбираться только с
   частью информации, передаваемой при особых ситуациях. Можно сказать,
   что, как правило, особая ситуация перехватывается обработчиком
   ее базового класса, а не обработчиком класса, соответствующего
   именно этой особой ситуации. Именование и перехват обработчиком особой
   ситуации семантически эквивалентно именованию и получению параметра
   в функции. Проще говоря, формальный параметр инициализируется
   значением фактического параметра. Это означает, что запущенная
   особая ситуация "низводится" до особой ситуации, ожидаемой
   обработчиком. Например:</p>
<pre>
             class Matherr {
               // ...
               virtual void debug_print();
             };

             class Int_overflow : public Matherr {
             public:
                char* op;
                int opr1, opr2;;
                int_overflow(const char* p, int a, int b)
                   { cerr << op << '(' << opr1 << ',' << opr2 << ')'; }
             };

             void f()
             {
               try {
                   g();
               }
               catch (Matherr m) {
                   // ...
               }
             }
</pre>
<p>При входе в обработчик Matherr особая ситуация m является объектом
   Matherr, даже если при обращении к g() была запущена Int_overflow.
   Это означает, что дополнительная информация, передаваемая в
   Int_overflow, недоступна.</p>
<p>Как обычно, чтобы иметь доступ к дополнительной информации можно
   использовать указатели или ссылки. Поэтому можно было написать так:</p>
<pre>
             int add(int x, int y)   // сложить x и y с контролем
             {
               if (x > 0 && y > 0 && x > MAXINT - y
                || x < 0 && y < 0 && x < MININT + y)
                   throw Int_overflow("+", x, y);

                // Сюда мы попадаем, либо когда проверка
                // на переполнение дала отрицательный результат,
                // либо когда x и y имеют разные знаки

                return x + y;
              }

              void f()
              {
                 try {
                    add(1,2);
                    add(MAXINT,-2);
                    add(MAXINT,2);  // а дальше - переполнение
                 }
                 catch (Matherr& m) {
                    // ...
                    m.debug_print();
                 }
               }
</pre>
<p>Здесь последнее обращение к add приведет к запуску особой ситуации,
   который, в свою очередь, приведет к вызову Int_overflow::debug_print().
   Если бы особая ситуация передавалась по значению, а не по ссылке, то
   была бы вызвана функция Matherr::debug_print().</p>
<p>Нередко бывает так, что перехватив особую ситуацию, обработчик
   решает, что с этой ошибкой он ничего не сможет поделать. В таком
   случае самое естественное запустить особую ситуацию  снова в надежде,
   что с ней сумеет разобраться другой обработчик:</p>
<pre>
                void h()
                {
                  try {
                      // какие-то операторы
                  }
                  catch (Matherr) {
                    if (can_handle_it) { // если обработка возможна,
                       // сделать ее
                    }
                    else {
                       throw;  // повторный запуск перехваченной
                               // особой ситуации
                    }
                  }
                }
</pre>
<p>Повторный запуск записывается как оператор throw без параметров.
   При этом снова запускается исходная особая ситуация, которая была
   перехвачена, а не та ее часть, на которую рассчитан обработчик
   Matherr. Иными словами, если была запущена Int_overflow, вызывающая
   h() функция могла бы перехватить ее как Int_overflow, несмотря на
   то, что она была перехвачена в h() как Matherr и запущена снова:</p>
<pre>
                 void k()
                 {
                   try {
                     h();
                     // ...
                   }
                   catch (Int_overflow) {
                     // ...
                   }
                 }
</pre>
<p>Полезен вырожденный случай перезапуска. Как и для функций,
    эллипсис ... для обработчика означает "любой параметр", поэтому
    оператор catch (...) означает перехват любой особой ситуации:</p>
<pre>
                 void m()
                 {
                    try {
                       // какие-то операторы
                    }
                    catch (...) {
                       // привести все в порядок
                       throw;
                    }

                 }
</pre>
<p>Этот пример надо понимать так: если при выполнении основной части
   m() возникает особая ситуация, выполняется обработчик, которые
   выполняет общие действия по устранению последствий особой ситуации,
   после этих действий особая ситуация, вызвавшая их, запускается
   повторно.</p>
<p>Поскольку обработчик может перехватить производные особые ситуации
   нескольких типов, порядок, в котором идут обработчики в проверяемом
   блоке, существенен. Обработчики пытаются перехватить особую
   ситуацию в порядке их описания. Приведем пример:</p>
<pre>
                try {
                   // ...
                }
                catch (ibuf) {
                   // обработка переполнения буфера ввода
                }
                catch (io) {
                   // обработка любой ошибки ввода-вывода
                }
                catch (stdlib) {
                   // обработка любой особой ситуации в библиотеке
                }
                catch (...) {
                   // обработка всех остальных особых ситуаций
                }
</pre>
<p>Тип особой ситуации в обработчике соответствует типу запущенной
   особой ситуации в следующих случаях: если эти типы совпадают, или
   второй тип является типом доступного базового класса запущенной ситуации,
   или он является указателем на такой класс, а тип ожидаемой ситуации
   тоже указатель (п.<a href="referenc.shtml#R.4.6">R.4.6</a>).</p>
<p>Поскольку транслятору известна иерархия классов, он способен
   обнаружить такие нелепые ошибки, когда обработчик  catch (...) указан
   не последним, или когда обработчик ситуации базового класса
   предшествует обработчику производной от этого класса ситуации
   (п.R15.4</a>). В обоих случая, последующий обработчик (или обработчики)
   не могут быть запущены, поскольку они "маскируются" первым
   обработчиком.</p>


<a name="resurs"></a><h4>9.4 Запросы ресурсов</h4>

<p>Если в некоторой функции потребуются определенные ресурсы, например,
   нужно открыть файл, отвести блок памяти в области свободной
   памяти, установить монопольные права доступа и т.д., для дальнейшей
   работы системы обычно бывает крайне важно, чтобы ресурсы были
   освобождены надлежащим образом. Обычно такой "надлежащий способ"
   реализует функция, в которой происходит запрос ресурсов и освобождение
   их перед выходом. Например:</p>
<pre>
              void use_file(const char* fn)
              {
                FILE* f = fopen(fn,"w");

                // работаем с f

                fclose(f);
              }
</pre>
<p>Все это выглядит вполне нормально до тех пор, пока вы не поймете,
   что при любой ошибке, происшедшей после вызова fopen() и до вызова
   fclose(), возникнет особая ситуация, в результате которой мы
   выйдем из use_file(), не обращаясь к fclose().+</p>

<p>+ Стоит сказать, что та же проблема возникает и в языках, не
   поддерживающих особые ситуации. Так, обращение к функции longjump()
   из стандартной библиотеки С может иметь такие же неприятные
   последствия.</p>

<p>Если вы создаете устойчивую к ошибкам системам, эту проблему
   придется решать. Можно дать примитивное решение:</p>
<pre>
              void use_file(const char* fn)
              {
                FILE* f = fopen(fn,"w");
                try {
                    // работаем с f
                }
                catch (...) {
                    fclose(f);
                    throw;
                }
                fclose(f);
              }
</pre>
<p>Вся часть функции, работающая с файлом f, помещена в проверяемый
   блок, в котором перехватываются все особые ситуации, закрывается
   файл и особая ситуация запускается повторно.</p>
<p>Недостаток этого решения в его многословности, громоздкости
   и потенциальной расточительности. К тому же всякое многословное
   и громоздкое решение чревато ошибками, хотя бы в силу усталости
   программиста. К счастью, есть более приемлемое решение. В общем
   виде проблему можно сформулировать так:</p>
<pre>
             void acquire()
             {
               // запрос ресурса 1
               // ...
               // запрос ресурса n

               // использование ресурсов

               // освобождение ресурса n
               // ...
               // освобождение ресурса 1
             }
</pre>
<p>Как правило бывает важно, чтобы ресурсы освобождались в обратном
   по сравнению с запросами порядке. Это очень сильно напоминает порядок
   работы с локальными объектами, создаваемыми конструкторами и
   уничтожаемыми деструкторами. Поэтому мы можем решить проблему запроса и
   освобождения ресурсов, если будем использовать подходящие объекты
   классов с конструкторами и деструкторами. Например, можно определить
   класс FilePtr, который выступает как тип FILE* :</p>
<pre>
             class FilePtr {
                FILE* p;
             public:
                FilePtr(const char* n, const char* a)
                  { p = fopen(n,a); }
                FilePtr(FILE* pp) { p = pp; }
                ~FilePtr() { fclose(p); }

                operator FILE*() { return p; }
             };
</pre>
<p>Построить объект FilePtr можно либо, имея объект типа FILE*, либо,
   получив нужные для fopen() параметры. В любом случае этот
   объект будет уничтожен при выходе из его области видимости, и
   его деструктор закроет файл. Теперь наш пример сжимается до такой
   функции:</p>
<pre>
             void use_file(const char* fn)
             {
               FilePtr f(fn,"w");
               // работаем с f
             }
</pre>
<p>Деструктор будет вызываться независимо от того, закончилась ли функция
   нормально, или произошел запуск особой ситуации.</p>

<a name="destr"></a><h5>9.4.1 Конструкторы и деструкторы</h5>

<p>Описанный способ управления ресурсами обычно называют "запрос ресурсов
   путем инициализации". Это универсальный прием, рассчитанный на
   свойства конструкторов и деструкторов и их взаимодействие с
   механизмом особых ситуаций.</p>
<p>Объект не считается построенным, пока не завершил выполнение его
   конструктор. Только после этого возможна раскрутка стека,
   сопровождающая вызов деструктора объекта. Объект, состоящий из
   вложенных объектов, построен в той степени, в какой построены
   вложенные объекты.</p>
<p>Хорошо написанный конструктор должен гарантировать, что объект
   построен полностью и правильно. Если ему не удается сделать это,
   он должен, насколько это возможно, восстановить состояние системы,
   которое было до начала построения. Для простых конструкторов было бы
   идеально всегда удовлетворять хотя бы одному условию - правильности
   или законченности объектов, и никогда не оставлять объект
   в "наполовину построенном" состоянии. Этого можно добиться, если
   применять при построении членов способ "запроса ресурсов путем
   инициализации".</p>
<p>Рассмотрим класс X, конструктору которого требуется два ресурса:
   файл x и замок y (т.е. монопольные права доступа к чему-либо).
   Эти запросы могут быть отклонены и привести к запуску особой
   ситуации. Чтобы не усложнять работу программиста, можно потребовать,
   чтобы конструктор класса X никогда не завершался тем, что запрос на
   файл удовлетворен, а на замок нет. Для представления двух видов
   ресурсов мы будем использовать объекты двух классов FilePtr и
   LockPtr (естественно, было бы достаточно одного класса, если x и y
   ресурсы одного вида). Запрос ресурса выглядит как инициализация
   представляющего ресурс объекта:</p>
<pre>
             class X {
               FilePtr aa;
               LockPtr bb;
               // ...
               X(const char* x, const char* y)
                  : aa(x),      // запрос `x'
                  bb(y)         // запрос `y'
               { }
               // ...
             };
</pre>
<p>Теперь, как это было для случая локальных объектов, всю служебную
   работу, связанную с ресурсами, можно возложить на реализацию.
   Пользователь не обязан следить за ходом такой работой. Например,
   если после построения aa и до построения bb возникнет особая
   ситуация, то будет вызван только деструктор aa, но не bb.</p>
<p>Это означает, что если строго придерживаться этой простой
   схемы запроса ресурсов, то все будет в порядке. Еще более важно
   то, что создателю конструктора не нужно самому писать обработчики
   особых ситуаций.</p>
<p>Для требований выделить блок в свободной памяти характерен самый
   произвольный порядок запроса ресурсов. Примеры таких запросов уже
   неоднократно встречались в этой книге:</p>
<pre>
               class X {
                 int* p;
                 // ...
               public:
                 X(int s) { p = new int[s]; init(); }
                 ~X() { delete[] p; }
                 // ...
               };
</pre>
<p>Это типичный пример использования свободной памяти, но в совокупности с
   особыми ситуациями он может привести к ее исчерпанию памяти.
   Действительно, если в init() запущена особая ситуация, то отведенная
   память не будет освобождена. Деструктор не будет вызываться, поскольку
   построение объекта не было завершено. Есть более надежный вариант
   этого примера:</p>
<pre>
                template<class T> class MemPtr {
                public:
                   T* p;
                   MemPtr(size_t s) { p = new T[s]; }
                   ~MemPtr() { delete[] p; }
                   operator T*() { return p; }
                }

                class X {
                   MemPtr<int> cp;
                   // ...
                public:
                   X(int s):cp(s) { init(); }
                   // ...
                };
</pre>
<p>Теперь уничтожение массива, на который указывает p, происходит неявно
   в MemPtr. Если init() запустит особую ситуацию, отведенная память
   будет освобождена при неявном вызове деструктора для полностью
   построенного вложенного объекта cp.</p>
<p>Отметим также, что стандартная стратегия выделения памяти в С++
   гарантирует, что если функции operator new() не удалось выделить память
   для объекта, то конструктор для него никогда не будет вызываться. Это
   означает, что пользователю не надо опасаться, что конструктор или
   деструктор может быть вызван для несуществующего объекта.</p>
<p>Теоретически дополнительные расходы, требующиеся для обработки
   особых ситуаций, когда на самом деле ни одна из них не возникла, могут
   быть сведены к нулю. Однако, вряд ли это верно для ранних
   реализациях языка. Поэтому будет разумно в критичных внутренних циклах
   программы пока не использовать локальные переменные классов
   с деструкторами.</p>

<a name="caution"></a><h5>9.4.2 Предостережения</h5>

<p>Не все программы должны быть устойчивы ко всем видам ошибок. Не все
   ресурсы являются настолько критичными, чтобы оправдать попытки
   защитить их с помощью описанного способа "запроса ресурсов путем
   инициализации". Есть множество программ, которые просто читают
   входные данные и выполняются до конца. Для них самой подходящей
   реакцией на динамическую ошибку будет просто прекращение счета
   (после выдачи соответствующего сообщения). Освобождение всех
   затребованных ресурсов возлагается на систему, а пользователь
   должен произвести повторный запуск программы с более подходящими
   входными данными. Наша схема предназначена для задач, в которых
   такая примитивная реакция на динамическую ошибку неприемлема.
   Например, разработчик библиотеки обычно не в праве делать допущения
   о том, насколько устойчива к ошибкам, должна быть программа,
   работающая с библиотекой. Поэтому он должен учитывать все динамические
   ошибки и освобождать все ресурсы до возврата из библиотечной функции
   в пользовательскую программу. Метод "запроса ресурсов путем
   инициализации" в совокупности с особыми ситуациями, сигнализирующими
   об ошибке, может пригодиться при создании многих библиотек.</p>

<a name="exhaust"></a><h5>9.4.3 Исчерпание ресурса</h5>

<p>Есть одна из вечных проблем программирования: что делать, если не
   удалось удовлетворить запрос на ресурс? Например, в предыдущем
   примере мы спокойно открывали с помощью fopen() файлы и запрашивали с
   помощью операции new блок свободной памяти, не задумываясь при этом,
   что такого файла может не быть, а свободная память может исчерпаться.
   Для решения такого рода проблем у программистов есть два способа:
<ol>
<li>Повторный запрос: пользователь должен изменить свой запрос и
       повторить его.
<li>Завершение: запросить дополнительные ресурсы от системы, если
       их нет, запустить особую ситуацию.
</ol>
<p>Первый способ предполагает для задания приемлемого запроса
   содействие пользователя, во втором пользователь должен быть готов
   правильно отреагировать на отказ в выделении ресурсов. В большинстве
   случаев последний способ намного проще и позволяет поддерживать в
   системе разделение различных уровней абстракции.</p>
<p>В С++ первый способ поддержан механизмом вызова функций, а
   второй - механизмом особых ситуаций. Оба способа можно
   продемонстрировать на примере реализации и использования операции
   new:</p>
<pre>
              #include <stdlib.h>

              extern void* _last_allocation;

              extern void* operator new(size_t size)
              {
                void* p;

                while ( (p=malloc(size))==0 ) {
                   if (_new_handler)
                      (*_new_handler)();  // обратимся за помощью
                   else
                      return 0;
                }
                return _last_allocation=p;
              }
</pre>
<p>Если операция new() не может найти свободной памяти, она обращается
   к управляющей функции _new_handler(). Если в _new_handler() можно
   выделить достаточный объем памяти, все нормально. Если нет, из
   управляющей функции нельзя возвратиться в операцию new, т.к.
   возникнет бесконечный цикл. Поэтому управляющая функция может
   запустить особую ситуацию и предоставить исправлять положение
   программе, обратившейся к new:</p>
<pre>
         void my_new_handler()
         {
           try_find_some_memory();   // попытаемся найти
                                     // свободную память
           if (found_some()) return; // если она найдена, все в порядке
           throw Memory_exhausted(); // иначе запускаем особую
                                     // ситуацию "Исчерпание_памяти"
         }
</pre>
<p>Где-то в программе должен быть проверяемый блок с соответствующим
   обработчиком:</p>
<pre>
              try {
                  // ...
              }
              catch (Memory_exhausted) {
                  // ...
              }
</pre>
<p>В функции operator new() использовался указатель на управляющую
   функцию _new_handler, который настраивается стандартной функцией
   set_new_handler(). Если нужно настроиться на собственную управляющую
   функцию, надо обратиться так</p>
<pre>
             set_new_handler(&my_new_handler);
</pre>
<p>Перехватить ситуацию Memory_exhausted можно следующим образом:</p>
<pre>
             void (*oldnh)() = set_new_handler(&my_new_handler);

             try {
                // ...
             }
             catch (Memory_exhausted) {
                // ...
             }
             catch (...) {
                set_new_handler(oldnh);  // восстановить указатель на
                                         // управляющую функцию
                throw();      // повторный запуск особой ситуации
             }

             set_new_handler(oldnh); // восстановить указатель на
                                     // управляющую функцию
</pre>
<p>Можно поступить еще лучше, если к управляющей функции применить
   описанный в п.<a href="#resurs">9.4</a> метод "запроса ресурсов путем инициализации" и
   убрать обработчик catch (...).</p>
<p>В решении, использующим my_new_handler(), от точки обнаружения
   ошибки до функции, в которой она обрабатывается, не передается
   никакой информации. Если нужно передать какие-то данные, то
   пользователь может включить свою управляющую функцию в класс.
   Тогда в функции, обнаружившей ошибку, нужные данные можно поместить в
   объект этого класса. Подобный способ, использующий объекты-функции,
   применялся в п.<a href="chap10.shtml#manipul">10.4.2</a> для реализации манипуляторов. Способ, в
   котором используется указатель на функцию или объект-функция для
   того, чтобы из управляющей функции, обслуживающей некоторый ресурс,
   произвести "обратный вызов" функции запросившей этот ресурс,
   обычно называется просто обратным вызовом (callback).</p>
<p>При этом нужно понимать, что чем больше информации передается
   из обнаружившей ошибку функции в функцию, пытающуюся ее исправить,
   тем больше зависимость между этими двумя функциями. В общем случае
   лучше сводить к минимуму такие зависимости, поскольку всякое
   изменение в одной из функций придется делать с учетом другой функцией,
   а, возможно, ее тоже придется изменять. Вообще, лучше не смешивать
   отдельные компоненты программы. Механизм особых ситуаций позволяет
   сохранять раздельность компонентов лучше, чем обычный механизм вызова
   управляющих функций, которые задает функция, затребовавшая ресурс.</p>
<p>В общем случае разумный подход состоит в том, чтобы выделение
   ресурсов было многоуровневым (в соответствии с уровнями абстракции).
   При этом нужно избегать того, чтобы функции одного уровня зависели
   от управляющей функции, вызываемой на другом уровне. Опыт создания
   больших программных систем показывает, что со временем удачные
   системы развиваются именно в этом направлении.</p>

<a name="constr"></a><h5>9.4.4 Особые ситуации и конструкторы</h5>

<p>Особые ситуации дают средство сигнализировать о происходящих в
   конструкторе ошибках. Поскольку конструктор не возвращает такое
   значение, которое могла бы проверить вызывающая функция, есть
   следующие обычные (т.е. не использующие особые ситуации) способы
   сигнализации:</p>
<ol>
<li>Возвратить объект в ненормальном состоянии в расчете,
           что пользователь проверит его состояние.
<li>Установить значение нелокальной переменной, которое
           сигнализирует, что создать объект не удалось.
</ol>
<p>Особые ситуации позволяют тот факт, что создать объект не удалось,
   передать из конструктора вовне:</p>
<pre>
           Vector::Vector(int size)
           {
              if (sz&lt;0 || max&lt;sz) throw Size();
              // ...
           }
</pre>
<p>В функции, создающей вектора, можно перехватить ошибки, вызванные
   недопустимым размером (Size()) и попытаться на них отреагировать:</p>
<pre>
           Vector* f(int i)
           {
             Vector* p;
             try {
               p = new Vector v(i);
             }
             catch (Vector::Size) {
               // реакция на недопустимый размер вектора
             }
             // ...
             return p;
           }
</pre>
<p>Управляющая созданием вектора функция способна правильно
   отреагировать на ошибку. В самом обработчике особой ситуации можно
   применить какой-нибудь из стандартных способов диагностики и
   восстановления после ошибки. При каждом перехвате особой ситуации
   в управляющей функции может быть свой взгляд на причину ошибки. Если
   с каждой особой ситуацией передаются описывающие ее данные, то объем
   данных, которые нужно анализировать для каждой ошибки, растет. Основная
   задача обработки ошибок в том, чтобы обеспечить надежный и удобный
   способ передачи данных от исходной точки обнаружения ошибки до того
   места, где после нее возможно осмысленное восстановление.</p>
<p>Способ "запроса ресурсов путем инициализации" - самый надежное
   и красивое решение в том случае, когда имеются конструкторы, требующие
   более одного ресурса. По сути он позволяет свести задачу выделения
   нескольких ресурсов к повторно применяемому, более простому, способу,
   рассчитанному на один ресурс.</p>

<a name="noterror"></a><h4>9.5 Особые ситуации могут не быть ошибками</h4>

<p>Если особая ситуация ожидалась, была перехвачена и не оказала
   плохого воздействия на ход программы, то стоит ли ее называть
   ошибкой? Так говорят только потому, что программист думает о ней
   как об ошибке, а механизм особых ситуаций является средством
   обработки ошибок. С другой стороны, особые ситуации можно
   рассматривать просто как еще одну структуру управления. Подтвердим
   это примером:</p>
<pre>
           class message { /* ... */ };   // сообщение

           class queue {        // очередь
              // ...
              message* get();   // вернуть 0, если очередь пуста
              // ...
           };

           void f1(queue& q)
           {
             message* m = q.get();
             if (m == 0) {  // очередь пуста
                // ...
             }
             // используем m
           }
</pre>
<p>Этот пример можно записать так:</p>
<pre>
           class Empty { }  // тип особой ситуации "Пустая_очередь"

           class queue {
               // ...
               message* get();  // запустить Empty, если очередь пуста
               // ...
           };

           void f2(queue& q)
           {
             try {
                message* m = q.get();
                // используем m
             }
             catch (Empty) {  // очередь пуста
                // ...
             }
           }
</pre>
<p>В варианте с особой ситуацией есть даже какая-то прелесть. Это
   хороший пример того, когда трудно сказать, можно ли считать
   такую ситуацию ошибкой. Если очередь не должна быть пустой
   (т.е. она бывает пустой очень редко, скажем один раз из тысячи),
   и действия в случае пустой очереди можно рассматривать как
   восстановление, то в функции f2() взгляд на особую ситуацию будет
   такой, которого мы до сих пор и придерживались (т.е. обработка особых
   ситуаций есть обработка ошибок). Если очередь часто бывает пустой,
   а принимаемые в этом случае действия образуют одну из ветвей
   нормального хода программы, то придется отказаться от такого взгляда
   на особую ситуацию, а функцию f2() надо переписать:</p>
<pre>
             class queue {
               // ...
               message* get();  // запустить Empty, если очередь пуста
               int empty();
               // ...
             };

             void f3(queue& q)
             {
               if (q.empty()) { // очередь пуста
                  // ...
               }
               else {
                  message* m = q.get();
                  // используем m
               }
             }
</pre>
<p>Отметим, что вынести из функции get() проверку очереди на пустоту
   можно только при условии, что к очереди нет параллельных обращений.</p>
<p>Не так то просто отказаться от взгляда, что обработка особой
   ситуации есть обработка ошибки. Пока мы придерживаемся такой точки
   зрения, программа четко подразделяется на две части: обычная часть
   и часть обработки ошибок. Такая программа более понятна. К сожалению,
   в реальных задачах провести четкое разделение невозможно, поэтому
   структура программы должна (и будет) отражать этот факт. Допустим,
   очередь бывает пустой только один раз (так может быть, если функция
   get() используется в цикле, и пустота очереди говорит о конце цикла).
   Тогда пустота очереди не является чем-то странным или ошибочным.
   Поэтому, используя для обозначения конца очереди особую ситуацию,
   мы расширяем представление об особых ситуациях как ошибках. С другой
   стороны, действия, принимаемые в случае пустой очереди, явно отличаются
   от действий, принимаемых в ходе цикла (т.е. в обычном случае).</p>
<p>Механизм особых ситуаций является менее структурированным,
   чем такие локальные структуры управления как операторы if или for.
   Обычно он к тому же является не столь эффективным, если особая
   ситуация действительно возникла. Поэтому особые ситуации следует
   использовать только в том случае, когда нет хорошего решения с более
   традиционными управляющими структурами, или оно, вообще, невозможно.
   Например, в случае пустой очереди можно прекрасно использовать для
   сигнализации об этом значение, а именно нулевое значение указателя на
   строку message, значит особая ситуация здесь не нужна. Однако, если бы
   из класса queue мы получали вместо указателя значение типа int, то
   то могло не найтись такого значения, обозначающего пустую очередь.
   В таком случае функция get() становится эквивалентной операции
   индексации из п.<a href="#errorhand">9.1</a>, и более привлекательно представлять пустую очередь
   с помощью особой ситуации. Последнее соображение подсказывает, что
   в самом общем шаблоне типа для очереди придется для обозначения пустой
   очереди использовать особую ситуацию, а работающая с очередью функция
   будет такой:</p>
<pre>
            void f(Queue<X>& q)
            {
              try {
                 for (;;) {  // ``бесконечный цикл''
                             // прерываемый особой ситуацией
                     X m = q.get();
                     // ...
                 }
              }
              catch (Queue<X>::Empty) {
                   return;
              }
            }
</pre>
<p>Если приведенный цикл выполняется тысячи раз, то он, по всей
   видимости, будет более эффективным, чем обычный цикл с проверкой
   условия пустоты очереди. Если же он выполняется только несколько
   раз, то обычный цикл почти наверняка эффективней.</p>
<p>В очереди общего вида особая ситуация используется как способ
   возврата из функции get(). Использование особых ситуаций как способа
   возврата может быть элегантным способом завершения функций поиска.
   Особенно это подходит для рекурсивных функций поиска в дереве. Однако,
   применяя особые ситуации для таких целей, легко перейти грань разумного
   и получить маловразумительную программу. Все-таки всюду, где это
   действительно оправдано, надо придерживаться той точки зрения, что
   обработка особой ситуации есть обработка ошибки. Обработка ошибок по
   самой своей природе занятие сложное, поэтому ценность имеют любые
   методы, которые дают ясное представление ошибок в языке и способ
   их обработки.</p>

<a name="interf"></a><h4>9.6 Задание интерфейса</h4>

<p>Запуск или перехват особой ситуации отражается на взаимоотношениях
   функций. Поэтому имеет смысл задавать в описании функции множество
   особых ситуаций, которые она может запустить:</p>
<pre>
             void f(int a) throw (x2, x3, x4);
</pre>
<p>В этом описании указано, что f() может запустить особые ситуации
   x2, x3 и x4, а также ситуации всех производных от них типов, но
   больше никакие ситуации она не запускает. Если функция перечисляет свои
   особые ситуации, то она дает определенную гарантию всякой вызывающей ее
   функции, а именно, если попытается запустить иную особую ситуацию, то
   это приведет к вызову функции unexpected().
   Стандартное предназначение unexpected() состоит в вызове функции
   terminate(), которая, в свою очередь, обычно вызывает abort().
   Подробности даны в п.<a href="#notint">9.7</a>.</p>
<p>По сути определение</p>
<pre>
            void f() throw (x2, x3, x4)
            {
              // какие-то операторы
            }
</pre>
<p>эквивалентно такому определению</p>
<pre>
            void f()
            {
              try {
                // какие-то операторы
              }
              catch (x2) {  // повторный запуск
               throw;
              }
              catch (x3) {  // повторный запуск
               throw;
              }
              catch (x4) {  // повторный запуск
               throw;
              }
              catch (...) {
               unexpected();
              }
            }
</pre>
<p>Преимущество явного задания особых ситуаций функции в ее описании
   перед эквивалентным способом, когда происходит проверка на
   особые ситуации в теле функции, не только в более краткой записи.
   Главное здесь в том, что описание функции входит в ее интерфейс,
   который видим для всех вызывающих функций. С другой стороны,
   определение функции может и не быть универсально доступным.
   Даже если у вас есть исходные тексты всех библиотечных функций,
   обычно желание изучать их возникает не часто.</p>
<p>Если в описании функции не указаны ее особые ситуации, считается,
   что она может запустить любую особую ситуацию.</p>
<pre>
            int f();  // может запустить любую особую ситуацию
</pre>
<p>Если функция не будет запускать никаких особых ситуаций, ее можно
   описать, явно указав пустой список:</p>
<pre>
            int g() throw (); // не запускает никаких особых ситуаций
</pre>
<p>Казалось было бы логично, чтобы по умолчанию функция не запускала
   никаких особых ситуаций. Но тогда пришлось бы описывать свои особые
   ситуации практически для каждой функции Это, как правило,
   требовало бы ее перетрансляции, а кроме того препятствовало бы общению
   с функциями, написанными на других языках. В результате программист
   стал бы стремиться отключить механизм особых ситуаций и писал бы
   излишние операторы, чтобы обойти их. Пользователь считал бы такие
   программы надежными, поскольку мог не заметить подмены, но это было
   бы совершенно неоправдано.</p>

<a name="unexpect"></a><h5>9.6.1 Неожиданные особые ситуации</h5>

<p>Если к описанию особых ситуаций относиться не достаточно серьезно, то
   результатом может быть вызов unexpected(), что нежелательно во всех
   случая, кроме отладки. Избежать вызова unexpected() можно, если хорошо
   организовать структуру особых ситуации и описание интерфейса. С
   другой стороны, вызов unexpected() можно перехватить и сделать его
   безвредным.</p>
<p>Если компонент Y хорошо разработан, все его особые ситуации
   могут быть только производными одного класса, скажем Yerr. Поэтому,
   если есть описание</p>
<pre>
             class someYerr : public Yerr { /* ... */ };
</pre>
<p>то функция, описанная как</p>
<pre>
             void f() throw (Xerr, Yerr, IOerr);
</pre>
<p>будет передавать любую особую ситуацию типа Yerr вызывающей функции.
   В частности, обработка особой ситуации типа someYerr в f() сведется к
   передаче ее вызывающей f() функции.</p>
<p>Бывает случаи, когда окончание программы при появлении
   неожиданной особой ситуации является слишком строгим решением.
   Допустим функция g() написана для несетевого режима в распределенной
   системе. Естественно, в g() ничего неизвестно об особых ситуациях,
   связанных с сетью, поэтому при появлении любой из них вызывается
   unexpected(). Значит для использования g() в распределенной системе
   нужно предоставить обработчик сетевых особых ситуаций или переписать
   g(). Если допустить, что переписать g() невозможно или нежелательно,
   проблему можно решить, переопределив действие функции unexpected().
   Для этого служит функция set_unexpected(). Вначале мы определим
   класс, который позволит нам применить для функций unexpected()
   метод "запроса ресурсов путем инициализации" :</p>
<pre>
             typedef void(*PFV)();
             PFV set_unexpected(PFV);

             class STC {   // класс для сохранения и восстановления
               PFV old;    // функций unexpected()
             public:
               STC(PFV f) { old = set_unexpected(f); }
               ~STC() { set_unexpected(old); }
             };
</pre>
<p>Теперь мы определим функцию, которая должна в нашем примере заменить
   unexpected():</p>
<pre>
             void rethrow() { throw; }  // перезапуск всех сетевых
                                        // особых ситуаций
</pre>
<p>Наконец, можно дать вариант функции g(), предназначенный для работы
   в сетевом режиме:</p>
<pre>
         void networked_g()
         {
          STC xx(&rethrow); // теперь unexpected() вызывает rethrow()
          g();
         }
</pre>
<p>В предыдущем разделе было показано, что unexpected() потенциально
   вызывается из обработчика catch (...). Значит в нашем случае
   обязательно произойдет повторный запуск особой ситуации. Повторный
   запуск, когда особая ситуация не запускалась, приводит к вызову
   terminate(). Поскольку обработчик catch (...) находится вне той
   области видимости, в которой была запущена сетевая особая ситуация,
   бесконечный цикл возникнуть не может.</p>
<p>Есть еще одно, довольно опасное, решение, когда на неожиданную
   особую ситуацию просто "закрывают глаза":</p>
<pre>
        void muddle_on() { cerr << "не замечаем особой ситуации\n"; }
        // ...
        STC xx(&muddle_on);  // теперь действие unexpected() сводится
                             // просто к печати сообщения
</pre>
<p>Такое переопределение действия unexpected() позволяет нормально
   вернуться из функции, обнаружившей неожиданную особую ситуацию.
   Несмотря на свою очевидную опасность, это решение используется.
   Например, можно "закрыть глаза" на особые ситуации в одной части
   системы и отлаживать другие ее части. Такой подход может быть
   полезен в процессе отладки и развития системы, перенесенной с языка
   программирования без особых ситуаций. Все-таки, как правило лучше,
   если ошибки проявляются как можно раньше.</p>
<p>Возможно другое решение, когда вызов unexpected() преобразуется
   в запуск особой ситуации Fail (неудача):</p>
<pre>
            void fail() { throw Fail; }
            // ...
            STC yy(&fail);
</pre>
<p>При таком решении вызывающая функция не должна подробно разбираться в
   возможном результате вызываемой функции: эта функции завершится
   либо успешно (т.е. возвратится нормально), либо неудачно (т.е.
   запустит Fail). Очевидный недостаток этого решения в том, что
   не учитывается дополнительная информация, которая может сопровождать
   особую ситуацию. Впрочем, при необходимости ее можно учесть, если
   передавать информацию вместе с Fail.</p>

<a name="notint"></a><h4>9.7 Неперехваченные особые ситуации</h4>

<p>Если особая ситуация запущена и не перехвачена, то вызывается функция
   terminate(). Она же вызывается, когда система поддержки особых
   ситуаций обнаруживает, что структура стека нарушена, или когда
   в процессе обработки особой ситуации при раскручивании стека вызывается
   деструктор, и он пытается завершить свою работу, запустив особую
   ситуацию.</p>
<p>Действие terminate() сводится к выполнению самой последней
   функции, заданной как параметр для set_terminate():</p>
<pre>
              typedef void (*PFV)();
              PFV set_terminate(PFV);
</pre>
<p>Функция set_terminate() возвращает указатель на ту функцию, которая
   была задана как параметр в предыдущем обращении к ней.</p>
<p>Необходимость такой функции как terminate() объясняется тем,
   что иногда вместо механизма особых ситуаций требуются более
   грубые приемы. Например, terminate() можно использовать для
   прекращения процесса, а, возможно, и для повторного запуска системы.
   Эта функция служит экстренным средством, которое применяется, когда
   отказала стратегия обработки ошибок, рассчитанная на особые
   ситуации, и самое время применить стратегию более низкого уровня.</p>
<p>Функция unexpected() используется в сходных, но не столь
   серьезных случаях, а именно, когда функция запустила особую ситуацию,
   не указанную в ее описании. Действие функции unexpected() сводится
   к выполнению самой последней функции, заданной как параметр для
   функции set_unexpected().</p>
<p>По умолчанию unexpected() вызывает terminate(), а та, в свою
   очередь, вызывает функцию abort(). Предполагается, что такое соглашение
   устроит большинство пользователей.</p>
<p>Предполагается, что функция terminate() не возвращается в
   обратившеюся  ней функцию.</p>
<p>Напомним, что вызов abort() свидетельствует о ненормальном
   завершении программы. Для нормального выхода из программы
   используется функция exit(). Она возвращает значение, которое
   показывает окружающей системе насколько корректно закончилась программа.</p>

<a name="method"></a><h4>9.8 Другие способы обработки ошибок</h4>

<p>Механизм особых ситуаций нужен для того, чтобы из одной части
   программы можно было сообщить в другую о возникновении в первой
   "особой ситуации". При этом предполагается, что части программы
   написаны независимо друг от друга, и в той части, которая
   обрабатывает особую ситуацию, возможна осмысленная реакция на
   ошибку.</p>
<p>Как же должен быть устроен обработчик особой ситуации? Приведем
   несколько вариантов:</p>
<pre>
         int f(int arg)
         {
            try {
               g(arg);
            }
            catch (x1) {
               // исправить ошибку и повторить
               g(arg);
            }
            catch (x2) {
               // произвести вычисления и вернуть результат
               return 2;
            }
            catch (x3) {
               // передать ошибку
               throw;
            }
            catch (x4) {
               // вместо x4 запустить другую особую ситуацию
               throw xxii;
            }
            catch (x5) {
               // исправить ошибку и продолжить со следующего оператора
            }
            catch (...) {
               // отказ от обработки ошибки
               terminate();
            }
            // ...
          }
</pre>
<p>Укажем, что в обработчике доступны переменные из области видимости,
   содержащей проверяемый блок этого обработчика. Переменные,
   описанные в других обработчиках или других проверяемых блоках,
   конечно, недоступны:</p>
<pre>
               void f()
               {
                 int i1;
                 // ...
                 try {
                    int i2;
                    // ...
                 }
                 catch (x1) {
                    int i3;
                    // ...
                 }
                 catch (x4) {
                    i1 = 1;   // нормально
                    i2 = 2;   // ошибка: i2 здесь невидимо
                    i3 = 3;   // ошибка: i3 здесь невидимо
                 }
               }
</pre>
<p>Нужна общая стратегия для эффективного использования обработчиков в
   программе. Все компоненты программы должны согласованно использовать
   особые ситуации и иметь общую часть для обработки ошибок. Механизм
   обработки особых ситуаций является нелокальным по своей сути,
   поэтому так важно придерживаться общей стратегии. Это предполагает,
   что стратегия обработки ошибок должна разрабатываться на самых
   ранних стадиях проектах. Кроме того, эта стратегия должна
   быть простой (по сравнению со сложностью всей программы) и ясной.
   Последовательно проводить сложную стратегию в такой сложной
   по своей природе области программирования, как восстановление после
   ошибок, будет просто невозможно.</p>
<p>Прежде всего стоит сразу отказаться от того, что одно средство
   или один прием можно применять для обработки всех ошибок. Это
   только усложнит систему. Удачная система, обладающая устойчивостью
   к ошибкам, должна строиться как многоуровневая. На каждом уровне
   надо обрабатывать настолько много ошибок, насколько это возможно
   без нарушения структуры системы, оставляя обработку других ошибок более
   высоким уровням. Назначение terminate() поддержать такой подход,
   предоставляя возможность экстренного выхода из такого положения,
   когда нарушен сам механизм обработки особых ситуаций, или когда
   он используется полностью, но особая ситуация оказалась
   неперехваченной. Функция unexpected() предназначена для выхода из
   такого положения, когда не сработало основанное на описании всех особых
   ситуаций средство защиты. Это средство можно представлять как брандмауер,
   т.е. стену, окружающую каждую функцию, и препятствующую
   распространению ошибки. Попытка проводить в каждой функции полный
   контроль, чтобы иметь гарантию, что функция либо успешно завершится,
   либо закончится неудачно, но одним из определенных и корректных
   способов, не может принести успех. Причины этого могут быть различными
   для разных программ, но для больших программ можно назвать следующие:</p>
<ol>
<li>работа, которую нужно провести, чтобы гарантировать надежность
         каждой функции, слишком велика, и поэтому ее не удастся
         провести достаточно последовательно;
<li>появятся слишком большие дополнительные расходы памяти и времени,
         которые будут недопустимы для нормальной работы системы
         (будет тенденция неоднократно проверять на одну и ту же ошибку,
          а значит постоянно будут проверяться переменные с правильными
          значениями);
<li>таким ограничениям не будут подчиняться функции, написанные на
         других языках;
<li>такое понятие надежности является чисто локальным и оно
         настолько усложняет систему, что становится дополнительной
         нагрузкой для ее общей надежности.
</ol>
<p>Однако, разбить программу на отдельные подсистемы, которые либо
   успешно завершаются, либо заканчиваются неудачно, но одним из
   определенных и корректных способов, вполне возможно, важно и даже
   выгодно. Таким свойством должны обладать основные библиотеки,
   подсистемы или ключевые функции. Описание особых ситуаций должно
   входить в интерфейсы таких библиотек или подсистем.</p>
<p>Иногда приходится от одного стиля реакции на ошибку переходить
   на другой. Например, можно после вызова стандартной функции С
   проверять значение errno и, возможно, запускать особую ситуацию,
   а можно, наоборот, перехватывать особую ситуацию и устанавливать
   значение errno перед выходом из стандартной функции в С-программу:</p>
<pre>
               void callC()
               {
                 errno = 0;
                 cfunction();
                 if (errno) throw some_exception(errno);
               }

               void fromC()
               {
                 try {
                    c_pl_pl_function();
                 }
                 catch (...) {
                    errno = E_CPLPLFCTBLEWIT;
                 }
               }
</pre>
<p>При такой смене стилей важно быть последовательным, чтобы изменение
   реакции на ошибку было полным.</p>
<p>Обработка ошибок должна быть, насколько это возможно, строго
   иерархической системой. Если в функции обнаружена динамическая
   ошибка, то не нужно обращаться за помощью для восстановления или
   выделения ресурсов к вызывающей функции. При таких обращениях в
   структуре системы возникают циклические зависимости, в результате
   чего ее труднее понять, и возможно возникновение бесконечных
   циклов в процессе обработки и восстановления после ошибки.</p>
<p>Чтобы часть программы, предназначенная для обработки ошибок
   была более упорядоченной, стоит применять такие упрощающие дело
   приемы, как "запрос ресурсов путем инициализации", и исходить из
   таких упрощающих дело допущений, что "особые ситуации являются
   ошибками".</p>

<a name="exercise"></a><h4>9.9 Упражнения</h4>

<ol>
<li>(*2) Обобщите класс STC до шаблона типа, который позволяет
      хранить и устанавливать функции разных типов.
<li>(*3) Дополните класс CheckedPtrToT из п.<a href="chap7.shtml#increm">7.10</a> до шаблона типа, в
      котором особые ситуации сигнализируют о динамических ошибках.
<li>(*3) Напишите функцию find для поиска в бинарном дереве узлов
      по значению поля типа char*. Если найден узел с полем, имеющим
      значение "hello", она должна возвращать указатель на него. Для
      обозначения неудачного поиска используйте особую ситуацию.
<li>(*1) Определите класс Int, совпадающий во всем со встроенным
      типом int за исключением того, что вместо переполнения или
      потери значимости в этом классе запускаются особые ситуации.
      Подсказка: см. п.<a href="#dersituat">9.3.2</a>.
<li>(*2) Перенесите из стандартного интерфейса С в вашу операционную
      систему основные операции с файлами: открытие, закрытие, чтение и
      запись. Реализуйте их как функции на С++ с тем же назначением,
      что и функций на С, но в случае ошибок запускайте особые
      ситуации.
<li>(*1) Напишите полное определение шаблона типа Vector с особыми
      ситуациями Range и Size. Подсказка: см. п.<a href="#names">9.3</a>.
<li>(*1) Напишите цикл для вычисления суммы элементов вектора,
      определенного в упражнении 6, причем не проверяйте размер вектора.
      Почему это плохое решение?
<li>(*2.5) Допустим класс Exception используется как базовый для всех
      классов, задающих особые ситуации. Каков должен быть его вид?
      Какая от него могла быть польза? Какие неудобства может вызвать
      требование обязательного использования этого класса?
<li>(*2) Напишите класс или шаблон типа, который поможет реализовать
      обратный вызов.
<li>(*2) Напишите класс Lock (замок) для какой-нибудь системы,
      допускающей параллельное выполнение.
<li>(*1) Пусть определена функция
           int main() { /* ... */ }
      Измените ее так, чтобы в ней перехватывались все особые ситуации,
      преобразовывались в сообщения об ошибке и вызов abort().
      Подсказка: в функции fromC() из п.<a href="#method">9.8</a> учтены не все случаи.
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap10.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>