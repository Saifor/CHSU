<HTML> <HEAD> <TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>
 </HEAD> <BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">  <A NAME="top"></A>  <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">  <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>  <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		   <td width="100%" valign="top">    <table width="540" border="0" cellspacing="0" cellpadding="0">     <tr><td colspan="2"></tr>     <tr><td width="10">&nbsp;</td>      <td> 
<!----- START MAIN CONTENT ----->  <h4>Бьерн Страуструп<br> Язык программирования С++</h4>  <p>Книга Б. Страуструпа "Язык программирования С++" дает описание языка,   его ключевых понятий и основных приемов программирования на нем. Это   завершенное руководство, написанное создателем языка, которое содержит   описание всех средств С++, в том числе управление исключительными   ситуациями, шаблоны типа (параметризованные типы данных) и множественное   наследование.</p> <p>Книга делится на три части. Первые десять глав являются учебником,   служащим введением в язык, включая подмножество собственно С. В трех   последующих главах обсуждаются вопросы проектирования и создания   программного обеспечения с помощью С++. Книга завершается полным   <a href="referenc.shtml">справочным руководством</a> по языку.</p> <p>В книге вы найдете:</p>  <ul> <li>законченный учебник и руководство по языку. <li>полное освещение средств языка, нацеленных на абстрактные типы данных     и объектно-ориентированное программирование. <li>обсуждение программистских и технических вопросов, возникающих в про-     цессе проектирования и создания больших программных систем. <li>описание способов построения библиотек высокого класса. <li>примеры реализации ключевых типов данных, определяемых пользователем,     таких как графические объекты, ассоциативные массивы и потоки ввода-     вывода. </ul>  <p>Эта книга будет хорошим помощником опытному программисту, решившему   использовать С++ для нетривиальных задач. Ее можно считать ключевой в   любом собрании книг по С++.</p> <p>Об авторе книги:</p> <p>Бьерн Страуструп является разработчиком языка С++ и создателем первого   транслятора. Он - сотрудник научно-исследовательского вычислительного   центра AT&T Bell Laboratories в Мюррей Хилл (Нью-Джерси, США). Он получил   звание магистра математики и вычислительной техники в университете г.   Аарус (Дания), а докторское звание по вычислительной технике в   кэмбриджском университете (Англия). Он специализируется в области рас-   пределенных систем, операционных систем, моделирования и программиро-   вания. Вместе с М. А. Эллис он является автором полного руководства по   языку С++ - "Руководство по С++ с примечаниями".</p>  <a name="#foreword"></a><h4>Предисловие</h4> <p align="right"><i>"А дорога идет все дальше и дальше"<br> (Бильбо Бэгинз)</i></p> <p>Как было обещано в первом издании книги, запросы пользователей   определили развитие С++. Его направлял опыт широкого круга пользователей,   работающих в разных областях программирования.  За шесть лет, отделяющих   нас от первого издания описания С++, число пользователей возросло в сотни   раз. За эти годы были усвоены многие уроки, были предложены и подтвердили   практикой свое право на существование различные приемы программирования. О   некоторых из них и пойдет речь ниже.</p> <p>Сделанные за эти шесть лет расширения языка прежде всего были   направлены на повышение выразительности С++ как языка абстракции данных и   объектно-ориентированного программирования вообще и как средства для   создания высококачественных библиотек с пользовательскими типами данных в   частности. Библиотекой высокого качества мы считаем библиотеку,   позволяющую пользователю определять с помощью классов понятия, работа с   которыми сочетает удобство, эффективность и надежность. Под надежностью   понимается то, что класс предоставляет защищенный по типам интерфейс между   пользователями библиотеки и ее разработчиками. Эффективность предполагает,   что использование классов не влечет за собой больших накладных расходов по   памяти или времени по сравнению с "ручными" программами на С.</p> <p>Эта книга является полным описанием языка С++. Главы с    <a href="chap1.shtml">1</a> по <a href="chap10.shtml">10</a>   представляют собой учебник, знакомящий с языком. В главах с    <a href="chap11.shtml">11</a> по <a href="chap.shtml">13</a>   обсуждаются вопросы проектирования и развития программного обеспечения.   Завершается книга <a href="referenc.shtml">справочным руководством</a> по языку С++. Естественно, что   все расширения языка и способы их использования, которые появились после   выхода в свет первого издания, являются частью изложения. К ним относятся   уточненные правила для разрешения перегрузки имени, средства управления   памятью и средства контроля доступа, надежная по типам процедура   связывания, статические и постоянные функции-члены, абстрактные классы,   множественное наследование, шаблоны типов и обработка особых ситуаций.</p> <p>С++ является языком программирования общего назначения.   Естественная для него область применения - системное программирование,   понимаемое в широком смысле этого слова. Кроме того, С++ успешно   используется во многих областях приложения, далеко выходящих за   указанные рамки. Реализации С++ теперь есть на всех машинах, начиная   с самых скромных микрокомпьютеров - до самых больших супер-ЭВМ, и   практически для всех операционных систем. Поэтому книга дает лишь описание   собственно языка, не объясняя особенности конкретных реализаций, среды   программирования или библиотек.</p> <p>Читатель найдет в книге много примеров с классами, которые, несмотря   на несомненную пользу, можно считать игрушечными. Такой стиль изложения   позволяет лучше выделить основные понятия и полезные приемы, тогда как в   настоящих, законченных программах они были бы скрыты массой деталей.  Для   большинства предложенных здесь классов, как то связанные списки, массивы,   строки символов, матрицы, графические классы, ассоциативные массивы и   т.д., - приводятся версии "со 100% гарантией" надежности и правильности,   полученные на основе классов из самых разных коммерческих и некоммерческих   программ. Многие из "промышленных" классов и библиотек получились как   прямые или косвенные потомки игрушечных классов, приводимых здесь как   примеры.</p> <p>В этом издании книги по сравнению с первым больше внимания уделено   задаче обучения. Вместе с тем, уровень изложения в равной мере учитывает и   опытных программистов, ни в чем не умаляя их знаний и профессионализма.   Обсуждение вопросов проектирования сопровождается более широкой подачей   материала, выходящей за рамки описаний конструкций языка и способам их   использования. В этом издании приводится больше технических деталей и   повышена строгость изложения. В особенности это относится к справочному   руководству, которое вобрало в себя многолетний опыт работы в этом   направлении. Предполагалось создать книгу с достаточно высоким уровнем   изложения, которая бы служила программистам не только книгой для чтения.   Итак, перед вами книга с описанием языка С++, его основных принципов и   методов программирования. Надеемся, что она доставит вам радость.</p> <p><b>Выражение признательности</b></p> <p>Кроме лиц, перечисленных в соответствующем разделе предисловия к   первому изданию книги, мне хотелось бы выразить свою благодарность Элу   Эхо, Стиву Бароффу, Джиму Коплину, Тому Хансену, Петеру Джаглу, Брайану   Кернигану, Эндрю Кенигу, Биллу Леггету, Лоррейн Мингаччи, Уоррену   Монтгомери, Майку Моубри, Робу Мюррею, Джонатану Шапиро, Майку Вилоту и   Петеру Вейнбергу за комментарии черновых вариантов второго издания книги.   В развитии языка С++ за период от 1985 до 1991 гг.  принимали участие   многие специалисты. Я могу упомянуть лишь нескольких из них: Эндрю Кенига,   Брайана Кернигана, Дага Макилроя и Джонатана Шапиро.  Кроме того, выражаю   признательность многим участникам создания справочного руководства С++,   предложившим свои варианты, а также тем, с кем довелось нести тяжкую ношу   в течение первого года работы комитета X3J16 по стандартизации языка С++.</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Мюррей-Хилл, шт.Нью Джерси&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Бьерн Страуструп</p>  <a name="#issuing1"></a><h4>Предисловие к первому изданию</h4> <p align="right"><i>"Язык образует  среду мышления и формирует<br> представление о том, о чем мы думаем".<br> (Б.Л.Уорф)</i></p> <p>С++ - язык общего назначения и задуман для того, чтобы настоящие   программисты получили удовольствие от самого процесса программирования.   За исключением второстепенных деталей он содержит язык С как подмножество.   Язык С расширяется введением гибких и эффективных средств, предназначенных   для построения новых типов. Программист структурирует свою задачу,   определив новые типы, которые точно соответствуют понятиям предметной   области задачи. Такой метод построения программы обычно называют   абстракцией данных. Информация о типах содержится в некоторых объектах   типов, определенных пользователем. С такими объектами можно работать   надежно и просто даже в тех случаях, когда их тип нельзя установить на   стадии трансляции. Программирование с использованием таких объектов обычно   называют объектно-ориентированным. Если этот метод применяется правильно,   то программы становятся короче и понятнее, а сопровождение их упрощается.</p> <p>Ключевым понятием С++ является класс. Класс - это определяемый   пользователем тип. Классы обеспечивают упрятывание данных, их   инициализацию, неявное преобразование пользовательских типов, динамическое   задание типов, контролируемое пользователем управление памятью и средства   для перегрузки операций. В языке С++ концепции контроля типов и модульного   построения программ реализованы более полно, чем в С. Кроме того, С++   содержит усовершенствования, прямо с классами не связанные: символические   константы, функции-подстановки, стандартные значения параметров функций,   перегрузка имен функций, операции управления свободной памятью и ссылочный   тип. В С++ сохранены все возможности С эффективной работы с основными   объектами, отражающими аппаратную "реальность" (разряды, байты, слова,   адреса и т.д.). Это позволяет достаточно эффективно реализовывать   пользовательские типы.</p> <p>Как язык, так и стандартные библиотеки С++ проектировались в расчете   на переносимость. Имеющиеся реализации языка будут работать в большинстве   систем, поддерживающих С. В программах на С++ можно использовать   библиотеки С. Большинство служебных программ, рассчитанных на С, можно   использовать и в С++.</p> <p>Данная книга в первую очередь рассчитана на профессиональных   программистов, желающих изучить новый язык и использовать его для   нетривиальных задач. В книге дается полное описание С++, содержится много   завершенных примеров и еще больше фрагментов программ.</p> <p><b>Выражение признательности</b></p> <p>Язык С++ никогда бы не стал реальностью без, если бы постоянно не   использовались предложения и советы и не учитывалась конструктивная   критика со стороны многих друзей и коллег. Особенно следует упомянуть Тома   Карджила, Джима Копли, Стью Фельдмана, Сэнди Фрэзера, Стива Джонсона,   Брайана Кернигана, Барта Локанти, Дага Макилроя, Дэнниса Ритчи, Лэрри   Рослера, Джерри Шварца и Джона Шапиро, которые внесли важные для развития   языка идеи. Дэйв Пресотто реализовал текущую версию библиотеки потокового   ввода/вывода.</p> <p>Свой вклад в развитие С++ и создание транслятора внесли сотни людей,   которые присылали мне предложения по совершенствованию языка, описания   трудностей, с которыми они сталкивались, и ошибки транслятора.  Здесь я   могу упомянуть лишь некоторых из них: Гари Бишопа, Эндрю Хьюма, Тома   Карцеса, Виктора Миленковича, Роба Мюррэя, Леони Росс, Брайана Шмальта и   Гарри Уокера.</p> <p>Многие участвовали в подготовке книги к изданию, особенно Джон Бентли,   Лаура Ивс, Брайан Керниган, Тэд Ковальски, Стив Махани, Джон Шапиро и   участники семинара по языку С++, который проводился фирмой Bell Labs в   Колумбии, Огайо, 26-27 июня 1985 г.</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Мюррей-Хилл, шт.Нью-Джерси&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Бьерн Страуструп</p>  <a name="#notes"></a><h4>Предварительные замечание</h4> <p align="right"><i>"О многом - молвил Морж,-<br> пришла пора поговорить ".<br> Л.Кэрролл</i></p> <p>Данная глава содержит краткий обзор книги, список литературы и   некоторые дополнительные замечания о языке С++. Замечания касаются истории   создания С++, идей, которые оказали существенное влияние на разработку   языка, и некоторых мыслей по поводу программирования на С++. Эта глава не   является введением; приведенные замечания не являются необходимыми для   понимания последующих глав. Некоторые из них предполагают знакомство   читателя с С++.</p>  <a name="#struct"></a><h5>Структура книги</h5> <p>Книга состоит из трех частей. Главы с    <a href="chap1.shtml">1</a> по <a href="chap.shtml">10</a> являются    учебником по языку. В главах с    <a href="chap11.shtml">11</a> по <a href="chap13.shtml">13</a> обсуждаются вопросы проектирования и развития   программного обеспечения с учетом возможностей С++. В конце книги   приведено полное    <a href="referenc.shtml">справочное руководство</a> по языку. Исчерпывающее описание   конструкций С++ содержится только там. Учебная часть книги содержит   примеры, советы, предостережения и упражнения, для которых не нашлось   места в руководстве.</p> <p>Книга в основном посвящена вопросу, как с помощью языка C++   структурировать программу, а не вопросу, как записать на нем алгоритм.   Следовательно, там, где можно было выбирать, предпочтение отдавалось не   профессиональным, но сложным для понимания, а тривиальным алгоритмам. Так   в одном из примеров используется пузырьковая сортировка, хотя алгоритм   быстрой сортировки больше подходит для настоящей программы.  Часто   написать ту же программу, но с более эффективным алгоритмом, предлагается   в виде упражнения.</p> <p>Глава <a href="chap1.shtml">1</a> содержит краткий обзор основных концепций и конструкций С++.   Она позволяет познакомиться с языком в общих чертах. Подробные объяснения   конструкций языка и способов их применения содержатся в последующих   главах. Обсуждаются в первую очередь средства, обеспечивающие абстракцию   данных и объектно-ориентированное программирование. Основные средства   процедурного программирования упоминаются кратко.</p> <p>В главах <a href="chap2.shtml">2</a>, <a href="chap3.shtml">3</a> и    <a href="chap4.shtml">4</a> описываются средства С++, которые не используются   для определения новых типов: основные типы, выражения и структуры   управления. Другими словами, эти главы содержат описание той части языка,   которая по сути представляет С. Изложение в указанных главах идет в   углубленном виде.</p> <p>Главы <a href="chap5.shtml">5</a> - <a href="chap8.shtml">8</a> посвящены    средствам построения новых типов, которые не   имеют аналогов в С. В главе <a href="chap5.shtml">5</a> вводится основное    понятие - класс. В ней   показано, как можно определять пользовательские типы (классы),   инициализировать их, обращаться к ним, и, наконец, как уничтожать их.   Глава <a href="chap6.shtml">6</a> посвящена понятию производных классов,    которое позволяет строить   из простых классов более сложные. Оно дает также возможность эффективной и   безопасной (в смысле типа) работы в тех ситуациях, когда типы объектов на   стадии трансляции неизвестны.  В главе <a href="chap7.shtml">7</a>    объясняется, как можно определить   унарные и бинарные операции для пользовательских типов, как задавать   преобразования таких типов, и каким образом можно создавать, копировать и   удалять объекты, представляющие пользовательские типы. Глава    <a href="chap8.shtml">8</a> посвящена   шаблонам типа, т.е. такому средству С++, которое позволяет определить   семейство типов и функций.</p> <p>В главе <a href="chap9.shtml">9</a> обсуждается обработка особых ситуаций,    рассматриваются   возможные реакции на ошибки и методы построения устойчивых к ошибкам   систем. В главе <a href="chap10.shtml">10</a> определяются классы ostream и    istream, предоставляемые   стандартной библиотекой для потокового ввода-вывода.</p> <p>Главы <a href="chap11.shtml">11<a> - <a href="chap13.shtml">13</a>    посвящены вопросам, связанным с применением С++ для   проектирования и реализации больших программных систем. В главе    <a href="chap11.shtml">11</a> в   основном рассматриваются вопросы проектирования и управления программными   проектами.  В главе <a href="chap12.shtml">12</a> обсуждается взаимосвязь    между языком С++ и   проблемами проектирования. В главе <a href="chap13.shtml">13</a> показаны    способы создания библиотек.</p> <p>Завершается книга <a href="referenc.shtml">справочным руководством</a> по С++.</p> <p>Ссылки на различные части книги даются в виде    п.<a href="chap2.shtml#void">2.3.4</a>, что означает   раздел 3.4 главы 2. Для обозначения справочного    руководства применяется буква R, например,    п.<a href="referenc.shtml#R.8.1">R.8.1</a>.</p>  <a name="#notesreal"></a><h5>Замечания по реализации</h5> <p>Существует несколько распространяемых независимых реализаций С++.   Появилось большое число сервисных программ, библиотек и интегрированных   систем программирования. Имеется масса книг, руководств, журналов, статей,   сообщений по электронной почте, технических бюллетеней, отчетов о   конференциях и курсов, из которых можно получить все необходимые сведения   о последних изменениях в С++, его использовании, сервисных программах,   библиотеках, новых трансляторах и т.д. Если вы серьезно рассчитываете на   С++, стоит получить доступ хотя бы к двум источникам информации, поскольку   у каждого источника может быть своя позиция.</p> <p>Большинство программных фрагментов, приведенных в книге, взяты   непосредственно из текстов программ, которые были транслированы на машине   DEC VAX 11/8550 под управлением 10-й версии системы UNIX [<a href="#book25">25</a>].   Использовался транслятор, являющийся прямым потомком транслятора С++,   созданного автором. Здесь описывается "чистый С++", т.е. не используются   никакие зависящие от реализации расширения. Следовательно, примеры должны   идти при любой реализации языка. Однако, шаблоны типа и обработка особых   ситуаций относятся к самым последним расширениям языка, и возможно, что   ваш транслятор их не содержит.</p>  <a name="#exercises"></a><h5>Упражнения</h5> <p>Упражнения даются в конце каждой главы. Чаще всего они предлагают   написать программу. Решением может считаться программа, которая   транслируется и правильно работает хотя бы на нескольких тестах.   Упражнения могут значительно различаться по сложности, поэтому дается   приблизительная оценка степени их сложности. Рост сложности   экспоненциальный, так что, если на упражнение (*1) у вас уйдет пять минут,   то (*2) может занять час, а (*3) - целый день. Однако время написания и   отладки программы больше зависит от опыта читателя, чем от самого   упражнения.  На упражнение (*1) может потребоваться целый день, если перед   запуском программы читателю придется ознакомиться с новой вычислительной   системой. С другой стороны, тот, у кого под рукой окажется нужный набор   программ, может сделать упражнение (*5) за один час.</p> <p>Любую книгу по программированию на языке С можно использовать как   источник дополнительных упражнений при изучении глав    <a href="chap2.shtml">2</a> - <a href="chap4.shtml">4</a>. В книге Ахо   ([<a href="#book1">1</a>]) приведено много общих структур данных и алгоритмов в терминах   абстрактных типов данных.  Эту книгу также можно использовать как источник   упражнений при изучении глав <a href="chap5.shtml">5</a> -    <a href="chap8.shtml">8</a>. Однако, использованному в ней языку не   достает функций-членов и производных классов.  Поэтому определяемые   пользователем типы на С++ можно написать более элегантно.</p>  <a name="#proj"></a><h5>Замечания по проекту языка</h5> <p>При разработке языка С++ одним из важнейших критериев выбора была   простота. Когда возникал вопрос, что упростить: руководство по языку и   другую документацию или транслятор, - то выбор делали в пользу первого.   Огромное значение придавалось совместимости с языком С, что помешало   удалить его синтаксис.</p> <p>В С++ нет типов данных и элементарных операций высокого уровня.   Например, не существует типа матрица с операцией обращения или типа строка   с операцией конкатенации. Если пользователю понадобятся подобные типы, он   может определить их в самом языке.  Программирование на С++ по сути   сводится к определению универсальных или зависящих от области приложения   типов. Хорошо продуманный пользовательский тип отличается от встроенного   типа только способом определения, но не способом применения.</p> <p>Из языка исключались возможности, которые могут привести к накладным   расходам памяти или времени выполнения, даже если они непосредственно не   используются в программе. Например, было отвергнуто предложение хранить в   каждом объекте некоторую служебную информацию. Если пользователь описал   структуру, содержащую две величины, занимающие по 16 разрядов, то   гарантируется, что она поместится в 32-х разрядный регистр.</p> <p>Язык С++ проектировался для использования в довольно традиционной   среде, а именно: в системе программирования С операционной системы UNIX.   Но есть вполне обоснованные доводы в пользу использования С++ в более   богатой программной среде. Такие возможности, как динамическая загрузка,   развитые системы трансляции и базы данных для хранения определений типов,   можно успешно использовать без ущерба для языка.</p> <p>Типы С++ и механизмы упрятывания данных рассчитаны на определенный   синтаксический анализ, проводимый транслятором для обнаружения случайной   порчи данных. Они не обеспечивают секретности данных и защиты от   умышленного нарушения правил доступа к ним. Однако, эти средства можно   свободно использовать, не боясь накладных расходов памяти и времени   выполнения программы. Учтено, что конструкция языка активно используется   тогда, когда она не только изящно записывается на нем, но и вполне по   средствам обычным программам.</p>  <a name="#history"></a><h5>Историческая справка</h5> <p>Безусловно С++ многим обязан языку С [<a href="#book8">8</a>], который    сохраняется как его   подмножество. Сохранены и все свойственные С средства низкого уровня,   предназначенные для решения самых насущных задач системного   программирования. С, в свою очередь, многим обязан своему предшественнику   языку BCPL [<a href="#book13">13</a>]. Комментарий языка BCPL был восстановлен в С++.  Если   читатель знаком с языком BCPL, то может заметить, что в С++ по-прежнему   нет блока VALOF. Еще одним источником вдохновения был язык SIMULA-67   [<a href="#book2">2</a>,<a href="#book3">3</a>]; именно из него была    заимствована концепция классов (вместе c   производными классами и виртуальными функциями).  Оператор inspect из   SIMULA-67 намеренно не был включен в С++.  Причина - желание   способствовать модульности за счет использования виртуальных функций.   Возможность в С++ перегрузки операций и свобода размещения описаний всюду,   где может встречаться оператор, напоминают язык Алгол-68    [<a href="#book24">24</a>].</p> <p>С момента выхода в свет первого издания этой книги язык С++ подвергся   существенным изменениям и уточнениям. В основном это касается разрешения   неоднозначности при перегрузке, связывании и управлении памятью. Вместе с   тем, были внесены незначительные изменения с целью увеличить совместимость   с языком С. Были также введены некоторые обобщения и существенные   расширения, как то: множественное наследование, функции-члены со   спецификациями static и const, защищенные члены (protected), шаблоны типа   и обработка особых ситуаций. Все эти расширения и доработки были нацелены   на то, чтобы С++ стал языком, на котором можно создавать и использовать   библиотеки. Все изменения описываются в    [<a href="#book10">10</a>,<a href="#book18">18</a>,<a href="#book20">20</a>,   <a href="#book21">21</a> и <a href="#book23">23</a>].</p> <p>Шаблоны типов появились частично из-за желания формализовать   макросредства, а частично были инспирированы описанием генерических   объектов в языке Ада (с учетом их достоинств и недостатков) и   параметризированными модулями языка CLU. Механизм обработки особых   ситуаций появился отчасти под влиянием языков Ада и CLU [<a href="#book11">11</a>], а отчасти   под влиянием ML [<a href="#book26">26</a>]. Другие расширения, введенные за период между 1985 и   1991 г.г. (такие как множественное наследование, статические функции-члены   и чистые виртуальные функции), скорее появились в результате обобщения   опыта программирования на С++, чем были почерпнуты из других языков.</p> <p>Более ранние версии языка, получившие название "С с классами"    [<a href="#book16">16</a>],   использовались, начиная с 1980 г. Этот язык возник потому, что автору   потребовалось написать программы моделирования, управляемые прерываниями.   Язык SIMULA-67 идеально подходит для этого, если не учитывать   эффективность. Язык "С с классами" использовался для больших задач   моделирования. Строгой проверке подверглись тогда возможности написания на   нем программ, для которых критичны ресурсы времени и памяти. В этом языке   недоставало перегрузки операций, ссылок, виртуальных функций и многих   других возможностей.  Впервые С++ вышел за пределы исследовательской   группы, в которой работал автор, в июле 1983 г., однако тогда многие   возможности С++ еще не были разработаны.</p> <p>Название С++ (си плюс плюс) , было придумано Риком Маскитти летом 1983   г. Это название отражает эволюционный характер изменений языка С.   Обозначение ++ относится к операции наращивания С. Чуть более короткое имя   С+ является синтаксической ошибкой. Кроме того, оно уже было использовано   как название совсем другого языка. Знатоки семантики С находят, что С++   хуже, чем ++С. Язык не получил названия D, поскольку он является   расширением С, и в нем не делается попыток решить какие-либо проблемы за   счет отказа от возможностей С. Еще одну интересную интерпретацию названия   С++ можно найти в приложении к [<a href="#book12">12</a>].</p> <p>Изначально С++ был задуман для того, чтобы автору и его друзьям не   надо было программировать на ассемблере, С или других современных языках   высокого уровня. Основное его предназначение - упростить и сделать более   приятным процесс программирования для отдельного программиста.  До   недавнего времени не было плана разработки С++ на бумаге. Проектирование,   реализация и документирование шли параллельно. Никогда не существовало   "проекта С++" или "Комитета по разработке С++". Поэтому язык развивался и   продолжает развиваться так, чтобы преодолеть все проблемы, с которыми   столкнулись пользователи. Толчками к развитию служат также и обсуждения   автором всех проблем с его друзьями и коллегами.</p> <p>В связи с лавинообразным процессом увеличения числа пользователей С++,   пришлось сделать следующие изменения. Примерно в 1987 г. стало очевидно,   что работа по стандартизации С++ неизбежна и что следует незамедлительно   приступить к созданию основы для нее [<a href="#book22">22</a>].  В результате были предприняты   целенаправленные действия, чтобы установить контакт между разработчиками   С++ и большинством пользователей.  Применялась обычная и электронная   почта, а также было непосредственное общение на конференциях по С++ и   других встречах.</p> <p>Фирма AT&T Bell Laboratories внесла основной вклад в эту работу,   предоставив автору право изучать версии справочного руководства по языку   вместе с упоминавшимися разработчиками и пользователями.  Не следует   недооценивать этот вклад, т.к. многие из них работают в компаниях, которые   можно считать конкурентами фирмы AT&T.  Менее просвещенная компания могла   бы просто ничего не делать, и в результате появилось бы несколько   несогласованных версий языка.  Около ста представителей из порядка 20   организаций изучали и комментировали то, что стало современной версией   справочного руководства и исходными материалами для ANSI по стандартизации   С++. Их имена можно найти в "Аннотированном справочном руководстве по   языку С++" [<a href="#book4">4</a>].     <a href="referenc.shtml">Справочное руководство</a> полностью вошло в настоящую книгу.   Наконец, по инициативе фирмы Hewlett-Packard в декабре 1989 г. в составе   ANSI был образован комитет X3J16. Ожидается, что работы по стандартизации   С++ в ANSI (американский стандарт) станут составной частью работ по   стандартизации силами ISO (Международной организации по стандартизации).</p> <p>С++ развивался одновременно с развитием некоторых фундаментальных   классов, представленных в данной книге. Например, автор разрабатывал   классы complex, vector и stack, создавая одновременно возможность   перегрузки операций.  В результате этих же усилий и благодаря содействию   Д. Шапиро появились строковые и списочные классы. Эти классы стали первыми   библиотечными классами, которые начали активно использоваться. Библиотека   task, описываемая в [<a href="#book19">19</a>] и в упражнении 13 из    п.<a href="chap6.shtml#exercise">6.8</a> стала частью самой   первой программы, написанной на языке "С с классами". Эта программа и   используемые в ней классы были созданы для моделирования в стиле Симулы.   Библиотека task была существенно переработана Д. Шапиро и продолжает   активно использоваться до настоящего времени. Потоковая библиотека, как   указывалось в первом издании книги, была разработана и применена автором.   Д. Шварц преобразовал ее в потоковую библиотеку ввода-вывода (   п.<a href="chap10.shtml#">10</a>),   используя наряду с другими приемами метод манипуляторов Э.Кенига   (п.<a href="chap10.shtml#manipul">10.4.2</a>). Класс map (   п.<a href="chap.shtml#associad">8.8</a>) был предложен Э.Кенигом.     Он же создал класс Pool (   п.<a href="chap13.shtml#memory">13.10</a>), чтобы использовать для библиотеки предложенный автором   способ распределения памяти для классов (   п.<a href="chap5.shtml#litlobj">5.5.6</a>). На создание остальных   шаблонов повлияли шаблоны Vector, Map, Slist и sort, представленные в   главе <a href="chap8.shtml">8</a>.</p>  <a name="#compare"></a><h5>Сравнение языков С++ и С</h5> <p>Выбор С в качестве базового языка для С++ объясняется следующими его   достоинствами:</p> <ol> <li>универсальность, краткость и относительно низкий уровень; <li>адекватность большинству задач системного программирования; <li>он идет в любой системе и на любой машине; <li>полностью подходит для программной среды UNIX. </ol> <p>В С существуют свои проблемы, но в языке, разрабатываемом "с нуля" они   появились бы тоже, а проблемы С, по крайней мере, хорошо известны. Более   важно то, что ориентация на С позволила использовать язык "С с классами"   как полезный (хотя и не очень удобный) инструмент в течение первых месяцев   раздумий о введении в С классов в стиле Симулы.</p> <p>С++ стал использоваться шире, но по мере роста его возможностей,   выходящих за пределы С, вновь и вновь возникала проблема совместимости.   Ясно, что отказавшись от части наследства С, можно избежать некоторых   проблем (см., например, [<a href="#book15">15</a>]). Это не было сделано по следующим причинам:</p> <ol> <li>существуют миллионы строк программ на С, которые можно улучшить с   помощью С++, но при условии, что полной переписи их на язык С++ не   потребуется; <li>существуют миллионы строк библиотечных функций и служебных   программ на С, которые можно было бы использовать в С++ при условиях   совместимости обоих языков на стадии связывания и их большого   синтаксического сходства; <li>существуют сотни тысяч программистов, знающих С; им достаточно   овладеть только новыми средствами С++ и не надо изучать основ языка; <li>поскольку С и С++ будут использоваться одними и теми же людьми на   одних и тех же системах многие годы, различия между языками должны быть   либо минимальными, либо максимальными, чтобы свести к минимуму количество   ошибок и недоразумений.  Описание С++ было переработано так, чтобы   гарантировать, что любая допустимая в обоих языках конструкция означала в   них одно и то же. </ol> <p>Язык С сам развивался в последние несколько лет, что отчасти было   связано с разработкой С++ [<a href="#book14">14</a>].    Стандарт ANSI для С [<a href="#book27">27</a>] содержит,   например, синтаксис описания функций, позаимствованный из языка "С с   классами". Происходит взаимное заимствование, например, тип указателя   void* был придуман для ANSI С, а впервые реализован в С++. Как было   обещано в первом издании этой книги, описание С++ было доработано, чтобы   исключить неоправданные расхождения.  Теперь С++ более совместим с языком   С, чем это было вначале (п.<a href="reference.shtml#R.18">R.18</a>).  В идеале С++ должен максимально   приближаться к ANSI C, но не более [<a href="#book9">9</a>].  Стопроцентной совместимости   никогда не было и не будет, поскольку это нарушит надежность типов и   согласованность использования встроенных и пользовательских типов, а эти   свойства всегда были одними из главных для С++.</p> <p>Для изучения С++ не обязательно знать С. Программирование на С   способствует усвоению приемов и даже трюков, которые при программировании   на С++ становятся просто ненужными. Например, явное преобразование типа   (приведение) , в С++ нужно гораздо реже, чем в С (см.  "Замечания для   программистов на С" ниже). Тем не менее, хорошие программы на языке С по   сути являются программами на С++. Например, все программы из классического   описания С [<a href="#book8">8</a>] являются программами на С++. В процессе изучения С++ будет   полезен опыт работы с любым языком со статическими типами.</p>  <a name="#effect"></a><h5>Эффективность и структура</h5> <p>Развитие языка С++ происходило на базе языка С, и, за небольшим   исключением, С был сохранен в качестве подмножества C++. Базовый язык С   был спроектирован таким образом, что имеется очень тесная связь между   типами, операциями, операторами и объектами, с которыми непосредственно   работает машина, т.е. числами, символами и адресами. За исключением   операций new, delete и throw, а также проверяемого блока, для выполнения   операторов и выражений С++ не требуется скрытой динамической аппаратной   или программной поддержки.</p> <p>В С++ используется та же (или даже более эффективная)   последовательность команд для вызова функций и возврата из них, что и в С.   Если даже эти довольно эффективные операции становятся слишком дорогими,   то вызов функции может быть заменен подстановкой ее тела, причем   сохраняется удобная функциональная запись безо всяких расходов на вызов   функции.</p> <p>Первоначально язык С задумывался как конкурент ассемблера, способный   вытеснить его из основных и наиболее требовательных к ресурсам задач   системного программирования. В проекте С++ были приняты меры, чтобы успехи   С в этой области не оказались под угрозой. Различие между двумя языками   прежде все состоит в степени внимания, уделяемого типам и структурам. Язык   С выразителен и в то же время снисходителен по отношению к типам. Язык С++   еще более выразителен, но такой выразительности можно достичь лишь тогда,   когда типам уделяют большое внимание. Когда типы объектов известны,   транслятор правильно распознает такие выражения, в которых иначе   программисту пришлось бы записывать операции с утомительными   подробностями.  Кроме того, знание типов позволяет транслятору   обнаруживать такие ошибки, которые в противном случае были бы выявлены   только при тестировании.  Отметим, что само по себе использование строгой   типизации языка для контроля параметров функции, защиты данных от   незаконного доступа, определения новых типов и операций не влечет   дополнительных расходов памяти и увеличения времени выполнения программы.</p> <p>В проекте С++ особое внимание уделяется структурированию программы.   Это вызвано увеличением размеров программ со времени появления С.   Небольшую программу (скажем, не более 1000 строк) можно заставить из   упрямства работать, нарушая все правила хорошего стиля программирования.   Однако, действуя так, человек уже не сможет справиться с большой   программой. Если у вашей программы в 10 000 строк плохая структура, то вы   обнаружите, что новые ошибки появляются в ней так же быстро, как удаляются   старые. С++ создавался с целью, чтобы большую программу можно было   структурировать таким образом, чтобы одному человеку не пришлось работать   с текстом в 25000 строк. В настоящее время можно считать, что эта цель   полностью достигнута.</p> <p>Существуют, конечно, программы еще большего размера. Однако те из них,   которые действительно используются, обычно можно разбить на несколько   практически независимых частей, каждая из которых имеет значительно   меньший упомянутого размер. Естественно, трудность написания и   сопровождения программы определяется не только числом строк текста, но и   сложностью предметной области. Так что приведенные здесь числа, которыми   обосновывались наши соображения, не надо воспринимать слишком серьезно.</p> <p>К сожалению, не всякую часть программы можно хорошо структурировать,   сделать независимой от аппаратуры, достаточно понятной и т.д.  В С++ есть   средства, непосредственно и эффективно представляющие аппаратные   возможности. Их использование позволяет избавиться от беспокойства о   надежности и простоте понимания программы. Такие части программы можно   скрывать, предоставляя надежный и простой интерфейс с ними.</p> <p>Естественно, если С++ используется для большой программы, то это   означает, что язык используют группы программистов. Полезную роль здесь   сыграют свойственные языку модульность, гибкость и строго типизированные   интерфейсы. В С++ есть такой же хороший набор средств для создания больших   программ, как во многих языках.  Но когда программа становится еще больше,   проблемы по ее созданию и сопровождению перемещаются из области языка в   более глобальную область программных средств и управления проектом. Этим   вопросам посвящены главы <a href="chap11.shtml">11</a> и    <a href="chap12.shtml">12</a>.</p> <p>В этой книге основное внимание уделяется методам создания   универсальных средств, полезных типов, библиотек и т.д. Эти методы можно   успешно применять как для маленьких, так и для больших программ. Более   того, поскольку все нетривиальные программы состоят из нескольких в   значительной степени независимых друг от друга частей, методы   программирования отдельных частей пригодятся как системным, так и   прикладным программистам.</p> <p>Может возникнуть подозрение, что запись программы с использованием   подробной системы типов, увеличит размер текста. Для программы на С++ это   не так: программа на С++, в которой описаны типы формальных параметров   функций, определены классы и т.п., обычно бывает даже короче своего   эквивалента на С, где эти средства не используются. Когда в программе на   С++ используются библиотеки, она также оказывается короче своего   эквивалента на С, если, конечно, он существует.</p>  <a name="#philos"></a><h5>Философские замечания</h5> <p>Язык программирования решает две взаимосвязанные задачи: позволяет   программисту записать подлежащие выполнению действия и формирует понятия,   которыми программист оперирует, размышляя о своей задаче. Первой цели   идеально отвечает язык, который очень "близок машине". Тогда со всеми ее   основными "сущностями" можно просто и эффективно работать на этом языке,   причем делая это очевидным для программиста способом. Именно это имели в   виду создатели С. Второй цели идеально отвечает язык, который настолько   "близок к поставленной задаче", что на нем непосредственно и точно   выражаются понятия, используемые в решении задачи. Именно это имелось в   виду, когда первоначально определялись средства, добавляемые к С.</p> <p>Связь между языком, на котором мы думаем и программируем, а также   между задачами и их решениями, которые можно представить в своем   воображении, довольно близка. По этой причине ограничивать возможности   языка только поиском ошибок программиста - в лучшем случае опасно.  Как и   в случае естественных языков, очень полезно обладать, по крайней мере,   двуязычием. Язык предоставляет программисту некоторые понятия в виде   языковых инструментов; если они не подходят для задачи, их просто   игнорируют. Например, если существенно ограничить понятие указателя, то   программист будет вынужден для создания структур, указателей и т.п.   использовать вектора и операции с целыми. Хороший проект программы и   отсутствие в ней ошибок нельзя гарантировать только наличием или   отсутствием определенных возможностей в языке.</p> <p>Типизация языка должна быть особенно полезна для нетривиальных задач.   Действительно, понятие класса в С++ проявило себя как мощное   концептуальное средство.</p>  <a name="#program"></a><h5>Замечания о программировании на языке С++</h5> <p>Предполагается, что в идеальном случае разработка программы делится на   три этапа: вначале необходимо добиться ясного понимания задачи, затем   определить ключевые понятия, используемые для ее решения, и, наконец,   полученное решение выразить в виде программы. Однако, детали решения и   точные понятия, которые будут использоваться в нем, часто проясняются   только после того, как их попытаются выразить в программе. Именно в этом   случае большое значение приобретает выбор языка программирования.</p> <p>Во многих задачах используются понятия, которые трудно представить в   программе в виде одного из основных типов или в виде функции без связанных   с ней статических данных. Такое понятие может представлять в программе   класс. Класс - это тип; он определяет поведение связанных с ним объектов:   их создание, обработку и уничтожение.  Кроме этого, класс определяет   реализацию объектов в языке, но на начальных стадиях разработки программы   это не является и не должно являться главной заботой. Для написания   хорошей программы надо составить такой набор классов, в котором каждый   класс четко представляет одно понятие. Обычно это означает, что   программист должен сосредоточиться на вопросах: Как создаются объекты   данного класса? Могут ли они копироваться и (или) уничтожаться?  Какие   операции можно определить над этими объектами? Если на эти вопросы   удовлетворительных ответов не находится, то, скорее всего, это означает,   что понятие не было достаточно ясно сформулировано.  Тогда, возможно,   стоит еще поразмышлять над задачей и предлагаемым решением, а не   немедленно приступать к программированию, надеясь в процессе него найти   ответы.</p> <p>Проще всего работать с понятиями, которые имеют традиционную   математическую форму представления: всевозможные числа, множества,   геометрические фигуры и т.д. Для таких понятий полезно было бы иметь   стандартные библиотеки классов, но к моменту написания книги их еще не   было. В программном мире накоплено удивительное богатство из таких   библиотек, но нет ни формального, ни фактического стандарта на них. Язык   С++ еще достаточно молод, и его библиотеки не развились в такой степени,   как сам язык.</p> <p>Понятие не существует в вакууме, вокруг него всегда группируются   связанные с ним понятия. Определить в программе взаимоотношения классов,   иными словами, установить точные связи между используемыми в задаче   понятиями, бывает труднее, чем определить каждый из классов сам по себе. В   результате не должно получиться "каши" - когда каждый класс (понятие)   зависит от всех остальных. Пусть есть два класса A и B. Тогда связи между   ними типа "A вызывает функцию из B", "A создает объекты B", "A имеет член   типа B" обычно не вызывают каких-либо трудностей. Связи же типа "A   использует данные из B", как правило, можно вообще исключить.</p> <p>Одно из самых мощных интеллектуальных средств, позволяющих справиться   со сложностью, - это иерархическое упорядочение, т.е.  упорядочение   связанных между собой понятий в древовидную структуру, в которой самое   общее понятие находится в корне дерева. Часто удается организовать классы   программы как множество деревьев или как направленный ацикличный граф. Это   означает, что программист определяет набор базовых классов, каждый из   которых имеет свое множество производных классов. Набор операций самого   общего вида для базовых классов (понятий) обычно определяется с помощью   виртуальных функций (п.<a href="chap6.shtml#multinher">6.5</a>).     Интерпретация этих операций, по мере   надобности, может уточняться для каждого конкретного случая, т.е. для   каждого производного класса.</p> <p>Естественно, есть ограничения и при такой организации программы.   Иногда используемые в программе понятия не удается упорядочить даже с   помощью направленного ацикличного графа. Некоторые понятия оказываются по   своей природе взаимосвязанными. Циклические зависимости не вызовут   проблем, если множество взаимосвязанных классов настолько мало, что в нем   легко разобраться. Для представления на С++ множества взаимозависимых   классов можно использовать дружественные классы (   п.<a href="chap5.shtml#friend">5.4.1</a>).</p> <p>Если понятия программы нельзя упорядочить в виде дерева или   направленного ацикличного графа, а множество взаимозависимых понятий не   поддается локализации, то, по всей видимости, вы попали в такое   затруднительное положение, выйти из которого не сможет помочь ни один из   языков программирования. Если вам не удалось достаточно просто   сформулировать связи между основными понятиями задачи, то, скорее всего,   вам не удастся ее запрограммировать.</p> <p>Еще один способ выражения общности понятий в языке предоставляют   шаблоны типа. Шаблонный класс задает целое семейство классов.  Например,   шаблонный класс список задает классы вида "список объектов T", где T может   быть произвольным типом. Таким образом, шаблонный тип указывает, как   получается новый тип из заданного в качестве параметра. Самые типичные   шаблонные классы - это контейнеры, в частности, списки, массивы и   ассоциативные массивы.</p> <p>Напомним, что можно легко и просто запрограммировать многие задачи,   используя только простые типы, структуры данных, обычные функции и   несколько классов из стандартных библиотек. Весь аппарат построения новых   типов следует привлекать только тогда, когда он действительно необходим.</p> <p>Вопрос "Как написать хорошую программу на С++?" очень похож на вопрос   "Как пишется хорошая английская проза?". На него есть два ответа: "Нужно   знать, что вы, собственно, хотите написать" и "Практика и подражание   хорошему стилю". Оба совета пригодны для С++ в той же мере, что и для   английского языка, и обоим достаточно трудно следовать.</p>  <a name="#advice"></a><h5>Несколько полезных советов</h5> <p>Ниже представлен "свод правил", который стоит учитывать при изучении   С++. Когда вы станете более опытными, то на базе этих правил сможете   сформулировать свои собственные, которые будут более подходить для ваших   задач и более соответствовать вашему стилю программирования. Сознательно   выбраны очень простые правила, и в них опущены подробности. Не следует   воспринимать их слишком буквально.  Хорошая программа требует и ума, и   вкуса, и терпения. С первого раза обычно она не получается, поэтому   экспериментируйте! Итак, свод правил.</p> <ol> <li>Когда вы пишите программу, то создаете конкретные представления       тех понятий, которые использовались в решении поставленной       задачи. Структура программы должна отражать эти понятия настолько       явно, насколько это возможно.   <ol type="a">   <li>Если вы считаете "нечто" отдельным понятием, то сделайте его           классом.   <li>Если вы считаете "нечто" существующим независимо, то сделайте           его объектом некоторого класса.   <li>Если два класса имеют нечто существенное, и оно является для них           общим, то выразите эту общность с помощью базового класса.   <li>Если класс является контейнером некоторых объектов, сделайте           его шаблонным классом.   </ol> <li>Если определяется класс, который не реализует математических объектов       вроде матриц или комплексных чисел и не является типом низкого       уровня наподобие связанного списка, то:   <ol type="a">   <li>Не используйте глобальных данных.   <li>Не используйте глобальных функций (не членов).   <li>Не используйте общих данных-членов.   <li>Не используйте функции friend (но только для того, чтобы            избежать [а], [b] или [c]).   <li>Не обращайтесь к данным-членам другого объекта непосредственно.   <li>Не заводите в классе "поле типа"; используйте виртуальные            функции.   <li>Используйте функции-подстановки только как средство            значительной оптимизации.   </ol> </ol>  <a name="#forprog"></a><h5>Замечание для программистов на С</h5> <p>Чем лучше программист знает С, тем труднее будет для него при   программировании на С++ отойти от стиля программирования на С.  Так он   теряет потенциальные преимущества С++. Поэтому советуем просмотреть раздел   "Отличия от С" в справочном руководстве (п.<a href="reference.shtml#R.18">R.18</a>).  Здесь мы только укажем   на те места, в которых использование дополнительных возможностей С++   приводит к лучшему решению, чем программирование на чистом С. Макрокоманды   практически не нужны в С++: используйте const (   п.<a href="chap2.shtml#nameconst">2.5</a>) или enum (   п.<a href="chap2.shtml#transfer">2.5.1</a>),   чтобы определить поименованные константы; используйте inline (   п.<a href="chap4.shtml#defined">4.6.2</a>),   чтобы избежать расходов ресурсов, связанных с вызовом функций; используйте   шаблоны типа (п.<a href="chap8.shtml">8</a>), чтобы задать семейство функций и типов. Не описывайте   переменную, пока она действительно вам не понадобится, а тогда ее можно   сразу инициализировать, ведь в С++ описание может появляться в любом   месте, где допустим оператор. Не используйте malloc(), эту операцию лучше   реализует new (п.<a href="chap3.shtml#freemem">3.2.6</a>).  Объединения нужны не столь часто, как в С,   поскольку альтернативность в структурах реализуется с помощью производных   классов. Старайтесь обойтись без объединений, но если они все-таки нужны,   не включайте их в основные интерфейсы; используйте безымянные объединения   (п.<a href="chap2.shtml#assoc">2.6.2</a>).  Старайтесь не использовать указателей типа void*,   арифметических операций с указателями, массивов в стиле С и операций   приведения.  Если все-таки вы используете эти конструкции, упрятывайте их   достаточно надежно в какую-нибудь функцию или класс.  Укажем, что   связывание в стиле С возможно для функции на С++, если она описана со   спецификацией extern "C" (п.<a href="chap4.shtml#progbind">4.4</a>).</p> <p>Но гораздо важнее стараться думать о программе как о множестве   взаимосвязанных понятий, представляемых классами и объектами, чем   представлять ее как сумму структур данных и функций, что-то делающих с   этими данными.</p>  <a name="#list"></a><h5>Список литературы</h5> <p>В книге немного непосредственных ссылок на литературу. Здесь приведен   список книг и статей, на которые есть прямые ссылки, а также тех, которые   только упоминаются.</p> <ol> <li><a name="book1"></a>A.V.Aho, J.E.Hopcroft, and J.D.Ulman: Data Structures and   Algoritms.  Addison-Wesley, Reading, Massachusetts. 1983. <li><a name="book2"></a>O-J.Dahl, B.Myrhaug, and K.Nugaard: SIMULA Common Base Language.   Norwegian Computing Ctnter S-22. Oslo, Norway. 1970 <li><a name="book3"></a>O-J.Dahl and C.A.R.Hoare: Hierarhical Program Construction in   Structured Programming. Academic Press, New York. 1972. pp. 174-220. <li><a name="book4"></a>Margaret A.Ellis and Bjarne Stroustrup: The Annotated C++   Reference Manual. Addison-Wesley, Reading, Massachusetts. 1990. <li><a name="book5"></a>A.Goldberg and D.Rodson: SMALLTALK-80 - The Language and Its   Implementation. Addison-Wesley, Reading, Massachusetts. 1983. <li><a name="book6"></a>R.E.Griswold et.al.: The Snobol14 Programming Language.   Prentice-Hall, Englewood Cliffs, New Jersy, 1970. <li><a name="book7"></a>R.E.Griswold and M.T.Griswold: The ICON Programming Language.   Prentice-Hall, Englewood Cliffs, New Jersy. 1983. <li><a name="book8"></a>Brian W.Kernighan and Dennis M.Ritchie: The C Programming   Language.  Prentice-Hall, Englewood Cliffs, New Jersy. 1978. Second   edition 1988. <li><a name="book9"></a>Andrew Koenig and Bjarne Stroustrup: C++: As Close to C as   possible - but no closer. The C++ Report. Vol.1 No.7. July 1989. <li><a name="book10"></a>Andrew Koenig and Bjarne Stroustrup: Exception Handling for C++   (revised). Proc USENIX C++ Conference, April 1990. Also, Journal of Object   Oriented Programming, Vol.3 No.2, July/August 1990. pp.16-33. <li><a name="book11"></a>Barbara Liskov et.al.: CLU Reference Manual. MIT/LCS/TR-225. <li><a name="book12"></a>George Orwell: 1984. Secker and Warburg, London. 1949. <li><a name="book13"></a>Martin Richards and Colin Whitby-Strevens: BCPL - The Language   and Its Compiler. Cambridge University Press. 1980. <li><a name="book14"></a>L.Rosler: The Evolution of C - Past and Future.  AT&T Bell   Laboratories Technical Journal. Vol.63 No.8 Part 2.  October 1984. pp.1685-1700. <li><a name="book15"></a>Ravi Sethi: Uniform Syntax for Type Expressions and Declarations.   Software Practice & Experience, Vol.11. 1981. pp.623-628. <li><a name="book16"></a>Bjarne Stroustrup: Adding Classes to C: An Exercise in Language   Evolution. Software Practice & Experience, Vol.13. 1983. pp.139-61. <li><a name="book17"></a>Bjarne Stroustrup: The C++ Programming Language.  Addison-Wesley. 1986. <li><a name="book18"></a>Bjarne Stroustrup: Multiple Inheritance for C++.  Proc. EUUG   Spring Conference, May 1987.  Also USENIX Computer Systems, Vol.2 No 4,   Fall 1989. <li><a name="book19"></a>Bjarne Stroustrup and Jonathan Shopiro: A Set of C classes for   Co-Routine Style Programming. Proc. USENIX C++ conference, Santa Fe.   November 1987. pp.417-439. <li><a name="book20"></a>Bjarne Stroustrup: Type-safe Linkage for C++.  USENIX Computer   Systems, Vol.1 No.4 Fall 1988. <li><a name="book21"></a>Bjurne Stroustrup: Parameterized Type for C++.  Proc. USENIX C++   Conference, Denver, October 1988. pp.1-18.  Also, USENIX Computer Systems,   Vol.2 No.1 Winter 1989. <li><a name="book22"></a>Bjarne Stroustrup: Standardizing C++.  The C++ Report. Vol.1 No.1. January 1989. <li><a name="book23"></a>Bjarne Stroustrup: The Evolution of C++: 1985-1989.  USENIX   Computer Systems, Vol.2 No.3. Summer 1989. <li><a name="book24"></a>P.M.Woodward and S.G.Bond: Algol 68-R Users Guide.  Her Majesty's   Stationery Office, London. 1974. <li><a name="book25"></a>UNIX Time-Sharing System: Programmer's Manual.  Research Version,   Tenth Edition.  AT&T Bell Laboratories, Murray Hill, New Jersy, February 1985. <li><a name="book26"></a>Aake Wilkstroem: Functional Programming Using ML.  Prentice-Hall,   Englewood Cliffs, New Jersy. 1987. <li><a name="book27"></a>X3 Secretariat: Standard - The C Language. X3J11/90-013.   Computer and Business Equipment Manufactures Association, 311 First   Street, NW, Suite 500, Washington, DC 20001, USA. </ol> <p>Ссылки на источники по проектированию и развитию больших систем   программного обеспечения можно найти в конце главы    <a href="chap11.shtml#comment">11</a>.</p>  <p align=center> <A HREF="#" onclick="history.back(); return false;">Назад</a> <A HREF="index.shtml">Оглавление</a> <A HREF="chap1.shtml">Вперед</a> </p>  <!----- END MAIN CONTENT ------->      </td>     </tr>    </table>			   </TD>  </TR>  <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR> </TABLE> </BODY> </HTML>