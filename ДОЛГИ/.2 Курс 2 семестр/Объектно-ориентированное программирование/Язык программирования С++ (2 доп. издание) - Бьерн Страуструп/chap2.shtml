<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 2<br> 
Описания и константы</h3>

<p align="right"><i>"Совершенство достижимо только в момент краха".<br>
(С.Н. Паркинсон)</i></p>
<p> В данной главе описаны основные типы (char,  int, float и т.д.) и
 способы построения на их основе новых типов (функций, векторов, указателей
 и т.д.). Описание вводит в программу имя, указав его тип и, возможно,
 начальное значение. В этой главе вводятся такие понятия, как описание и
 определение, типы, область видимости имен, время жизни объектов.
 Даются обозначения литеральных констант С++ и способы задания
 символических констант. Приводятся примеры, которые просто
 демонстрируют возможности языка. Более осмысленные примеры, иллюстрирующие
 возможности выражений и операторов языка С++, будут приведены в следующей
 главе. В этой главе лишь упоминаются средства для определения
 пользовательских типов и операций над ними. Они обсуждаются в главах 
 <a href="chap5.shtml">5</a> и <a href="chap7.shtml">7</a>.</p>

<a name="#descr"></a><h4>2.1 Описания</h4>
<p> Имя (идентификатор) следует описать прежде, чем оно будет использоваться
 в программе на  С++. Это означает, что нужно указать его тип, чтобы
 транслятор знал, к какого вида объектам относится имя. Ниже приведены
 несколько примеров, иллюстрирующих все разнообразие описаний:</p>
<pre>
     char ch;
     int count = 1;
     char* name = "Njal";
     struct complex { float re, im; };
     complex cvar;
     extern complex sqrt(complex);
     extern int error_number;
     typedef complex point;
     float real(complex* p) { return p->re; };
     const double pi = 3.1415926535897932385;
     struct user;
     template<class T> abs(T a) { return a&lt;0 ? -a : a; }
     enum beer { Carlsberg, Tuborg, Thor };
</pre>
<p>Из этих примеров видно, что роль описаний не сводится лишь к привязке
  типа к имени. Большинство указанных описаний одновременно являются
  определениями, т.е. они создают объект, на который ссылается имя.
   Для ch, count, name и cvar таким объектом является  элемент памяти
   соответствующего размера. Этот элемент будет использоваться как
   переменная, и говорят, что для него отведена память. Для real подобным
   объектом будет заданная функция.<br>
   Для константы pi объектом будет число 3.1415926535897932385.<br>
   Для complex объектом будет новый тип. Для point объектом является
   тип complex, поэтому point становится синонимом  complex. Следующие
   описания уже не являются определениями:</p>
<pre>
     extern complex sqrt(complex);
     extern int error_number;
     struct user;
</pre>
<p>Это означает, что объекты, введенные ими, должны быть определены
   где-то в другом месте программы. Тело функции sqrt должно быть указано
   в каком-то другом описании. Память для переменной error_number типа
   int должна выделяться в результате другого описания error_number.
   Должно быть и какое-то другое описание типа user,  из которого  можно
   понять, что это за тип. В программе на языке С++ должно быть только
   одно определение каждого имени, но описаний может быть много. Однако все
   описания должны быть согласованы по типу вводимого в них объекта.
   Поэтому в приведенном ниже фрагменте содержатся две ошибки:</p>
<pre>
     int count;
     int count;               // ошибка: переопределение

     extern int error_number;
     extern short error_number; // ошибка: несоответствие типов
</pre>
<p>Зато в следующем фрагменте нет ни одной ошибки (об использовании
   extern см. #4.2):</p>
<pre>
    extern int error_number;
    extern int error_number;
</pre>
<p>В некоторых описаниях указываются "значения"  объектов, которые они
  определяют:</p>
<pre>
    struct complex { float re, im; };
    typedef complex point;
    float real(complex* p) { return  p->re };
    const double pi = 3.1415926535897932385;
</pre>
<p>Для типов, функций и констант "значение" остается неизменным;
  для данных, не являющихся константами, начальное значение может
  впоследствии изменяться:</p>
<pre>
     int count = 1;
     char* name = "Bjarne";
     //...
     count = 2;
     name = "Marian";
</pre>
<p>Из всех определений только следующее не задает значения:</p>
<pre>
      char ch;
</pre>
<p>Всякое описание, которое задает значение, является определением.</p>

<a name="#areavis"></a><h5>2.1.1 Область видимости</h5>
<p>  Описанием определяется область видимости имени. Это значит, что
  имя может использоваться только в определенной части текста программы.
  Если имя описано в функции (обычно его называют "локальным именем"), то
  область видимости имени простирается от точки описания
  до конца блока, в котором появилось это описание. Если имя не находится
  в описании функции или класса (его обычно называют "глобальным именем"),
  то область видимости простирается от точки описания до конца файла,
  в котором появилось это описание.
  Описание имени в блоке может скрывать описание в объемлющем блоке или
  глобальное имя; т.е. имя может быть переопределено так, что оно будет
  обозначать другой объект внутри блока. После выхода из блока прежнее
  значение имени (если оно было) восстанавливается. Приведем пример:</p>
<pre>
  int x;            // глобальное x

  void f()
  {
      int x;        // локальное x скрывает глобальное x
      x = 1;        // присвоить локальному x
      {
          int x;    // скрывает первое локальное x
          x = 2;    // присвоить второму локальному x
      }
      x = 3;        // присвоить первому локальному x
  }

  int* p = &x;      // взять адрес глобального x

</pre>
<p>В больших программах не избежать переопределения имен. К сожалению,
  человек легко может проглядеть такое переопределение. Возникающие
  из-за этого ошибки найти непросто, возможно потому, что они
  достаточно редки. Следовательно, переопределение имен следует
  свести к минимуму. Если вы обозначаете глобальные переменные или
  локальные переменные в большой функции такими именами, как i или x,
  то сами напрашиваетесь на неприятности.
    Есть возможность с помощью операции разрешения области видимости
  :: обратиться к скрытому глобальному имени, например:</p>
<pre>
     int x;

     void f2()
     {
       int x = 1;      // скрывает глобальное x
       ::x = 2;        // присваивание глобальному x
     }
</pre>
<p>Возможность использовать скрытое локальное имя отсутствует.</p>
<p>Область видимости имени начинается в точке его описания (по
  окончании описателя, но еще до начала инициализатора - см. п.<a href="referenc.shtml#R.3.2">R.3.2</a>). Это
  означает, что имя можно использовать даже до того, как задано его
  начальное значение. Например:</p>
<pre>
     int x;

     void f3()
     {
        int x = x;    // ошибочное присваивание
      }
</pre>
<p>Такое присваивание недопустимо и лишено смысла. Если вы попытаетесь
   транслировать эту программу, то получите предупреждение: "использование
   до задания значения". Вместе с тем, не применяя оператора ::, можно
   использовать одно и то же имя для обозначения двух различных объектов
   блока. Например:</p>
<pre>
      int x = 11;

      void f4()         // извращенный пример
      {
        int y = x;   //  глобальное x
        int x = 22;
        y = x;       // локальное x
      }
</pre>
<p>Переменная y инициализируется значением глобального x, т.е. 11,
   а затем ей присваивается значение локальной переменной x, т.е. 22.
   Имена  формальных параметров функции считаются описанными в самом
   большом блоке функции, поэтому в описании ниже есть ошибка:</p>
<pre>
      void f5(int x)
      {
        int x;       // ошибка
       }
</pre>
<p>Здесь x определено дважды в одной и той  же  области видимости.<br>
   Это хотя и не слишком редкая, но довольно тонкая ошибка.</p>


<a name="#address"></a><h5>2.1.2 Объекты и адреса</h5>
<p>Можно выделять память для "переменных",  не имеющих имен, и
   использовать эти переменные.<br>
   Возможно даже присваивание таким странно выглядящим "переменным",
   например, *p[a+10]=7. Следовательно, есть потребность именовать
   "нечто хранящееся в памяти". Можно привести подходящую цитату из
   справочного руководства: "Любой объект - это некоторая область
   памяти, а адресом называется выражение, ссылающееся на объект или
   функцию" (п.<a href="referenc.shtml#R.3.7">R.3.7</a>). Слову адрес (lvalue - left value, т.е. величина
   слева) первоначально приписывался смысл "нечто, что может в
   присваивании стоять слева". Адрес может ссылаться и на константу
   (см. п. <a href="chap2.shtml#nameconst">2.5</a>). Адрес, который не был описан со спецификацией const,
   называется изменяемым адресом.</p>

<a name="#timeobj"></a><h5>2.1.3 Время жизни объектов</h5>
<p>Если только программист не вмешается явно, объект будет создан при
   появлении его определения и уничтожен, когда исчезнет из
   области видимости. Объекты с глобальными именами создаются,
   инициализируются (причем только один раз) и существуют до конца
   программы. Если локальные объекты описаны со служебным словом
   static, то они также существуют до конца программы. Инициализация их
   происходит, когда в первый раз управление "проходит через"
   описание этих объектов, например:</p>
<pre>
      int a = 1;

      void f()
      {
        int b = 1;   // инициализируется при каждом вызове f()
        static int c = a;  // инициализируется только один раз
        cout << " a = " << a++
             << " b = " << b++
             << " c = " << c++ << '\n';
      }

      int main()
      {
        while (a < 4) f();
      }
</pre>
<p>Здесь программа выдаст такой результат:</p>
<pre>
      a = 1 b = 1 c = 1
      a = 2 b = 1 c = 2
      a = 3 b = 1 c = 3
</pre>
<p>''Из примеров этой главы для краткости изложения исключена
  макрокоманда #include &lt;iostream>. Она нужна лишь в тех из них, которые
  выдают результат.</p>
<p>Операция "++" является инкрементом, т. е. a++ означает: добавить 1
   к переменной a.</p>
<p>Глобальная переменная или локальная переменная static, которая не была
   явно инициализирована, инициализируется неявно нулевым значением (п.<a href="#string">2.4.5</a>).</p>
<p>Используя операции  new и delete, программист может создавать
   объекты, временем жизни которых он управляет сам (см. п.
   <a href="chap3.shtml#freemem">3.2.6</a>).</p>

<a name="#names"></a><h4>2.2 Имена</h4>
<p>Имя (идентификатор) является последовательностью букв или цифр.
   Первый символ должен быть буквой. Буквой считается и символ
   подчеркивания _. Язык С++ не ограничивает число символов в имени.
   Но в реализацию входят программные компоненты, которыми создатель
   транслятора управлять не может (например, загрузчик), а они,
   к сожалению, могут устанавливать ограничения. Кроме того, некоторые
   системные программы, необходимые для выполнения программы на С++, могут
   расширять или сужать множество символов, допустимых в идентификаторе.
   Расширения (например, использование $ в имени) могут нарушить
   переносимость программы. Нельзя использовать в качестве имен
   служебные слова С++ (см. п.<a href="referenc.shtml#R.2.4">R.2.4</a>), например:</p>
<pre>
          hello    this_is_a_most_unusially_long_name
          DEFINED  foO    bAr     u_name    HorseSense
          var0     var1   CLASS   _class    ___
</pre>
<p>Теперь приведем примеры последовательностей символов, которые не могут
  использоваться как идентификаторы:</p>
<pre>
          012      a fool    $sys     class    3var
          pay.due  foo~bar   .name    if
</pre>
<p>Заглавные и строчные буквы считаются различными, поэтому Count и
  count - разные имена. Но выбирать имена, почти не отличающиеся
  друг от друга, неразумно. Все имена, начинающиеся с символа
  подчеркивания, резервируются для использования в самой реализации
  или в тех программах, которые выполняются совместно с рабочей,
  поэтому крайне легкомысленно вставлять такие имена в
  свою программу.</p>
<p>При разборе программы транслятор всегда стремится выбрать самую
  длинную последовательность символов, образующих имя, поэтому var10
  - это имя, а не идущие подряд имя var и число 10. По той же причине
  elseif - одно имя (служебное), а не два служебных имени else и if.</p>

<a name="#types"></a><h4>2.3 Типы</h4>
<p>С каждым именем (идентификатором) в программе связан тип. Он
  задает те операции, которые могут применяться к имени (т.е. к объекту,
  который обозначает имя), а также интерпретацию этих операций.
  Приведем примеры:</p>
<pre>
        int error_number;
        float real(complex* p);
</pre>
<p>Поскольку переменная error_number описана как int (целое), ей можно
  присваивать, а также можно использовать ее значения в арифметических
  выражениях. Функцию real можно вызывать с параметром, содержащим
  адрес complex. Можно получать адреса и переменной, и функции.
  Некоторые имена, как в нашем примере int и complex, являются именами
  типов. Обычно имя типа нужно, чтобы задать в описании типа некоторое
  другое имя. Кроме того, имя типа может использоваться
  в качестве операнда в операциях sizeof (с ее помощью определяют
  размер памяти, необходимый для объектов этого типа) и new (с ее
  помощью можно разместить в свободной памяти объект этого типа).
  Например:</p>
<pre>
         int main()
         {
           int* p = new int;
           cout << "sizeof(int) = " << sizeof(int) '\n';
         }
</pre>
<p>Еще имя типа может использоваться в операции явного преобразования
  одного типа к другому (п.<a href="chap3.shtml#typetrans">3.2.5</a>), например:</p>
<pre>
         float f;
         char* p;
         //...
         long ll = long(p);     // преобразует p в long
         int i = int(f);        // преобразует f в int
</pre>

<a name="#maintype"></a><h5>2.3.1 Основные типы</h5>
<p>С каждым именем (идентификатором) в программе связан тип. Он
  задает те операции, которые могут применяться к имени (т.е. к объекту,
  который обозначает имя), а также интерпретацию этих операций.<br>
  Приведем примеры:</p>
<pre>
        int error_number;
        float real(complex* p);
</pre>
<p>Поскольку переменная error_number описана как int (целое), ей можно
  присваивать, а также можно использовать ее значения в арифметических
  выражениях. Функцию real можно вызывать с параметром, содержащим
  адрес complex. Можно получать адреса и переменной, и функции.
  Некоторые имена, как в нашем примере int и complex, являются именами
  типов. Обычно имя типа нужно, чтобы задать в описании типа некоторое
  другое имя. Кроме того, имя типа может использоваться
  в качестве операнда в операциях sizeof (с ее помощью определяют
  размер памяти, необходимый для объектов этого типа) и new (с ее
  помощью можно разместить в свободной памяти объект этого типа).<br>
  Например:</p>
<pre>
         int main()
         {
           int* p = new int;
           cout << "sizeof(int) = " << sizeof(int) '\n';
         }
</pre>
<p>Еще имя типа может использоваться в операции явного преобразования
  одного типа к другому (п.<a href="chap3.shtml#typetrans">3.2.5</a>), например:</p>
<pre>
         float f;
         char* p;
         //...
         long ll = long(p);     // преобразует p в long
         int i = int(f);        // преобразует f в int
</pre>

<a name="#impltransf"></a><h5>2.3.2 Неявное преобразование типа</h5>
<p>В присваивании и выражении основные типы могут совершенно свободно
  использоваться совместно. Значения преобразовываются всюду, где
  это возможно, таким образом, чтобы информация не терялась. Точные
  правила преобразований даны в п.<a href="referenc.shtml#R.4">R.4</a> и п.<a href="referenc.shtml#R.5.4">R.5.4</a>.</p>
<p>Все-таки есть ситуации, когда информация может быть потеряна или
  даже искажена. Потенциальным источником таких ситуаций становятся
  присваивания, в которых значение одного типа присваивается значению
  другого типа, причем в представлении последнего используется
  меньше разрядов. Допустим, что следующие присваивания выполняются
  на машине, в которой целые представляются в дополнительном коде, и символ
  занимает 8 разрядов:</p>
<pre>
       int i1 = 256+255;
       char ch = i1        // ch == 255
       int i2 = ch;        // i2 == ?
</pre>
<p>В присваивании ch=i1 теряется один разряд (и самый важный!), а когда
  мы присваиваем значение переменной i2, у переменной ch значение "все
  единицы", т.е. 8 единичных разрядов. Но какое значение примет i2? На
  машине DEC VAX, в которой char представляет знаковые значения, это будет
  -1, а на машине Motorola 68K, в которой char - беззнаковый,
  это будет 255. В С++ нет динамических средств  контроля
  подобных ситуаций, а контроль на этапе трансляции вообще слишком
  сложен, поэтому надо быть осторожными.</p>

<a name="#derivtype"></a><h5>2.3.3 Производные типы</h5>
<p>Исходя из основных (и определенных пользователем) типов, можно с
  помощью следующих операций описания:</p>
<pre>
       *     указатель
       &     ссылка
       []    массив
       ()    функция
</pre>
<p>а также с помощью определения структур, задать другие, производные типы.<br>
  Например:</p>
<pre>
       int* a;
       float v[10];
       char* p[20];   // массив из 20 символьных указателей
       void f(int);
       struct str { short length; char* p; };
</pre>
<p>Правила построения типов с помощью этих операций подробно объяснены
  в п.<a href="referenc.shtml#R.8">R.8</a>. Ключевая идея состоит в том, что описание объекта производного
  типа должно отражать его использование, например:</p>
<pre>
       int v[10];     // описание вектора
       i = v[3];      // использование элемента вектора

       int* p;        // описание указателя
       i = *p;        // использование указуемого объекта
</pre>
<p>Обозначения, используемые для производных типов, достаточно трудны
  для понимания лишь потому, что операции * и & являются префиксными, а
  [] и () - постфиксными. Поэтому в задании типов, если приоритеты
  операций не отвечают цели, надо ставить скобки. Например, приоритет
  операции [] выше, чем у *, и мы имеем:</p>
<pre>
      int* v[10];        // массив указателей
      int (*p)[10];      // указатель массива
</pre>
<p>Большинство людей просто запоминает, как выглядят наиболее часто
  употребляемые типы.<br>
  Можно описать сразу несколько имен в одном описании. Тогда оно содержит
  вместо одного имени список отделяемых друг от друга запятыми
  имен. Например, можно так описать две переменные целого типа:</p>
<pre>
       int x, y;    // int x; int y;
</pre>
<p>Когда мы описываем производные типы, не надо забывать, что операции
  описаний применяются только к данному имени (а вовсе не ко всем
  остальным именам того же описания). Например:</p>
<pre>
      int* p, y;        // int* p; int y; НО НЕ int* y;
      int x, *p;        // int x; int* p;
      int v[10], *p;    // int v[10]; int* p;
</pre>
<p>Но такие описания запутывают программу, и, возможно, их следует
  избегать.</p>

<a name="#void"></a><h5>2.3.4. Тип void</h5>
<p>Тип void синтаксически эквивалентен основным типам, но использовать
  его можно только в производном типе. Объектов типа void не существует.
  С его помощью задаются указатели на объекты неизвестного типа или
<pre>  функции, невозвращающие значение.</p>

     void f();    // f не возвращает значения
     void* pv;    // указатель на объект неизвестного типа
</pre>
<p>Указатель произвольного типа можно присваивать переменной типа void*.
  На первый взгляд этому трудно найти применение, поскольку для void*
  недопустимо косвенное обращение (разыменование). Однако, именно
  на этом ограничении основывается использование типа void*. Он
  приписывается параметрам функций, которые не должны знать истинного
  типа этих параметров. Тип void* имеют также бестиповые объекты,
  возвращаемые функциями.<br>
  Для использования таких объектов нужно выполнить явную операцию
  преобразования типа. Такие функции обычно находятся на самых нижних
  уровнях системы, которые управляют аппаратными
  ресурсами. Приведем пример:</p>
<pre>
      void* malloc(unsigned size);
      void free(void*);

      void f()          // распределение памяти в стиле Си
      {
        int* pi = (int*)malloc(10*sizeof(int));
        char* pc = (char*)malloc(10);
        //...
        free(pi);
        free(pc);
      }
</pre>
<p>Обозначение: (тип) выражение - используется для задания операции
   преобразования выражения к типу, поэтому перед присваиванием
   pi тип void*, возвращаемый в первом вызове malloc(), преобразуется
   в тип int. Пример записан в архаичном стиле; лучший стиль
   управления размещением в свободной памяти показан в п.
   <a href="chap3.shtml#freemem">3.2.6</a>.</p>

<a name="#pointer"></a><h5>2.3.5 Указатели</h5>
<p>Для большинства типов T указатель на T имеет тип T*. Это значит, что
  переменная типа T* может хранить адрес объекта типа T. Указатели на
  массивы и функции, к сожалению, требуют более сложной записи:<p>
<pre>
      int* pi;
      char** cpp;             // указатель на указатель на char
      int (*vp)[10];          // указатель на массив из 10 целых
      int (*fp)(char, char*); // указатель на функцию с параметрами
                              // char  и char*,  возвращающую int
</pre>
<p>Главная операция над указателями - это косвенное обращение
  (разыменование), т.е. обращение к объекту, на который настроен
  указатель. Эту операцию обычно называют просто косвенностью.
  Операция косвенности * является префиксной унарной операцией.<br>
  Например:</p>
<pre>
      char c1 = 'a';
      char* p = &c1;    // p содержит адрес c1
      char c2 = *p;    // c2 = 'a'
</pre>
<p>Переменная, на которую указывает p,- это c1, а значение, которое
   хранится в c1, равно 'a'. Поэтому присваиваемое c2 значение *p
   есть 'a'.<br>
   Над указателями можно выполнять и некоторые арифметические операции.
   Ниже в качестве примера представлена функция, подсчитывающая число
   символов в строке, заканчивающейся нулевым символом (который
   не учитывается):</p>
<pre>
       int strlen(char* p)
       {
         int i = 0;
         while (*p++) i++;
         return i;
       }
</pre>
<p>Можно определить длину строки по-другому: сначала найти ее конец, а затем
  вычесть адрес начала строки из адреса ее конца.</p>
<pre>
        int strlen(char* p)
        {
          char* q = p;
          while (*q++) ;
          return q-p-1;
        }
</pre>
<p>Широко используются указатели на функции; они особо обсуждаются
  в п.<a href="chap4.shtml#pointer">4.6.9</a></p>

<a name="#array"></a><h5>2.3.6 Массивы</h5>
<p>Для типа T T[size] является типом "массива из size элементов типа T".<br>
  Элементы индексируются от 0 до size-1. Например:</p>
<pre>
       float v[3];   // массив из трех чисел с плавающей точкой:
                     //     v[0], v[1], v[2]
       int a[2][5];  // два массива, из пяти целых каждый
       char* vpc;    // массив из 32 символьных указателей
</pre>
<p>Можно следующим образом записать цикл, в котором печатаются целые
   значения прописных букв:</p>
<pre>
       extern "C" int strlen(const char*);  // из <string.h>

       char alpha[] = "abcdefghijklmnopqrstuvwxyz";

       main()
       {
         int sz = strlen(alpha);

         for (int i=0; i&lt;sz; i++) {
             char ch = alpha[i];
             cout &lt;&lt; '\''&lt;&lt; ch &lt;&lt; '\''
                  &lt;&lt; " = " &lt;&lt;int(ch)
                  &lt;&lt; " = 0" &lt;&lt; oct(ch)
                  &lt;&lt; " = 0x" &lt;&lt; hex(ch) &lt;&lt; '\n';
          }
       }
</pre>
<p>Здесь функции oct() и hex() выдают свой параметр целого типа
  в восьмеричном и шестнадцатеричном виде соответственно. Обе функции
  описаны в <iostream.h>. Для подсчета числа символов в alpha
  используется функция strlen() из <string.h>, но вместо нее можно
  было использовать размер массива alpha (п.<a href="#string">2.4.4</a>). Для множества
  символов ASCII результат будет таким:</p>
<pre>
       'a' = 97 = 0141 = 0x61
       'b' = 98 = 0142 = 0x62
       'c' = 99 = 0143 = 0x63
       ...
</pre>
<p>Отметим, что не нужно указывать размер массива alpha: транслятор
  установит его, подсчитав число символов в строке, заданной в качестве
  инициализатора. Задание массива символов в виде строки инициализатора
  - это удобный, но к сожалению, единственный способ подобного применения
  строк. Присваивание строки массиву недопустимо, поскольку
  в языке присваивание массивам не определено, например:</p>
<pre>
        char v[9];
        v = "a string";          // ошибка
</pre>
<p>Классы позволяют реализовать представление строк с большим набором
  операций (см. п.<a href="chap7.shtml#increm">7.10</a>).</p>
<p>Очевидно, что строки пригодны только для инициализации символьных
  массивов; для других типов приходится использовать более сложную
  запись. Впрочем, она может использоваться и для символьных массивов.<br>
  Например:</p>
<pre>
        int  v1[] = { 1, 2, 3, 4 };
        int  v2[] = { 'a', 'b', 'c', 'd' };

        char v3[] = { 1, 2, 3, 4 };
        char v4[] = { 'a', 'b', 'c', 'd' };
</pre>
<p>Здесь v3 и v4 - массивы из четырех (а не пяти) символов; v4 не оканчивается
  нулевым символом, как того требуют соглашение о строках и большинство
  библиотечных функций.  Используя такой массив char мы сами
  готовим почву для будущих ошибок.</p>
<p>Многомерные массивы представлены как массивы массивов. Однако нельзя
  при задании граничных значений индексов использовать, как это делается
  в некоторых языках, запятую. Запятая - это особая операция для
  перечисления выражений (см. п.<a href="chap3.shtml#ordcalc">3.2.2</a>). Можно попробовать задать такое
  описание:</p>
<pre>
        int bad[5,2];    // ошибка
</pre>
<p>или такое</p>
<pre>
        int v[5][2];
        int bad = v[4,1];      // ошибка
        int good = v[4][1];    // правильно
</pre>
<p>Ниже описывается
  массив из двух элементов, каждый из которых является, в свою очередь,
  массивом из 5 элементов типа char:</p>
<pre>
        char v[2][5];
</pre>
<p>В следующем примере первый массив инициализируется пятью первыми буквами
  алфавита, а второй - пятью младшими цифрами.</p>
<pre>
        char v[2][5] = {
             { 'a', 'b', 'c', 'd', 'e' },
             { '0', '1', '2', '3', '4' }
        };

        main() {
            for (int i = 0; i&lt;2; i++) {
              for (int j = 0; j&lt;5; j++)
                  cout &lt;&lt; "v[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j
                       &lt;&lt; "]=" &lt;&lt; v[i][j] &lt;&lt; "  ";
                  cout &lt;&lt; '\n';

            }
        }
</pre>
<p>В результате получим:</p>
<pre>
       v[0][0]=a v[0][1]=b v[0][2]=c v[0][3]=d v[0][4]=e
       v[1][0]=0 v[1][1]=1 v[1][2]=2 v[1][3]=3 v[1][4]=4
</pre>

<a name="#arrpoint"></a><h5>2.3.7 Указатели и массивы</h5>
<p>Указатели и массивы в языке Си++ тесно связаны. Имя массива можно
   использовать как указатель на его первый элемент, поэтому пример с
   массивом alpha  можно записать так:</p>
<pre>
        int main()
        {
          char alpha[] = "abcdefghijklmnopqrstuvwxyz";
          char* p = alpha;
          char ch;

          while (ch = *p++)
                cout << ch << " = " << int (ch)
                     << " = 0" << oct(ch) << '\n';
        }
</pre>
<p>Можно также задать описание p следующим образом:</p>
<pre>
        char* p = &alpha[0];
</pre>
<p>Эта эквивалентность широко используется при вызовах функций с
  параметром-массивом, который всегда передается как указатель на его
  первый элемент. Таким образом, в следующем примере в обоих вызовах
  strlen передается одно и то же значение:</p>
<pre>
       void f()
       {
         extern "C" int strlen(const char*);  // из <string.h>
         char v[] = "Annemarie";
         char* p = v;
         strlen(p);
         strlen(v);
       }
</pre>
<p>Но в том и загвоэдка, что обойти это нельзя: не существует способа так
  описать функцию, чтобы при ее вызове массив v копировался (п.
  <a href="chap4.shtml#param">4.6.3</a>).<p>
<p>Результат применения к указателям арифметических операций +,
  -, ++ или -- зависит от типа указуемых объектов. Если такая операция
  применяется к указателю p типа T*, то считается, что p указывает на
  массив объектов типа T. Тогда p+1 обозначает следующий элемент
  этого массива, а p-1 - предыдущий элемент. Отсюда следует, что
  значение (адрес) p+1 будет на sizeof(T) байтов больше, чем значение
  p. Поэтому в следующей программе</p>
<pre>
      main()
      {
        char cv[10];
        int iv[10];

        char* pc = cv;
        int* pi = iv;

        cout << "char* " << long(pc+1)-long(pc) << '\n';
        cout << "int*  " << long(pi+1)-long(pi) << '\n';
      }
</pre>
<p>с учетом того, что на машине автора (Maccintosh) символ занимает один байт,
  а целое - четыре байта, получим:</p>
<pre>
        char* 1
        int*  4
</pre>
<p>Перед вычитанием указатели были явной операцией преобразованы
  к типу long (п.<a href="chap3.shtml#typetrans">3.2.5</a>). Он использовался для преобразования вместо
  "очевидного" типа int, поскольку в некоторых реализациях языка С++
  указатель может не поместиться в тип int (т.е. sizeof(int)&lt;sizeof(char*)).</p>
<p>Вычитание указателей определено только в том случае, когда
  они оба указывают на один и тот же массив (хотя в языке нет
  возможностей гарантировать этот факт). Результат вычитания одного
  указателя из другого равен числу (целое) элементов массива, находящихся
  между этими указателями. Можно складывать с указателем или вычитать из него
  значение целого типа; в обоих случаях результатом будет указатель.
  Если получится значение, не являющееся указателем на элемент того же
  массива, на который был настроен исходный указатель (или указателем на
  следующий за массивом элемент), то результат использования такого
  значения неопределен. Приведем пример:</p>
<pre>
        void f()
        {
          int v1[10];
          int v2[10];

          int i = &v1[5]-&v1[3];    // 2
          i = &v1[5]-&v2[3];    // неопределенный результат

           int* p = v2+2;            // p == &v2[2]
                p = v2-2;            // *p неопределено
        }
</pre>
<p>Как правило, сложных арифметических операций с указателями не требуется
  и лучше всего их избегать.<br>
  Следует сказать, что в
  большинстве реализаций языка С++ нет контроля над границами массивов.
  Описание массива не является самодостаточным, поскольку необязательно
  в нем будет храниться число элементов массива.<br>
  Понятие массива в С является, по сути, понятием языка низкого
  уровня. Классы помогают развить его (см. п.
  <a href="chap1.shtml#except">1.4.3</a>).</p>

<a name="#struct"></a><h5>2.3.8 Структуры</h5>
<p>Массив представляет собой совокупность элементов одного типа, а
   структура является совокупностью элементов произвольных
   (практически) типов. Например:</p>
<pre>
      struct address {
          char* name;         // имя "Jim Dandy"
          long  number;       // номер дома 61
          char* street;       // улица "South Street"
          char* town;         // город "New Providence"
          char* state[2];     // штат 'N' 'J'
          int   zip;          // индекс 7974
      };
</pre>
<p>Здесь определяется новый тип, называемый address, который задает
  почтовый адрес. Определение не является достаточно общим, чтобы
  учесть все случаи адресов, но оно вполне пригодно для примера. Обратите
  внимание на точку с запятой в конце определения: это один из
  немногих в С++ случаев, когда после фигурной скобки требуется
  точка с запятой, поэтому про нее часто забывают.</p>
<p>Переменные типа address можно описывать точно так же, как и любые
  другие переменные,  а с помощью операции . (точка) можно обращаться
  к отдельным членам структуры. Например:</p>
<pre>
      address jd;
      jd.name = "Jim Dandy";
      jd.number = 61;
</pre>
<p>Инициализировать переменные типа struct можно так же, как массивы.
  Например:</p>
<pre>
       address jd = {
          "Jim Dandy",
           61, "South Street",
           "New Providence", {'N','J'}, 7974
       };
</pre>
<p>Но лучше для этих целей использовать конструктор (п.
  <a href="chap5.shtml#init">5.2.4</a>). Отметим,
  что jd.state нельзя инициализировать строкой "NJ". Ведь строки
  оканчиваются нулевым символом '\0', значит в строке "NJ" три символа,
  а это на один больше, чем помещается в jd.state.
  К структурным объектам часто обращаются c помощью указателей,
  используя операцию ->. Например:</p>
<pre>
       void print_addr(address* p)
      {
        cout << p->name << '\n'
             << p->number << ' ' << p->street << '\n'
             << p->town << '\n'
             << p->state[0] << p->state[1]
             << ' ' << p->zip << '\n';
      }
</pre>
<p>Объекты структурного типа могут быть присвоены, переданы как фактические
  параметры функций и возвращены функциями в качестве результата. Например:</p>
<pre>
      address current;

     address set_current(address next)
     {
       address prev = current;
       current = next;
       return prev;
     }
</pre>
<p>Другие допустимые операции, например, такие, как сравнение (== и !=),
  неопределены. Однако пользователь может сам определить эти операции
  (см. главу 7).</p>
<p>Размер объекта структурного типа не обязательно равен сумме
  размеров всех его членов. Это происходит по той причине, что
  на многих машинах требуется размещать объекты определенных типов,
  только выравнивая их по некоторой зависящей от системы адресации
  границе (или просто потому, что работа при таком выравнивании будет
  более эффективной ). Типичный пример - это выравнивание целого по
  словной границе. В результате выравнивания могут появиться "дырки" в
  структуре. Так, на уже упоминавшейся машине автора sizeof(address)
  равно 24, а не 22, как можно было ожидать.<p>
<p>Следует также упомянуть, что тип можно использовать сразу после его
  появления в описании, еще до того, как будет завершено все описание.
  Например:</p>
<pre>
       struct link{
             link* previous;
             link* successor;
        };
</pre>
<p>Однако новые объекты типа структуры нельзя описать до тех пор, пока не
   появится ее полное описание. Поэтому описание</p>
<pre>
        struct no_good {
           no_good member;
        };
</pre>
<p>является ошибочным (транслятор не в состоянии установить размер no_good).
   Чтобы позволить двум (или более) структурным типам ссылаться друг на
   друга, можно просто описать имя одного из них как имя некоторого
   структурного типа. Например:</p>
<pre>
        struct list;        // будет определено позднее

        struct link {
             link* pre;
             link* suc;
             list* member_of;
        };

        struct list {
             link* head;
        };
</pre>
<p>Если бы не было первого описания list, описание члена link привело бы к
  синтаксической ошибке.<br>
  Можно также использовать имя структурного типа еще до того, как тип будет
  определен, если только это использование не предполагает знания размера
  структуры. Например:</p>
<pre>
          class S;        // 'S' - имя некоторого типа

          extern S a;

          S f();

          void g(S);
</pre>
<p>Но приведенные описания можно использовать лишь после того, как тип S
  будет определен:</p>
<pre>
          void h()
          {
            S a;        // ошибка: S - неописано
            f();        // ошибка: S - неописано
            g(a);       // ошибка: S - неописано
          }
</pre>

<a name="#equivtype"></a><h5>2.3.9 Эквивалентность типов</h5>
<p>Два структурных типа считаются различными даже тогда, когда они имеют
  одни и те же члены. Например, ниже определены различные типы:<p>
<pre>
          struct s1 { int a; };
          struct s2 { int a; };
</pre>
<p>В результате имеем:</p>
<pre>
          s1 x;
          s2 y = x;    // ошибка: несоответствие типов
</pre>
<p>Кроме того, структурные типы отличаются  от основных типов, поэтому
   получим:</p>
<pre>
          s1 x;
          int i = x;    // ошибка: несоответствие типов
</pre>
<p>Есть, однако, возможность, не определяя новый тип, задать новое имя
   для типа. В описании, начинающемся служебным словом typedef, описывается
   не переменная указанного типа, а вводится новое имя для типа.<br>
   Приведем пример:</p>
<pre>
          typedef char* Pchar;
          Pchar p1, p2;
          char* p3 = p1;
</pre>
<p>Это просто удобное средство сокращения записи.</p>

<a name="#ref"></a><h5>2.3.10 Ссылки</h5>
<p>Ссылку можно рассматривать как еще одно имя объекта.
   В основном ссылки используются для задания параметров и возвращаемых
   функциями значений , а также для перегрузки операций (см. п.<a href="chap7.shtml">7</a>).
   Запись X& обозначает ссылку на X. Например:</p>
<pre>
         int i = 1;
         int& r = i;    // r и i  ссылаются на одно и то же целое
         int x = r;     // x = 1
         r = 2;         // i = 2;
</pre>
<p>Ссылка должна быть инициализирована, т.е.
  должно быть нечто, что она может обозначать. Следует помнить, что
  инициализация ссылки совершенно отличается от операции присваивания.
  Хотя можно указывать операции над ссылкой, ни одна из них на саму ссылку
  не действует, например,</p>
<pre>
        int ii = 0;
        int& rr = ii;
        rr++;        // ii увеличивается на 1
</pre>
<p>Здесь операция ++ допустима, но rr++ не увеличивает саму
  ссылку rr; вместо этого ++ применяется к целому, т.е. к переменной ii.
  Следовательно, после инициализации значение ссылки не может быть
  изменено: она всегда указывает на тот объект, к которому была привязана
  при ее инициализации. Чтобы получить указатель на объект,
  обозначаемый ссылкой rr, можно написать &rr.<br>
  Очевидной реализацией ссылки может служить постоянный указатель,
  который используется только для косвенного обращения. Тогда инициализация
  ссылки будет тривиальной, если в качестве инициализатора указан адрес
  (т.е. объект, адрес которого можно получить; см. п.<a href="referenc.shtml#R.3.7">R.3.7</a>).
  Инициализатор для типа T должен быть адресом. Однако, инициализатор
  для &T может быть и не адресом, и даже не типом T. В таких случаях
  делается следующее:</p>
<ol>
<li>во-первых,  если необходимо, применяется преобразование типа
      (см.п.<a href="referenc.shtml#R.8.4.3">R.8.4.3</a>);
<li>затем получившееся значение помещается во временную переменную;
<li>наконец, адрес этой переменной используется в качестве инициализатора
      ссылки.
</ol>
<p>Пусть имеются описания:</p>
<pre>
        double& dr = 1;          // ошибка: нужен адрес
        const double& cdr = 1;   // нормально
</pre>
<p>Это интерпретируется так:</p>
<pre>
        double* cdrp;    // ссылка, представленная как указатель
        double temp;
        temp = double(1);
        cdrp = &temp;
</pre>
<p>Ссылки на переменные и ссылки на константы различаются по следующей
  причине: в первом случае создание временной переменной чревато
  ошибками, поскольку присваивание этой переменной означает присваивание
  временной переменной, которая могла к этому моменту исчезнуть.
  Естественно, что во втором случае подобных проблем не существует.
  и ссылки на константы часто используются как параметры функций
  (см. п.<a href="referenc.shtml#R.6.3">R.6.3</a>).</p>
<p>Ссылка может использоваться для функции, которая изменяет значение своего
  параметра. Например:</p>
<pre>
       void incr(int& aa) { aa++; }

       void f()
       {
         int x = 1;
         incr(x);     // x = 2
       }
</pre>
<p>По определению передача параметров имеет ту же семантику, что и
  инициализация, поэтому при вызове функции incr ее параметр aa
  становится другим именем для x. Лучше, однако, избегать изменяющих
  свои параметры функций, чтобы не запутывать программу. В большинстве
  случаев предпочтительнее, чтобы функция возвращала результат явным
  образом, или чтобы использовался параметр типа указателя:</p>
<pre>
         int next(int p) { return p+1; }
         void inc(int* p) { (*p)++; }

         void g()
         {
           int x = 1;
           x = next(x);            // x = 2
           inc(&x);                // x = 3
         }
</pre>
<p>Кроме перечисленного, с помощью ссылок можно определить функции,
   используемые как в правой, так и в левой частях присваивания.
   Наиболее интересное применение это обычно находит при определении
   нетривиальных пользовательских типов. В качестве примера определим
   простой ассоциативный массив. Начнем с определения структуры
   pair:</p>
<pre>
          struct pair {
             char* name;  // строка
             int val;     // целое
          };
</pre>
<p>Идея заключается в том, что со строкой связывается некоторое целое значение.
  Нетрудно написать функцию  поиска  find(),  которая работает со структурой
  данных, представляющей ассоциативный массив. В нем для каждой отличной от
  других строки содержится структура pair (пара: строка и значение ). В
  данном примере - это просто массив. Чтобы сократить пример, используется
  предельно простой, хотя и неэффективный алгоритм:</p>
<pre>
           const int large = 1024;
           static pair vec[large+1];

           pair* find(const char* p)
        /*
           // работает со множеством пар "pair":
           // ищет p, если находит, возвращает его "pair",
           // в противном случае возвращает неиспользованную "pair"
        */
       {
           for (int i=0; vec[i].name; i++)
               if (strcmp(p,vec[i].name)==0) return &vec[i];

           if (i == large) return &vec[large-1];

           return &vec[i];
         }
</pre>
<p>Эту функцию использует функция value(), которая реализует массив целых,
  индексируемый строками (хотя привычнее строки индексировать целыми):</p>
<pre>
         int& value(const char* p)
         {
           pair* res = find(p);
           if (res->name == 0) {  // до сих пор строка не встречалась,
                                  // значит надо инициализировать
             res->name = new char[strlen(p)+1];
             strcpy(res->name,p);
             res->val = 0;      // начальное значение равно 0
          }
          return res->val;
        }
</pre>
<p>Для заданного параметра (строки) value() находит объект,
   представляющий целое (а не просто значение соответствующего целого) и
   возвращает ссылку на него. Эти функции можно использовать, например, так:</p>
<pre>
         const int MAX = 256;    // больше длины самого длинного слова

         main()
         // подсчитывает частоту слов во входном потоке
        {
          char buf[MAX];

          while (cin>>buf) value(buf)++;

          for (int i=0; vec[i].name; i++)
              cout << vec[i].name << ": " << vec [i].val<< '\n';
         }
</pre>
<p>В цикле while из стандартного входного потока cin читается по одному
   слову и записывается в буфер buf (см. глава 10), при этом каждый
   раз значение счетчика, связанного со считываемой строкой, увеличивается.
   Счетчик отыскивается в ассоциативном массиве vec с помощью функции
   find(). В цикле for печатается получившаяся таблица различных слов из cin
   вместе с их частотой. Имея входной поток</p>
<pre>
          aa bb bb aa aa bb aa aa

<p>программа выдает:</p>

          aa: 5
          bb: 3
</pre>
<p>С помощью шаблонного класса и перегруженной операции [] (п. 
  <a href="chap8.shtml#associad">8.8</a>)
  достаточно просто довести массив из этого примера до настоящего
  ассоциативного массива.</p>

<a name="#literal"></a><h4>2.4 Литералы</h4>
<p>В С++ можно задавать значения всех основных типов:
  символьные константы, целые константы и константы с плавающей точкой.
  Кроме того, нуль (0) можно использовать как значение указателя
  произвольного типа, а символьные строки являются константами типа
  char[]. Есть возможность определить символические константы.
  Символическая константа - это имя, значение которого в его области
  видимости изменять нельзя. В С++ символические константы можно задать
  тремя способами:</p>
<ol>
<li>добавив служебное слово const в определении,
  можно связать с именем любое значение произвольного типа;
<li>множество целых констант можно определить как перечисление;
<li>константой является имя массива или функции.
</ol>

<a name="#wholeconst"></a><h5>2.4.1 Целые константы</h5>
<p>Целые константы могут появляться в четырех обличьях: десятичные,
  восьмеричные, шестнадцатеричные и символьные константы. Десятичные
  константы используются чаще всего и выглядят естественно:</p>
<pre>
          0    1234    976    12345678901234567890
</pre>
<p>Десятичная константа имеет тип int,  если она умещается в память,
  отводимую для int, в противном случае ее тип long. Транслятор должен
  предупреждать о константах, величина которых превышает выбранный формат
  представления чисел.
  Константа, начинающаяся с нуля, за которым следует x (0x), является
  шестнадцатеричным числом (с основанием 16), а константа, которая
  начинающаяся с нуля, за которым следует цифра, является восьмеричным
  числом (с основанием 8). Приведем примеры восьмеричных констант:</p>
<pre>
          0        02        077        0123
</pre>
<p>Их десятичные эквиваленты равны соответственно: 0, 2, 63, 83.<br>
  В шестнадцатеричной записи эти константы выглядят так:</p>
<pre>
          0x0      0x2       0x3f       0x53
</pre>
<p>Буквы a,  b, c, d, e и f или эквивалентные им заглавные буквы
  используются для представления чисел 10, 11, 12, 13, 14 и 15,
  соответственно. Восьмеричная  и шестнадцатеричная формы записи наиболее
  подходят для задания набора разрядов, а
  использование их для обычных чисел может дать неожиданный эффект.
  Например, на машине, в которой int представляется как 16-разрядное
  число в дополнительном коде, 0xffff есть отрицательное десятичное
  число -1. Если бы для представления целого использовалось большее число
  разрядов, то это было бы числом 65535.</p>
<p>Окончание U может использоваться для явного задания констант типа
  unsigned. Аналогично, окончание L явно задает константу типа long.
  Например:</p>
<pre>
            void f(int);
            void f(unsigned int);
            void f(long int);

            void g()
            {
              f(3);      // вызов f(int)
              f(3U);     // вызов f(unsigned int)
              f(3L);     // вызов f(long int)
            }
</pre>

<a name="#float"></a><h5>2.4.2 Константы с плавающей точкой</h5>
<p>Константы с плавающей точкой имеют тип double. Транслятор должен
   предупреждать о таких константах, значение которых не укладывается в
   формат, выбранный для представления чисел с плавающей точкой. Приведем
   примеры констант с плавающей точкой:</p>
<pre>
           1.23    .23      0.23     1.    1.0     1.2e10    1.23e-15
</pre>
<p>Отметим, что внутри константы с плавающей точкой не должно быть пробелов.
  Например, 65.43  e-21 не является константой с плавающей точкой, транслятор
  распознает это как четыре отдельные лексемы:</p>
<pre>
            65.43    e    -    21
</pre>
<p>что вызовет синтаксическую ошибку.
  Если нужна константа с плавающей точкой типа float, то ее можно получить,
  используя окончание f:</p>
<pre>
            3.14159265f     2.0f     2.997925f
</pre>

<a name="#simblconst"></a><h5>2.4.3 Символьные константы</h5>
<p>Символьной константой является символ, заключенный в одиночные кавычки,
  например, 'a' или '0'. Символьные константы можно считать константами,
  которые дают имена целым значениям символов из набора, принятого на
  машине, на которой выполняется программа.
  Это необязательно тот же набор символов, который есть на машине,
  где программа транслировалась. Таким образом, если вы запускаете
  программу на машине, использующей набор символов
  ASCII, то значение '0' равно 48, а если машина использует код EBCDIC,
  то оно будет равно 240. Использование символьных констант вместо их
  десятичного целого эквивалента повышает переносимость программ.
  Некоторые специальные комбинации символов, начинающиеся с обратной
  дробной черты, имеют стандартные названия:</p>
<pre>
        Конец строки                NL(LF)    \n
        Горизонтальная табуляция    HT        \t
        Вертикальная табуляция      VT        \v
        Возврат                     BS        \b
        Возврат каретки             CR        \r
        Перевод формата             FF        \f
        Сигнал                      BEL       \a
        Обратная дробная черта      \         \\
        Знак вопроса                ?         \?
        Одиночная кавычка           '         \'
        Двойная кавычка             "         \"
        Нулевой символ              NUL       \0
        Восьмеричное число          ooo       \ooo
        Шестнадцатеричное число     hhh       \xhhh
</pre>
<p>Несмотря на их вид, все эти комбинации задают один символ. Тип
  символьной константы - char. Можно также задавать символ с помощью
  восьмеричного числа,  представленного одной, двумя или тремя
  восьмеричными цифрами (перед цифрами идет \) или с помощью
  шестнадцатеричного числа
  (перед шестнадцатеричными цифрами идет \x). Число шестнадцатеричных
  цифр в такой последовательности неограничено. Последовательность
  восьмеричных или шестнадцатеричных цифр завершается первым символом,
  не являющимся такой цифрой. Приведем примеры:</p>
<pre>
      '\6'      '\x6'        6        ASCII ack
      '\60'     '\x30'       48       ASCII '0'
      '\137'    '\x05f'      95       ASCII '_'
</pre>
<p>Этим способом можно представить любой символ из набора символов
  машины. В частности, задаваемые таким образом символы можно
  включать в символьные строки (см. следующий раздел). Заметим, что
  если для символов
  используется числовая форма задания, то нарушается переносимость
  программы между машинами с различными наборами символов.</p>

<a name="#string"></a><h5>2.4.4 Строки</h5>
<p>Строка - это последовательность символов, заключенная в двойные кавычки:</p>
<pre>
          "это строка"
</pre>
<p>Каждая строка содержит на один символ больше, чем явно задано:
  все строки оканчиваются нулевым символом ('\0'), имеющим
  значение 0. Поэтому</p>
<pre>
         sizeof("asdf")==5;
</pre>
<p>Типом строки считается "массив из соответствующего числа символов",
  поэтому тип "asdf" есть char[5]. Пустая строка записывается как
  "" и имеет тип char[1]. Отметим, что для любой строки s выполняется
  strlen(s)==sizeof(s)-1, поскольку функция strlen() не учитывает
  завершающий символ '\0'.</p>
<p>Внутри строки можно использовать для представления невидимых
  символов специальные комбинации с \. В частности, в строке можно
  задать сам символ двойной кавычки " или символ \. Чаще всего из
  таких символов оказывается нужным символ конца строки '\n', например:</p>
<pre>
         cout << "звуковой сигнал в конце сообщения\007\n"
</pre>
<p>Здесь  7 - это значение в ASCII символа BEL (сигнал), который в
  переносимом виде обозначается как \a.
  Нет возможности задать в строке "настоящий" символ конца строки:</p>
<pre>
        "это не строка,
         а синтаксическая ошибка"
</pre>
<p>Для большей наглядности программы длинные строки можно разбивать
  пробелами, например:</p>
<pre>
         char alpha[] = "abcdefghijklmnopqrstuvwxyz"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
</pre>
<p>Подобные, подряд идущие, строки будут объединяться в одну, поэтому
  массив alpha можно эквивалентным образом инициализировать с помощью
  одной строки:</p>
<pre>
          "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
</pre>
<p>В строке можно задавать символ '\0', но большинство программ
  не ожидает после него встречи с какими-либо еще символами. Например,
  строку "asdf\000hjkl"  стандартные функции strcpy() и strlen()
  будут рассматривать как строку "asdf".</p>
<p>Если вы задаете в строке последовательностью восьмеричных цифр
  числовую константу, то разумно указать все три цифры. Запись
  этой строки и так не слишком проста, чтобы еще и раздумывать,
  относится ли цифра к числу или является отдельным символом.
  Для шестнадцатеричных констант используйте два разряда. Рассмотрим
  следующие примеры:</p>
<pre>
         char v1[] = "a\x0fah\0129";    // 'a' '\xfa' 'h' '\12' '9'
         char v2[] = "a\xfah\129";      // 'a' '\xfa' 'h' '\12' '9'
         char v3[] = "a\xfad\127";      // 'a' '\xfad' '\127'
</pre>

<a name="#zero"></a><h5>2.4.5 Нуль</h5>
<p>Нуль (0) имеет тип int. Благодаря стандартным преобразованиям (п.<a href="referenc.shtml#R.4">R.4</a>)
  0 можно использовать как константу целого типа, или типа с плавающей
  точкой, или типа указателя. Нельзя разместить никакой объект, если
  вместо адреса указан 0. Какой из типов нуля использовать, определяется
  контекстом. Обычно (но необязательно) нуль представляется
  последовательностью разрядов "все нули" подходящей длины.</p>

<a name="#nameconst"></a><h4>2.5 Поименованные константы</h4>
<p>Добавив к описанию объекта служебное слово const, можно превратить
  этот объект из переменной в константу, например:</p>
<pre>
         const int model = 90;
         const int v[] = { 1, 2, 3, 4 };
</pre>
<p>Поскольку константе нельзя ничего присвоить, она должна быть
  инициализирована. Описывая какой-либо объект как const, мы гарантируем,
  что его значение не изменяется в области видимости:</p>
<pre>
        model = 200;        // ошибка
        model++;            // ошибка
</pre>
<p>Отметим, что спецификация const скорее ограничивает возможности
  использования объекта, чем указывает, где следует размещать объект.
  Может быть вполне разумным и даже полезным описание функции с типом
  возвращаемого значения const:</p>
<pre>
   const char* peek(int i)    // вернуть указатель на строку-константу
  {
    return hidden[i];
  }
</pre>
<p>Приведенную функцию можно было бы использовать для передачи строки,
  защищенной от записи, в другую программу, где она будет читаться.
  Вообще говоря, транслятор может воспользоваться тем фактом, что объект
  является const, для различных целей (конечно, это зависит от
  "разумности" транслятора). Самое очевидное - это то, что для
  константы не нужно отводить память, поскольку ее значение известно
  транслятору. Далее, инициализатор для константы, как правило (но не
  всегда) является постоянным выражением, которое можно вычислить на
  этапе трансляции. Однако, для массива констант обычно приходится
  отводить память, поскольку в общем случае транслятор не знает,
  какой элемент массива используется в выражении. Но и в этом случае
  на многих машинах возможна оптимизация, если поместить такой массив
  в защищенную от записи память.</p>
<p>Задавая указатель, мы имеем дело с двумя объектами: с самим указателем
  и с указуемым объектом.  Если в описании указателя есть "префикс"
  const, то константой  объявляется сам объект, но не указатель на него,
  например:</p>
<pre>
         const char* pc = "asdf";    // указатель на константу
         pc[3] = 'a';                // ошибка
         pc = "ghjk";                // нормально
</pre>
<p>Чтобы описать как константу сам указатель, а не указуемый объект,
  нужно использовать операцию * перед const. Например:</p>
<pre>
        char *const cp = "asdf";    // указатель-константа
        cp[3] = 'a';                // нормально
        cp = "ghjk";                // ошибка
</pre>
<p>Чтобы сделать константами и указатель, и объект, надо оба объявить
  const, например:</p>
<pre>
       const char *const cpc = "asdf";  // указатель-константа на const
       cpc[3] = 'a';                    // ошибка
       cpc = "ghjk";                    // ошибка
</pre>
<p>Объект может быть объявлен константой при обращении к нему с помощью
  указателя, и в то же время быть изменяемым, если обращаться к
  нему другим способом. Особенно это удобно использовать для параметров
  функции. Описав параметр-указатель функции как const, мы запрещаем
  изменять в ней указуемый объект, например:</p>
<pre>
      char* strcpy(char* p, const char* q); // не может изменять *q
</pre>
<p>Указателю на константу можно присвоить адрес переменной, т.к. это
  не принесет вреда. Однако, адрес константы нельзя присваивать указателю
  без спецификации const, иначе станет возможным менять ее значение,
  например:</p>
<pre>
        int a = 1;
        const int c = 2;
        const int* p1 = &c;    // нормально
        const int* p2 = &a;    // нормально
        int* p3 = &c;          // ошибка
        *p3 = 7;               // меняет значение c
</pre>

<a name="#transfer"></a><h5>2.5.1 Перечисления</h5>
<p>Добавив к описанию объекта служебное слово const, можно превратить
  этот объект из переменной в константу, например:</p>
<pre>
         const int model = 90;
         const int v[] = { 1, 2, 3, 4 };
</pre>
<p>Поскольку константе нельзя ничего присвоить, она должна быть
  инициализирована. Описывая какой-либо объект как const, мы гарантируем,
  что его значение не изменяется в области видимости:</p>
<pre>
        model = 200;        // ошибка
        model++;            // ошибка
</pre>
<p>Отметим, что спецификация const скорее ограничивает возможности
  использования объекта, чем указывает, где следует размещать объект.
  Может быть вполне разумным и даже полезным описание функции с типом
  возвращаемого значения const:</p>
<pre>
   const char* peek(int i)    // вернуть указатель на строку-константу
  {
    return hidden[i];
  }
</pre>
<p>Приведенную функцию можно было бы использовать для передачи строки,
  защищенной от записи, в другую программу, где она будет читаться.
  Вообще говоря, транслятор может воспользоваться тем фактом, что объект
  является const, для различных целей (конечно, это зависит от
  "разумности" транслятора). Самое очевидное - это то, что для
  константы не нужно отводить память, поскольку ее значение известно
  транслятору. Далее, инициализатор для константы, как правило (но не
  всегда) является постоянным выражением, которое можно вычислить на
  этапе трансляции. Однако, для массива констант обычно приходится
  отводить память, поскольку в общем случае транслятор не знает,
  какой элемент массива используется в выражении. Но и в этом случае
  на многих машинах возможна оптимизация, если поместить такой массив
  в защищенную от записи память.</p>
<p>Задавая указатель, мы имеем дело с двумя объектами: с самим указателем
  и с указуемым объектом.  Если в описании указателя есть "префикс"
  const, то константой  объявляется сам объект, но не указатель на него,
  например:</p>
<pre>
         const char* pc = "asdf";    // указатель на константу
         pc[3] = 'a';                // ошибка
         pc = "ghjk";                // нормально
</pre>
<p>Чтобы описать как константу сам указатель, а не указуемый объект,
  нужно использовать операцию * перед const. Например:</p>
<pre>
        char *const cp = "asdf";    // указатель-константа
        cp[3] = 'a';                // нормально
        cp = "ghjk";                // ошибка
</pre>
<p>Чтобы сделать константами и указатель, и объект, надо оба объявить
  const, например:</p>
<pre>
       const char *const cpc = "asdf";  // указатель-константа на const
       cpc[3] = 'a';                    // ошибка
       cpc = "ghjk";                    // ошибка
</pre>
<p>Объект может быть объявлен константой при обращении к нему с помощью
  указателя, и в то же время быть изменяемым, если обращаться к
  нему другим способом. Особенно это удобно использовать для параметров
  функции. Описав параметр-указатель функции как const, мы запрещаем
  изменять в ней указуемый объект, например:</p>
<pre>
      char* strcpy(char* p, const char* q); // не может изменять *q
</pre>
<p>Указателю на константу можно присвоить адрес переменной, т.к. это
  не принесет вреда. Однако, адрес константы нельзя присваивать указателю
  без спецификации const, иначе станет возможным менять ее значение,
  например:</p>
<pre>
        int a = 1;
        const int c = 2;
        const int* p1 = &c;    // нормально
        const int* p2 = &a;    // нормально
        int* p3 = &c;          // ошибка
        *p3 = 7;               // меняет значение c
</pre>

<a name="#econmem"></a><h4>2.6 Экономия памяти</h4>
<p>В процессе создания нетривиальной программы рано или поздно наступает
  момент, когда требуется больше памяти, чем можно выделить или
  запросить. Есть два способа выжать еще некоторое количество памяти:</p>
<ol>
<li>паковать в байты переменные с малыми значениями;
<li>использовать одну и ту же память для хранения разных объектов в разное время.
</ol>
<p>Первый способ реализуется с помощью полей, а второй - с помощью
  объединений. И те, и другие описываются ниже. Поскольку назначение
  этих конструкций  связано  в основном с оптимизацией программы,  и
  поскольку, как правило,  они непереносимы,  программисту следует
  хорошенько подумать, прежде чем использовать их. Часто лучше изменить
  алгоритм работы с данными, например, больше использовать динамически
  выделяемую память, чем заранее отведенную статическую память.</p>

<a name="#field"></a><h5>2.6.1 Поля</h5>
<p>Кажется расточительным использовать для признака, принимающего
  только два значения ( например: да, нет) тип char, но объект типа
  char является в С++ наименьшим объектом, который может независимо
  размещаться в памяти. Однако, есть возможность собрать переменные
  с малым диапазоном значений воедино, определив их как поля структуры.
  Член структуры является полем, если в его определении после имени
  указано число разрядов, которое он должен занимать. Допустимы
  безымянные поля. Они не влияют на работу с поименованными полями,
  но могут улучшить размещение полей в памяти для конкретной машины:</p>
<pre>
         struct sreg {
                unsigned enable : 1;
                unsigned page : 3;
                unsigned : 1;        // не используется
                unsigned mode : 2;
                unsigned : 4;        // не используется
                unsigned access : 1;
                unsigned length : 1;
                unsigned non_resident : 1;
          };
</pre>
<p>Приведенная структура описывает разряды нулевого
  регистра состояния DEC PDP11/45 (предполагается, что поля в слове
  размещаются слева  направо).  Этот  пример  показывает   также   другое
  возможное применение полей: давать имена тем частям
  объекта, размещение которых определено извне. Поле должно иметь
  целый тип (п.<a href="referenc.shtml#R.3.6.1">R.3.6.1</a> и п.<a href="referenc.shtml#R.9.6">R.9.6</a>), и оно используется аналогично другим
  объектам целого типа. Но есть исключение: нельзя брать адрес поля.
  В ядре операционной системы или в отладчике тип sreg мог бы
  использоваться следующим образом:</p>
<pre>
              sreg* sr0 = (sreg*)0777572;
              //...
              if (sr0->access) {        // нарушение прав доступа
                  // разобраться в ситуации
                 sr0->access = 0;
              }
</pre>
<p>Тем не менее,
   применяя поля для упаковки нескольких переменных в один байт, мы
   необязательно сэкономим память. Экономится память для данных, но
   на большинстве машин одновременно возрастает объем команд,
   нужных для работы с упакованными данными.<br>
   Известны даже такие программы, которые значительно сокращались в объеме,
   если двоичные переменные, задаваемые полями, преобразовывались в
   переменные типа char! Кроме того, доступ к char или int обычно
   происходит намного быстрее, чем доступ к полю. Поля - это просто
   удобная краткая форма задания логических операций для извлечения
   или занесения информации в части слова.</p>

<a name="#assoc"></a><h5>2.6.2 Объединения</h5>
<p>Рассмотрим таблицу имен, в которой каждый элемент содержит имя и
   его значение. Значение может задаваться либо строкой, либо целым числом:</p>
<pre>
      struct entry {
         char* name;
         char  type;
         char* string_value;  // используется если type == 's'
         int   int_value;     // используется если type == 'i'
      };
      void print_entry(entry* p)
      {
        switch(p->type) {
        case 's':
             cout << p->string_value;
             break;
        case 'i':
             cout << p->int_value;
             break;
        default:
             cerr << "type corrupted\n";
             break;
        }
      }
</pre>
<p>Поскольку переменные
   string_value и int_value никогда не могут использоваться одновременно,
   очевидно, что часть памяти пропадает впустую. Это можно легко исправить,
   описав обе переменные как члены объединения, например, так:</p>
<pre>
       struct entry {
            char* name;
            char  type;
            union {
               char* string_value; // используется если type == 's'
               int   int_value;    // используется если type == 'i'
            };
       };
</pre>
<p>Теперь гарантируется, что при выделении памяти для entry члены
  string_value и int_value будут размещаться с одного адреса, и
  при этом не нужно менять все части программы, работающие с entry.
  Из этого следует, что все члены объединения вместе занимают такой же
  объем памяти, какой занимает наибольший член объединения.</p>
<p>Надежный способ работы с объединением заключается в том, чтобы
  выбирать значение с помощью того же самого члена, который его записывал.
  Однако, в больших программах трудно гарантировать, что объединение
  используется только таким способом, а в результате использования
  не того члена обЪединения могут возникать трудно обнаруживаемые ошибки.
  Но можно встроить объединение в такую структуру, которая обеспечит
  правильную связь между значением поля типа  и текущим типом члена
  объединения (п.<a href="chap5.shtml#structco">5.4.6</a>).</p>
<p>Иногда объединения используют для "псевдопреобразований" типа
  (в основном на это идут программисты, привыкшие к языкам, в которых
  нет средств преобразования типов, и в результате приходится обманывать
  транслятор). Приведем пример такого "преобразования"  int в int*
  на машине VAX, которое достигается простым совпадением разрядов:</p>
<pre>
           struct fudge {
                union {
                  int  i;
                  int* p;
                };
           };

           fudge a;
           a.i = 4095;
           int* p = a.p;    // некорректное использование
</pre>
<p>В действительности это вовсе не преобразование типа, т.к. на одних
  машинах int и int* занимают разный объем памяти, а на других целое
  не может размещаться по адресу, задаваемому нечетным числом. Такое
  использование объединений не является переносимым, тогда как
  существует переносимый способ задания явного преобразования
  типа (п.<a href="chap3.shtml#typetrans">3.2.5</a>).</p>
<p>Иногда объединения используют специально, чтобы избежать
  преобразования типов. Например, можно использовать fudge, чтобы
  узнать, как представляется указатель 0:</p>
<pre>
           fudge.p = 0;
           int i = fudge.i;    // i необязательно должно быть 0
</pre>
<p>Объединению можно дать имя, то есть можно сделать его
  полноправным типом. Например, fudge можно описать так:</p>
<pre>
           union fudge {
                 int  i;
                 int* p;
           };
</pre>
<p>и использовать (некорректно) точно так же, как и раньше. Вместе с тем,
  поименованные объединения можно использовать и вполне корректным
  и оправданным способом (см. п.<a href="chap5.shtml#structco">5.4.6</a>).</p>

<a name="#exercise"></a><h4>2.7 Упражнения</h4>
<ol>
<li>(*1) Запустить программу  "Hello, world" (см. п.<a href="chap1.shtml#standout">1.3.1</a>).
<li>(*1) Для каждого описания из п.<a href="chap2.shtml#descr">2.1</a> 
     сделать следующее: если описание
     не является определением, то написать соответствующее определение;
     если же описание является определением, написать для него описание,
     которое не являлось бы одновременно и определением.
<li>(*1) Напишите описания следующих объектов: указателя на символ;
     массива из 10 целых; ссылки на массив из 10 целых; указателя
     на массив символьных строк; указателя на указатель на символ;
     целого-константы; указателя на целое-константу; константного
     указателя на целое. Описания снабдить инициализацией.
<li>(*1.5) Напишите программу, которая печатает размеры основных типов
     и типа указателя. Используйте операцию sizeof.
<li>(*1.5) Напишите программу, которая печатает буквы от 'a' до 'z' и цифры
     от '0' до '9' и их целые значения. Проделайте то же самое для других
     видимых символов. Проделайте это, используя шестнадцатеричную
     запись.
<li>(*1) Напечатайте последовательность разрядов представления указателя
     0 на вашей машине. Подсказка: см. п.<a href="chap2.shtml#assoc">2.6.2</a>.
<li>(*1.5) Напишите функцию, печатающую порядок и мантиссу параметра типа
     double.
<li>(*2) Каковы на используемой вами машине наибольшие и наименьшие
     значения следующих типов: char, short,int,long, float, double,
     long double, unsigned, char*, int* и void*? Есть ли какие-то
     особые ограничения на эти значения? Например, может ли int* быть
     нечетным целым? Как выравниваются в памяти объекты этих типов?
     Например, может ли целое иметь нечетный адрес?
<li>(*1) Какова максимальная длина локального имени, которое
     можно использовать в вашей реализации С++ ? Какова максимальная
     длина внешнего имени? Есть ли какие-нибудь ограничения на символы,
     которые можно использовать в имени?
<li>(*1) Напишите функцию, которая меняет местами значения двух целых.
     В качестве типа параметров используйте int*. Напишите другую функцию
     с тем же назначением, используя в качестве типа параметров int&.
<li>(*1)  Каков размер массива str в следующем примере:
        char str[] = "a short string";
     Какова длина строки "a short string"?
<li>(*1.5) Составьте таблицу из названий месяцев года и числа дней
     в каждом из них. Напишите программу, печатающую ее. Проделайте
     это дважды: один раз - используя массивы для названий месяцев
     и количества дней, а другой раз - используя массив структур,
     каждая из которых содержит название месяца и количество дней в нем.
<li>(*1) С помощью typedef определите типы: unsigned char, константный
     unsigned char, указатель на целое, указатель на указатель на
     символ, указатель на массив символов, массив из 7 указателей
     на целое, указатель на массив из 7 указателей на целое и массив из
     8 массивов из 7 указателей на целое.
<li>(*1) Определить функции f(char), g(char&) и h(const char&) и
     вызвать их, используя в качестве параметров 'a', 49, 3300, c, uc, и
     sc, где c - char, uc - unsigned char и sc - signed char. Какой
     вызов является законным? При каком вызове транслятору придется
     завести временную переменную?
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap3.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>