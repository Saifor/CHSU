<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 1<br> 
Краткий обзор С++</h3>

<p align="right"><i>"Начнем с того, что вздернем<br>
  всех этих законников, языковедов".<br>
  ("Король Генрих VI", действие II)</i></p>
<p>В этой главе содержится краткий обзор основных концепций и конструкций
  языка С++. Он служит для беглого знакомства с языком. Подробное описание
  возможностей языка и методов программирования на нем дается в следующих
  главах. Разговор ведется в основном вокруг абстракции данных и
  объектно-ориентированного программирования, но перечисляются и основные
  возможности процедурного программирования.</p>

<h4><a name="#introduct"></a>1.1 Введение</h4>
  Язык программирования С++ задумывался как язык, который будет: 
<ul>
<li>лучше языка С;
<li>поддерживать абстракцию данных;
<li> поддерживать объектно-ориентированное программирование.
</ul>
<p>В этой главе объясняется смысл этих фраз без подробного описания
  конструкций языка.</p>
<p><a href="#paradigm">п.1.2</a> содержит неформальное описание различий "процедурного",
  "модульного" и "объектно-ориентированного" программирования.  Приведены
  конструкции языка, которые существенны для каждого из перечисленных стилей
  программирования. Свойственный С стиль программирования обсуждается в
  разделах "процедурное программирование и "модульное программирование".
  Язык С++ - "лучший вариант С". Он лучше поддерживает такой стиль
  программирования, чем сам С, причем это делается без потери какой-либо
  общности или эффективности по сравнению с С.  В то же время язык C
  является подмножеством С++. Абстракция данных и объектно-ориентированное
  программирование рассматриваются как "поддержка абстракции данных" и
  "поддержка объектно- ориентированного программирования". Первая базируется
  на возможности определять новые типы и работать с ними, а вторая - на
  возможности задавать иерархию типов.</p>
<p><a href="#impovec">п.1.3</a> содержит описание основных конструкций для процедурного и
  модульного программирования. В частности, определяются функции, указатели,
  циклы, ввод-вывод и понятие программы как совокупности раздельно
  транслируемых модулей. Подробно эти возможности описаны в главах 
  <a href="chap2.shtml">2</a>, <a href="chap3.shtml">3</a> и 
  <a href="chap4.shtml">4</a>.</p>
<p><a href="#support">п.1.4</a> содержит описание средств, предназначенных для эффективной
  реализации абстракции данных. В частности, определяются классы, простейший
  механизм контроля доступа, конструкторы и деструкторы, перегрузка
  операций, преобразования пользовательских типов, обработка особых ситуаций
  и шаблоны типов. Подробно эти возможности описаны в главах 
  <a href="chap5.shtml">5</a>, <a href="chap7.shtml">7</a>, 
  <a href="chap8.shtml">8</a> и <a href="chap9.shtml">9</a>.</p>
<p><a href="#ooprog">п.1.5</a> содержит описание средств поддержки объектно-ориентированного
  программирования. В частности, определяются производные классы и
  виртуальные функции, обсуждаются некоторые вопросы реализации.  Все это
  подробно изложено в главе <a href="chap6.shtml">6.</p>
<p><a href="#limitperf">п.1.6</a> содержит описание определенных ограничений на пути
  совершенствования как языков программирования общего назначения вообще,
  так и С++ в частности. Эти ограничения связаны с эффективностью, с
  противоречащими друг другу требованиями разных областей приложения,
  проблемами обучения и необходимостью трансляции и выполнения программ в
  старых системах.</p>
<p>Если какой-то раздел окажется для вас непонятным, настоятельно
  советуем прочитать соответствующие главы, а затем, ознакомившись с
  подробным описанием основных конструкций языка, вернуться к этой главе.
  Она нужна для того, чтобы можно было составить общее представление о
  языке. В ней недостаточно сведений, чтобы немедленно начать
  программировать.</p>
<a name="#paradigm"></a><h4>1.2 Парадигмы программирования</h4>
  Объектно-ориентированное программирование - это метод
  программирования, способ написания "хороших" программ для множества задач.
  Если этот термин имеет какой-то смысл, то он должен подразумевать: такой
  язык программирования, который предоставляет хорошие возможности для
  объектно-ориентированного стиля программирования.
<p>Здесь следует указать на важные различия. Говорят, что язык
  поддерживает некоторый стиль программирования, если в нем есть такие
  возможности, которые делают программирование в этом стиле удобным
  (достаточно простым, надежным и эффективным). Язык не поддерживает
  некоторый стиль программирования, если требуются большие усилия или даже
  искусство, чтобы написать программу в этом стиле. Однако это не означает,
  что язык запрещает писать программы в этом стиле. Действительно, можно
  писать структурные программы на Фортране и объектно-ориентированные
  программы на С, но это будет пустой тратой сил, поскольку данные языки не
  поддерживают указанных стилей программирования.</p>
<p>Поддержка языком определенной парадигмы (стиля) программирования явно
  проявляется в конкретных языковых конструкциях, рассчитанных на нее.  Но
  она может проявляться в более тонкой, скрытой форме, когда отклонение от
  парадигмы диагностируется на стадии трансляции или выполнения программы.
  Самый очевидный пример - это контроль типов.  Кроме того, языковая
  поддержка парадигмы может дополняться проверкой на однозначность и
  динамическим контролем. Поддержка может предоставляться и помимо самого
  языка, например, стандартными библиотеками или средой программирования.</p>
<p>Нельзя сказать, что один язык лучше другого только потому, что в нем
  есть возможности, которые в другом отсутствуют. Часто бывает как раз
  наоборот. Здесь более важно не то, какими возможностями обладает язык, а
  то, насколько имеющиеся в нем возможности поддерживают избранный стиль
  программирования для определенного круга задач. Поэтому можно
  сформулировать следующие требования к языку:</p>
<ol>
<li>Все конструкции языка должны естественно и элегантно определяться в нем.
<li>Для решения определенной задачи должна быть возможность использовать 
  сочетания конструкций, чтобы избежать необходимости вводить для этой цели 
  новую конструкцию.
<li>Должно быть минимальное число неочевидных конструкций специального 
  назначения.
<li>Конструкция должна допускать такую реализацию, чтобы в неиспользующей  
  ее программе не возникло дополнительных расходов.
<li>Пользователю достаточно знать только то множество конструкций, которое 
  непосредственно используется в его программе.
</ol>
<p>Первое требование апеллирует к логике и эстетическому вкусу. Два
  следующих выражают принцип минимальности. Два последних можно иначе
  сформулировать так: "то, чего вы не знаете, не сможет нанести вам вреда".<p>
<p>С учетом ограничений, указанных в этих правилах, язык С++
  проектировался для поддержки абстракции данных и объектно-ориентированного
  программирования в добавление к традиционному стилю С. Впрочем, это не
  значит, что язык требует какого-то одного стиля программирования от всех
  пользователей.</p>
<p>Теперь перейдем к конкретным стилям программирования и посмотрим
  каковы основные конструкции языка, их поддерживающие. Мы не собираемся
  давать полное описание этих конструкций.</p>
<a name="#procprog"></a><h5>1.2.1 Процедурное программирование</h5>
  Первоначальной (и, возможно, наиболее используемой) парадигмой
  программирования было:
<p>Определите, какие процедуры вам нужны; используйте лучшие из известных
  вам алгоритмов!
<p>Ударение делалось на обработку данных с помощью алгоритма,
  производящего нужные вычисления. Для поддержки этой парадигмы языки
  предоставляли механизм передачи параметров и получения результатов
  функций. Литература, отражающая такой подход, заполнена рассуждениями о
  способах передачи параметров, о том, как различать параметры разных типов,
  о различных видах функций (процедуры, подпрограммы, макрокоманды, ...) и
  т.д. Первым процедурным языком был Фортран, а Алгол60, Алгол68, Паскаль и
  С продолжили это направление.</p>
<p>Типичным примером хорошего стиля в таком понимании может служить
  функция извлечения квадратного корня. Для заданного параметра она выдает
  результат, который получается с помощью понятных математических операций:</p>
<pre>
      double sqrt ( double arg )
      {
      // программа для вычисления квадратного корня
      }

      voide some_function ()
      {
        double root = sqrt ( 2 );
        // ..
      }
</pre>
<p>Двойная наклонная черта // начинает комментарий, который продолжается
  до конца строки.</p>
<p>При такой организации программы функции вносят определенный порядок в
  хаос различных алгоритмов.</p>
<a name="#modulprog"></a><h5>1.2.2 Модульное программирование</h5>
  Со временем при в проектировании программ акцент сместился с
  организации процедур на организацию структур данных. Помимо всего прочего
  это вызвано и ростом размеров программ. Модулем обычно называют
  совокупность связанных процедур и тех данных, которыми они управляют.
  Парадигма программирования приобрела вид:
<p>Со временем при в проектировании программ акцент сместился с
  организации процедур на организацию структур данных. Помимо всего прочего
  это вызвано и ростом размеров программ. Модулем обычно называют
  совокупность связанных процедур и тех данных, которыми они управляют.
  Парадигма программирования приобрела вид:</p>
<p>Определите, какие модули нужны; поделите программу так, чтобы данные
  были скрыты в этих модулях</p>
<p>Эта парадигма известна также как "принцип сокрытия данных". Если в
  языке нет возможности сгруппировать связанные процедуры вместе с данными,
  то он плохо поддерживает модульный стиль программирования. Теперь метод
  написания "хороших" процедур применяется для отдельных процедур модуля.
  Типичный пример модуля - определение стека. Здесь необходимо решить такие
  задачи:</p>
<ol>
<li>Предоставить пользователю интерфейс для стека (например, функции
  push () и pop ()).
<li>Гарантировать, что представление стека (например, в виде массива
  элементов) будет доступно лишь через интерфейс пользователя.
<li>Обеспечивать инициализацию стека перед первым его использованием.
</ol>
<p>Язык Модула-2 прямо поддерживает эту парадигму, тогда как С только
  допускает такой стиль. Ниже представлен на С возможный внешний интерфейс
  модуля, реализующего стек:</p>
<pre>
      // описание интерфейса для  модуля,
      // реализующего стек символов:

       void push ( char );
       char pop ();
       const int stack_size = 100;
</pre>
<p>Допустим, что описание интерфейса находится в файле stack.h, тогда
  реализацию стека можно определить следующим образом:</p>
<pre>
        #include "stack.h"            // используем интерфейс стека

        static char v [ stack_size ]; // ``static'' означает локальный
                                      // в данном файле/модуле
        static char * p = v;           // стек вначале пуст

        void push ( char c )
        {
        //проверить на переполнение и поместить в стек
        }

        char pop ()
        {
        //проверить, не пуст ли стек, и считать из него
        }
</pre>
<p>Вполне возможно, что реализация стека может измениться, например, если
  были скрыты в этих модулях</p>
<p>Эта парадигма известна также как "принцип сокрытия данных". Если в
  языке нет возможности сгруппировать связанные процедуры вместе с данными,
  то он плохо поддерживает модульный стиль программирования. Теперь метод
  написания "хороших" процедур применяется для отдельных процедур модуля.
  Типичный пример модуля - определение стека. Здесь необходимо решить такие
  задачи:</p>
<ol>
<li>Предоставить пользователю интерфейс для стека (например, функции
  push () и pop ()).
<li>Гарантировать, что представление стека (например, в виде массива
  элементов) будет доступно лишь через интерфейс пользователя.
<li>Обеспечивать инициализацию стека перед первым его использованием.
</ol>
<p>Язык Модула-2 прямо поддерживает эту парадигму, тогда как С только
  допускает такой стиль. Ниже представлен на С возможный внешний интерфейс
  модуля, реализующего стек:</p>
<pre>
      // описание интерфейса для  модуля,
      // реализующего стек символов:

       void push ( char );
       char pop ();
       const int stack_size = 100;
</pre>
<p>Допустим, что описание интерфейса находится в файле stack.h, тогда
  реализацию стека можно определить следующим образом:</p>
<pre>
        #include "stack.h"            // используем интерфейс стека

        static char v [ stack_size ]; // ``static'' означает локальный
                                      // в данном файле/модуле
        static char * p = v;           // стек вначале пуст

        void push ( char c )
        {
        //проверить на переполнение и поместить в стек
        }

        char pop ()
        {
        //проверить, не пуст ли стек, и считать из него
        }
</pre>
<p>Вполне возможно, что реализация стека может измениться, например, если
  использовать для хранения связанный список. Пользователь в любом случае не
  имеет непосредственного доступа к реализации: v и p - статические
  переменные, т.е. переменные локальные в том модуле (файле), в котором они
  описаны. Использовать стек можно так:</p>
<pre>
        #include "stack.h"       // используем интерфейс стека

        void some_function ()
        {
          push ( 'c' );
          char c = pop ();
          if ( c != 'c' )  error ( "невозможно" );
        }
</pre>
<p>Поскольку данные есть единственная вещь, которую хотят скрывать,
  понятие упрятывания данных тривиально расширяется до понятия упрятывания
  информации, т.е. имен переменных, констант, функций и типов, которые тоже
  могут быть локальными в модуле. Хотя С++ и не предназначался специально
  для поддержки модульного программирования, классы поддерживают концепцию
  модульности (п.<a href="chap5.shtml#enclose">5.4.3</a> и п.
  <a href="chap5.shtml#static">5.4.4</a>).  Помимо этого С++, естественно, имеет уже
  продемонстрированные возможности модульности, которые есть в С, т.е.
  представление модуля как отдельной единицы трансляции.</p>

<a name="#abstrdata"></a><h5>1.2.3 Абстракция данных</h5>
<p>Модульное программирование предполагает группировку всех данных одного
  типа вокруг одного модуля, управляющего этим типом. Если потребуются стеки
  двух разных видов, можно определить управляющий ими модуль с таким
  интерфейсом:</p>
<pre>

    class stack_id { /* ... */ };        // stack_id только тип
                                         // никакой информации о стеках
                                         // здесь не содержится
    stack_id create_stack ( int size );  // создать стек и возвратить
                                         // его идентификатор
    void push ( stack_id, char );
    char pop ( stack_id );
    destroy_stack ( stack_id );          // уничтожение стека
</pre>
<p>Конечно такое решение намного лучше, чем хаос, свойственный
  традиционным, неструктурированным решениям, но моделируемые таким способом
  типы совершенно очевидно отличаются от "настоящих", встроенных. Каждый
  управляющий типом модуль должен определять свой собственный алгоритм
  создания "переменных" этого типа. Не существует универсальных правил
  присваивания идентификаторов, обозначающих объекты такого типа. У
  "переменных" таких типов не существует имен, которые были бы известны
  транслятору или другим системным программам, и эти "переменные" не
  подчиняются обычным правилам областей видимости и передачи параметров.</p>
<p>Тип, реализуемый управляющим им модулем, по многим важным аспектам
  существенно отличается от встроенных типов. Такие типы не получают той
  поддержки со стороны транслятора (разного вида контроль), которая
  обеспечивается для встроенных типов.  Проблема здесь в том, что программа
  формулируется в терминах небольших (одно-два слова) дескрипторов объектов,
  а не в терминах самих объектов ( stack_id может служить примером такого
  дескриптора). Это означает, что транслятор не сможет отловить глупые,
  очевидные ошибки, вроде тех, что допущены в приведенной ниже функции:</p>
<pre>
          void f ()
          {
            stack_id s1;
            stack_id s2;

            s1 = create_stack ( 200 );
            // ошибка: забыли создать s2

            push ( s1,'a' );
            char c1 = pop ( s1 );  

            destroy_stack ( s2 ); // неприятная ошибка

            // ошибка: забыли уничтожить s1

            s1 = s2;  // это присваивание является по сути
                      // присваиванием указателей,
                      // но здесь s2 используется после уничтожения
          }
</pre>
<p>Иными словами, концепция модульности, поддерживающая парадигму
  упрятывания данных, не запрещает такой стиль программирования, но и не
  способствует ему.</p>
<p>В языках Ада, Clu, С++ и подобных им эта трудность преодолевается
  благодаря тому, что пользователю разрешается определять свои типы, которые
  трактуются в языке практически так же, как встроенные.  Такие типы обычно
  называют абстрактными типами данных, хотя лучше, пожалуй, их называть
  просто пользовательскими. Более строгим определением абстрактных типов
  данных было бы их математическое определение. Если бы удалось его дать,
  то, что мы называем в программировании типами, было бы конкретным
  представлением действительно абстрактных сущностей. Как определить "более
  абстрактные" типы, показано в п.<a href="chap4.shtml#func">4.6</a>. Парадигму же программирования можно
  выразить теперь так:</p>
<p>Определите, какие типы вам нужны; предоставьте полный набор операций
  для каждого типа.</p>
<p>Если нет необходимости в разных объектах одного типа, то стиль
  программирования, суть которого сводится к упрятыванию данных, и
  следование которому обеспечивается с помощью концепции модульности, вполне
  адекватен этой парадигме.</p>
<p>Арифметические типы, подобные типам рациональных и комплексных чисел,
  являются типичными примерами пользовательских типов:</p>
<pre>
       class complex 
       {
           double re, im;
       public:
           complex(double r, double i) { re=r; im=i; }
           complex(double r)  // преобразование float->complex
               { re=r; im=0; }
           friend complex operator+(complex, complex);
           friend complex operator-(complex, complex); // вычитание
           friend complex operator-(complex)           // унарный минус
           friend complex operator*(complex, complex);
           friend complex operator/(complex, complex);
           // ...
       };

</pre>
<p>Описание класса (т.е. определяемого пользователем типа) complex задает
  представление комплексного числа и набор операций с комплексными числами.
  Представление является частным (private): re и im доступны только для
  функций, указанных в описании класса complex. Подобные функции могут быть
  определены так:</p>
<pre>
          complex operator + ( complex a1, complex a2 )
          {
            return complex ( a1.re + a2.re, a1.im + a2.im );
          }

      и использоваться следующим образом:

           void f ()
           {
             complex a = 2.3;
             complex b = 1 / a;
             complex c = a + b * complex ( 1, 2.3 );
              // ...
             c = - ( a / b ) + 2;
           }
</pre>
<p>Большинство модулей (хотя и не все) лучше определять как
  пользовательские типы.</p>

<a name="#limitabstr"></a><h5>1.2.4 Пределы абстракции данных</h5>
<p>Абстрактный тип данных определяется как некий "черный ящик". После
  своего определения он по сути никак не взаимодействует с программой. Его
  никак нельзя приспособить для новых целей, не меняя определения. В этом
  смысле это негибкое решение. Пусть, например, нужно определить для
  графической системы тип shape (фигура).  Пока считаем, что в системе могут
  быть такие фигуры: окружность (circle), треугольник (triangle) и квадрат
  (square). Пусть уже есть определения точки и цвета:</p>
<pre>
          class point { /* ... */ };
          class color { /* ... */ };
</pre>
<p>Тип shape можно определить следующим образом:</p>
<pre>
          enum kind { circle, triangle, square };

          class shape 
          {
             point center;
             color col;
             kind k;
             // представление фигуры
          public:
             point where () { return center; }
             void move ( point to )  { center = to; draw (); }
             void draw ();
             void rotate ( int );
             // еще некоторые операции
          };
</pre>
<p>"Поле типа" k необходимо для того, чтобы такие операции, как draw () и
  rotate (), могли определять, с какой фигурой они имеют дело (в языках
  вроде Паскаля можно использовать для этого запись с вариантами, в которой
  k является полем-дескриминантом). Функцию draw () можно определить так:</p>
<pre>
           void shape :: draw ()
           {

             switch ( k )  
             {
             case circle:
                 // рисование окружности
                 break;
             case triangle:      
</pre>
<p>Это не функция, а кошмар. В ней нужно учесть все возможные фигуры,
  какие только есть. Поэтому она дополняется новыми операторами, как только
  в системе появляется новая фигура. Плохо то, что после определения новой
  фигуры нужно проверить и, возможно, изменить все старые операции класса.
  Поэтому, если вам недоступен исходный текст каждой операции класса, ввести
  новую фигуру в систему просто невозможно. Появление любой новой фигуры
  приводит к манипуляциям с текстом каждой существенной операции класса.
  Требуется достаточно высокая квалификация, чтобы справиться с этой
  задачей, но все равно могут появиться ошибки в уже отлаженных частях
  программы, работающих со старыми фигурами. Возможность выбора
  представления для конкретной фигуры сильно сужается, если требовать, чтобы
  все ее представления укладывались в уже заданный формат, специфицированный
  общим определением фигуры (т.е. определением типа shape).</p>

<a name="#objprog"></a><h5>1.2.5 Объектно-ориентированное программирование</h5>
<p>Проблема состоит в том, что мы не различаем общие свойства фигур
  (например, фигура имеет цвет, ее можно нарисовать и т.д.) и свойства
  конкретной фигуры (например, окружность - это такая фигура, которая имеет
  радиус, она изображается с помощью функции, рисующей дуги и т.д.). Суть
  объектно-ориентированного программирования в том, что оно позволяет
  выражать эти различия и использует их. Язык, который имеет конструкции для
  выражения и использования подобных различий, поддерживает
  объектно-ориентированное программирование. Все другие языки не
  поддерживают его.  Здесь основную роль играет механизм наследования,
  заимствованный из языка Симула. Вначале определим класс, задающий общие,
  свойства всех фигур:<p>
<pre>
      class shape 
      { 
        point center; 
        color col; 
        // ...  
        public: 
        point where () { return center; } 
        void move ( point to ) { center = to; draw(); } 
        virtual void draw (); 
        virtual void rotate ( int ); 
        // ...  
      };
</pre>
<p>Те функции, для которых можно определить заявленный интерфейс, но
  реализация которых (т.е. тело с операторной частью) возможна только для
  конкретных фигур, отмечены служебным словом virtual (виртуальные). В
  Симуле и С++ виртуальность функции означает: "функция может быть
  определена позднее в классе, производном от данного". С учетом такого
  определения класса можно написать общие функции, работающие с фигурами:</p>
<pre>
            void rotate_all ( shape v [], int size, int angle )
            // повернуть все элементы массива "v" размера "size"
            // на угол равный "angle"
            {
              int i = 0;
              while ( i&lt;size ) 
              {
                v [ i ] . rotate ( angle );
                i = i + 1;
              }
            }
</pre>
<p>Для определения конкретной фигуры следует указать, прежде всего, что
  это - именно фигура и задать ее особые свойства (включая и виртуальные
  функции):</p>
<pre>
            class circle : public shape 
            {
                int radius;
            public:
                void draw () { /* ... */ };
                void rotate ( int ) {}  // да, пока пустая функция
            };
</pre>
<p>В языке С++ класс circle называется производным по отношению к классу
  shape, а класс shape называется базовым для класса circle.  Возможна
  другая терминология, использующая названия "подкласс" и "суперкласс" для
  классов circle и shape соответственно.  Теперь парадигма программирования
  формулируется так:</p>
<p>Определите, какой класс вам необходим; предоставьте полный набор
  операций для каждого класса; общность классов выразите явно с помощью
  наследования.</p>
<p>Если общность между классами отсутствует, вполне достаточно абстракции
  данных. Насколько применимо объектно-ориентированное программирование для
  данной области приложения определяется степенью общности между разными
  типами, которая позволяет использовать наследование и виртуальные функции.
  В некоторых областях, таких, например, как интерактивная графика, есть
  широкий простор для объектно-ориентированного программирования. В других
  областях, в которых используются традиционные арифметические типы и
  вычисления над ними, трудно найти применение для более развитых стилей
  программирования, чем абстракция данных. Здесь средства, поддерживающие
  объектно-ориентированное программирование, очевидно, избыточны.</p>
<p>Нахождение общности среди отдельных типов системы представляет собой
  нетривиальный процесс. Степень такой общности зависит от способа
  проектирования системы. В процессе проектирования выявление общности
  классов должно быть постоянной целью. Она достигается двумя способами:
  либо проектированием специальных классов, используемых как "кирпичи" при
  построении других, либо поиском похожих классов для выделения их общей
  части в один базовый класс.</p>
<p>С попытками объяснить, что такое объектно-ориентированное
  программирование, не используя конкретных конструкций языков
  программирования, можно познакомиться в работах [<a href="chap0.shtml#book2">2</a>] 
  и [<a href="chap0.shtml#book6">6</a>], приведенных в
  списке литературы в главе <a href="chap11.shtml">11</a>.</p>
<p>Итак, мы указали, какую минимальную поддержку должен обеспечивать язык
  программирования для процедурного программирования, для упрятывания
  данных, абстракции данных и объектно-ориентированного программирования.
  Теперь несколько подробнее опишем средства языка, хотя и не самые
  существенные, но позволяющие более эффективно реализовать абстракцию
  данных и объектно-ориентированное программирование.</p>

<a name="#impovec"></a><h4>1.3 "Улучшенный С"</h4>
<p>Минимальная поддержка процедурного программирования включает функции,
  арифметические операции, выбирающие операторы и циклы. Помимо этого должны
  быть предоставлены операции ввода- вывода.  Базовые языковые средства С++
  унаследовал от С (включая указатели), а операции ввода-вывода
  предоставляются библиотекой. Самая зачаточная концепция модульности
  реализуется с помощью механизма раздельной трансляции.</p>

<a name="#standout"></a><h5>1.3.1 Программа и стандартный вывод</h5>
  Самая маленькая программа на С++ выглядит так:
<pre>
      main () { }
</pre>
<p>В этой программе определяется функция, называемая main, которая не
  имеет параметров и ничего не делает. Фигурные скобки { и } используются в
  С++ для группирования операторов. В данном случае они обозначают начало и
  конец тела (пустого) функции main. В каждой программе на С++ должна быть
  своя функция main(), и программа начинается с выполнения этой функции.</p>
   <p>Обычно программа выдает какие-то результаты. Вот программа, которая
  выдает приветствие Hello, World! (Всем привет!):</p>
<pre>
           #include <iostream.h>

           int main ()
           {
              cout << "Hello, World!\n";
           }
</pre>
<p>Строка #include <iostream.h> сообщает транслятору, что надо включить в
  программу описания, необходимые для работы стандартных потоков ввода-
  вывода, которые находятся в iostream.h. Без этих описаний выражение</p>
<pre>
      cout << "Hello, World!\n"
</pre>
<p>не имело бы смысла. Операция << ("выдать") записывает свой второй
  параметр в первый параметр. В данном случае строка "Hello, World!\n"
  записывается в стандартный выходной поток cout. Строка - это
  последовательность символов, заключенная в двойные кавычки. Два символа:
  обратной дробной черты \ и непосредственно следующий за ним - обозначают
  некоторый специальный символ. В данном случае \n является символом конца
  строки (или перевода строки), поэтому он выдается после символов Hello,
  world!</p>
<p>Целое значение, возвращаемое функцией main(), если только оно есть,
  считается возвращаемым системе значением программы. Если ничего не
  возвращается, система получит какое-то "мусорное" значение.</p>
<p>Средства ввода/вывода потоковой библиотеки подробно описываются в
  главе <a href="chap11.shtml">10</a>.<p>

<a name="#vars"></a><h5>1.3.2 Переменные и арифметические операции</h5>
<p>Каждое имя и каждое выражение обязаны иметь тип. Именно тип определяет
  операции, которые могут выполняться над ними. Например, в описании</p>
<pre>
      int inch;
</pre>
<p>Каждое имя и каждое выражение обязаны иметь тип. Именно тип определяет
  операции, которые могут выполняться над ними. Например, в описании</p>
<pre>
      int inch;
</pre>
<p>говорится, что inch имеет тип int, т.е. inch является целой
  переменной.</p>
<p>Описание - это оператор, который вводит имя в программу. В описании
  указывается тип имени. Тип, в свою очередь, определяет как правильно
  использовать имя или выражение.</p>
<p>Основные типы, наиболее приближенные к "аппаратной реальности" машины,
  таковы:</p>
<pre>
                char
                short
                int
                long
</pre>
<p>Они представляют целые числа.  Следующие типы:</p>
<pre>
                float
                double
                long double
</pre>
<p>представляют числа с плавающей точкой. Переменная типа char имеет
  размер, нужный для хранения одного символа на данной машине (обычно это
  один байт). Переменная int имеет размер, необходимый для целой арифметики
  на данной машине (обычно это одно слово).</p>
<p>Следующие арифметические операции можно использовать над любым
  сочетанием перечисленных типов:</p>
<pre>
              +    (плюс, унарный и бинарный)
              -    (минус, унарный и бинарный)
              *    (умножение)
</pre>
<p>говорится, что inch имеет тип int, т.е. inch является целой
  переменной.</p>
<p>Описание - это оператор, который вводит имя в программу. В описании
  указывается тип имени. Тип, в свою очередь, определяет как правильно
  использовать имя или выражение.</p>
<p>Основные типы, наиболее приближенные к "аппаратной реальности" машины,
  таковы:</p>
<pre>
                char
                short
                int
                long
</pre>
<p>Они представляют целые числа.  Следующие типы:</p>
<pre>
                float
                double
                long double
</pre>
<p>представляют числа с плавающей точкой. Переменная типа char имеет
  размер, нужный для хранения одного символа на данной машине (обычно это
  один байт). Переменная int имеет размер, необходимый для целой арифметики
  на данной машине (обычно это одно слово).</p>
<p>Следующие арифметические операции можно использовать над любым
  сочетанием перечисленных типов:</p>
<pre>
              +    (плюс, унарный и бинарный)
              -    (минус, унарный и бинарный)
              *    (умножение)
              /    (деление)
              %    (остаток от деления)
</pre>
<p>То же верно для операций отношения:</p>
<pre>
              ==   (равно)
              !=   (не равно)
              <    (меньше чем)
              <=   (меньше или равно)
              >=   (больше или равно)
</pre>
<p>Для операций присваивания и арифметических операций в С++ выполняются
  все осмысленные преобразования основных типов, чтобы их можно было
  неограниченно использовать любые их сочетания:</p>
<pre>
              double d;
              int i;
              short s;
              // ...
              d = d + i;
              i = s * i;
</pre>
<p>Символ = обозначает обычное присваивание.</p>

<a name="#pointer"></a><h5>1.3.3 Указатели и массивы</h5>
<p>Массив можно описать так:</p>
<pre>
      char v [ 10 ]; // массив из 10 символов

      Описание указателя имеет такой вид:

      char * p; // указатель на символ
</pre>
<p>Здесь [] означает "массив из", а символ * означает "указатель на".
  Значение нижней границы индекса для всех массивов равно нулю, поэтому v
  имеет 10 элементов: v [ 0 ] ... v [ 9 ]. Переменная типа указатель может
  содержать адрес объекта соответствующего типа:</p>
<pre>
<p>p = & v [ 3 ]; // p указывает на 4-й элемент массива v</p>
</pre>
<p>Унарная операция & означает взятие адреса.</p>

<a name="#for"></a><h5>1.3.4 Условные операторы и циклы</h5>
<p>В С++ есть традиционный набор выбирающих операторов и циклов. Ниже
  приводятся примеры операторов if, switch и while.</p>
<p>В следующем примере показано преобразование дюйма в сантиметр и
  обратно. Предполагается, что во входном потоке значение в сантиметрах
  завершается символом i, а значение в дюймах - символом c:</p>
<pre>
            #include <iostream.h>

            int main ()
            {
                const float fac = 2.54;
                float x, in, cm;
                char ch = 0;

                cout << "enter length: ";

                cin >> x;   // ввод числа с плавающей точкой
                cin >> ch   // ввод завершающего символа

                if ( ch == 'i' ) 
                {      // дюйм
                    in = x;
                    cm = x * fac;
                }
                else if ( ch == 'c' ) 
                { // сантиметры
                    in = x / fac;
                    cm = x;
                }
                else
                    in = cm = 0;

                cout << in << " in = " << cm << " cm\n";
            }
</pre>
<p>Операция >> ("ввести из") используется как оператор ввода; cin
  является стандартным входным потоком. Тип операнда, расположенного справа
  от операции >>, определяет, какое значение вводится; оно записывается в
  этот операнд.</p>

<a name="#func"></a><h5>1.3.5 Функции</h5>
<p>Функция - это поименованная часть программы, которая может вызываться
  из других частей программы столько раз, сколько необходимо. Приведем
  программу, выдающую степени числа два:</p>
<pre>
          extern float pow ( float, int ); 
              // pow () определена в другом месте

          int main ()
          {
              for ( int i=0; i&lt;10; i++ ) cout << pow ( 2, i ) << '\n';
          }
</pre>
<p>Первая строка является описанием функции. Она задает pow как функцию с
  параметрами типа float и int, возвращающую значение типа float. Описание
  функции необходимо для ее вызова, ее определение находится в другом месте.</p>
<p>При вызове функции тип каждого фактического параметра сверяется с
  типом, указанным в описании функции, точно так же, как если бы
  инициализировалась переменная описанного типа. Это гарантирует надлежащую
  проверку и преобразования типов. Например, вызов функции pow(12.3,"abcd")
  транслятор сочтет ошибочным, поскольку "abcd" является строкой, а не
  параметром типа int. В вызове pow(2,i) транслятор преобразует целую
  константу (целое 2) в число с плавающей точкой (float), как того требует
  функция. Функция pow может быть определена следующим образом:</p>
<pre>
  float pow ( float x, int n )
  {
      if ( n < 0 ) 
          error ( "ошибка: для pow () задан отрицательный показатель");
      switch ( n ) 
      {
      case 0:  return 1;
      case 1:  return x;
      default: return x * pow ( x, n-1 );
      }
  }
</pre>
<p>Первая часть определения функции задает ее имя, тип возвращаемого
  значения (если оно есть), а также типы и имена формальных параметров (если
  они существуют). Значение возвращается из функции с помощью оператора
  return.</p>
<p>Разные функции обычно имеют разные имена, но функциям, выполняющим
  сходные операции над объектами разных типов, лучше дать одно имя.  Если
  типы параметров таких функций различны, то транслятор всегда может
  разобраться, какую функцию нужно вызывать. Например, можно иметь две
  функции возведения в степень: одну - для целых чисел, а другую - для чисел
  с плавающей точкой:</p>
<pre>
            int pow ( int, int );
            double pow ( double, double );
            //...
            x = pow ( 2,10 );    // вызов pow ( int, int )
            y = pow ( 2.0, 10.0 );// вызов pow ( double, double )
</pre>
<p>Такое многократное использование имени называется перегрузкой имени
  функции или просто перегрузкой; перегрузка рассматривается особо в главе
  <a href="chap7.shtml">7</a>.</p>
<p>Параметры функции могут передаваться либо "по значению", либо "по
  ссылке". Рассмотрим определение функции, которая осуществляет взаимообмен
  значений двух целых переменных. Если используется стандартный способ
  передачи параметров по значению, то придется передавать указатели:</p>
<pre>
           void swap ( int * p, int * q )
           {
             int t = * p;
             * p = * q;
             * q = t;
           }
</pre>
<p>Унарная операция * называется косвенностью (или операцией
  разыменования), она выбирает значение объекта, на который настроен
  указатель. Функцию можно вызывать следующим образом:</p>
<pre>
           void f ( int i, int j )
           {
             swap ( & i, & j );
           }
</pre>
<p>Если использовать передачу параметра по ссылке, можно обойтись без
  явных операций с указателем:</p>
<pre>
           void swap (int & r1, int & r2 )
           {
             int t = r1;
             r1 = r2;
             r2 = t;
           }

           void g ( int i, int j )
           {
               swap ( i, j );
           }
</pre>
<p>Для любого типа T запись T& означает "ссылка на T". Ссылка служит
  синонимом той переменной, которой она инициализировалась. Отметим, что
  перегрузка допускает сосуществование двух функций swap в одной программе.</p>

<a name="#module"></a><h5>1.3.6 Модули</h5>
<p>Программа С++ почти всегда состоит из нескольких раздельно
  транслируемых "модулей". Каждый "модуль" обычно называется исходным
  файлом, но иногда - единицей трансляции. Он состоит из последовательности
  описаний типов, функций, переменных и констант. Описание extern позволяет
  из одного исходного файла ссылаться на функцию или объект, определенные в
  другом исходном файле. Например:</p>
<pre>
             extern "C" double sqrt ( double );
             extern ostream cout;
</pre>
<p>Самый распространенный способ обеспечить согласованность описаний
  внешних во всех исходных файлах - поместить такие описания в специальные
  файлы, называемые заголовочными. Заголовочные файлы можно включать во все
  исходные файлы, в которых требуются описания внешних. Например, описание
  функции sqrt хранится в заголовочном файле стандартных математических
  функций с именем math.h, поэтому, если нужно извлечь квадратный корень из
  4, можно написать:</p>
<pre>
              #include <math.h>
              //...
              x = sqrt ( 4 );
</pre>
<p>Поскольку стандартные заголовочные файлы могут включаться во многие
  исходные файлы, в них нет описаний, дублирование которых могло бы вызвать
  ошибки. Так, тело функции присутствует в таких файлах, если только это
  функция-подстановка, а инициализаторы указаны только для констант (п. 
  <a href="chap4.shtml#headfile">4.3</a>).
  Не считая таких случаев, заголовочный файл обычно служит хранилищем для
  типов, он предоставляет интерфейс между раздельно транслируемыми частями
  программы.</p>
<p> В команде включения заключенное в угловые скобки имя файла (в нашем
  примере - <math.h>) ссылается на файл, находящийся в стандартном каталоге
  включаемых файлов. Часто это - каталог /usr/include/CC. Файлы, находящиеся
  в других каталогах, обозначаются своими путевыми именами, взятыми в
  кавычки. Поэтому в следующих командах:</p>
<pre>
            #include "math1.h"
            #include "/usr/bs/math2.h"
</pre>
  включаются файл math1.h из текущего каталога пользователя и файл
  math2.h из каталога /usr/bs.
<p>Приведем небольшой законченный пример, в котором строка определяется в
  одном файле, а печатается в другом. В файле header.h определяются нужные
  типы:</p>
<pre>
            // header.h

            extern char * prog_name;
            extern void f ();
</pre>
      Файл main.c является основной программой:
<pre>
            // main.c

            #include "header.h"
            char * prog_name = "примитивный, но законченный пример";
            int main ()
            {
              f ();
            }
</pre>
<p>а строка печатается функцией из файла f.c:</p>
<pre>
            // f.c

            #include <stream.h>
            #include "header.h"
            void f ()
            {
              cout << prog_name << '\n';
            }
</pre>
<p>При запуске транслятора С++ и передаче ему необходимых
  файлов-параметров в различных реализациях могут использоваться разные
  расширения имен для программ на С++. На машине автора трансляция и запуск
  программы выглядит так:</p>
<pre>
            $ CC main.c f.c -o silly
            $ silly

              примитивный, но законченный пример

            $
</pre>
<p>Кроме раздельной трансляции концепцию модульности в С++ поддерживают
  классы (п. <a href="chap5.shtml#elseclass">5.4</a>).</p>

<a name="#support"></a><h4>1.4 Поддержка абстракции данных</h4>
<p>Поддержка программирования с абстракцией данных в основном сводится к
  возможности определить набор операций (функции и операции) над типом. Все
  обращения к объектам этого типа ограничиваются операциями из заданного
  набора. Однако, имея такие возможности, программист скоро обнаруживает,
  что для удобства определения и использования новых типов нужны еще
  некоторые расширения языка. Хорошим примером такого расширения является
  перегрузка операций.</p>

<a name="#init"></a><h5>1.4.1 Инициализация и удаление</h5>
<p>Когда представление типа скрыто, необходимо дать пользователю средства
  для инициализации переменных этого типа. Простейшее решение - до
  использования переменной вызывать некоторую функцию для ее инициализации.
  Например:</p>
<pre>
          class vector 
          {
          // ...
          public:
             void init ( init size );  // вызов init () перед первым
                                       // использованием объекта vector
             // ...
          };

          void f ()
          {
            vector v;
            // пока v нельзя использовать
            v.init ( 10 );
            // теперь можно
          }
</pre>
<p>Но это некрасивое и чреватое ошибками решение. Будет лучше, если
  создатель типа определит для инициализации переменных некоторую
  специальную функцию. Если такая функция есть, то две независимые операции
  размещения и инициализации переменной совмещаются в одной (иногда ее
  называют инсталляцией или просто построением). Функция инициализации
  называется конструктором. Конструктор выделяется среди всех прочих функций
  данного класса тем, что имеет такое же имя, как и сам класс. Если объекты
  некоторого типа строятся нетривиально, то нужна еще одна дополнительная
  операция для удаления их после последнего использования. Функция удаления
  в С++ называется деструктором.  Деструктор имеет то же имя, что и его
  класс, но перед ним стоит символ ~ (в С++ этот символ используется для
  операции дополнения).  Приведем пример:</p>
<pre>
             class vector 
             {
                int  sz;            // число элементов
                int * v;             // указатель на целые
             public:
                vector ( int );                // конструктор
                ~vector ();                  // деструктор
                int& operator [] ( int index ); // операция индексации
             };
</pre>
<p>Конструктор класса vector можно использовать для контроля над ошибками
  и выделения памяти:</p>
<pre>
               vector::vector ( int s )
               {
                 if ( s <= 0 ) 
                    error ( "недопустимый размер вектора" );
                 sz = s;
                 v = new int [ s ];  // разместить массив из s целых
               }
</pre>
<p>Деструктор класса vector освобождает использовавшуюся память:</p>
<pre>
               vector::~vector ()
               {
                 delete [] v;      // освободить массив, на который
                                  // настроен указатель v
               }
</pre>
<p>От реализации С++ не требуется освобождения выделенной с помощью new
  памяти, если на нее больше не ссылается ни один указатель (иными словами,
  не требуется автоматическая "сборка мусора"). В замен этого можно без
  вмешательства пользователя определить в классе собственные функции
  управления памятью. Это типичный способ применения конструкторов и
  деструкторов, хотя есть много не связанных с управлением памятью
  применений этих функций (см., например, п. <a href="chap9.shtml#resurs">9.4</a>).</p>

<a name="#pattern"></a><h5>1.4.2 Шаблоны типа</h5>
<p>Для многих типов задача управления ими сводится к построению и
  уничтожению связанных с ними объектов, но есть типы, для которых этого
  мало. Иногда необходимо управлять всеми операциями копирования.  Вернемся
  к классу vector:</p>
<pre>
            void f ()
            {
              vector v1 ( 100 );
              vector v2 = v1;   // построение нового вектора v2,
                                // инициализируемого v1
              v1 = v2;          // v2 присваивается v1
               // ...
            }
</pre>
<p>Должна быть возможность определить интерпретацию операций
  инициализации v2 и присваивания v1. Например, в описании:</p>
<pre>
            class vector 
            {
                int * v;
                int sz;
            public:
                // ...
                void operator = ( const vector & );  // присваивание
                vector ( const vector & );          // инициализация
            };
</pre>
<p>указывается, что присваивание и инициализация объектов типа vector
  должны выполняться с помощью определенных пользователем операций.<br>
  Присваивание можно определить так:</p>
<pre>
            void vector::operator = ( const vector & a )
             // контроль размера и копирование элементов
            {
              if ( sz != a.sz ) 
                error ( "недопустимый размер вектора для =" );
              for ( int i = 0; i < sz; i++ ) v [ i ] = a.v [ i ];
            }
</pre>
<p>Поскольку эта операция использует для присваивания "старое значение"
  вектора, операция инициализации должна задаваться другой функцией,
  например, такой:</p>
<pre>
     vector::vector ( const vector & a )
     // инициализация вектора значением другого вектора
     {
       sz = a.sz;                        // размер тот же
       v = new int [ sz ];               // выделить память для массива
       for ( int i = 0; i < sz; i++ )    //копирование элементов
           v [ i ] = a.v [ i ];
     }
</pre>
<p>В языке С++ конструктор вида T(const T&) называется конструктором
  копирования для типа T. Любую инициализацию объектов типа T он выполняет с
  помощью значения некоторого другого объекта типа T.  Помимо явной
  инициализации конструкторы вида T(const T&) используются для передачи
  параметров по значению и получения возвращаемого функцией значения.</p>

<a name="#except"></a><h5>1.4.3 Обработка особых ситуаций</h5>
<p>Зачем программисту может понадобиться определить такой тип, как вектор
  целых чисел? Как правило, ему нужен вектор из элементов, тип которых
  неизвестен создателю класса Vector. Следовательно, надо суметь определить
  тип вектора так, чтобы тип элементов в этом определении участвовал как
  параметр, обозначающий "реальные" типы элементов:</p>
<pre>
            template < class T > class Vector 
            { // вектор элементов типа T
                T * v;
                int sz;
            public:
                Vector ( int s )
                {
                    if ( s <= 0 ) 
                        error ( "недопустимый для Vector размер" );
                    v = new T [ sz = s ];  
                        // выделить память для массива s типа T
                }
                T & operator [] ( int i );
                int size () { return sz; }
                // ...
            };
</pre>
<p>Таково определение шаблона типа. Он задает способ получения семейства
  сходных классов. В нашем примере шаблон типа Vector показывает, как можно
  получить класс вектор для заданного типа его элементов. Это описание
  отличается от обычного описания класса наличием начальной конструкции
  template<class T>, которая и показывает, что описывается не класс, а
  шаблон типа с заданным параметром-типом (здесь он используется как тип
  элементов).  Теперь можно определять и использовать вектора разных типов:</p>
<pre>
             void f ()
             {
               Vector < int > v1 ( 100 );     // вектор из 100 целых
               Vector < complex > v2 ( 200 ); // вектор из 200
                                              // комплексных чисел
               v2 [ i ] = complex ( v1 [ x ], v1 [ y ] );
               // ...
             }
</pre>
<p>Возможности, которые реализует шаблон типа, иногда называются
  параметрическими типами или генерическими объектами.  Оно сходно с
  возможностями, имеющимися в языках Clu и Ада.  Использование шаблона типа
  не влечет за собой каких-либо дополнительных расходов времени по сравнению
  с использованием класса, в котором все типы указаны непосредственно.</p>

<a name="#convers"></a><h5>1.4.4 Преобразования типов</h5>
<p>По мере роста программ, а особенно при активном использовании
  библиотек появляется необходимость стандартной обработки ошибок (или, в
  более широком смысле, "особых ситуаций"). Языки Ада, Алгол-68 и Clu
  поддерживают стандартный способ обработки особых ситуаций.</p>

<p>Снова вернемся к классу vector. Что нужно делать, когда операции
  индексации передано значение индекса, выходящее за границы массива?
  Создатель класса vector не знает, на что рассчитывает пользователь в таком
  случае, а пользователь не может обнаружить подобную ошибку (если бы мог,
  то эта ошибка вообще не возникла бы).  Выход такой: создатель класса
  обнаруживает ошибку выхода за границу массива, но только сообщает о ней
  неизвестному пользователю.  Пользователь сам принимает необходимые меры.
  Например:</p>
<pre>
           class vector {
             // определение типа возможных особых ситуаций
           class range { };
             // ...
           };
</pre>
<p>Вместо вызова функции ошибки в функции vector::operator[]() можно
  перейти на ту часть программы, в которой обрабатываются особые ситуации.
  Это называется "запустить особую ситуацию" ("throw the exception"):</p>
<pre>
          int & vector::operator [] ( int i )
          {
            if ( i < 0 || sz <= i ) throw range ();
            return v [ i ];
          }
</pre>
<p>В результате из стека будет выбираться информация, помещаемая туда при
  вызовах функций, до тех пор, пока не будет обнаружен обработчик особой
  ситуации с типом range для класса вектор (vector::range); он и будет
  выполняться.</p>
<p>Обработчик особых ситуаций можно определить только для специального
  блока:</p>
<pre>
            void f ( int i )
            {
                try 
                {      
                // в этом блоке обрабатываются особые ситуации
                // с помощью определенного ниже обработчика
                vector v ( i );
                // ...
                v [ i + 1 ] = 7;  // приводит к особой ситуации range
                // ...
                g ();         // может привести к особой ситуации range
                              // на некоторых векторах
                }
                catch ( vector::range ) 
                {
                    error ( "f (): vector range error" );
                    return;
                }
            }
</pre>
<p>Использование особых ситуаций делает обработку ошибок более
  упорядоченной и понятной. Обсуждение и подробности отложим до главы 
  <a href="chap9.shtml">9</a>.</p>

<a name="#multreal"></a><h5>1.4.5 Множественные реализации</h5>
<p>Определяемые пользователем преобразования типа, например, такие, как
  преобразование числа с плавающей точкой в комплексное, которое необходимо
  для конструктора complex(double), оказались очень полезными в С++.
  Программист может задавать эти преобразования явно, а может полагаться на
  транслятор, который выполняет их неявно в том случае, когда они необходимы
  и однозначны:</p>
<pre>
            complex a = complex ( 1 );
            complex b = 1;      // неявно: 1 -> complex ( 1 )
            a = b + complex ( 2 );
            a = b + 2;          // неявно: 2 -> complex ( 2) 
</pre>
<p>Преобразования типов нужны в С++ потому, что арифметические операции
  со смешанными типами являются нормой для языков, используемых в числовых
  задачах. Кроме того, большая часть пользовательских типов, используемых
  для "вычислений" (например, матрицы, строки, машинные адреса) допускает
  естественное преобразование в другие типы (или из других типов).</p>
<p>Преобразования типов способствуют более естественной записи программы:</p>
<pre>
   complex a = 2;
   complex b = a + 2;  // это означает: operator + ( a, complex ( 2  ))
   b = 2 + a;          // это означает: operator + ( complex ( 2 ), a )
</pre>
<p>В обоих случаях для выполнения операции "+" нужна только одна функция,
  а ее параметры единообразно трактуются системой типов языка. Более того,
  класс complex описывается так, что для естественного и беспрепятственного
  обобщения понятия числа нет необходимости что-то изменять для целых чисел.</p>

<a name="#ooprog"></a><h4>1.5 Поддержка объектно-ориентированного программирования</h4>
<p>Поддержку объектно-ориентированного программирования обеспечивают
  классы вместе с механизмом наследования, а также механизм вызова
  функций-членов в зависимости от истинного типа объекта (дело в том, что
  возможны случаи, когда этот тип неизвестен на стадии трансляции). Особенно
  важную роль играет механизм вызова функций-членов.  Не менее важны
  средства, поддерживающие абстракцию данных (о них мы говорили ранее). Все
  доводы в пользу абстракции данных и базирующихся на ней методов, которые
  позволяют естественно и красиво работать с типами, действуют и для языка,
  поддерживающего объектно-ориентированное программирование. Успех обоих
  методов зависит от способа построения типов, от того, насколько они
  просты, гибки и эффективны. Метод объектно-ориентированного
  программирования позволяет определять более общие и гибкие
  пользовательские типы по сравнению с теми, которые получаются, если
  использовать только абстракцию данных.</p>

<a name="#mechanism"></a><h5>1.5.1 Механизм вызова</h5>
<p>Основное средство поддержки объектно-ориентированного программирования
  - это механизм вызова функции-члена для данного объекта, когда истинный
  тип его на стадии трансляции неизвестен. Пусть, например, есть указатель
  p. Как происходит вызов p->rotate(45)?  Поскольку С++ базируется на
  статическом контроле типов, задающее вызов выражение имеет смысл только
  при условии, что функция rotate() уже была описана. Далее, из обозначения
  p->rotate() мы видим, что p является указателем на объект некоторого
  класса, а rotate должна быть членом этого класса. Как и при всяком
  статическом контроле типов проверка корректности вызова нужна для того,
  чтобы убедиться (насколько это возможно на стадии трансляции), что типы в
  программе используются непротиворечивым образом. Тем самым гарантируется,
  что программа свободна от многих видов ошибок.<p>
<p>Итак, транслятору должно быть известно описание класса, аналогичное
  тем, что приводились в п.<a href="chap1.shtml#objprog">1.2.5</a>:</p>
<pre>
           class shape 
           {
           // ...
           public:
              // ...
              virtual void rotate ( int );
              // ...
           };
</pre>
<p>а указатель p должен быть описан, например, так:</p>
<pre>
      T * p;
</pre>
<p>где T - класс shape или производный от него класс. Тогда транслятор
  видит, что класс объекта, на который настроен указатель p, действительно
  имеет функцию rotate(), а функция имеет параметр типа int. Значит,
  p->rotate(45) корректное выражение.</p>
<p>Поскольку shape::rotate() была описана как виртуальная функция, нужно
  использовать механизм вызова виртуальной функции. Чтобы узнать, какую
  именно из функций rotate следует вызвать, нужно до вызова получить из
  объекта некоторую служебную информацию, которая была помещена туда при его
  создании. Как только установлено, какую функцию надо вызвать, допустим
  circle::rotate, происходит ее вызов с уже упоминавшимся контролем типа.
  Обычно в качестве служебной информации используется таблица адресов
  функций, а транслятор преобразует имя rotate в индекс этой таблицы. С
  учетом этой таблицы объект типа shape можно представить так:</p>
<pre>
          center
                               vtbl:
          color                    &X::draw
                                   &Y::rotate
           ...
                                       ...
</pre>
<p>Функции из таблицы виртуальных функций vtbl позволяют правильно
  работать с объектом даже в тех случаях, когда в вызывающей функции
  неизвестны ни таблица vtbl, ни расположение данных в части объекта,
  обозначенной ... . Здесь как X и Y обозначены имена классов, в которые
  входят вызываемые функции. Для объекта circle оба имени X и Y есть circle.
  Вызов виртуальной функции может быть по сути столь же эффективен, как
  вызов обычной функции.</p>

<a name="#checktype"></a><h5>1.5.2 Проверка типа</h5>
  <p>Необходимость контроля типа при обращениях к виртуальным функциям
  может оказаться определенным ограничением для разработчиков библиотек.
  Например, хорошо бы предоставить пользователю класс "стек чего-угодно".
  Непосредственно в С++ это сделать нельзя. Однако, используя шаблоны типа и
  наследование, можно приблизиться к той эффективности и простоте
  проектирования и использования библиотек, которые свойственны языкам с
  динамическим контролем типов. К таким языкам относится, например, язык
  Smalltalk, на котором можно описать "стек чего-угодно".  Рассмотрим
  определение стека с помощью шаблона типа:</p>
<pre>
              template < class T > class stack 
              {
                 T * p;
                 int sz;
              public:
                 stack ( int );
                 ~stack ();

                 void push ( T );
                 T & pop ();
              };
</pre>
<p>Не ослабляя статического контроля типов, можно использовать такой стек
  для хранения указателей на объекты типа plane (самолет):</p>
<pre>
      stack < plane * > cs ( 200 );

      void f ()
      {
         cs.push ( new Saab900 );   // Ошибка при трансляции :
                                    // требуется plane*, а передан car*
         cs.push ( new Saab37B );
                                    // прекрасно: Saab 37B - на самом
                                    // деле самолет, т.е. типа plane
         cs.pop () -> takeoff ();
         cs.pop () -> takeoff ();
       }
</pre>
<p>Если статического контроля типов нет, приведенная выше ошибка
  обнаружится только при выполнении программы:</p>
<pre>
          // пример  динамическое контроля типа
          // вместо статического; это не С++
          Stack s; // стек может хранить указатели на объекты
                   // произвольного типа
           void f ()
           {
              s.push ( new Saab900 );
              s.push ( new Saab37B );
              s.pop () -> takeoff ();  // прекрасно: Saab 37B - самолет
              cs.pop () -> takeoff (); // динамическая ошибка:
                                       // машина не может взлететь
           }
</pre>
<p>Для способа определения, допустима ли операция над объектом, обычно
  требуется больше дополнительных расходов, чем для механизма вызова
  виртуальных функций в С++.</p>
<p>Рассчитывая на статический контроль типов и вызов виртуальных функций,
  мы приходим к иному стилю программирования, чем надеясь только на
  динамический контроль типов. Класс в С++ задает строго определенный
  интерфейс для множества объектов этого и любого производного класса, тогда
  как в Smalltalk класс задает только минимально необходимое число операций,
  и пользователь вправе применять незаданные в классе операции. Иными
  словами, класс в С++ содержит точное описание операций, и пользователю
  гарантируется, что только эти операции транслятор сочтет допустимыми.
</p>

<a name="#multinher"></a><h5>1.5.3 Множественное наследование</h5>
<p>Если класс A является базовым классом для B, то B наследует атрибуты
  A.  т.е. B содержит A плюс еще что-то. С учетом этого становится очевидно,
  что хорошо, когда класс B может наследовать из двух базовых классов A1 и
  A2. Это называется множественным наследованием.</p>
<p>Приведем некий типичный пример множественного наследования. Пусть есть
  два библиотечных класса displayed и task. Первый представляет задачи,
  информация о которых может выдаваться на экран с помощью некоторого
  монитора, а второй - задачи, выполняемые под управлением некоторого
  диспетчера. Программист может создавать собственные классы, например,
  такие:</p>
<pre>
         class my_displayed_task: public displayed, public task 
         {
            // текст пользователя
         };

         class my_task: public task {  
            // эта задача не изображается
            // на экране, т.к. не содержит класс displayed
            // текст пользователя
         };

         class my_displayed: public displayed 
         { 
            // а это не задача
            // т.к. не содержит класс task
            // текст пользователя
         };
</pre>
<p>Если наследоваться может только один класс, то пользователю доступны
  только два из трех приведенных классов. В результате либо получается
  дублирование частей программы, либо теряется гибкость, а, как правило,
  происходит и то, и другое. Приведенный пример проходит в С++ безо всяких
  дополнительных расходов времени и памяти по сравнению с программами, в
  которых наследуется не более одного класса.  Статический контроль типов от
  этого тоже не страдает.</p>
<p>Все неоднозначности выявляются на стадии трансляции:</p>
<pre>
           class task 
           {
           public:
             void trace ();
             // ...
           };

           class displayed 
           {
           public:
             void trace ();
             // ...
           };

           class my_displayed_task:public displayed, public task 
           {
             // в этом классе trace () не определяется
           };

           void g ( my_displayed_task * p )
           {
             p -> trace ();  // ошибка: неоднозначность
           }
</pre>
<p>В этом примере видны отличия С++ от объектно-ориентированных диалектов
  языка Лисп, в которых есть множественное наследование. В этих диалектах
  неоднозначность разрешается так: или считается существенным порядок
  описания, или считаются идентичными объекты с одним и тем же именем в
  разных базовых классах, или используются комбинированные способы, когда
  совпадение объектов доля базовых классов сочетается с более сложным
  способом для производных классов. В С++ неоднозначность, как правило,
  разрешается введением еще одной функции:</p>
<pre>
        class my_displayed_task:public displayed, public task 
        {
            // ...
        public:
            void trace ()
            {
              // текст пользователя
              displayed::trace ();  // вызов trace () из displayed
              task::trace ();       // вызов trace () из task
            }
            // ...
       };

      void g ( my_displayed_task * p )
      {
         p -> trace ();  // теперь нормально
      }
</pre>

<a name="#incaps"></a><h5>1.5.4 Инкапсуляция</h5>
<p>Пусть члену класса (неважно функции-члену или члену, представляющему
  данные) требуется защита от "несанкционированного доступа". Как разумно
  ограничить множество функций, которым такой член будет доступен? Очевидный
  ответ для языков, поддерживающих объектно-ориентированное
  программирование, таков: доступ имеют все операции, которые определены для
  этого объекта, иными словами, все функции-члены. Например:/<p>
<pre>
          class window 
          {
          // ...
          protected:
             Rectangle inside;
             // ...
          };

          class dumb_terminal : public window 
          {
             // ...
          public:
             void prompt ();
             // ...
          };
</pre>
<p>Здесь в базовом классе window член inside типа Rectangle описывается
  как защищенный (protected), но функции-члены производных классов,
  например, dumb_terminal::prompt(), могут обратиться к нему и выяснить, с
  какого вида окном они работают. Для всех других функций член
  window::inside недоступен.</p>
<p>В таком подходе сочетается высокая степень защищенности
  (действительно, вряд ли вы "случайно" определите производный класс) с
  гибкостью, необходимой для программ, которые создают классы и используют
  их иерархию (действительно, "для себя" всегда можно в производных классах
  предусмотреть доступ к защищенным членам).</p>
<p>Неочевидное следствие из этого: нельзя составить полный и
  окончательный список всех функций, которым будет доступен защищенный член,
  поскольку всегда можно добавить еще одну, определив ее как функцию-член в
  новом производном классе. Для метода абстракции данных такой подход часто
  бывает мало приемлемым. Если язык ориентируется на метод абстракции
  данных, то очевидное для него решение - это требование указывать в
  описании класса список всех функций, которым нужен доступ к члену.  В С++
  для этой цели используется описание частных (private) членов. Оно
  использовалось и в приводившихся описаниях классов complex и shape.</p>
<p>Важность инкапсуляции, т.е. заключения членов в защитную оболочку,
  резко возрастает с ростом размеров программы и увеличивающимся разбросом
  областей приложения. В п.<a href="chap6.shtml#contrl">6.6</a> более подробно обсуждаются возможности языка
  по инкапсуляции.
</p>

<a name="#limitperf"></a><h4>1.6 Пределы совершенства</h4>
<p>Язык С++ проектировался как "лучший С", поддерживающий абстракцию
  данных и объектно-ориентированное программирование. При этом он должен
  быть пригодным для большинства основных задач системного программирования.</p>
<p>Основная трудность для языка, который создавался в расчете на методы
  упрятывания данных, абстракции данных и объектно-ориентированного
  программирования, в том, что для того, чтобы быть языком общего
  назначения, он должен:</p>
<ul>
<li>идти на традиционных машинах;
<li>сосуществовать с традиционными операционными системами и языками;
<li>соперничать с традиционными языками программирования в эффективности
выполнения программы;
<li>быть пригодным во всех основных областях приложения.
</ul>
<p>Это значит, что должны быть возможности для эффективных числовых
  операций (арифметика с плавающей точкой без особых накладных расходов,
  иначе пользователь предпочтет Фортран) и средства такого доступа к памяти,
  который позволит писать на этом языке драйверы устройств. Кроме того, надо
  уметь писать вызовы функций в достаточно непривычной записи, принятой для
  обращений в традиционных операционных системах. Наконец, должна быть
  возможность из языка, поддерживающего объектно-ориентированное
  программирование, вызывать функции, написанные на других языках, а из
  других языков вызывать функцию на этом языке, поддерживающем
  объектно-ориентированное программирование.</p>
<p>Далее, нельзя рассчитывать на широкое использование искомого языка
  программирования как языка общего назначения, если реализация его целиком
  полагается на возможности, которые отсутствуют в машинах с традиционной
  архитектурой.</p>
<p>Если не вводить в язык возможности низкого уровня, то придется для
  основных задач большинства областей приложения использовать некоторые
  языки низкого уровня, например С или ассемблер. Но С++ проектировался с
  расчетом, что в нем можно сделать все, что допустимо на С, причем без
  увеличения времени выполнения.  Вообще, С++ проектировался, исходя из
  принципа, что не должно возникать никаких дополнительных затрат времени и
  памяти, если только этого явно не пожелает сам программист.</p>
<p>Язык проектировался в расчете на современные методы трансляции,
  которые обеспечивают проверку согласованности программы, ее эффективность
  и компактность представления. Основным средством борьбы со сложностью
  программ видится, прежде всего, строгий контроль типов и инкапсуляция.
  Особенно это касается больших программ, создаваемых многими людьми.
  Пользователь может не являться одним из создателей таких программ, и может
  вообще не быть программистом.  Поскольку никакую настоящую программу
  нельзя написать без поддержки библиотек, создаваемых другими
  программистами, последнее замечание можно отнести практически ко всем
  программам.</p>
<p>С++ проектировался для поддержки того принципа, что всякая программа
  есть модель некоторых существующих в реальности понятий, а класс является
  конкретным представлением понятия, взятого из области приложения (п. 
  <a href="chap12.shtml#class">12.2</a>).
  Поэтому классы пронизывают всю программу на С++, и налагаются жесткие
  требования на гибкость понятия класса, компактность объектов класса и
  эффективность их использования. Если работать с классами будет неудобно
  или слишком накладно, то они просто не будут использоваться, и программы
  выродятся в программы на "лучшем С". Значит пользователь не сумеет
  насладиться теми возможностями, ради которых, собственно, и создавался
  язык.
</p>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap2.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>