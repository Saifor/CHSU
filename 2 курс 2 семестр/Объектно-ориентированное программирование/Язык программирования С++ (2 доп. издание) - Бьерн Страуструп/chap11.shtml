<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 11<br>
Проектирование и развитие</h3>

<p align="right"><i>"Серебряной пули не существует."<br>
- Ф. Брукс</i></p>

<p>В этой  главе  обсуждаются подходы к разработке программного обеспечения.
  Обсуждение затрагивает как технические, так и социологические аспекты
  процесса развития программного обеспечения. Программа рассматривается
  как модель реальности, в которой каждый класс представляет определенное
  понятие. Ключевая задача проектирования состоит в определении доступной
  и защищенной частей интерфейса класса, исходя из которых определяются
  различные части программы. Определение этих интерфейсов есть
  итеративный процесс, обычно требующий экспериментирования. Упор
  делается на важной роли  проектирования и организационных факторов
  в процессе развития программного обеспечения.</p>

<a name="introduct"></a><h4>11.1 Введение</h4>

<p>Создание любой нетривиальной программной системы - сложная и часто
  выматывающая задача. Даже для отдельного программиста собственно запись
  операторов программы есть только часть всей работы. Обычно анализ всей
  задачи, проектирование программы в целом, документация, тестирование,
  сопровождение и управление всем этим затмевает задачу написания и
  отладки отдельных частей программы. Конечно, можно все эти виды
  деятельности обозначить  как  "программирование" и затем вполне
  обоснованно утверждать: "Я не проектирую, я только программирую".
  Но как бы не назывались отдельные виды деятельности, бывает иногда важно
  сосредоточиться на них по отдельности, так же как иногда бывает важно
  рассмотреть весь процесс в целом. Стремясь поскорее довести систему
  до поставки, нельзя упускать из вида ни детали, ни картину в целом,
  хотя довольно часто происходит именно это.</p>
<p>Эта глава сосредоточена на тех частях процесса развития программы,
  которые не связаны с написанием и отладкой отдельных программных
  фрагментов. Обсуждение здесь менее точное и детальное, чем во всех
  остальных частях книги, где рассматриваются конкретные черты языка
  или определенные приемы программирования. Это неизбежно, поскольку нет
  готовых рецептов создания хороших программ. Детальные рецепты "как"
  могут существовать только для определенных, хорошо разработанных областей
  применения, но не для достаточно широких областей приложения. В
  программировании не существует заменителей разума, опыта и вкуса.
  Следовательно, в этой главе вы найдете только общие рекомендации,
  альтернативные подходы и осторожные выводы.</p>
<p>Сложность данной тематики связана с абстрактной природой программ
  и тем фактом, что приемы, применимые для небольших проектов (скажем,
  программа в 10000 строк, созданная одним или двумя людьми), не
  распространяются на средние или большие проекты. По этой причине иногда
  мы приводим  примеры из менее абстрактных инженерных дисциплин, а не
  только из программирования. Не преминем напомнить, что "доказательство по
  аналогии" является мошенничеством, и аналогии служат здесь только в
  качестве примера. Понятия проектирования, формулируемые
  с помощью определенных конструкций С++, и поясняемые примерами, мы
  будем обсуждать в главах <a href="chap12.shtml">12</a> и 
<a href="chap13.shtml">13</a>. Предложенные в этой главе рекомендации,
  отражаются как в самом языке С++, так и в решении конкретных программных
  задач по всей книге.</p>
<p>Снова напомним, что в силу чрезвычайного разнообразия областей
  применения, программистов и среды, в которой развивается программная
  система, нельзя ожидать, что каждый вывод, сделанный здесь, будет
  прямо применим для вашей задачи. Эти выводы применимы
  во многих самых разных случаях, но их нельзя считать универсальными
  законами. Смотрите на них со здоровой долей скептицизма.</p>
<p>Язык С++ можно просто использовать как лучший вариант С. Однако,
  поступая так, мы не используем наиболее мощные возможности С++ и
  определенные приемы программирования на нем, так что реализуем лишь
  малую долю потенциальных достоинств С++. В этой главе излагается такой
  подход к проектированию, который позволяет полностью использовать
  возможности абстрактных данных и средства объектного программирования С++.
  Такой подход обычно называют объектно-ориентированным проектированием.
  В главе <a href="chap12.shtml">12</a> обсуждаются 
основные приемы программирования на С++, там же
  содержится предостережение от сомнительных идей, что есть только один
  "правильный" способ использования С++, и что для получения
  максимального выигрыша следует всякое средство С++
  применять в любой программе (п.<a href="chap12.shtml#lang">12.1</a>).</p>
<p>Укажем некоторые основные принципы, рассматриваемые в этой главе:</p>
<ul>
<li>из всех вопросов, связанных с процессом развития программного
       обеспечения, самый важный - четко сознавать, что собственно вы
       пытаетесь создать.
<li>Успешный процесс развития программного обеспечения - это дли-
       тельный процесс.
<li>Системы, которые мы создаем, стремятся к пределу сложности
       по отношению как к самим создателям, так и используемым средствам.
<li>Эксперимент является необходимой частью проекта для разработки всех
       нетривиальных программных систем.
<li>Проектирование и программирование - это итеративные процессы.
<li>Различные стадии проекта программного обеспечения, такие как:
       проектирование, программирование и тестирование - невозможно строго
       разделить.
<li>Проектирование и программирование нельзя рассматривать в отрыве от
       вопросов управления этими видами деятельности.
</ul>
<p>Недооценить любой из этих принципов очень легко, но обычно накладно.
  В то же время трудно воплотить эти абстрактные идеи на практике.
  Здесь необходим определенный опыт. Подобно построению лодки, езде на
  велосипеде или программированию проектирование - это искусство, которым
  нельзя овладеть только с помощью теоретических занятий.</p>
<p>Может быть все эти емкие принципы можно сжать в один:
  проектирование и программирование - виды человеческой деятельности;
  забудь про это - и все пропало.
  Слишком часто мы забываем про это и рассматриваем процесс развития
  программного обеспечения просто как "последовательность хорошо
  определенных шагов, на каждом из которых по заданным правилам
  производятся некоторые действия над входными данными, чтобы получить
  требуемый результат". Сам стиль предыдущего предложения выдает
  присутствие человеческой природы!
  Эта глава относится к проектам, которые можно считать честолюбивыми,
  если учитывать ресурсы и опыт людей, создающих систему. Похоже, это в
  природе как индивидуума, так и организации - браться за проекты на
  пределе своих возможностей. Если задача не содержит определенный вызов,
  нет смысла уделять особое внимание ее проектированию. Такие задачи
  решаются в рамках уже устоявшейся структуры, которую не следует разрушать.
  Только если замахиваются на что-то амбициозное, появляется потребность
  в новых, более мощных средствах и приемах. Кроме того, существует
  тенденция у тех, кто "знает как делать", перепоручать проект новичкам,
  которые не имеют таких знаний.</p>
<p>Не существует "единственного правильного способа" для
  проектирования и создания всей системы. Я бы считал веру в "единственный
  правильный способ" детской болезнью, если бы этой болезнью слишком
  часто не заболевали и опытные программисты. Напомним еще раз: только
  по той причине, что прием успешно использовался в течение года для
  одного проекта, не следует, что он без всяких изменений окажется
  столь же полезен для другого человека или другой задачи. Всегда важно
  не иметь предубеждений.</p>
<p>Убеждение в том, что нет единственно верного решения, пронизывает
  весь проект языка С++, и, в основном, по этой причине в первом издании
  книги не было раздела, посвященного проектированию: я не хотел, чтобы
  его рассматривали как "манифест" моих личных симпатий. По этой же
  причине здесь, как и в главах <a href="chap12.shtml">12</a> и 
<a href="chap13.shtml">13</a>, нет четко определенного взгляда на
  процесс развития программного обеспечения, скорее здесь просто дается
  обсуждение определенного круга, часто возникающих, вопросов и
  предлагаются некоторые решения, оказавшиеся полезными в определенных
  условиях.</p>
<p>За этим введением следует краткое обсуждение целей и средств
  развития программного обеспечения в п.<a href='#purpose'>11.2</a>, 
а дальше глава распадается
  на две основных части:</p>
<ul>
<li>п.<a href="#process">11.3</a> содержит 
описание процесса развития  программного обеспечения.
<li>п.<a href="#control">11.4</a> содержит 
некоторые практические рекомендации по организации
    этого процесса.</ul>
<p>Взаимосвязь между проектированием и языком программирования обсуждается
  в главе <a href="chap12.shtml">12</a>, а глава 
<a href="chap13.shtml">13</a> посвящена вопросам проектирования библиотек для
  С++.</p>
<p>Очевидно, большая часть рассуждений относится к программным проектам
  большого объема. Читатели, которые не участвуют в таких разработках,
  могут сидеть спокойно и радоваться, что все эти ужасы  их миновали,
  или же они могут выбрать вопросы, касающиеся только их интересов. Нет
  нижней границы размера программы, начиная с которой имеет смысл заняться
  проектированием прежде, чем начать писать программу. Однако все-таки есть нижняя
  граница, начиная с которой можно использовать какие-либо методы
  проектирования. Вопросы, связанные с размером, обсуждаются в 
п.<a href="#size">11.4.2</a>.</p>
<p>Труднее всего в программных проектах бороться с их сложностью.
  Есть только один общий способ борьбы со сложностью: разделяй и
  властвуй. Если задачу удалось разделить на две подзадачи, которые можно
  решать в отдельности, то можно считать ее решенной за счет разделения
  более, чем наполовину. Этот простой принцип применим для удивительно
  большого числа ситуаций. В частности, использование модулей или классов
  при разработке программных систем позволяет разбить программу на две
  части: часть реализации и часть, открытую пользователю - которые
  связаны между собой (в идеале) вполне определенным интерфейсом. Это
  основной, внутренне присущий программированию, принцип борьбы со
  сложностью.
  Подобно этому и процесс проектирования программы можно разбить на
  отдельные виды деятельности с четко определенным (в идеале)
  взаимодействием между людьми, участвующими в них. Это основной,
  внутренне присущий проектированию, принцип борьбы со сложностью и
  подход к управлению людьми,занятыми в проекте.</p>
<p>В обоих случаях выделение частей и определение интерфейса между
  частями - это то место, где требуется максимум опыта и чутья. Такое
  выделение не является чисто механическим процессом, обычно оно требует
  проницательности, которая может появиться только в  результате  доско-
  нального понимания   системы  на  различных  уровнях  абстракции  (см.
  п.<a href="#steps">11.3.3</a>, 
п.<a href="chap12.shtml#whatis">12.2.1</a> и 
п.<a href="chap13.shtml#abstr">13.3</a>). Близорукий взгляд на программу или на
  процесс разработки программного обеспечения часто приводит к дефектной
  системе. Отметим, что как программы, так и программистов разделить
  просто. Труднее достигнуть эффективного взаимодействия между участниками
  по обе стороны границы, не нарушая ее и не делая взаимодействие слишком
  жестким.</p>
<p>Здесь предложен определенный подход к проектированию, а не полное
  формальное описание метода проектирования. Такое описание выходит за
  предметную область книги. Подход, предложенный здесь, можно применять
  с различной степенью формализации, и он может служить базой для различных
  формальных спецификаций. В тоже время нельзя считать эту главу
  рефератом, и здесь не делается попытка рассмотреть каждую тему,
  относящуюся к процессу разработки программ или изложить каждую точку
  зрения. Это тоже выходит за предметную область книги. Реферат по этой
  тематике можно найти в [<a href="chap0.shtml#book2">2</a>]. В этой книге используется достаточно
  общая и традиционная терминология. Самые "интересные" термины, как:
  проектирование, прототип, программист - имеют в литературе несколько
  определений, часто противоречащих друг другу, поэтому предостерегаем вас
  от того, чтобы, исходя из принятых в вашем окружении определений терминов,
  вы не вынесли из книги то, на что автор совершенно не рассчитывал.</p>

<a name="purpose"></a><h4>11.2 Цели и средства</h4>

<p>Цель программирования - создать продукт, удовлетворяющий пользователя.
  Важнейшим средством для достижении этой цели является создание
  программы с ясной внутренней структурой и воспитание коллектива
  программистов и разработчиков, имеющих достаточный опыт и мотивацию,
  чтобы быстро и эффективно реагировать на все изменения.</p>
<p>Почему это так? Ведь внутрення структура программы и процесс, с
  помощью которого она получена, в идеале никак не касаются конечного
  пользователя. Более того, если конечный пользователь почему-то
  интересуется тем, как написана программа, то что-то с этой программой
  не так. Почему, несмотря на это, так важны структура программы и люди,
  ее создавшие?  В  конце  концов  конечный пользователь ничего об этом
  не должен знать.</p>
<p>Ясная внутренняя структура программы облегчает:</p>
<ul>
<li>тестирование,
<li>переносимость,
<li>сопровождение,
<li>расширение,
<li>реорганизацию и
<li>понимание.
</ul>
<p>Главное здесь в том, что любая удачная большая программа имеет
  долгую жизнь, в течение которой над ней работают
  поколения программистов и разработчиков, она переносится на новую
  машину, приспосабливается к непредусмотренным требованиям и несколько
  раз перестраивается. Во все время жизни необходимо в приемлемое время и
  с допустимым числом ошибок выдавать версии программы. Не планировать все
  это - все равно, что запланировать неудачу.</p>
<p>Отметим, что, хотя в идеальном случае случае пользователи не
  должны знать внутреннюю структуру системы, на практике они обычно
  хотят ее знать. Например, пользователь может желать познакомиться в
  деталях с разработкой системы с целью научиться контролировать
  возможности и надежность системы на случай переделок и расширений.
  Если рассматриваемый программный продукт есть не полная система, а набор
  библиотек для получения программных систем, то пользователь захочет
  узнать побольше "деталей", чтобы они служили источником идей и
  помогали лучше использовать библиотеку.</p>
<p>Нужно уметь очень точно определить объем проектирования программы.
  Недостаточный объем приводит к бесконечному срезанию острых углов
  ("побыстрее передадим систему, а ошибку устраним в следующей версии").
  Избыточный объем приводит к усложненному описанию системы, в котором
  существенное теряется в формальностях, в результате чего при
  реорганизации программы получение работающей версии затягивается ("новая
  структура намного лучше старой, пользователь согласен ждать ради нее").
  К тому же возникают такие потребности в ресурсах, которые непозволительны
  для большинства потенциальных пользователей. Выбор объема
  проектирования - самый трудный момент в разработке, именно здесь
  проявляется талант и опыт. Выбор трудно сделать и для одного программиста
  или разработчика, но он еще труднее для больших задач, где занято
  много людей разного уровня квалификации.</p>
<p>Организация должна создавать программный продукт и сопровождать
  его, несмотря на изменения в штате, в направлении работы или в
  управляющей структуре. Распространенный способ решения этих проблем
  заключался в попытке сведения процесса создания системы к нескольким
  относительно простым задачам, укладывающимся в жесткую структуру.
  Например, создать группу легко обучаемых (дешевых) и взаимозаменяемых
  программистов низкого уровня ("кодировщиков") и группу не таких
  дешевых, но взаимозаменяемых (а значит также не уникальных)
  разработчиков. Считается, что кодировщики не принимают решений по
  проектированию, а разработчики не утруждают  себя  "грязными"
  подробностями кодирования. Обычно такой подход приводит к неудаче, а
  где он срабатывает, получается слишком громоздкая система с плохими
  характеристиками.</p>
<p>Недостатки такого подхода состоят в следующем:</p>
<ul>
<li>слабое взаимодействие между программистами и разработчиками
     приводит к неэффективности, промедлению, упущенным возможностям и
     повторению ошибок из-за плохого учета и отсутствия обмена опытом;
<li>сужение области творчества разработчиков приводит
     к слабому профессиональному росту, безынициативности, небрежности и
     большой текучести кадров.
</ul>
<p>По сути, подобные системы - это бесполезная трата редких человеческих
  талантов. Создание структуры, в рамках которой люди могут найти
  применение разным талантам, овладеть новым родом деятельности и
  участвовать в творческой работе - это не только благородное дело, но
  и практичное, коммерчески выгодное предприятие.</p>
<p>С другой стороны, нельзя создать систему, представить документацию
  по ней и бесконечно ее сопровождать без некоторой жесткой организационной
  структуры. Для чисто новаторского проекта хорошо начать с того, что
  просто найти лучших специалистов и позволить им решать задачу в
  соответствии с их идеями.  Но по мере развития проекта  требуется  все
  больше планирования,  специализации и строго определенного взаимодействия
  между занятыми в нем людьми. Под строго определенным понимается не
  математическая или автоматически верифицируемая запись (хотя это
  безусловно хорошо там, где возможно и применимо), а скорее набор
  указаний по записи, именованию, документации, тестированию и т.п.
  Но и здесь необходимо чувство меры. Слишком жесткая структура может
  мешать росту и затруднять совершенствование. Здесь подвергается
  проверке талант и опыт менеджера. Для отдельного работника аналогичная
  проблема сводится к определению, где нужно проявить смекалку, а где
  действовать по рецептам.</p>
<p>Можно рекомендовать планировать не на период до выдачи следующей
  версии системы, а на более долгий срок. Строить планы только до
  выпуска очередной версии - значит планировать неудачу. Нужно иметь
  организацию и стратегию развития программного обеспечения, которые
  нацелены на создание и поддержание многих версий разных систем, т.е.
  нужно многократное планирование успеха.</p>
<p>Цель проектирования в выработке ясной и относительно простой
  внутренней структуры программы, называемой иногда архитектурой, иными
  словами каркаса, в который укладываются отдельные программные фрагменты,
  и который помогает написанию этих фрагментов.</p>
<p>Проект - конечный результат процесса проектирования (если только
  бывает конечный продукт у итеративного процесса). Он является
  средоточием взаимодействий между разработчиком и программистом и
  между программистами. Здесь необходимо соблюсти чувство меры. Если я,
  как отдельный программист, проектирую небольшую программу, которую
  собираюсь написать завтра, то точность и полнота описания проекта
  может свестись к нескольким каракулям на обратной стороне конверта.
  На другом полюсе находится система, над которой работают сотни
  программистов и разработчиков, и здесь могут потребоваться тома
  тщательно составленных спецификаций проекта на формальном или
  полуформальном языке. Определение нужной степени точности, детализации
  и формальности проектирования является уже само по себе нетривиальной
  технической и административной задачей.</p>
<p>Далее будет предполагаться, что проект системы записывается
  как ряд определений классов (в которых частные описания опущены
  как лишние детали) и взаимоотношений между ними. Это упрощение, т.к.
  конкретный проект может учитывать: вопросы параллельности, использование
  глобального пространства имен, использование глобальных функций и
  данных, построение программы для минимизации перетрансляции,
  устойчивость, многомашинный режим и т.п. Но при обсуждении на данном
  уровне детализации без упрощения не обойтись, а классы в контексте С++
  являются ключевым понятием проектирования. Некоторые из указанных
  вопросов будут обсуждаться ниже, а те, которые прямо затрагивают
  проектирование библиотек С++, будут рассмотрены в главе 
<a href="chap13.shtml">13</a>. Более
  подробное обсуждение и примеры определенных методов объектно-
  ориентированного проектирования содержатся в [<a href="chap0.shtml#book2">2</a>].</p>
<p>Мы сознательно не проводили четкого разделения анализа и
  проектирования, поскольку обсуждение их различий выходит за рамки этой
  книги, и оно зависит от применяемых методов проектирования. Главное в том,
  чтобы выбрать метод анализа, подходящий для метода проектирования, и
  выбрать метод проектирования, подходящий для стиля программирования
  и используемого языка.</p>

<a name="process"></a><h4>11.3 Процесс развития</h4>

<p>Процесс развития программного обеспечения - это итеративный и
  расширяющийся процесс. По мере развития каждая стадия повторяется
  многократно, и при всяком возврате на некоторую стадию процесса уточняется
  конечный продукт, получаемый на этой стадии. В общем случае процесс
  не имеет ни начала, ни конца, поскольку, проектируя и реализуя систему,
  вы начинаете, используя как базу другие проекты, библиотеки и прикладные
  системы, в конце работы после вас остается описание проекта и программа,
  которые другие могут уточнять, модифицировать, расширять и переносить.
  Естественно конкретный проект имеет определенное начало и конец, и
  важно (хотя часто удивительно трудно) четко и строго ограничить время
  и область действия проекта. Но заявление, что вы начинаете с "чистого
  листа", может привести к серьезным проблемам для вас, также как и позиция,
  что после передачи окончательной версии - хоть потоп, вызовет
  серьезные проблемы для ваших последователей (или для вас в новой
  роли).</p>
<p>Из этого вытекает, что следующие разделы можно читать в любом
  порядке, поскольку вопросы проектирования и реализации могут в
  реальном проекте переплетаться почти произвольно. Именно, "проект"
  почти всегда подвергается перепроектированию на основе предыдущего
  проекта, определенного опыта реализации, ограничений, накладываемых
  сроками, мастерством работников, вопросами совместимости и т.п.
  Здесь основная трудность для менеджера или разработчика или
  программиста в том, чтобы создать такой порядок в этом процессе,
  который не препятствует усовершенствованиям и не запрещает повторные
  проходы, необходимые для успешного развития.</p>
<p>У процесса развития три стадии:</p>
<ul>
<li>Анализ: определение области задачи.
<li>Проектирование: создание общей структуры системы.
<li>Реализация: программирование и тестирование.
</ul>
<p>Не забудьте об итеративной природе этих процессов (неспроста стадии
  не были пронумерованы), и заметьте, что никакие важные аспекты процесса
  развития программы не выделяются в отдельные стадии, поскольку они
  должны допускать:</p>
<ul>
<li>Экспериментирование.
<li>Тестирование.
<li>Анализ проектирования и реализации.
<li>Документирование.
<li>Сопровождение.
</ul>
<p>Сопровождение программного обеспечения рассматривается просто как
   еще несколько проходов по стадиям процесса развития (см. также
  п.<a href="#support">11.3.6</a>).</p>
<p>Очень важно, чтобы анализ, проектирование и реализация не были
  слишком оторваны друг от друга, и чтобы люди, принимающие в них
  участие, были одного уровня квалификации для налаживания эффективных
  контактов.
  В больших проектах слишком часто бывает иначе. В идеале, в процессе
  развития проекта работники должны сами переходить с одной стадии на
  другую: лучший способ передачи тонкой информации - это использовать
  голову работника. К сожалению, в организациях часто устанавливают
  барьеры для таких переходов, например, у разработчика может быть
  более высокий статус и (или) более высокий оклад, чем у "простого"
  программиста. Не принято, чтобы сотрудники ходили по отделам с целью
  набраться опыта и знаний, но пусть, по крайней мере, будут
  регулярными собеседования сотрудников, занятых на разных стадиях проекта.</p>
<p>Для средних и малых проектов обычно не делают различия между
  анализом и проектированием - эти стадии сливаются в одну. Для малых
  проектов также не разделяют проектирование и программирование.
  Конечно, тем самым решается проблема взаимодействия. Для данного
  проекта важно найти подходящую степень формализации и выдержать
  нужную степень разделения между стадиями 
(п.<a href="#size">11.4.2</a>). Нет единственно
  верного способа для этого.</p>
<p>Приведенная здесь модель процесса развития программного обеспечения
  радикально отличается от традиционной модели "каскад" (waterfall).
  В последней процесс развития протекает линейно от стадии анализа до
  стадии тестирования. Основной недостаток модели каскад тот, что в ней
  информация движется только в одном направлении. Если выявлена
  проблема "ниже по течению", то возникает сильное методологическое
  и организационное давление, чтобы решить проблему на данном уровне,
  не затрагивая предыдущих стадий процесса. Отсутствие повторных
  проходов приводит к дефектному проекту, а в результате локального
  устранения проблем получается искаженная реализация. В тех
  неизбежных случаях, когда информация должна быть передана назад к
  источнику ее получения и вызвать изменения в проекте, мы получим
  лишь слабое "колыхание" на всех уровнях системы, стремящейся подавить
  внесенное изменение, а значит система плохо приспособлена к
  изменениям. Аргумент в пользу "никаких изменений" или "только локальные
  изменения" часто сводится к тому, что один отдел не хочет
  перекладывать большую работу на другой отдел "ради их же блага".
  Часто бывает так, что ко времени, когда ошибка уже найдена, исписано
  столько бумаги относительно ошибочного решения, что усилия,
  нужные на исправление документации, затмевают усилия для исправления
  самой программы. Таким образом, бумажная работа может стать главной
  проблемой процесса создания системы. Конечно, такие проблемы могут быть
  и возникают в процессе развития больших систем. В конце концов,
  определенная работа с бумагами необходима. Но выбор линейной модели
  развития (каскад) многократно увеличивает вероятность, что эта
  проблема выйдет из-под контроля.
  Недостаток модели каскад в отсутствии повторных проходов и
  неспособности реагировать на изменения. Опасность предлагаемой здесь
  итеративной модели состоит в искушении заменить размышление и
  реальное развитие на последовательность бесконечных изменений.
  Тот и другой недостатки легче указать, чем устранить, и для того,
  кто организует работу, легко принять простую активность за реальный
  прогресс.</p>
<p>Вы можете уделять пристальное внимание деталям, использовать
  разумные приемы управления, развитую технологию, но ничто не спасет
  вас, если нет ясного понимания того, что вы пытаетесь создать. Больше
  всего проектов проваливалось именно из-за отсутствия хорошо
  сформулированных реалистичных целей, а не по какой-либо иной причине.
  Что бы вы не делали и чем бы не занимались, надо ясно представлять
  имеющиеся у вас средства, ставить достижимые цели и ориентиры и не
  искать технических решений социологических проблем. С другой стороны,
  надо применять только адекватную технологию, даже если она потребует
  затрат,- люди работают лучше, имея адекватные средства и приемлемую
  среду. Не заблуждайтесь, думая, что легко выполнить эти рекомендации.</p>

<a name="cycle"></a><h5>11.3.1 Цикл развития</h5>

<p>Процесс развития системы - это итеративная деятельность. Основной
  цикл сводится к повторяемым в следующей последовательности шагам:</p>
<ol>
<li>Создать общее описание проекта.
<li>Выделить стандартные компоненты.
<ol type="a">
  <li>Подогнать компоненты под данный проект.
  </ol>
<li>Создать новые стандартные компоненты.
<ol type="a">
  <li>Подогнать компоненты под данный проект.
  </ol>
<li>Составить уточненное описание проекта.
</ol>
<p>В качестве примера рассмотрим автомобильный завод. Проект должен
  начинаться с самого общего описания новой машины. Этот первый шаг
  базируется на некотором анализе и описании машины в самых общих
  терминах, которые скорее относятся к предполагаемому использованию,
  чем к характеристикам желаемых возможностей машины. Часто самой
  трудной частью проекта бывает выбор желаемых возможностей, или,
  точнее, определение относительно простого критерия выбора желаемых
  возможностей. Удача здесь, как правило, является
  результатом работы отдельного проницательного человека и часто
  называется предвидением. Слишком типично как раз отсутствие
  ясных целей, что приводит к неуверенно развивающимся или просто
  проваливающимся проектам.</p>
<p>Итак, допустим необходимо создать машину среднего размера с
  четырьмя дверцами и достаточно мощным мотором. Очевидно, что
  на первом этапе проекта не следует начинать проектирование машины
  (и всех ее компонентов) с нуля. Хотя программист или разработчик
  программного обеспечения в подобных обстоятельствах поступит именно
  так.</p>
<p>На первом этапе надо выяснить, какие компоненты доступны на
  вашем собственном складе и какие можно получить от надежных
  поставщиков. Найденные таким образом компоненты не обязательно
  в точности подойдут для новой машины. Всегда требуется подгонка
  компонентов. Может быть даже потребуется изменить характеристики
  "следующей версии" выбранных компонентов, чтобы сделать их
  пригодными для проекта. Например, может существовать вполне пригодный
  мотор, вырабатывающий немного меньшую мощность.Тогда
  или вы, или поставщик мотора должны предложить, не изменяя общего
  описания проекта, в качестве компенсации дополнительный
  зарядный генератор.  Заметим, что сделать это,"не изменяя общего описания
  проекта", маловероятно, если только само описание не приспособлено
  к определенной подгонке. Обычно подобная
  подгонка требует кооперации между вами и поставщиком моторов.
  Сходные вопросы возникают и у программиста или разработчика
  программного обеспечения. Здесь подгонку обычно облегчает эффективное
  использование производных классов. Но не рассчитывайте провести
  произвольные расширения в проекте без определенного предвидения
  или кооперации с создателем таких классов.</p>
<p>Когда исчерпается набор подходящих стандартных компонентов,
  проектировщик машины не спешит заняться проектированием новых
  оптимальных компонентов для своей машины. Это было бы слишком
  расточительно. Допустим, что не нашлось подходящего блока
  кондиционирования воздуха, зато есть свободное пространство, имеющее
  форму буквы L, в моторном отсеке. Возможно решение разработать
  блок кондиционирования указанной формы. Но вероятность того, что
  блок подобной странной формы будет использоваться в машинах другого
  типа (даже после значительной подгонки), крайне низка. Это означает,
  что наш проектировщик машины не сможет разделить затраты на
  производство такого блока с создателями машин другого типа, а значит
  время жизни этого блока коротко. Поэтому стоит спроектировать блок,
  который найдет более широкое применение, т.е. разработать
  разумный проект блока, более приспособленный для подгонки, чем наше
  L-образное чудище. Возможно, это потребует больших усилий, и даже
  придется для приспособления более универсального блока изменить
  общее описание проекта машины. Поскольку новый блок разрабатывался
  для более общего применения, чем наше L-образное чудище,
  предположительно, для него потребуется некоторая подгонка, чтобы
  полностью удовлетворить наши пересмотренные запросы.
  Подобная же альтернатива возникает и у программиста или разработчика
  программного обеспечения: вместо того, чтобы создать программу,
  привязанную к конкретному проекту, разработчик может спроектировать
  новую достаточно универсальную программу, которая будет иметь
  хорошие шансы стать стандартной в определенной области.</p>
<p>Наконец, когда мы прошлись по всем стандартным компонентам,
  составляется "окончательное" общее описание проекта. Несколько
  специально разработанных средств указываются как возможные. Вероятно,
  в следующем году придется для новой модели повторить наши шаги,
  и как раз эти специальные средства придется переделать или выбросить.
  Как ни печально, но опыт традиционно проектировавшихся программ
  показывает, что лишь несколько частей системы можно выделить в
  отдельные компоненты и лишь несколько из них пригодны вне
  данного проекта.</p>
<p>Мы не пытаемся утверждать, что все разработчики машин
  действуют столь разумно, как в приведенном примере, а разработчики
  программ совершают все указанные ошибки. Утверждается, что указанная
  методика разработки машин применима и для программного обеспечения.
  Так, в этой и следующей главах даны приемы использования ее для С++.
  Тем не менее можно сказать, что сама природа программирования
  способствует совершению указанных ошибок 
(п.<a href="chap12.shtml#whatis">12.2.1</a> и 
п.<a href="chap12.shtml#membship">12.2.5</a>).
  В разделе <a href="#human">11.4.3</a> опровергается 
профессиональное предубеждение против
  использования описанной здесь модели проектирования.</p>
<p>Заметим, что модель развития программного обеспечения хорошо
  применима только в расчете на большие сроки. Если ваш горизонт
  сужается до времени выдачи очередной версии, нет смысла создавать
  и поддерживать функционирование стандартных компонентов. Это
  просто приведет к излишним накладным расходам. Наша модель
  рассчитана на организации со временем жизни, за которое проходит
  несколько проектов, и с размерами, которые позволяют нести
  дополнительные расходы и на средства проектирования, программирования,
  и на сопровождение проектов, и на повышение квалификации разработчиков,
  программистов и менеджеров. Фактически это эскиз некоторой фабрики по
  производству программ. Как ни удивительно, она только масштабом
  отличается от действий лучших программистов, которые для повышения своей
  производительности в течении лет накапливали запас приемов и методов
  проектирования, создавали инструменты и библиотеки. Похоже, что
  большинство организаций просто не умеет воспользоваться достижениями
  лучших сотрудников, как из-за отсутствия предвидения, так и по
  неспособности применить эти достижения в достаточно широком
  объеме.</p>
<p>Все-таки неразумно требовать, чтобы "стандартные компоненты"
  были стандартными универсально. Существует лишь малое число
  международных стандартных библиотек, а в своем большинстве компоненты
  окажутся стандартными только в пределах страны, отрасли, компании,
  производственной цепочки, отдела или области приложения и т.д.
  Просто мир слишком велик, чтобы универсальный стандарт
  всех компонентов и средств был реальной или желанной целью проекта.</p>


<a name="design"></a><h5>11.3.2 Цели проектирования</h5>

<p>Каковы самые общие цели проектирования? Конечно, простота, но в чем
  критерий простоты? Поскольку мы считаем, что проект должен развиваться
  во времени, т.е. система будет расширяться, переноситься,
  настраиваться и, вообще, изменяться массой способов, которые невозможно
  предусмотреть, необходимо стремиться к такой системе проектирования
  и реализации, которая была бы простой с учетом, что она будет
  меняться многими способами. На самом деле, практично допустить,
  что сами требования к системе будут меняться неоднократно за период
  от начального проекта до выдачи первой версии системы.</p>
<p>Вывод таков: система должна проектироваться максимально простой
  при условии, что она будет подвергаться серии изменений. Мы должны
  проектировать в расчете на изменения, т.е. стремиться к</ul>
<ul>
<li>гибкости,
<li>расширяемости и
<li>переносимости
</ul>
<p>Лучшее решение - выделить части системы, которые вероятнее всего будут
  меняться, в самостоятельные единицы, и предоставить программисту или
  разработчику гибкие возможности для модификаций таких единиц. Это
  можно сделать, если выделить ключевые для данной задачи понятия
  и предоставить класс, отвечающий за всю информацию, связанную с
  отдельным понятием (и только с ним). Тогда изменение будет затрагивать
  только определенный класс. Естественно, такой идеальный способ
  гораздо легче описать, чем воплотить.</p>
<p>Рассмотрим пример: в задаче моделирования метеорологических
  объектов нужно представить дождевое облако. Как это сделать?
  У нас нет общего метода изображения облака, поскольку его вид зависит
  от внутреннего состояния облака, а оно может быть задано только
  самим облаком.</p>
<p>Первое решение: пусть облако изображает себя само. Оно подходит
  для многих ограниченных приложений. Но оно не является достаточно
  общим, поскольку существует много способов представления облака:
  детальная картина, набросок очертаний, пиктограмма, карта и т.п.
  Другими словами, вид облака определяется как им самим, так и его
  окружением.</p>
<p>Второе решение заключается в том, чтобы предоставить самому облаку
  для его изображения сведения о его окружении. Оно годится для
  большего числа случаев. Однако и это не общее решение. Если мы
  предоставляем облаку сведения об его окружении, то нарушаем основной
  постулат, который требует, чтобы класс отвечал только за одно
  понятие, и каждое понятие воплощалось определенным классом.
  Может оказаться невозможным предложить согласованное определение
  "окружения облака", поскольку, вообще говоря, как выглядит облако
  зависит от самого облака и наблюдателя. Чем представляется облако
  мне, сильно зависит от того, как я смотрю на него: невооруженным
  глазом, с помощью поляризационного фильтра, с помощью метеорадара и т.д.
  Помимо наблюдателя и облака следует учитывать и "общий фон", например,
  относительное положение солнца. К дальнейшему усложнению картины
  приводит добавление новых объектов типа других облаков, самолетов.
  Чтобы сделать задачу разработчика практически неразрешимой, можно
  добавить возможность одновременного существования нескольких
  наблюдателей.</p>
<p>Третье решение состоит в том, чтобы облако, а также и другие
  объекты, например, самолеты или солнце, сами описывали себя по
  отношению к наблюдателю. Такой подход обладает достаточной
  общностью, чтобы удовлетворить большинство запросов+. Однако,
  он может привести к значительному усложнению и большим накладным
  расходам при выполнении. Как, например, добиться того, чтобы
  наблюдатель понимал описания, произведенные облаком или другими
  объектами?</p>

<p>+ Даже эта модель будет, по всей видимости, не достаточной для таких
    предельных случаев, как графика с высокой степенью разрешимости.
    Я думаю, что для получения очень детальной картины нужен другой
    уровень абстракции.</p>

<p>Дождевые облака - это не тот объект, который часто встретишь
  в программах, но объекты, участвующие в различных операциях ввода
  и вывода, встречаются часто. Поэтому можно считать пример с облаком
  пригодным для программирования вообще и для разработки библиотек
  в частности. Логически схожий пример в С++ представляют манипуляторы,
  которые используются для форматирования вывода в потоковом
  вводе-выводе (п.<a href="chap10.shtml#manipul">10.4.2</a>). 
Заметим, что третье решение не есть "верное
  решение", это просто более общее решение. Разработчик должен
  сбалансировать различные требования системы, чтобы найти уровень
  общности и абстракции, пригодный для данной задачи в данной области.
  Золотое правило: для программы с долгим сроком жизни правильным
  будет самый общий уровень абстракции, который вам еще понятен и
  который вы можете себе позволить, но не обязательно абсолютно
  общий. Обобщение, выходящее за пределы данного проекта и
  понятия людей, в нем участвующих, может принести вред, т.е.
  привести к задержкам, неприемлемым характеристикам, неуправляемым
  проектам и просто к провалу.</p>
<p>Чтобы использование указанных методов было экономично и
  поддавалось управлению, проектирование и управление должно
  учитывать повторное использование, о чем говорится в 
п.<a href="#reuse">11.4.1</a> и
  не следует совсем забывать об эффективности (см. 
п.<a href="#efficient">11.3.7</a>).</p>

<a name="steps"></a><h5>11.3.3 Шаги проектирования</h5>

<p>Рассмотрим проектирование отдельного класса. Обычно это не лучший
  метод. Понятия не существуют изолированно, наоборот, понятие
  определяется в связи с другими понятиями. Аналогично и класс не
  существует изолированно, а определяется совместно с множеством
  связанных между собой классов. Это множество часто называют
  библиотекой классов или компонентом. Иногда все классы компонента
  образуют единую иерархию, иногда это не так (см. 
п.<a href="chap12.shtml#component">12.3</a>).</p>
<p>Множество классов компонента бывают объединены некоторым логическим
  условием, иногда это - общий стиль программирования или описания,
  иногда - предоставляемый сервис. Компонент является единицей
  проектирования, документации, права собственности и,
  часто, повторного использования.
  Это не означает, что если вы используете один класс компонента, то
  должны разбираться во всех и уметь применять все классы компонента или
  должны подгружать к вашей программе модули всех классов компонента. В
  точности наоборот, обычно стремятся обеспечить, чтобы использование
  класса вело к минимуму накладных расходов: как машинных ресурсов,
  так и человеческих усилий. Но для использования любого класса
  компонента нужно понимать логическое условие, которое его
  определяет (можно надеяться, что оно предельно ясно изложено в
  документации), понимать соглашения и стиль, примененный в процессе
  проектирования и описания компонента, и доступный сервис (если он
  есть).</p>
<p>Итак, перейдем к способам проектирования компонента. Поскольку
  часто это непростая задача, имеет смысл разбить ее на шаги и,
  сконцентрировавшись на подзадачах, дать полное и последовательное
  описание. Обычно нет единственно правильного способа разбиения.
  Тем не менее, ниже приводится описание последовательности шагов,
  которая пригодилась в нескольких случаях:</p>
<ol>
<li>Определить понятие / класс и установить основные связи
        между ними.
<li>Уточнить определения классов, указав набор операций для
        каждого.
  <ol type="a">
  <li>Провести классификацию операций. В частности уточнить
            необходимость построения, копирования и уничтожения.
  <li>Убедиться в минимальности, полноте и удобстве.
  </ol>
<li>Уточнить определения классов, указав их зависимость от
        других классов.
  <ol type="a">
  <li>Наследование.
  <li>Использование зависимостей.
  </ol>
<li>Определить интерфейсы классов.
  <ol type="a">
  <li>Поделить функции на общие и защищенные.
  <li>Определить точный тип операций класса.
  </ol>
</ol>
<p>Отметим, что это шаги итеративного процесса. Обычно для получения
  проекта, который можно уверенно использовать для первичной реализации
  или повторной реализации, нужно несколько раз проделать
  последовательность шагов. Одним из преимуществ глубокого анализа и
  предложенной здесь  абстракции  данных  оказывается относительная
  легкость, с которой можно перестроить взаимоотношения классов
  даже после программирования каждого класса. Хотя это никогда не
  бывает просто.</p>
<p>Далее следует приступить к реализации классов, а затем
  вернуться, чтобы оценить проект, исходя из опыта реализации.
  Рассмотрим эти шаги в отдельности.</p>

<a name="step1"></a><h6>11.3.3.1 Шаг 1: определение классов</h6>

<p>Определите понятия/классы и установите основные связи между ними.
  Главное в хорошем проекте - прямо отразить какое-либо понятие
  "реальности", т.е. уловить понятие из области приложения классов,
  представить взаимосвязь между классами строго определенным способом,
  например, с помощью наследования, и повторить эти действия на
  разных уровнях абстракции. Но как мы можем уловить эти понятия?
  Как на практике решить, какие нам нужны классы?</p>
<p>Лучше поискать ответ в самой области приложения, чем рыться
  в программистском хранилище абстракций и понятий. Обратитесь к тому,
  кто стал экспертом по работе в некогда сделанной системе, а также
  к тому, кто стал критиком системы, пришедшей ей на смену. Запомните
  выражения того и другого.</p>
<p>Часто говорят, что существительные играют роль классов и объектов,
  используемых в программе, это действительно так. Но это только начало.
  Далее, глаголы могут представлять операции над объектами или
  обычные (глобальные) функции, вырабатывающие новые значения, исходя
  из своих параметров, или даже классы. В качестве примера
  можно рассматривать функциональные объекты, описанные в 
п.<a href="chap10.shtml#manipul">10.4.2</a>.
  Такие глаголы, как "повторить" или "совершить" (commit) могут быть
  представлены итеративным объектом или объектом, представляющим
  операцию выполнения программы в базах данных.
  Даже прилагательные можно успешно
  представлять с помощью классов, например, такие, как "хранимый",
  "параллельный", "регистровый", "ограниченный". Это могут быть классы,
  которые помогут разработчику или программисту, задав виртуальные
  базовые классы, специфицировать и выбрать нужные свойства для
  классов, проектируемых позднее.</p>
<p>Лучшее средство для поиска этих понятий / классов - грифельная
  доска, а лучший метод первого уточнения - это беседа со специалистами
  в области приложения или просто с друзьями. Обсуждение необходимо,
  чтобы создать начальный жизнеспособный словарь терминов и понятийную
  структуру. Мало кто может сделать это в одиночку. Обратитесь к [<a href="chap0.shtml#book1">1</a>],
  чтобы узнать о методах подобных уточнений.</p>
<p>Не все классы соответствуют понятиям из области приложения.
  Некоторые могут представлять ресурсы системы или абстракции
  периода реализации (см. п.<a href="chap12.shtml#whatis">12.2.1</a>).</p>
<p>Взаимоотношения, о которых мы говорим, естественно устанавливаются
  в области приложения или (в случае повторных проходов по шагам
  проектирования) возникают из последующей работы над структурой классов.
  Они отражают наше понимание основ области приложения. Часто они
  являются классификацией основных понятий. Пример такого отношения:
  машина с выдвижной лестницей есть грузовик, есть пожарная машина,
  есть движущееся средство.
  В п.<a href="#step2">11.3.3.2</a> и п.<a href="#reorg">11.3.3.5</a> 
предлагается некоторая точка зрения на
  классы и иерархию классов, если необходимо улучшить их структуру.</p>

<a name="step2"></a><h6>11.3.3.2 Шаг 2: определение набора операций</h6>

<p>Уточните определения классов, указав набор операций для каждого.
  В действительности нельзя разделить процессы определения классов и
  выяснения того, какие операции для них нужны. Однако, на практике
  они различаются, поскольку при определении классов внимание
  концентрируется на основных понятиях, не останавливаясь
  на программистских вопросах их реализации, тогда как при определении
  операций прежде всего сосредотачивается на том, чтобы задать полный и
  удобный набор операций. Часто бывает слишком трудно совместить оба
  подхода, в особенности, учитывая, что связанные классы надо
  проектировать одновременно.</p>
<p>Возможно несколько подходов к процессу определения набора операций.
  Предлагаем следующую стратегию:</p>
<ol>
<li>Рассмотрите, каким образом объект класса будет создаваться,
         копироваться (если нужно) и уничтожаться.
<li>Определите минимальный набор операций, который необходим
         для понятия, представленного классом.
<li>Рассмотрите операции, которые могут быть добавлены для удобства
         записи, и включите только несколько действительно важных.
<li>Рассмотрите, какие операции можно считать тривиальными, т.е.
         такими, для которых класс выступает в роли интерфейса для
         реализации производного класса.
<li>Рассмотрите, какой общности именования и функциональности
         можно достигнуть для всех классов компонента.
</ol>
<p>Очевидно, что это - стратегия минимализма. Гораздо проще добавлять
  любую функцию, приносящую ощутимую пользу, и сделать все операции
  виртуальными. Но, чем больше функций, тем больше вероятность, что
  они не будут использоваться, наложат определенные ограничения на
  реализацию и затруднят эволюцию системы. Так, функции, которые
  могут непосредственно читать и писать в переменную состояния объекта
  из класса, вынуждают использовать единственный способ реализации и
  значительно сокращают возможности перепроектирования. Такие функции
  снижают уровень абстракции от понятия до его конкретной реализации.
  К тому же добавление функций добавляет работы программисту и
  даже разработчику, когда он вернется к проектированию. Гораздо
  легче включить в интерфейс еще одну функцию, как только
  установлена потребность в ней, чем удалить ее оттуда, когда уже
  она стала привычной.</p>
<p>Причина, по которой мы требуем явного принятия решения о
  виртуальности данной функции, не оставляя его на стадию реализации,
  в том, что, объявив функцию виртуальной, мы существенно повлияем
  на использование ее класса и на взаимоотношения этого класса с
  другими. Объекты из класса, имеющего хотя бы одну виртуальную
  функцию, требуют нетривиального распределения памяти, если сравнить
  их с объектами из таких языков как С или Фортран. Класс с хотя бы
  одной виртуальной функцией по сути выступает в роли интерфейса
  по отношению к классам, которые "еще могут быть определены", а
  виртуальная функция предполагает зависимость от классов, которые
  "еще могу быть определены" (см. 
п.<a href="chap12.shtml#depend">12.2.3</a>)</p>
<p>Отметим, что стратегия минимализма требует, пожалуй, больших
  усилий со стороны разработчика.</p>
<p>При определении набора операций больше внимания следует уделять
  тому, что надо сделать, а не тому, как это делать.</p>
<p>Иногда полезно классифицировать операции класса по тому,
  как они работают с внутренним состоянием объектов:</p>
<ul>
<li>Базовые операции: конструкторы, деструкторы, операции копирования.
<li>Селекторы: операции, не изменяющие состояния объекта.
<li>Модификаторы: операции, изменяющие состояние объекта.
<li>Операции преобразований, т.е. операции порождающие объект
      другого типа, исходя из значения (состояния) объекта, к которому
      они применяются.
<li>Повторители: операции, которые открывают доступ к объектам класса
      или используют последовательность объектов.
</ul>
<p>Это не есть разбиение на ортогональные группы операций. Например,
  повторитель может быть спроектирован как селектор или модификатор.
  Выделение этих групп просто предназначено помочь в процессе
  проектирования интерфейса класса. Конечно, допустима и другая
  классификация. Проведение такой классификации особенно полезно для
  поддержания непротиворечивости между классами в рамках одного
  компонента.</p>
<p>В языке С++ есть конструкция, помогающая заданию селекторов и
  модификаторов в виде функции-члена со спецификацией const и без нее.
  Кроме того, есть средства, позволяющие явно задать конструкторы,
  деструкторы и функции преобразования. Операция копирования реализуется
  с помощью операций присваивания и конструкторов копирования.</p>

<a name="step3"></a><h6>11.3.3.3 Шаг 3: указание зависимостей</h6>

<p>Уточните определение классов, указав их зависимости от других классов.
  Различные виды зависимостей обсуждаются в 
п.<a href="chap12.shtml#class">12.2</a>. Основными по
  отношению к проектированию следует считать отношения наследования
  и использования. Оба предполагают понимание того, что значит для
  класса отвечать за определенное свойство системы. Отвечать за что-либо
  не означает, что класс должен содержать в себе всю информацию, или,
  что его функции-члены должны сами проводить все необходимые операции.
  Как раз наоборот, каждый класс, имеющий определенный уровень
  ответственности, организует работу, перепоручая ее в виде
  подзадач другим классам, которые имеют меньший уровень ответственности.
  Но надо предостеречь, что злоупотребление этим приемом приводит
  к неэффективным и плохо понимаемым проектам, поскольку
  происходит размножение классов и объектов до такой степени, что
  вместо реальной работы производится только серия запросов на
  ее выполнение. То, что можно сделать в данном месте, следует
  сделать.</p>
<p>Необходимость учесть отношения наследования и использования
  на этапе проектирования (а не только в процессе реализации) прямо
  вытекает из того, что классы представляют определенные понятия.
  Отсюда также следует, что именно компонент (т.е. множество
  связанных классов), а не отдельный класс, являются единицей
  проектирования.</p>

<a name="step4"></a><h6>11.3.3.4 Шаг 4: определение интерфейсов</h6>

<p>Определите интерфейсы классов. На этой стадии проектирования не нужно
  рассматривать приватные функции. Вопросы реализации, возникающие на
  стадии проектирования, лучше всего обсуждать на шаге 3 при
  рассмотрении различных зависимостей. Более того, существует
  золотое правило: если класс не допускает по крайней мере двух
  существенно отличающихся реализаций, то что-то явно не в порядке с этим
  классом, это просто замаскированная реализация, а не представление
  абстрактного понятия. Во многих случаях для ответа на вопрос:
  "Достаточно ли интерфейс класса независим от реализации?"- надо
  указать, возможна ли для класса схема ленивых вычислений.</p>
<p>Отметим, что общие базовые классы и друзья (friend) являются
  частью общего интерфейса класса (см. 
п.<a href="chap5.shtml#friend">5.4.1</a> и 
п.<a href="chap12.shtml#interf">12.4</a>). Полезным
  упражнением может быть определение раздельного интерфейса для
  классов-наследников и всех остальных классов с помощью разбиения
  интерфейса на общую и закрытые части.</p>
<p>Именно на этом шаге следует продумать и описать точные определения
  типов аргументов. В идеале желательно иметь максимальное число
  интерфейсов со статическими типами, относящимися к области приложения
  (см. п.<a href="chap12.shtml#igntype">12.1.3</a> и 
п.<a href="chap12.shtml#interf">12.4</a>).</p>
<p>При определении интерфейсов следует обратить внимание на те
  классы, где набор операций представлен более, чем на одном уровне
  абстракции. Например, в классе file у некоторых функций-членов
  аргументы имеют тип file_descriptor (дескриптор_файла), а у других
  аргументы - строка символов, которая обозначает имя файла.
  Операции с file_descriptor работают на другом уровне (меньшем)
  абстракции, чем операции с именем файла, так что даже странно,
  что они относятся к одному классу. Возможно, было бы лучше иметь
  два класса: один представляет понятие дескриптора файла, а
  другой - понятие имени файла. Обычно все операции класса должны
  представлять понятия одного уровня абстракции. Если это не так,
  то стоит подумать о реорганизации и его, и связанных с ним классов.</p>

<a name="reorg"></a><h6>11.3.3.5 Перестройка иерархии классов</h6>

<p>Шаги 1 и 3 требуют исследования классов и их иерархии, чтобы
  убедиться, что они адекватно отвечают нашим требованиям. Обычно
  это не так, и приходится проводить перестройку для улучшения
  структуры, проекта или реализации.</p>
<p>Самая типичная перестройка иерархии классов состоит в выделении
  общей части двух классов в новый класс или в разбиении класса на два
  новых. В обоих случаях в результате получится три класса:
  базовый класс и два
  производных. Когда следует проводить такую перестройку? Каковы
  общие показания, что такая перестройка будет полезной?</p>
<p>К сожалению нет простого и универсального ответа на эти
  вопросы. Это и не удивительно, поскольку то, что предлагается,
  не является мелочью при реализации, а изменяет основные
  понятия системы. Важной и нетривиальной задачей является поиск
  общности среди классов и выделение общей части.  Нет точного
  определения общности, но следует обращать внимание на общность
  для понятий системы, а не просто для удобства реализации. Указаниями,
  что два класса имеют нечто общее, что возможно выделить в общий базовый
  класс, служат схожие способы использования, сходство наборов операций,
  сходство реализаций и просто тот факт, что часто в процессе обсуждения
  проекта оба   класса   появляются  одновременно.  С другой
  стороны,  если  есть
  несколько наборов операций класса с различными способами использования,
  если эти наборы обеспечивают доступ к раздельным подмножествам объектов
  реализации, и, если класс возникает в процессе обсуждения несвязанных
  тем, то этот класс является явным кандидатом для разбиения на части.</p>
<p>В силу тесной связи между понятиями и классами проблемы
  перестройки иерархии классов высвечиваются на поверхности проблем
  именования классов и использования имен классов в процессе обсуждения
  проекта. Если имена классов и их упорядоченность, задаваемая иерархией
  классов, кажутся неудобными при обсуждении проекта, значит, по всей
  видимости, есть возможность улучшения иерархии. Заметим, что
  подразумевается, что анализ иерархии классов лучше проводить не в
  одиночку. Если вы оказались в таком положении, когда не с кем
  обсудить проект, хорошим выходом будет попытаться составить учебное
  описание системы, используя имена классов.</p>

<a name="models"></a><h6>11.3.3.6 Использование моделей</h6>

<p>Когда пишешь статью, пытаешься найти подходящую для темы модель. Нужно
  не бросаться сразу печатать текст, а поискать статьи на сходные темы,
  вдруг найдется такая, которая может послужить отправной точкой.
  Если ею окажется моя собственная статья, то можно будет использовать
  даже куски из нее, изменяя по мере надобности другие части, и вводить
  новую информацию только там, где требует логика предмета. Таким
  образом, исходя из первого издания, написана эта книга. Предельный
  случай такого подхода - это написание открытки-формуляра, где просто
  нужно указать имя и, возможно, добавить пару строк для придания
  "личного" отношения. По сути такие открытки пишутся с указанием отличия
  от стандарта.</p>
<p>Во всех видах творческой деятельности использование существующих
  систем в качестве моделей для новых проектов является скорее правилом,
  а не исключением. Всегда, когда это возможно, проектирование и
  программирование должны основываться на предыдущих работах. Это
  сокращает степени свободы для разработчика и позволяет сосредоточить
  внимание на меньшем числе вопросов в заданное время. Начать большой
  проект "практически с нуля" - это может возбуждать, но правильнее будет
  употребить термин "опьянение", которое приведет к "пьяному
  блужданию" в множестве вариантов. Построение модели не накладывает
  каких-либо ограничений и не означает покорного следования ей, это
  просто освобождает разработчика от некоторых вопросов.</p>
<p>Заметим, что на самом деле использование моделей неизбежно,
  поскольку каждый проект синтезируется из опыта его разработчиков.
  Лучше, когда использование модели является явно сформулированным
  решением, тогда все допущения делаются явно, определяется общий
  словарь терминов, появляется начальный каркас проекта и увеличивается
  вероятность того, что у разработчиков есть общий подход.</p>
<p>Естественно, что выбор начальной модели является важным решением,
  и обычно оно принимается только после поиска потенциальных моделей
  и тщательной оценки вариантов. Более того, во многих случаях модель
  подходит только при условии понимания того, что потребуются
  значительные изменения для воплощения ее идей в иной области
  приложения. Но проектирование программного обеспечения - тяжелый
  труд, и надо использовать любую помощь. Не следует отказываться
  от использования моделей из-за неоправданного пренебрежения к
  имитации. Имитация - не что иное, как форма искреннего восхищения,
  а, с учетом права собственности и авторского права, использование
  моделей и предшествующих работ в качестве источника вдохновения -
  допустимый способ для всех новаторских работ во всех видах
  деятельности. То, что было позволено Шекспиру, подходит и для нас.
  Некоторые обозначают использование моделей в процессе проектирования
  как "проектирование повторного использования".</p>

<a name="experim"></a><h5>11.3.4 Эксперимент и анализ</h5>

<p>В начале честолюбивого проекта нам неизвестен лучший способ построения
  системы. Часто бывает так, что мы даже не знаем точно, что должна
  делать система, поскольку конкретные факты прояснятся только в процессе
  построения, тестирования и эксплуатации системы. Как задолго до
  создания законченной системы получить сведения, необходимые для
  понимания того, какие решения при проектировании окажутся
  существенными, и к каким последствиям они приведут?</p>
<p>Нужно проводить эксперименты. Конечно, нужен анализ проекта и его
  реализации, как только появляется пища для него. Преимущественно
  обсуждение вертится вокруг альтернатив при проектировании и
  реализации. За исключением редких случаев проектирование есть
  социальная активность, которая ведет по пути презентации и
  обсуждений. Часто самым важным средством проектирования оказывается
  простая грифельная доска; без нее идеи проекта, находящиеся в
  зародыше, не могут развиться и стать общим достоянием в среде
  разработчиков и программистов.</p>
<p>Похоже, что самый популярный способ проведения эксперимента сводится
  к построению прототипа, т.е. уменьшенной версии системы. Прототип не
  обязан удовлетворять характеристикам реальных систем, обычно в
  изобилии есть машинные ресурсы и программная поддержка, и в таких
  условиях программисты и разработчики становятся непривычно опытными,
  хорошо образованными и активными. Появляется цель - сделать
  работающий прототип как можно скорее, чтобы начать исследование
  вариантов проекта и способов реализации.</p>
<p>Такой подход, если применять его разумно, может привести к
  успеху. Но он также может служить оправданием неудачно сделанных
  систем. Дело в том, что уделяя особое внимание прототипу, можно
  прийти к смещению усилий от "исследование вариантов
  проекта" к "получение как можно скорее рабочей версии системы".
  Тогда быстро угаснет интерес к внутренней структуре прототипа
  ("ведь это только прототип"), а работа по проектированию будет
  вытесняться манипулированием с реализацией прототипа.  Просчет
  заключается в том, что такая реализация может легко привести к системе,
  которая имеет вид "почти законченной", а по сути является пожирателем
  ресурсов и кошмаром для тех, кто ее сопровождает. В этом
  случае на прототип тратятся время и энергия, которые лучше приберечь
  для реальной системы. Для разработчиков и менеджеров есть искушение
  переделать прототип в конечный программный продукт, а "искусство
  настройки системы" отложить до выпуска следующей версии. Если идти
  таким путем, то прототипы отрицают все основы проектирования.</p>
<p>Сходная проблема возникает, если исследователи привязываются
  к тем средствам, которые они создали при построении прототипа,
  и забывают, что они могут оказаться непригодными для
  рабочей системы, и что свобода от ограничений и формальностей, к
  которой они привыкли, работая в небольшой группе, может оказаться
  невозможной в большом коллективе, бьющимся над устранением длинной
  цепи препятствий.</p>
<p>И в то же время создание прототипов может сыграть важную роль.
  Рассмотрим, например, проектирование пользовательского интерфейса. Для
  этой задачи внутренняя структура той части системы, которая прямо не
  общается с пользователем, обычно не важна, и использование прототипов -
  это единственный способ узнать,
  какова будет реакция пользователя при работе с системой.
  Другим примером служат прототипы, прямо предназначенные для изучения
  внутренней структуры системы. Здесь уже интерфейс с пользователем
  может быть примитивным, возможна работа с моделью пользователей.</p>
<p>Использование прототипов - это способ экспериментирования.
  Ожидаемый результат - это более глубокое понимание целей, а не
  сам прототип. Возможно, сущность прототипа заключается в том,
  что он является настолько неполным, что может служить лишь средством
  для эксперимента, и его нельзя превратить в конечный продукт без
  больших затрат на перепроектирование и на другую реализацию. Оставляя
  прототип "неполным", мы тем самым переключаем внимание на
  эксперимент и уменьшаем опасность превращения прототипа в законченный
  продукт. Это также почти избавляет от искушения взять за основу
  проекта системы проект прототипа, при этом забывая или игнорируя те
  ограничения, которые внутренне присущи прототипу. После эксперимента
  прототип надо просто выбросить.</p>
<p>Не следует забывать о других способах проведения эксперимента,
  которые могут служить во многих случаях альтернативой созданию прототипа,
  и там, где они применимы, их использование предпочтительнее, поскольку
  они обладают большей точностью и требуют меньших затрат
  времени разработчика и ресурсов системы. Примерами могут служить
  математические модели и различные формы моделирования. По сути,
  существует бесконечная возрастающая последовательность,
  начиная от математических моделей,
  ко все более и более детальным способам моделирования, затем к
  прототипам, к частичным реализациям системы, вплоть до полной системы.</p>
<p>Это подводит к идее построения системы, исходя из начального
  проекта и реализации, и двигаясь путем повторного прохождения
  этапов проектирования и реализации. Это идеальная стратегия,
  но она предъявляет высокие требования к средствам проектирования
  и реализации, и в ней содержится определенный риск того, что
  программный объем, реализующий решения, принятые
  при начальном проектировании, в процессе развития вырастет до такой
  величины, что существенное улучшение проекта будет просто невозможно.</p>
<p>Похоже, что по крайней мере теперь такую стратегию применяют
  или в проектах от малого до среднего размеров, т.е. там, где
  маловероятны переделки общего проекта, или же для перепроектирования
  и иной реализации после выдачи первоначальной версии системы, где
  указанная стратегия становится неизбежной.</p>
<p>Помимо экспериментов, предназначенных для оценки решений,
  принимаемых на этапе проектирования, источником получения полезной
  информации может быть анализ собственно проектирования и (или)
  реализации. Например, может оказаться полезным изучение различных
  зависимостей между классами 
(см. п.<a href="chap12.shtml#class">12.2</a>), не следует забывать и о
  таких традиционных вспомогательных средствах реализации, как
  граф вызовов функций, оценка производительности и т.п.</p>
<p>Заметим, что спецификация (результат анализа системы) и проект
  могут содержать ошибки, как и реализация, и возможно, они даже
  больше подвержены ошибкам, т.к. являются менее точными, не могут быть
  проверены на практике и обычно не окружены такими развитыми средствами,
  как те, что служат для анализа и проверки реализации. Введение
  большей формализации в язык или запись, с помощью которой изложен проект,
  в какой-то степени облегчает использования этих средств для
  проектирования. Но, как сказано в 
п.<a href="chap12.shtml#ignclass">12.1.1</a>, это нельзя делать
  за счет ухудшения языка, используемого для реализации. К тому
  же формальная запись может сама стать источником трудностей и
  проблем. Это происходит, когда выбранная степень формализации плохо
  подходит для конкретных задач, когда строгость формализации превосходит
  математическую основу системы и квалификацию разработчиков и
  программистов, и когда формальное описание системы начинает
  расходиться с реальной системой, для которой оно предназначалось.</p>
<p>Заключение о необходимости опыта и о том, что проектирование
  неизбежно сопровождается ошибками и плохо поддержано программными
  средствами, служит основным доводом в пользу итеративной модели
  проектирования и реализации. Альтернатива - это линейная модель
  процесса развития, начиная с анализа и кончая тестированием, но
  она существенно дефектна, поскольку не допускает повторных
  проходов, исходя из опыта, полученного на различных этапах развития
  системы.</p>


<a name="test"></a><h5>11.3.5 Тестирование</h5>

<p>Программа, которая не прошла тестирование, не работает. Идеал, чтобы
  после проектирования и (или) верификации программа заработала с
  первого раза, недостижим для всех, за исключением самых тривиальных
  программ. Следует стремиться к идеалу, но не заблуждаться, что
  тестирование простое дело.</p>
<p>"Как проводить тестирование?" - на этот вопрос нельзя ответить
  в общем случае. Однако, вопрос "Когда начинать тестирование?" имеет
  такой ответ - на самом раннем этапе, где это возможно. Стратегия
  тестирования должна быть разработана как часть проекта и включена
  в реализацию, или, по крайней мере, разрабатываться параллельно
  с ними. Как только появляется работающая система, надо начинать
  тестирование. Откладывание тестирования до "проведения полной
  реализации" - верный способ выйти из графика или передать версию
  с ошибками.</p>
<p>Всюду, где это возможно, проектирование должно вестись так,
  чтобы тестировать систему было достаточно просто. В частности,
  имеет смысл средства тестирования прямо встраивать в систему.
  Иногда это не делается из-за боязни слишком объемных проверок на
  стадии выполнения, или из-за опасений, что избыточность, необходимая
  для полного тестирования, излишне усложнит структуры данных.
  Обычно такие опасения неоправданы, поскольку собственно программы
  проверки и дополнительные конструкции, необходимые для них,
  можно при необходимости удалить из системы перед ее поставкой
  пользователю. Иногда могут пригодится утверждения о свойствах
  программы (см. п.<a href="chap12.shtml#inclass">12.2.7</a>).</p>
<p>Более важной, чем набор тестов, является подход, когда
  структура системы такова, что есть реальные шансы убедить себя
  и пользователей, что ошибки можно исключить с помощью определенного
  набора статических проверок, статического анализа и тестирования.
  Если разработана стратегия построения системы, устойчивой к ошибкам
  (см.п.<a href="chap9.shtml#exercise">9.8</a>), стратегия 
тестирования обычно разрабатывается как вспомогательная.</p>
<p>Если вопросы тестирования полностью игнорируются на этапе
  проектирования, возникнут проблемы с тестированием, временем
  поставки и сопровождением системы. Лучше всего начать работать
  над стратегией тестирования с интерфейсов классов и их
  взаимозависимостей (как предлагается в 
п.<a href="chap12.shtml#class">12.2</a> и 
п.<a href="chap12.shtml#interf">12.4</a>).</p>
<p>Трудно определить необходимый объем тестирования. Однако,
  очевидно, что проблему представляет недостаток тестирования,
  а не его избыток. Сколько именно ресурсов в сравнении с проектированием
  и реализацией следует отвести для тестирования зависит от
  природы системы и методов ее построения. Однако, можно предложить
  следующее правило: отводить больше ресурсов времени и человеческих
  усилий на тестирование системы, чем на получения ее первой реализации.</p>

<a name="support"></a><h5>11.3.6 Сопровождение</h5>

<p>"Сопровождение программного обеспечения" - неудачный термин. Слово
  "сопровождение" предлагает неверную аналогию с аппаратурой. Программы
  не требуют смазки, не имеют движущихся частей, которые изнашиваются
  так, что требуют замены, у них нет трещин, в которые попадает
  вода, вызывая ржавчину. Программы можно воспроизводить в точности
  и передавать в течении минуты на длинные расстояния. Короче,
  программы это совсем не то, что аппаратура. (В оригинале:
  "Software is not hardware").</p>
<p>Деятельность, которая обозначается, как сопровождение программ,
  на самом деле, состоит из перепроектирования и повторной реализации,
  а значит входит в обычный цикл развития программного обеспечения.
  Если в проекте учтены вопросы расширяемости, гибкости и переносимости,
  то обычные задачи сопровождения решаются естественным образом.</p>
<p>Подобно тестированию задачи сопровождения не должны решаться
  вне основного направления развития проекта и их не следует откладывать
  на потом.</p>

<a name="efficient"></a><h5>11.3.7 Эффективность</h5>

<p>Д. Кнуту принадлежит утверждение "Непродуманная оптимизация - корень
  всех бед". Некоторые слишком хорошо убедились в справедливости этого
  и считают вредными все заботы об оптимизации. На самом деле вопросы
  эффективности надо все время иметь в виду во время проектирования и
  реализации. Это не означает, что разработчик должен заниматься
  задачами локальной оптимизации, только задача оптимизации на самом
  глобальном уровне должна его волновать.</p>
<p>Лучший способ добиться эффективности - это создать ясный и
  простой проект. Только такой проект может остаться относительно
  устойчивым на весь период развития и послужить основой для
  настройки системы с целью повышения производительности. Здесь
  важно избежать "гаргантюализма", который является проклятием
  больших проектов. Слишком часто люди добавляют определенные
  возможности системы "на всякий случай" (см. 
п.<a href="#step2">11.3.3.2</a> и п.<a href="#human">11.4.3</a>),
  удваивая, учетверяя размер выполняемой программы ради завитушек.
  Еще хуже то, что такие усложненные системы трудно поддаются
  анализу, а по этому трудно отличить избыточные накладные расходы
  от необходимых и провести анализ и оптимизации на общем уровне.
  Оптимизация должна быть результатом анализа и оценки производительности
  системы, а не произвольным манипулированием с программным кодом,
  причем это особенно справедливо для больших систем, где интуиция
  разработчика или программиста не может служить надежным указателем
  в вопросах эффективности.</p>
<p>Важно избегать по сути неэффективных конструкций, а так же
  таких конструкций, которые можно довести до приемлемого уровня
  выполнения, только затратив массу времени и усилий. По этой же
  причине важно свести к минимуму использование непереносимых по
  своей сути конструкций и средств, поскольку их наличие препятствует
  работе системы на других машинах (менее мощных, менее дорогих).</p>

<a name="control"></a><h4>11.4 Управление проектом</h4>

<p>Если только это имеет какой-то смысл, большинство людей делает то,
  что их поощряют делать. Так, в контексте программного проекта, если
  менеджер поощряет определенные способы действий и наказывает за
  другие, редкие программисты или разработчики рискнут своим
  положением, встречая сопротивления или безразличия администрации,
  чтобы делать так, как они полагают нужным+.</p>

<p>+ Организация, в которой считают своих программистов недоумками,
  очень скоро получит программистов, которые будут рады и способны
  действовать только как недоумки.</p>

<p>Отсюда следует, что менеджер должен поощрять такие структуры,
  которые соответствуют сформулированным целям проекта и реализации.
  Однако на практике слишком часто бывает иначе. Существенное
  изменение стиля программирования достижимо только при соответствующем
  изменении в стиле проектирования, кроме того, обычно и то и другое
  требует изменения в стиле управления. Мыслительная и организационная
  инерция слишком просто сводят все к локальным изменениям, хотя
  только глобальные изменения могут принести успех. Прекрасной
  иллюстрацией служит переход на язык с объектно-ориентированным
  программированием, например на С++, когда он не влечет за собой
  соответствующих изменений в методах проектирования, чтобы
  воспользоваться новыми возможностями языка (см. 
п.<a href="chap12.shtml#lang">12.1</a>), и, наоборот,
  когда переход на "объектно-ориентированное проектирование" не
  сопровождается переход на язык реализации, который поддерживает
  этот стиль.</p>

<a name="reuse"></a><h5>11.4.1 Повторное использование</h5>

<p>Часто основной причиной перехода на новый язык или новый метод
  проектирования называют то, что это облегчает повторное использование
  программ или проекта. Однако, во многих организациях поощряют
  сотрудника или группу, когда они предпочитают изобретать колесо.
  Например, если производительность программиста измеряется числом
  строк программы, то будет ли он писать маленькие программы,
  работающие со стандартными библиотеками, за счет своего дохода
  и, может быть, положения? А менеджер, если он оплачивается
  пропорционально числу людей в его группе, будет ли он использовать
  программы, сделанные другими коллективами, если он может просто
  нанять еще пару программистов в свою группу? Компания может
  получить правительственный контракт, в котором ее доход составляет
  фиксированный процент от расходов на проект, будет ли она
  сокращать свой доход за счет использования наиболее эффективных
  средств? Трудно обеспечить вознаграждение за повторное использование,
  но если администрация не найдет способов поощрения и вознаграждения,
  то его просто не будет.</p>
<p>Повторное использование является прежде всего социальным
  фактором. Повторное использование программы возможно при условии,
  что</p>
<ol>
<li>она работает; нельзя использовать повторно, если это невозможно
         и в первый раз;
<li>она понятна; здесь имеет значение структура программы, наличие
         комментариев, документации, руководства;
<li>она может работать вместе с программами, которые не создавались
         специально с таким условием;
<li>можно рассчитывать на ее сопровождение (или придется делать
         это самому, что обычно не хочется);
<li>это выгодно (хотя можно и разделить расходы по разработке
         и сопровождению с другими пользователями) и, наконец;
<li>ее можно найти.
</ol>
<p>К этому можно еще добавить, что компонент не является повторно
  используемым, пока кто-то действительно не сделал это. Обычно задача
  приспособления компонента к существующему окружению приводит к
  уточнению набора операций, обобщению его поведения, и повышению его
  способности адаптации к другим программам. Пока все это не проделано
  хотя бы один раз, неожиданные острые углы находятся даже у
  компонентов, которые тщательно проектировались и реализовывались.</p>
<p>Личный опыт подсказывает, что условия для повторного
  использования возникают только в том случае, когда находится
  конкретный человек, занятый этим вопросом. В маленьких группах
  это обычно бывает тот, кто случайно или запланированно оказывается
  хранителем общих библиотек или документации. В больших организациях
  это бывает группа или отдел, которые получают привилегию собирать,
  документировать, популяризировать и сопровождать программное
  обеспечение, используемое различными группами.</p>
<p>Нельзя недооценивать такие группы "стандартных компонентов".
  Укажем, что в первом приближении, система отражает организацию,
  которая ее создала. Если в организации нет средств поощрения и
  вознаграждения кооперации и разделения труда, то и на практике
  они будут исключением. Группа стандартных компонентов должна
  активно предлагать свои компоненты. Обычная традиционная
  документация важна, но ее недостаточно. Помимо этого указанная
  группа должна предоставлять руководства и другую информацию,
  которая позволит потенциальному пользователю отыскать компонент и
  понять как он может ему помочь. Значит эта группа должна предпринимать
  действия, которые обычно связываются с системой образования и
  маркетинга. Члены группы компонентов должны всегда, когда это
  возможно, работать в тесном сотрудничестве с разработчиками из
  областей приложения. Только тогда они будут в курсе запросов
  пользователей и сумеют почуять возможности использования
  стандартного компонента в различных областях. Это является
  аргументом за использование такой группы в роли консультанта и в
  пользу внутренних поставок программ, чтобы информация из группы
  компонентов могла свободно распространяться.</p>
<p>Заметим, что не все программы должны быть рассчитаны на
  повторное использование, иными словами, повторное использование не
  является универсальным свойством. Сказать, что некоторый компонент
  может быть повторно использован, означает, что в рамках определенной
  структуры его повторное использование не потребует значительных
  усилий. Но в большинстве случаев перенос в другую структуру может
  потребовать большой работы. В этом смысле повторное использование
  сильно напоминает переносимость. Важно понимать, что повторное
  использование является результатом проектирования, ставившего
  такую цель, модификации компонентов на основе опыта и специальных
  усилий, предпринятых для поиска среди существующих компонентов
  кандидатов на повторное использование. Неосознанное использование
  средств языка или приемов программирования не может чудесным
  образом гарантировать повторное использование. Такие средства языка
  С++, как классы, виртуальные функции и шаблоны типа, способствуют
  проектированию, облегчающему повторное использование (значит делают
  его более вероятным), но сами по себе эти средства не гарантируют
  повторное использование.</p>

<a name="size"></a><h5>11.4.2 Размер</h5>

<p>Человек и организация склонны излишне радоваться тому, что они
  "действуют по правильной методе". В институтской среде это часто
  звучит как "развитие согласно строгим предписаниям". В обоих случаях
  здравый смысл становится первой жертвой страстного и часто искреннего
  желания внести улучшения. К несчастью, если здравого смысла не хватает,
  то ущерб, нанесенный неразумными действиями, может быть неограниченным.</p>
<p>Вернемся к этапам процесса развития, перечисленным в 
п.<a href="#process">11.3</a>, и
  к шагам проектирования, указанным в п.<a href="#steps">11.3.3</a>. 
Относительно просто
  переработать эти этапы в точный метод проектирования, когда шаг точно
  определен, имеет хорошо определенные входные и выходные данные и
  полуформальную запись для задания входных и выходных данных. Можно
  составить протокол, которому должно подчиняться проектирование,
  создать средства, предоставляющие определенные удобства для записи
  и организации процесса. Далее, исследуя классификацию зависимостей,
  приведенную в п.<a href="chap12.shtml#class">12.2</a>, 
можно постановить, что определенные зависимости
  являются хорошими, а другие следует считать плохими, и предоставить
  средства анализа, которые обеспечат проведение таких оценок во всех
  стадиях проекта. Чтобы завершить такую "стандартизацию" процесса
  создания программ, можно было бы ввести стандарты на документацию
  (в том числе правила на правописание и грамматику и соглашения о
  формате документации), а так же стандарты на общий вид программ
  (в том числе указания какие средства языка следует использовать,
  а какие нет, перечисление допустимых библиотек и тех, которые не нужно
  использовать, соглашения об именовании функций, типов, переменных,
  правила расположения текста программы и т.д.).</p>
<p>Все это может способствовать успеху проекта. По крайней мере,
  было бы явной глупостью, браться за проект системы, которая
  предположительно будет иметь порядка десяти миллионов строк текста,
  над которой будут работать сотни человек, и которую будут
  сопровождать тысячи человек в течении десятилетий, не имея достаточно
  хорошо определенного и строгого плана по всем перечисленным выше
  позициям.</p>
<p>К счастью, большинство систем не относится к этой категории.
  Тем не менее, если решено, что данный метод проектирования или
  следование указанным образцам в программировании и документации
  являются "правильными", то начинает оказываться давление, чтобы
  применять их повсеместно. В небольших проектах это приводит к
  нелепым ограничениям и большим накладным расходам. В частности,
  это может привести к тому, что мерой развития и успеха становится
  не продуктивная работа, а пересылка бумажек и заполнение различных
  бланков. Если это случится, то в таком проекте настоящих
  программистов и разработчиков вытеснят бюрократы.</p>
<p>Когда происходит такое нелепое злоупотребление методами
  проектирования (по всей видимости совершенно разумными), то неудача
  проекта становится оправданием отказа от практически всякой
  формализации процесса разработки программного обеспечения. Это,
  в свою очередь, ведет к такой путанице и таким провалам, которые
  как раз и должен был предотвратить надлежащий метод проектирования.</p>
<p>Основная проблема состоит в определении степени формализации,
  пригодной для процесса развития конкретного проекта. Не рассчитывайте
  легко найти ее решение. По сути для малого проекта каждый метод
  может сработать. Еще хуже то, что похоже практически каждый метод,
  даже если он плохо продуман и жесток по отношению к исполнителям,
  может сработать для большого проекта, если вы готовы затратить
  уйму времени и денег.</p>
<p>В процессе развития программного обеспечения главная задача -
  сохранить целостность проекта. Трудность этой задачи зависит
  нелинейно от размера проекта. Сформулировать и сохранить основные
  установки в большом проекте может только один человек или маленькая
  группа. Большинство людей тратит столько времени на решение
  подзадач, технические детали, повседневную административную работу,
  что общие цели проекта легко забывает или заменяет их на более
  локальные и близкие цели. Верный путь к неудаче, когда нет человека
  или группы с прямым заданием следить за целостностью проекта.
  Верный путь к неудаче, когда у такого человека или группы нет
  средств воздействовать на проект в целом.</p>
<p>Отсутствие согласованных дальних целей намного более опасно
  для проекта и организации, чем отсутствие какого-либо одного
  конкретного свойства. Небольшая группа людей должна сформулировать
  такие общие цели, постоянно держать их в уме, составить документы,
  содержащие самое общее описание проекта, составить пояснения к
  основным понятиям, и вообще, помогать всем остальным помнить о
  назначении проекта.</p>

<a name="human"></a><h5>11.4.3 Человеческий фактор</h5>

<p>Описанный здесь метод проектирования рассчитан на искусных
  разработчиков и программистов, поэтому от их подбора зависит
  успех организации.</p>
<p>Менеджеры часто забывают, что организация состоит из
  индивидуумов. Распространено мнение, что программисты равны и
  взаимозаменяемы. Это заблуждение может погубить организацию за счет
  вытеснения многих самых активных сотрудников и принуждения
  остальных работать над задачами значительно ниже их уровня.
  Индивидуумы взаимозаменяемы только, если им не дают применить
  свой талант, который поднимает их над общим минимальным уровнем,
  необходимым для решения данной задачи. Поэтому миф о взаимозаменяемости
  бесчеловечен и по сути своей расточителен.</p>
<p>Многие системы оценок производительности программиста поощряют
  расточительность и не могут учесть существенный личный вклад
  человека. Самым очевидным примером служит широко распространенная
  практика оценивать успех в количестве запрограммированных строк,
  выданных страниц документации, пропущенных тестов и т.п.
  Такие цифры эффектно выглядят на диаграммах, но имеют самое
  отдаленное отношение к действительности. Например, если
  производительность измерять числом запрограммированных строк, то
  удачное повторное использование ухудшит оценку труда программиста.
  Обычно тот же эффект будет иметь удачное применение лучших приемов
  в процессе перепроектирования большой части системы.</p>
<p>Качество результата измерить значительно труднее, чем количество,
  и  вознаграждать исполнителя или группу следует за качество их труда,
  а не на основе грубых количественных оценок. К сожалению, насколько
  известно, практическая разработка способов оценки качества еще не
  началась. К тому же оценки, которые неполно описывают состояние
  проекта, могут исказить процесс его развития. Люди приспосабливаются,
  чтобы уложиться в отведенный срок и перестраивают свою работу в
  соответствии с оценками производительности, в результате страдает
  общая целостность системы и ее производительность. Например, если
  отведен срок для выявления определенного числа ошибок, то для того,
  чтобы уложиться в него, активно используют проверки на стадии
  выполнения, что ухудшает производительность системы. Обратно, если
  учитываются только характеристики системы на стадии выполнения, то
  число невыявленных ошибок будет расти при условии недостатка
  времени у исполнителей. Отсутствие хороших и разумных оценок
  качества повышает требования к технической квалификации менеджеров,
  иначе будет постоянная тенденция поощрять произвольную активность,
  а не реальный прогресс. Не надо забывать, что менеджеры тоже люди,
  и они должны по крайней мере настолько разбираться в новых
  технологиях, как и те, кем они управляют.</p>
<p>Здесь, как и в других аспектах процесса развития программного
  обеспечения, следует рассматривать большие временные сроки. По сути
  невозможно указать производительность человека на основе его
  работы за год. Однако, многие сотрудники имеют карточку своих
  достижений за большой период, и она может послужить надежным указанием
  для предсказания их производительности. Если не принимать во внимание
  такие карточки, что и делается, когда сотрудников считают
  взаимозаменяемыми спицами в колесе организации, то у менеджера
  остаются только вводящие в заблуждения количественные оценки.</p>
<p>Если мы рассматриваем только достаточно большие временные
  сроки и отказываемся от методов управления, рассчитанных на
  "взаимозаменяемых недоумков", то надо признать, что индивидууму
  (как разработчику или программисту, так и менеджеру) нужен большой
  срок, чтобы дорасти до более интересной и важной работы. Такой
  подход не одобряет как "скакание" с места на место, так и передачу
  работы другому из-за карьерных соображений. Целью должен быть
  низкий оборот ключевых специалистов и ключевых менеджеров. Никакой
  менеджер не добьется успеха без подходящих технических знаний и
  взаимопонимания с основными разработчиками и программистами.
  В тоже время, в конечном счете никакая группа разработчиков или
  программистов не добьется успеха без поддержки компетентных
  менеджеров и без понимания хотя бы основных нетехнических вопросов,
  касающихся окружения, в котором они работают.</p>
<p>Когда требуется предложить нечто новое, на передний план выходят
  основные специалисты - аналитики, разработчики, программисты. Именно
  они должны решить трудную и критическую задачу внедрения новой
  технологии. Это те люди, которые должны овладеть новыми методами и
  во многих случаях забыть старые привычки. Это не так легко. Ведь
  эти люди сделали большой личный вклад в создание старых методов и
  свою репутацию как специалиста обосновывают успехами, полученными с
  помощью старых методов. Так же обстоит дело и с многими менеджерами.</p>
<p>Естественно у таких людей есть страх перед изменениями. Он может
  привести к преувеличению проблем, возникающих при изменениях, и к
  нежеланию признать проблемы, вызванные старыми методами. Естественно,
  с другой стороны люди, выступающие за изменения, могут переоценивать
  выгоды, которые принесут изменения, и недооценивать возникающие
  здесь проблемы. Эти две группы людей должны общаться, они должны
  научиться говорить на одном языке и должны помочь друг другу
  разработать подходящую схему перехода. Альтернативой будет
  организационный паралич и уход самых способных людей из обоих групп.
  Тем и другим следует знать, что самые удачливые из "старых ворчунов"
  могли быть "молодыми львами" в прошлом году, и если человеку дали
  возможность научиться без всяких издевательств, то он может стать
  самым стойким и разумным сторонником перемен. Он будет обладать
  неоценимыми свойствами здорового скептицизма, знания пользователей
  и понимания организационных препятствий. Сторонники немедленных и
  радикальных изменений должны осознать, что гораздо чаще  нужен
  переход, предполагающий постепенное внедрение новых методов.
  С другой стороны, те, кто не желает перемен, должны поискать для
  себя такие области, где это возможно, чем вести ожесточенные,
  арьергардные бои в той области, где новые требования уже задали
  совершенно иные условия для успешного проекта.</p>

<a name="rules"></a><h4>11.5 Свод правил</h4>

<p>В этой главе мы затронули много тем, но как правило не давали
  настоятельных и конкретных рекомендаций по проектированию. Это
  соответствует моему убеждению, что нет "единственно верного решения".
  Принципы и приемы следует применять тем способом, который лучше
  подходит для конкретных задач. Для этого нужен вкус, опыт и разум.
  Все-таки можно указать некоторый свод правил, который разработчик
  может использовать в качестве ориентиров, пока не наберется достаточно
  опыта, чтобы выработать лучшие. Ниже приведен свод таких правил.</p>
<p>Эти правила можно использовать в качестве отправной точки в
  процессе выработки основных направлений для проекта или организации
  или в качестве проверочного списка. Подчеркну еще раз, что они не
  являются универсальными правилами и не могут заменить размышления.</p>
<ul>
<li>Узнайте, что вам предстоит создать.
<li>Ставьте определенные и осязаемые цели.
<li>Не пытайтесь с помощью технических приемов решить социальные
       проблемы.
<li>Рассчитывайте на большой срок
  <ul>
  <li>в проектировании, и
  <li>управлении людьми.
  </ul>
<li>Используйте существующие системы в качестве моделей, источника
       вдохновения и отправной точки.
<li>Проектируйте в расчете на изменения:
  <ul>
  <li>гибкость,
  <li>расширяемость,
  <li>переносимость, и
  <li>повторное использование.
  </ul>
<li>Документируйте, предлагайте и поддерживайте повторно используемые
       компоненты.
<li>Поощряйте и вознаграждайте повторное использование
  <ul>
  <li>проектов,
  <li>библиотек, и
  <li>классов.
  </ul>
<li>Сосредоточьтесь на проектировании компоненты.
  <ul>
  <li>Используйте классы для представления понятий.
  <li>Определяйте интерфейсы так, чтобы сделать открытым минимальный
         объем информации, требуемой для интерфейса.
  <li>Проводите строгую типизацию интерфейсов всегда, когда это
         возможно.
  <li>Используйте в интерфейсах типы из области приложения всегда,
         когда это возможно.
  </ul>
<li>Многократно исследуйте и уточняйте как проект, так и реализацию.
<li>Используйте лучшие доступные средства для проверки и анализа
  <ul>
  <li>проекта, и
  <li>реализации.
  </ul>
<li>Экспериментируйте, анализируйте и проводите тестирование на
       самом раннем возможном этапе.
<li>Стремитесь к простоте, максимальной простоте, но не сверх того.
<li>Не разрастайтесь, не добавляйте возможности "на всякий случай".
<li>Не забывайте об эффективности.
<li>Сохраняйте уровень формализации, соответствующим размеру проекта.
<li>Не забывайте, что разработчики, программисты и даже менеджеры
       остаются людьми.
</ul>
<p>Еще некоторые правила можно найти в 
п.<a href="chap12.shtml#rules">12.5</a></p>

<a name="comment"></a><h4>11.6 Список литературы с комментариями</h4>

<p>В этой главе мы только поверхностно затронули вопросы проектирования
  и управления программными проектами. По этой причине ниже предлагается
  список литературы с комментариями. Значительно более обширный список
  литературы с комментариями можно найти в [<a href="chap0.shtml#book2">2</a>].</p>
<ol>
<li>Bruce Anderson and Sanjiv Gossain: An Iterative Design Model for
      Reusable Object-Oriented Software. Proc. OOPSLA'90. Ottawa,
      Canada. pp. 12-27.
      Описание модели итеративного проектирования и повторного
      проектирования с некоторыми примерами и обсуждением результатов.
<li>Grady Booch: Object Oriented Design. Benjamin Cummings. 1991.
      В этой книге есть детальное описание проектирования, определенный
      метод проектирования с графической формой записи и несколько
      больших примеров проекта, записанных на различных языках. Это
      превосходная книга, которая во многом повлияла на эту главу. В ней
      более глубоко рассматриваются многие из затронутых здесь вопросов.
<li>Fred Brooks: The Mythical Man Month. Addison Wesley. 1982.
      Каждый должен перечитывать эту книгу раз в пару лет.
      Предостережение от высокомерия. Она несколько устарела в
      технических вопросах, но совершенно не устарела во всем, что
      касается отдельного работника, организации и вопросов размера.
<li>Fred Brooks: No Silver Bullet. IEEE Computer, Vol.20 No.4.
      April 1987.
      Сводка различных подходов к процессу развития больших программных
      систем с очень полезным предостережением от веры в магические
      рецепты ("золотая пуля").
<li>De Marco and Lister: Peopleware. Dorset House Publishing Co. 1987.
      Одна из немногих книг, посвященных роли человеческого фактора
      в производстве программного обеспечения. Необходима для каждого
      менеджера. Достаточно успокаивающая для чтения перед сном.
      Лекарство от многих глупостей.
<li>Ron Kerr: A Materialistic View of the Software "Engineering"
      Analogy. in SIGPLAN Notices, March 1987. pp 123-125.
      Использование аналогии в этой и следующей главах во многом
      обязано наблюдениям из указанной статьи, а так же беседам с
      Р. Керром, которые этому предшествовали.
<li>Barbara Liskov: Data Abstraction and Hierarchy. Proc. OOPSLA'87
      (Addendum). Orlando, Florida. pp 17-34.
      Исследуется как использование наследования может повредить
      концепции абстрактных данных. Укажем, что в С++ есть специальные
      языковые средства, помогающие избежать большинство указанных
      проблем (п.12.2.5).
<li>C. N. Parkinson: Parkinson's Law and other Studies in
      Administration. Houghton-Mifflin. Boston. 1957.
      Одно из забавных и самых язвительных описаний бед, к которым
      приводит процесс администрирования.
<li>Bertrand Meyer: Object Oriented Software Construction.
      Prentice Hall. 1988.
      Страницы 1-64 и 323-334 содержат хорошее описание одного взгляда
      на объектно-ориентированное программирование и проектирование,
      а также много здравых, практических советов. В остальной части
      книги описывается язык Эйффель (Eiffel).
<li>Alan Snyder: Encapsulation and Inheritance in Object-Oriented
      Programming Languages. Proc. OOPSLA'86. Portland, Oregon. pp.38-45.
      Возможно первое хорошее описание взаимодействия оболочки и
      наследования. В статье так же на хорошем уровне рассматриваются
      некоторые понятия, связанные с множественным наследованием.
<li>Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener:
      Designing Object-Oriented Software. Prentice Hall. 1990.
      Описывается антропоморфный метод проектирования основанный на
      специальных карточках CRC (Classes, Responsibilities,
      Collaboration) (т.е. Классы, Ответственность, Сотрудничество).
      Текст, а может быть и сам метод тяготеет к языку Smalltalk.
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap12.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>