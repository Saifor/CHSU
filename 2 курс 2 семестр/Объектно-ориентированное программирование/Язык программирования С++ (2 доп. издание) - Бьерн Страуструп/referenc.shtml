<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Справочное руководство</h3>

<a name="#R.1"></a><h4>R.1 Введение</h4>
<p>Это справочное руководство описывает язык программирования С++ по
  состоянию на май 1991. С++ - язык программирования общего назначения,
  базирующийся на языке программирования С +.</p>
<p>+ "The C Programming Language" B. Kernighan, D. Ritchie. Prentice
     Hall, 1978, 1988.
     Есть русский перевод: "Язык программирования С. Задачи по языку С"
     Б. Керниган, Д. Ритчи, А. Фьюер. "Финансы и статистика". 1984</p>
<p>В дополнение к возможностям С язык С++ предоставляет классы, функции
  подстановки, перегрузку операций, перегрузку имен функций, постоянные
  типы, ссылки, операторы управления свободной памятью, проверку
  параметров функций и приведение типов. Все расширения С суммируются
  в п.<a href="#R.18.1">R.18.1</a>. Различия между С++ и ANSI C++ приведены в 
  п.<a href="#R.18.2">R.18.2</a> +.</p>
<p>+ American National Standard X3.159-1989. Американский национальный
     стандарт.</p>
<p>Расширения  С++ версии 1985 года до данного описания суммируются в
  п.<a href="#R.18.1.2">R.18.1.2</a>. Разделы, относящиеся к шаблонам типа 
  (п.<a href="#R.14">R.14</a>) и
  управлению особыми ситуациями (п.<a href="#R.15">R.15</a>), являются местами планируемых
  расширений языка.</p>

<a name="#R.1.1"></a><h5>R.1.1 Запись синтаксиса</h5>
<p>В записи синтаксиса языка в этом руководстве синтаксические понятия
  обозначаются курсивом, а литеральные слова и символы шрифтом постоянной
  ширины. Варианты перечисляются на отдельных строках, за исключением
  тех немногих случаев, когда длинный список вариантов дается на одной
  строке с пометкой "один из". Необязательный терминальный или
  нетерминальный символ обозначается с помощью нижнего индекса "opt",
  поэтому
<pre>
     { выражение opt }
</pre>
<p>означает необязательное выражение, заключенное в фигурные скобки.</p>

<a name="#R.2"></a><h4>R.2 Соглашения о лексических понятиях</h4>
<p>Программа на С++ состоит из одного или нескольких файлов (п.<a href="#R.3.3">R.3.3</a>).
  С логической точки зрения файл транслируется за несколько проходов.
  Первый проход состоит в препроцессорной обработке (п.<a href="#R.16">R.16</a>), на которой
  происходит включение файлов и макроподстановка. Работа препроцессора
  управляется с помощью команд, являющихся строками, первый символ
  которых отличный от пробела есть # (п.<a href="#R.2.1">R.2.1</a>). Результат работы
  препроцессора есть последовательность лексем. Такую последовательность
  лексем, т.е. файл после препроцессорной обработки, называют
  единицей трансляции.</p>

<a name="#R.2.1"></a><h5>R.2.1 Лексемы</h5>
<p>Существуют лексемы пяти видов: идентификаторы, служебные слова,
  литералы, операции и различные разделители. Пробелы, вертикальная
  и горизонтальная табуляция, конец строки, перевод строки и комментарии
  (все вместе "обобщенные" пробелы), как указано ниже, игнорируются,
  за исключением того, что они отделяют лексемы. Обобщенные пробелы
  нужны, чтобы разделить стоящие рядом идентификаторы, служебные
  слова и константы.</p>
<p>Если входной поток разобран на лексемы до данного символа, то
  следующей лексемой считается лексема с максимально возможной длиной,
  которая начинается с этого символа.</p>

<a name="#R.2.2"></a><h5>R.2.2 Комментарии</h5>
<p>Символы /* начинают комментарий, который завершается символами */.
  Такие комментарии не могут быть вложенными. Символы // начинают
  комментарий, который завершается концом этой строки. Символы //,
  /* и */ не имеют специального назначения в комментарии // и
  рассматриваются как обычные символы. Аналогично символы // и /*
  не имеют специального назначения внутри комментария /*.</p>

<a name="#R.2.3"></a><h5>R.2.3 Идентификаторы</h5>
<p>Идентификатор - это последовательность букв и цифр произвольной длины.
  Первый символ должен быть буквой, символ подчеркивания _ считается
  буквой. Прописные и строчные буквы различаются. Все символы
  существенны.</p>

<a name="#R.2.4"></a><h5>R.2.4 Служебные слова</h5>
<p>Перечисленные ниже идентификаторы фиксируются как служебные слова и
  в другом смысле не могут использоваться:</p>
<pre>
   asm        continue     float    new          signed      try
   auto       default      for      operator     sizeof      typedef
   break      delete       friend   private      static      union
   case       do           goto     protected    struct      unsigned
   catch      double       if       public       switch      virtual
   char       else         inline   register     template    void
   class      enum         int      return       this        volatile
   const      extern       long     short        throw       while
</pre>
<p>В дополнение к этому идентификаторы, содержащие двойное подчеркивание
  (__) резервируются для реализаций С++ и стандартных библиотек и
  пользователи не должны употреблять их.</p>
<p>В представлении программы на С++ в кодировке ASCII используются
  в качестве операций или разделителей следующие символы:</p>
<pre>
    !  %  ^  &   *  (  )  -  +  =  {  }  |  ~
    [  ]  \  ;   '  :  "  <  >  ?   , .  /
</pre>
<p>а следующие комбинации символов используются для задания операций:</p>
<pre>
    ->  ++  --  .*  ->*  <<  >>   <=  >=  ==  !=  &&
    ||  *=  /=  %=  +=   -=  <<=  >>= &=  ^=  |=  ::
</pre>
<p>Каждая операция считается отдельной лексемой.<br>
     В дополнении к этому следующие символы резервируются для препроцессора:</p>
<pre>
     #  ##
</pre>
<p>Определенные, зависящие от реализации, свойства, такие как
  тип операции sizeof (п.<a href="#R.5.3.2">R.5.3.2</a>) или диапазоны базовых типов
  (п.<a href="#R.3.6.1">R.3.6.1</a>) определяются в стандартных заголовочных файлах
  (п.<a href="#R.16.4">R.16.4)</a></p>
<pre>
        &lt;float.h>   &lt;limits.h>  &lt;stddef.h>
</pre>
<p>Эти файлы являются частью ANSI стандарта для С. Кроме того
  заголовочные файлы</p>
<pre>
        &lt;new.h>    &lt;stdarg.h>   &lt;stdlib.h>
</pre>
<p>определяют типы самых важных библиотечных функций. Два последних
  файла входят в ANSI стандарт для С, файл <new.h> относится только
  к С++.</p>

<a name="#R.2.5"></a><h5>R.2.5 Литералы</h5>
<p>Есть несколько видов литералов (часто называемых "константами").
<ul>
<li>целая константа
<li>символьная константа
<li>константа с плавающей точкой
<li>строка литералов
</ul>

<a name="#R.2.5.1"></a><h6>R.2.5.1 Целые константы</h6>
<p>Все целые константы, состоящие из последовательности цифр, считаются
  десятичными (основание счисления десять), если только они не начинаются
  с 0 (цифра ноль). Последовательность цифр, начинающаяся с 0,
  считается восьмеричным целым (основание счисления восемь). Цифры 8 и 9
  не являются восьмеричными. Последовательность цифр, начинающаяся с
  0x или 0X, считается шестнадцатеричным целым (основание счисления
  шестнадцать). Шестандцатеричные цифры могут состоять из символов
  от a или A до f или F с десятичными значениями их от десяти до
  пятнадцати. Например, число двенадцать можно записать как 12,
  014 или 0XC.</p>
<p>Тип целой константы определяется ее представлением, значением и
  окончанием. Если она десятичная и не имеет окончания, ее тип будет
  первым подходящим для ее значения из следующих типов: int, long int,
  unsigned long int. Если она восьмеричная или шестнадцатеричная и
  не имеет окончания, ее тип будет первым подходящим для ее значения
  из следующих: int, unsigned int, long int, unsigned long int.
  Если она оканчивается символом u или U, ее тип будет первым подходящим
  для ее значения из следующих: unsigned int, unsigned long int. Если
  она оканчивается символом l или L, ее тип будет первым подходящим
  для ее значения из следующих: long int, unsigned long int. Если
  она оканчивается на ul, lu, uL, Lu, Ul, lU, UL или LU, ее типом
  будет unsigned long int.</p>

<a name="#R.2.5.2"></a><h6>R.2.5.2 Символьные константы</h6>
<p>Символьной константой является один или несколько символов, заключенные
  в одиночные кавычки, например 'x'. Константа из одного символа имеет
  тип char. Значение константы из одного символа есть порядковый номер
  символа в таблице кодировки символов на данной машине. Символьные
  константы из нескольких символов имеют тип int. Значение такой
  константы зависит от реализации.</p>
<p>Некоторые символы, не имеющие графического представления, как
  одиночная кавычка ',двойная кавычка ", знак вопроса ?, обратная
  дробная черта \, можно представлять комбинацией символов (начинающейся
  с \) в соответствии с приводимой ниже таблицей:</p>
<pre>
       конец строки                  NL (LF)  \n
       горизонтальная табуляция      HT       \t
       вертикальная табуляция        VT       \v
       шаг назад                     BS       \b
       возврат каретки               CR       \r
       перевод формата (авторегистр) FF       \f
       сигнал                        BEL      \a
       обратная дробная черта        \        \\
       знак вопроса                  ?        \?
       одиночная кавычка             '        \'
       двойная кавычка               "        \"
       восьмеричное число            ooo      \ooo
       шестнадцатеричное число       hhh      \xhhh
</pre>
<p>Если за обратной дробной чертой следует символ, отличный от
  перечисленных, результат неопределен.
  Комбинация \ooo состоит из обратной дробной черты, а которой
  следуют одна, две или три восьмеричные цифры. Считается, что они
  определяют значение искомого символа. Комбинация \xhhh состоит из
  из обратной дробной черты, за которой следует x, а за ним, в свою
  очередь, следует последовательность шестнадцатеричных цифр.
  Считается, что она задает значение искомого символа. Нет ограничения
  на длину  этой  последовательности шестнадцатеричных цифр.
  Последовательность восьмеричных или шестнадцатеричных цифр
  оканчивается, когда встречается первый символ, который не есть
  восьмеричная или шестнадцатеричная цифра соответственно. Если
  значение символьной константы превосходит максимальное из char,
  то оно определяется реализацией.</p>
<p>Символьная константа, которой непосредственно предшествует
  буква L, является широкой символьной константой, например, L'ab'.
  Такие константы имеют тип wchar_t, являющийся целочисленным типом
  (п.<a href="#R.3.6.1">R.3.6.1</a>), определенном в стандартном заголовочном файле
  <stddef.h>. Широкие символы предназначены для такого набора
  символов, где значение символа не помещается в один байт.</p>

<a name="#R.2.5.3"></a><h6>R.2.5.3 Константы с плавающей точкой</h6>
<p>Константы с плавающей точкой состоят из целой части, символа
  точка, дробной части, e или E, целого показателя с возможным
  знаком и возможным окончанием, указывающим тип. Целая и дробная
  части состоят из последовательности десятичных (основание
  счисления десять) цифр. Или целая часть, или дробная часть
  (но не обе) могут отсутствовать. Или точка, или символ e (или E)
  вместе с показателем могут отсутствовать (но не оба). Тип
  константы с плавающей точкой есть double, если только он не
  задан явно с помощью окончания. Окончания f или F задают тип
  float, окончания l или L задают тип long double.</p>

<a name="#R.2.5.4"></a><h6>R.2.5.4 Строки литералов</h6>
<p>Строка литералов есть последовательность символов  (как они определены
  в п.<a href="#R.2.5.2">R.2.5.2</a>), заключенная в двойные кавычки, т.е. "...". Строка
  имеет тип "массив символов" и класс памяти static (п.<a href="#R.3.5">R.3.5</a>), она
  инициализируется заданными символами. Будут ли все строки различны
  (т.е. хранится в отдельных объектах), определяется реализацией.</p>
<p>Соседние строки литералов конкатенируются. Символы в строках,
  полученных при конкатенации, хранятся отдельно. Например, после
  конкатенации</p>
<pre>
      "\xA"  "B"
</pre>
<p>строка будет содержать два символа '\xA' и 'B' (а не один
  шестнадцатеричный символ '\xAB').</p>
<p>После всех необходимых конкатенаций к строке добавляется
  символ '\0', чтобы программа, читающая строку, могла определить
  ее конец. Размер строки равен числу всех ее символов, включая
  символ завершитель строки. Внутри строки перед символом двойной
  кавычки " должен идти символ \.</p>
<p>Строка литералов, перед которой непосредственно идет символ L,
  считается широкосимвольной строкой, например, L"asdf". Такая
  строка имеет тип "массив элементов типа wchar_t", где wchar_t
  целочисленный тип, определенный в стандартном заголовочном файле
  &lt;stddef.h>. Результат конкатенации обычных и широкосимвольных
  строк литералов неопределен.</p>

<a name="#R.3"></a><h4>R.3 Основные понятия</h4>
<p>Имя обозначает объект, функцию, множество функций, элемент
  перечисления, тип, член класса, шаблон типа, значение или метку.
  Имя становится известно в программе с помощью описания. Имя можно
  использовать только в пределах части программы, называемой областью
  видимости имени. Имя имеет тип, который задает его использование.
  Имя, используемое в более чем одной единице трансляции, может
  обозначать один и тот же (а может и разные) объект, функцию, тип,
  шаблон типа или значение, в зависимости от компоновки (п.<a href="#R.3.3">R.3.3</a>)
  этих единиц трансляции.</p>
<p>Объект имеет область для его хранения (п.<a href="#R.3.7">R.3.7</a>). Поименованный
  объект имеет класс памяти (п.<a href="#R.3.5">R.3.5</a>), который определяет его время
  жизни. Интерпретация значений, хранящихся в объекте, определяется
  типом выражения, задающего доступ к объекту.</p>

<a name="#R.3.1"></a><h5>R.3.1 Описания и определения</h5>
<p>Описание (п.<a href="#R.7">R.7</a>) делает известным в программе одно или несколько
  имен. Описание считается определением, если только оно не описывает
  функцию без задания ее тела (п.<a href="#R.8.3">R.8.3</a>), не содержит описателя
  extern (п.<a href="#R.7.1.1">R.7.1.1</a>), не имеет части инициализации или тела функции,
  не является описанием статического члена данных в описании класса
  (п.<a href="#R.9.4">R.9.4</a>), не является описанием имени класса (п.<a href="#R.9.1">R.9.1</a>), не является
  описанием typedef (п.<a href="#R.7.1.3">R.7.1.3</a>). Ниже приведены примеры определений:</p>
<pre>
       int a;
       extern const c = 1;
       int f(int x) { return x+a; }
       struct S { int a; int b; };
       enum { up, down };
</pre>
<p>тогда как ниже следуют только описания:</p>
<pre>
       extern int a;
       extern const c;
       int f(int);
       struct S;
       typedef int Int;
</pre>
<p>Для каждого объекта, функции, класса и элемента перечисления,
  используемых в программе, должно быть только одно определение
  (п.<a href="#R.3.3">R.3.3</a>). Если функция никогда не вызывается и ее адрес никогда
  не используется, ее не нужно определять. Аналогично, если имя класса
  используется только так, что не требуется знать определения класса,
  то такой класс не надо определять.</p>

<a name="#R.3.2"></a><h5>R.3.2 Область видимости</h5>
<p>Существует четыре области видимости: локальная, функция, файл и класс.</p>
<dl>
 <dt>Локальная:</dt>
  <dd>Имя, описанное в блоке (п.<a href="#R.6.3">R.6.3</a>), является локальным
      в этом блоке и может использоваться только в нем и в блоках,
      содержащихся в этом блоке и появляющихся после момента описания.
      Имена формальных параметров рассматриваются, как если бы они были
      описаны в самом объемлющем блоке этой функции.
  </dd>
  <dt>Функция:</dt>
  <dd>Метки (п.<a href="#R.6.1">R.6.1</a>) можно использовать повсюду в функции,
      в которой они описаны. Только метки имеют область видимости,
      совпадающую с функцией.
  </dd>
  <dt>Файл:</dt>
  <dd>Имя описанное вне всех блоков (п.<a href="#R.6.3">R.6.3</a>) и классов (п.<a href="#R.9">R.9</a>)
      имеет область видимости файл и может быть использовано в единице
      трансляции, в которой оно появляется после момента описания. Имена,
      описанные с файловой областью видимости, называются глобальными.
  </dd>
  <dt>Класс:</dt>
  <dd>Имя члена класса является локальным в своем классе и
      оно может быть использовано только в функции-члене этого класса
      (п.<a href="#R.9.3">R.9.3</a>), или после операции . , применяемой к объекту данного
      класса (п.<a href="#R.5.2.4">R.5.2.4</a>) или объекту производного  класса(п.<a href="#R.10">R.10</a>),
      или после операции ->, применяемой к указателю на объект данного
      класса (п.<a href="#R.5.2.4">R.5.2.4</a>) или на объект производного класса, или после
      операции разрешения :: (п.<a href="#R.5.1">R.5.1</a>), примененной к имени данного
      или производного класса. Имя, введенное с помощью операции
     friend (п.<a href="#R.11.4">R.11.4</a>), принадлежит той же области определенности,
     что и класс, содержащий описание friend. Класс, впервые
     описанный в операторе return или в типе параметра, принадлежит
     к глобальной области видимости.
   </dd>
</dl>
<p>Специальные соглашения действуют на имена, введенные при описании
  параметров функции (п.<a href="#R.8.2.5">R.8.2.5</a>) и в описаниях friend (п.<a href="#R.11.4">R.11.4</a>).</p>
<p>Имя может быть скрыто явным описанием того же имени в объемлющем
  блоке или классе. Скрытое имя члена класса все-таки можно
  использовать, если оно предваряется именем класса, к которому
  применена операция :: (п.<a href="#R.4.1">R.4.1</a>, п.<a href="#R.9.4">R.9.4</a>, п.<a href="#R.10">R.10</a>). Скрытое имя объекта,
  функции, типа или элемента перечисления с файловой областью видимости
  можно использовать, если оно предваряется унарной операцией ::
  (п.<a href="#R.5.1">R.5.1</a>). В дополнении к этому, имя класса (п.<a href="#R.9.1">R.9.1</a>) может быть
  скрыто именем объекта, функции или элемента перечисления, имеющего
  ту же область видимости. Если класс и объект, или функция, или
  элемент перечисления описаны (в любом порядке) с одинаковым именем
  в одной области видимости, то имя класса становится скрытым. Имя
  класса, скрытое в локальной области видимости или в области
  видимости класса именем объекта, функции или элемента перечисления,
  все-таки можно использовать, если предварить его подходящей
  спецификацией class, struct или union (п.<a href="#R.7.1.6">R.7.1.6</a>). Аналогично,
  скрытое имя элемента перечисления можно использовать, если
  предварить его спецификацией типа enum (п.<a href="#R.7.1.6">R.7.1.6</a>). В п.<a href="#R.10.4">R.10.4</a>
  приводится сводка правил области видимости.</p>
<p>Моментом описания имени считается момент завершения описателя имени
  (п.<a href="#R.8">R.8</a>), предшествующей части инициализации (если она есть).
  Например,</p>
<pre>
      int x = 12;
      { int x = x; }
</pre>
<p>Здесь второе x инициализируется своим собственным (неопределенным)
  значением.</p>
<p>Моментом описания элемента перечисления считается момент сразу
  после появления его идентификатора, например:</p>
<pre>
      enum { x = x };
</pre>
<p>Здесь элемент перечисления x опять инициализируется своим собственным
  (неопределенным) значением.</p>

<a name="#R.3.3"></a><h5>R.3.3 Программа и связывание</h5>
<p>Программа состоит из одного или нескольких файлов, связываемых вместе
  (п.<a href="#R.2">R.2</a>). Файл состоит из последовательности описаний.</p>
<p>Имя с файловой областью видимости, которое явно описано как
  static, является локальным в своей единице трансляции и может
  использоваться для именования объектов, функций и т.п. в других
  единицах трансляции. Говорят, что такие имена имеют внутреннее
  связывание. Имя с файловой областью видимости, которое явно описано
  со спецификацией inline, является локальным в своей единице
  трансляции. Имя с файловой областью видимости, которое явно описано
  со спецификацией const и не описано явно как extern, считается
  локальным в своей единице трансляции. То же верно для имени класса,
  которое не использовалось в нелокальных для данной единицы
  трансляции описаниях объекта, функции  или класса, и который не
  имеет статических членов (п.<a href="#R.9.4">R.9.4</a>), не имеет функций-членов, кроме
  подстановок (п.<a href="#R.9.3.2">R.9.3.2</a>). Всякое описание некоторого имени с
  файловой областью видимости, которое не описано одним из перечисленных
  способов так, чтобы иметь внутреннее связывание, в многофайловой
  программе обозначает один и тот же объект (п.<a href="#R.3.7">R.3.7</a>), функцию
  (п.<a href="#R.8.2.5">R.8.2.5</a>) или класс (п.<a href="#R.9">R.9</a>). Такие имена называются внешними или
  говорят, что они имеют внешнее связывание. В частности, поскольку
  нельзя описать имя класса как static, всякое употребление имени
  некоторого класса с файловой областью видимости, который (класс)
  использовался для описания объекта или функции с внешним связыванием,
  или же который имеет статический член или функцию-член,
  не являющуюся подстановкой, будет обозначать один и тот же класс.</p>
<p>Имена определяемых типов (typedef п.<a href="#R.7.1.3">R.7.1.3</a>), элементы перечисления
  (п.<a href="#R.7.2">R.7.2</a>) или имена шаблонов типа (п.<a href="#R.14">R.14</a>) не имеют внешнего
  связывания.</p>
<p>Статические члены класса (п.<a href="#R.9.4">R.9.4</a>) допускают внешнее связывание.</p>
<p>Функции-члены, не являющиеся подстановкой, допускают внешнее
  связывание. Функции-члены, являющиеся подстановкой, должны иметь
  в точности одно определение в программе.</p>
<p>Локальные имена (п.<a href="#R.3.2">R.3.2</a>), явно описанные со спецификацией
  extern, имеют внешнее связывание, если только они уже не были
  описаны как static (п.<a href="#R.7.1.1">R.7.1.1</a>).</p>
<p>Типы, используемые во всех описаниях некоторого внешнего имени,
  должны совпадать, за исключением использования имен определяемых
  типов (п.<a href="#R.7.1.3">R.7.1.3</a>) и указания границ массивов 
  (п.<a href="#R.8.2.4">R.8.2.4</a>).
  Должно быть в точности одно определение для каждой функции, объекта,
  класса и элемента перечисления, используемых в программе. Однако,
  если функция никогда не вызывается и ее адрес никогда не используется,
  ее не нужно определять. Аналогично, если имя класса используется
  только таким образом, что не требуется знать определение класса,
  то класс не нужно определять.</p>
<p>Область видимости функции может быть только файл или класс.</p>
<p>С помощью спецификации связывания можно добиться связывания с
  описаниями на другом языке (п.<a href="#R.7.4">R.7.4</a>).</p>

<a name="#R.3.4"></a><h5>R.3.4 Начало и окончание программы</h5>
<p>Программа должна содержать функцию с именем main(). Ей приписывается
  роль начала программы. Эта функция не является предопределенной
  для транслятора, она не может быть перегружена, а ее тип зависит
  от реализации. Предполагается, что любая реализация должна
  допускать два приведенных ниже определения и что можно добавлять
  после argv любые параметры. Функция main может определяться так</p>
<pre>
     int main() { /* ... */ }
</pre>
<p>или</p>
<pre>
     int main(int argc, char* argv[]) { /* ... */ }
</pre>
<p>В последнем определении argc задает число параметров, передаваемых
  программе окружением, в котором она выполняется. Если argc не
  равно нулю, параметры должны передаваться как строки, завершающиеся
  символом '\0', с помощью argv[0] до argv[argc-1], причем
  argv[0] должно быть именем, под которым программа была запущена,
  или "". Должно гарантироваться, что argv[argc]==0.</p>
<p>Функция main() не должна вызываться в программе. Связывание
  main() (п.<a href="#R.3.3">R.3.3</a>) зависит от реализации. Нельзя получать адрес
  main() и не следует описывать ее как inline или static.
  Вызов функции</p>
<pre>
      void exit(int);
</pre>
<p>описанной в <stdlib.h>, завершает программу. Значение параметра
  передается окружению программы в качестве результата программы.</p>
<p>Инициализация нелокальных статических объектов (п.<a href="#R.3.5">R.3.5</a>)
  единицы трансляции происходит прежде первого обращения к функции
  или объекту, определенному в этой единице трансляции. Эта
  инициализация (п.<a href="#R.8.4">R.8.4</a>, п.<a href="#R.9.4">R.9.4</a>, <a href="#R.12.1">R.12.1</a>, п.<a href="#R.12.6.1">R.12.6.1</a>) может
  быть проведена перед выполнением первого оператора main() или
  отложена до любого момента, предшествующего первому использованию
  функции или объекта, определенных в данной единице трансляции.
  Все статические объекты по умолчанию инициализируются нулем (п.<a href="#R.8.4">R.8.4</a>)
  прежде любой динамической (во времени выполнения программы)
  инициализации. Больше никаких требований на порядок инициализации
  объектов из различных единиц трансляции не налагается. Инициализация
  локальных и статических объектов описана в п.<a href="#R.8.4">R.8.4</a>.</p>
<p>Деструкторы (п.<a href="#R.12.4">R.12.4</a>) для инициализированных статических
  объектов вызываются при возврате из main() или при вызове exit().
  Уничтожение происходит в обратном порядке по сравнению с
  инициализацией. С помощью функции atexit() из <stdlib.h> можно
  указать функцию, которую нужно вызывать при выходе из программы.
  Если было обращение к функции atexit(), объекты, инициализированные
  до вызова atexit(), не должны уничтожаться до тех пор, пока не
  произойдет вызов функции, указанной в atexit(). Если реализация С++
  сосуществует с реализацией С, все действия, которые должны были
  произойти после вызова функции, заданной в atexit(), происходят
  только после вызова всех деструкторов.</p>
<p>Вызов функции</p>
<pre>
      void abort();
</pre>
<p>описанной в <stdlib.h>, завершает программу без выполнения
  деструкторов статических объектов и без вызова функций, заданных
  в atexit().</p>

<a name="#R.3.5"></a><h5>R.3.5 Классы памяти</h5>
<p>Существует два описываемых класса памяти: автоматический и статический.</p>
<p>Автоматические объекты становятся локальными при передаче
  управления в каждый блок.</p>
<p>Статические объекты существуют и сохраняют свое значение во все
  время выполнения программы.</p>
<p>Автоматические объекты инициализируются (п.<a href="#R.12.1">R.12.1</a>) всякий раз,
  когда управление переходит в блок, где они определены и уничтожаются
  (п.<a href="#R.12.4">R.12.4</a>) по выходе из этого блока (п.<a href="#R.6.7">R.6.7</a>).</p>
<p>Поименованный автоматический объект не должен быть уничтожен
  до окончания его блока, точно так же, как не может быть исключен
  поименованный автоматический объект класса, имеющего конструктор
  или деструктор с побочным эффектом, даже если кажется, что этот
  объект не используется.</p>
<p>Аналогично, глобальный объект класса с конструктором или
  деструктором, имеющими побочный эффект, не может быть исключен,
  даже если кажется, что он не используется.</p>
<p>Статические объекты инициализируются и уничтожаются в
  соответствии с описанием в п.<a href="#R.3.4">R.3.4</a> и п.<a href="#R.6.7">R.6.7</a>. С некоторыми объектами
  не связано никакого имени, см. п.<a href="#R.5.3.3">R.5.3.3</a> и п.<a href="#R.12.2">R.12.2</a>. Все глобальные
  объекты имеют класс памяти статический. Локальным объектам и членам
  класса можно предать класс памяти статический с помощью явного
  использования спецификации класса памяти static (п.<a href="#R.7.1.1">R.7.1.1</a>).</p>

<a name="#R.3.6"></a><h5>R.3.6 Типы</h5>
<p>Существуют два вида типов: основные и производные.</p>

<a name="#R.3.6.1"></a><h6>R.3.6.1 Основные типы</h6>
<p>Существует несколько основных типов. В стандартном заголовочном
  файле &lt;limits.h> задаются в зависимости от реализации минимальные и
  максимальные значения каждого типа.</p>
<p>Объекты, описанные как символы (char), могут хранить любой
  элемент из базового набора символов данной машины. Если символ
  этого набора хранится в символьной переменной, то ее значение
  равно целому значению кода этого символа. Символы могут явно
  описываться как unsigned или signed. Обычный char, signed char и
  unsigned char являются тремя различными типами. Для всех этих
  трех типов требуется одинаковый объем памяти.</p>
<p>С помощью описаний short int, int и long int можно определить
  целые трех различных размеров. Для длинных целых требуется памяти
  не меньше чем для коротких целых, но в реализации или короткие
  целые, или длинные целые, или и те и другие могут оказаться
  эквивалентными обычным целым. Обычные целые имеют размер,
  определяемый системой команд, размеры других целых определяются
  конкретными потребностями.</p>
<p>Для каждого из типов signed char, short, int и long существует
  соответствующий беззнаковый тип, который занимает тот же объем
  памяти и удовлетворяет тем же требованиям выравнивания.
  Требование выравнивание - это ограничение на значение указателя
  на данный объект, которое накладывает реализация (п.<a href="#R.5.4">R.5.4</a>).</p>
<p>Беззнаковые целые, описанные как unsigned, подчиняются законом
  арифметики по модулю 2@n, где n число битов, используемое для
  представления значения. Отсюда следует, что в арифметике беззнаковых
  не возникает переполнения.</p>
<p>Существует три типа с плавающей точкой: float, double и long double.
  Тип double гарантирует не меньшую точность представления, чем
  float, а тип long double гарантирует точность не меньше, чем у
  double. Характеристики основных типов с плавающей точкой определяются
  в соответствии с реализацией в стандартном заголовочном файле
  &lt;float.h>.</p>
<p>Типы char, int любых размеров и тип перечисления (п.<a href="#R.7.2">R.7.2</a>)
  называются целочисленными типами. Целочисленные типы вместе с
  типами с плавающей точкой образуют арифметические типы.</p>
<p>Тип void задает пустое множество значений. Он используется для
  обозначения типа функций, которые не возвращают результат. Нельзя
  описывать объекты с типом void. Любое выражение можно явно
  преобразовать к типу void (п.<a href="#R.5.4">R.5.4</a>), получившееся выражение можно
  использовать только как выражение-оператор (п.<a href="#R.6.2">R.6.2</a>), как
  левый операнд операции запятая (п.<a href="#R.5.18">R.5.18</a>) или в качестве второго или
  третьего операнда в операции ?: (п.<a href="#R.5.16">R.5.16</a>).</p>

<a name="#R.3.6.2"></a><h6>R.3.6.2 Производные типы</h6>
<p>Существует потенциально бесконечное число производных типов, которые
  строятся из основных типов следующими способами:</p>
<ul>
<li>массив объектов данного типа, п.<a href="#R.8.4">R.8.4</a>;
<li>функции, имеющие параметры данного типа и возвращающие объекты
    данного типа, п.<a href="#R.8.2.5">R.8.2.5</a>;
<li>указатели на объекты или функции данного типа, п.<a href="#R.8.2.1">R.8.2.1</a>;
<li>ссылки на объекты или функции данного типа, п.<a href="#R.8.2.2">R.8.2.2</a>;
<li>константы, являющиеся значениями данного типа, п.<a href="#R.7.1.6">R.7.1.6</a>;
<li>классы, содержащие совокупность объектов различных типов (п.<a href="#R.9">R.9</a>),
    набор функций для управления этими объектами (п.<a href="#R.9.3">R.9.3</a>) и
    и список ограничений на доступ к этим объектам и функциям, п.<a href="#R.11">R.11</a>;
    структуры, которые являются классами без стандартных ограничений
    на доступ, п.<a href="#R.11">R.11</a>;
<li>объединения, которые являются структурами, способными содержать
    в разное время объекты различных типов, п.<a href="#R.9.5">R.9.5</a>;
<li>указатели на члены классов, которые задают члены данного типа
    среди всех объектов данного класса, п.<a href="#R.8.2.3">R.8.2.3</a>.
</ul>
<p>В общем случае указанные методы построения объектов могут применяться
  рекурсивно, ограничения приведены в п.<a href="#R.8.2.1">R.8.2.1</a>, п.<a href="#R.8.2.4">R.8.2.4</a>, п.<a href="#R.8.2.5">R.8.2.5</a>
  и п.<a href="#R.8.2.2">R.8.2.2</a>.</p>
<p>Про указатель на объекты типа T говорят "указатель на на T". Например,
  про указатель на объект типа int говорят "указатель на int", а
  указатель на объект класса X называется "указатель на X".</p>
<p>Объекты типа void* (указатель на void), const void* и
  volatile void* могут использоваться как указатели на объекты
  неизвестного типа. Объект типа void* должен иметь достаточно памяти,
  чтобы хранить указатель на любой объект.</p>
<p>Все фрагменты руководства, говорящие об "указателях", не относятся
  к указателям на члены, за исключением указателей на статические
  члены.</p>

<a name="#R.3.6.3"></a><h6>R.3.6.3 Имена типов</h6>
<p>Основные и производные типы можно поименовать с помощью механизма
  typedef (п.<a href="#R.7.1.3">R.7.1.3</a>), а семейство типов и функций можно задать и
  поименовать с помощью механизма шаблона типов (п.<a href="#R.14">R.14</a>).</p>

<a name="#R.3.7"></a><h5>R.3.7 Адреса</h5>
<p>Любой объект - это некоторая область памяти, адрес - выражение,
  ссылающееся на объект или функцию. Очевидным примером адреса будет
  имя объекта. Существуют операции, порождающие адреса, например,
  если E выражение типа указатель, то *E - адресное выражение,
  соответствующее объекту, на который указывает E. Термин "адрес"
  ("lvalue" т.е. left value - левая величина) появляется из оператора
  присваивания E1 = E2, где левый операнд E1 должен "адресовать"
  изменяемую переменную. При обсуждении всех операций в п.<a href="#R.5">R.5</a> указывается
  применимы ли они к адресным операндам и порождают ли они сами адреса.
  Адрес может изменяться, если он не является именем функции,
  именем массива или const.</p>

<a name="#R.4"></a><h4>R.4 Стандартные преобразования</h4>
<p>Некоторые операции в зависимости от своих операндов могут вызвать
  преобразование значения операнда от одного типа к другому. Здесь
  описываются преобразования, вызванные самыми обычными операциями,
  и объясняется каковы могут быть результаты таких преобразований.
  По мере надобности будут даны дополнительные объяснения при
  обсуждении каждой операции. Подобные преобразования также происходят
  при инициализации (п.<a href="#R.8.4">R.8.4</a>, 
  п.<a href="#R.8.4.3">R.8.4.3</a>, п.<a href="#R.12.8">R.12.8</a>, 
  п.<a href="#R.12.1">R.12.1</a>).
  В п.<a href="#R.12.3">R.12.3</a>  и п.<a href="#R.13.2">R.13.2</a> описываются преобразования, заданные
  пользователем, и их соотношения со стандартными преобразованиями.
  В результате преобразования может получиться адрес, только если
  результат есть ссылка (п.<a href="#R.8.2.2">R.8.2.2</a>).</p>

<a name="#R.4.1"></a><h5>R.4.1 Стандартные преобразования для целочисленных</h5>
<p>Всюду, где требуется целое, можно использовать char, short int,
  элемент перечисления (п.<a href="#R.7.2">R.7.2</a>) или битовое поле (п.<a href="#R.9.6">R.9.6</a>), причем
  в знаковом и беззнаковом вариантах. Если int может представлять
  все значения исходного типа, значение преобразуется к int, иначе
  оно преобразуется к unsigned int. Это называется стандартным
  преобразованием для целочисленных.</p>

<a name="#R.4.2"></a><h5>R.4.2 Преобразования целочисленных</h5>
<p>Если целое преобразуется в беззнаковый тип, то полученное значение
  есть наименьшее беззнаковое целое, совпадающее с целым со знаком
  по (mod 2**n), где n есть число битов в представлении беззнакового
  целого. Для представления в дополнительном коде это преобразование
  лишь концептуальное, никаких изменений в двоичном представлении
  в действительности не происходит.</p>
<p>Если целое преобразуется к знаковому типу, значение не меняется,
  при условии, что его можно представить с помощью нового типа,
  иначе значение определяется реализацией.</p>

<a name="#R.4.3"></a><h5>R.4.3 Значения с плавающей точкой и двойной точностью</h5>
<p>Для выражений типа float может использоваться арифметика с обычной
  точностью. Если значение с плавающей точкой меньшей точности
  преобразуется в значение типа float равной или большей точности,
  то изменения значения не происходит. Если значение с плавающей
  точкой большей точности преобразуется в значение типа float
  меньшей точности и значение находится в пределах, задаваемых
  представлением типа, то в результате может получиться или
  ближайшее большее или ближайшее меньшее представимое значение.
  Если результат оказался вне границ представления типа, поведение
  неопределено.</p>

<a name="#R.4.4"></a><h5>R.4.4 Целочисленные и числа с плавающей точкой</h5>
<p>Преобразование значения с плавающей точкой к целочисленному типу
  сводится к "усечению", т.е. отбрасыванию дробной части. Такие
  преобразования зависят от машины, в частности в какую сторону будет
  проходить усечение для отрицательных чисел определяется на разных
  машинах по разному. Результат считается неопределенным, если
  значение нельзя представить в целочисленном типе.</p>
<p>Преобразования целочисленных значений к значениям с плавающей
  точкой математически корректны настолько, насколько это позволяет
  система команд. Может произойти потеря точности, если целочисленное
  значение нельзя точно представить как значение с плавающей точкой.</p>

<a name="#R.4.5"></a><h5>R.4.5 Арифметические преобразования</h5>
<p>Для большинства операций преобразования операндов и тип результата
  определяются одними и и теми же правилами. Это правило можно назвать
  "обычными арифметическими преобразованиями".</p>
<pre>
     Если один из операндов есть long double, другой операнд
     преобразуется в long double.
     Иначе, если один из операндов есть double, другой операнд
     преобразуется в double.
     Иначе, если один из операндов есть float, другой операнд
     преобразуется в float.
     Иначе, если стандартные целочисленные преобразования 
     (п.<a href="#R.4.1">R.4.1</a>)
     происходят над обоими операндами.
     Тогда, если один из операндов есть unsigned long, другой
     операнд преобразуется в unsigned long.
     Иначе, если один из операндов есть long int, а другой -
     unsigned int, то при условии, что long int может представлять
     все возможные значения unsigned int, значение unsigned int
     преобразуется в long int, в противном случае оба операнда
     преобразуются в unsigned long int.
     Иначе, если один из операндов есть long, другой операнд
     преобразуется в long.
     Иначе, если один из операндов есть unsigned, другой операнд
     преобразуется в unsigned.
     Иначе, оба операнда должны быть int.
</pre>

<a name="#R.4.6"></a><h5>R.4.6 Преобразования указателей</h5>
<p>Всюду, где указатели (п.<a href="#R.8.2.1">R.8.2.1</a>) присваиваются, инициализируются,
  сравниваются или используются иным образом, могут происходить
  следующие преобразования:</p>
<ul>
<li>     Константное выражение (п.<a href="#R.5.19">R.5.19</a>), которое сводится к нулю,
     преобразуется в указатель, обычно называемый пустым указателем.
<li>     Гарантируется, что значение такого указателя будет отлично от
     любого указателя на объект или функцию.
<li>     Указатель на объект любого типа, не являющегося const или
     volatile, можно преобразовать в void*.
<li>     Указатель на функцию можно преобразовать в void*, при условии,
     что для void* отводится достаточно памяти, чтобы хранить этот
     указатель.
<li>     Указатель на данный класс можно преобразовать в указатель на
     доступный базовый класс данного класса (п.<a href="#R.10">R.10</a>), если такое
     преобразование не содержит двусмысленность (п.<a href="#R.10.1">R.10.1</a>). Базовый
     класс считается доступным, если доступны его общие члены (п.<a href="#R.11.1">R.11.1</a>).
<li>     Результатом преобразования будет указатель на объект типа базового
     класса, вложенный в объект типа производного класса. Пустой указатель
     (0) преобразуется сам в себя.
<li>     Выражение типа "массив T" может преобразовываться в указатель
     на начальный элемент массива.
<li>     Выражение типа "функция, возвращающая T" преобразуется в "указатель
     на функцию, возвращающую T", за исключением тех случаев, когда
     оно используется как операнд адресной операции & или операции
     вызова функции ().
</ul>

<a name="#R.4.7"></a><h5>R.4.7 Преобразования ссылок</h5>
<p>Всюду, где ссылки (п.<a href="#R.8.2.2">R.8.2.2</a>) инициализируются (включая передачу
  параметров (п.<a href="#R.5.2.2">R.5.2.2</a>) и возврат значения функции (п.<a href="#R.6.6.3">R.6.6.3</a>)) или
  используются иным образом, возможны следующие преобразования:<br>
     Ссылка на данный класс может быть преобразована в ссылку на доступный
     базовый класс (п.<a href="#R.10">R.10</a>, п.<a href="#R.11.1">R.11.1</a>) данного класса (п.<a href="#R.8.4.3">R.8.4.3</a>),
     при условии, что такое преобразование не содержит двусмысленности
     (п.<a href="#R.10.1.1">R.10.1.1</a>). Результатом преобразования будет ссылка на объект
     базового класса, вложенный в объект производного класса.</p>

<a name="#R.4.8"></a><h5>R.4.8 Указатели на члены</h5>
<p>Всюду, где указатели на члены (п.<a href="#R.8.2.3">R.8.2.3</a>) инициализируются,
  присваиваются, сравниваются или используются иным образом,
  могут происходить следующие преобразования:<br>
     Константное выражение (п.<a href="#R.5.19">R.5.19</a>), которое сводится к нулю,
     преобразуется в указатель на член. Гарантируется, что его
     значение будет отлично от любых других указателей на члены.
     Указатель на член данного класса можно преобразовать в
     указатель на член производного от данного класса, при условии,
     что допустимо обратное преобразование от указателя на член производного
     класса в указатель член базового класса, и что оно выполнимо
     однозначным образом (п.<a href="#R.10.1.1">R.10.1.1</a>).</p>
<p>Правило преобразования указателей на члены (т.е. от указателя на
  член базового класса к указателю на член производного класса) выглядит
  перевернутым, если сравнивать его с правилом для указателей на
  объекты (т.е. от указателя на производный объект к указателю на
  базовый объект) (п.<a href="#R.4.6">R.4.6</a>, п.<a href="#R.10">R.10</a>). Это необходимо для гарантии
  надежности типов.</p>
<p>Отметим, что указатель на член не является указателем на объект
  или указателем на функцию и правила преобразований таких указателей
  не применимы для указателей на члены. В частности указатель на член
  нельзя преобразовать в void*.</p>

<a name="#R.5"></a><h4>R.5 Выражения</h4>
<p>Здесь определяются синтаксис, порядок вычисления и назначение
  выражений. Выражение - это последовательность операций и операндов,
  которая задает вычисление. Вычисление может выдавать в качестве
  результата значение и может вызывать побочные эффекты.</p>
<p>Операции могут быть перегружены, т.е. им может быть приписано значение,
  когда они применяются к выражениям типа класс (п.<a href="#R.9">R.9</a>). Применение
  перегруженных операций преобразуется в вызовы функций в соответствии
  с описанием в п.<a href="#R.13.4">R.13.4</a>. Перегруженные операции подчиняются
  синтаксическим правилам, определенным в этом разделе, но требования
  к типу операнда, адресу и порядку вычисления заменяются на правила
  вызова функции. Соотношения между операциями, типа ++a означает
  a+=1, не гарантируются для перегруженных операций (п.<a href="#R.13.4">R.13.4</a>).</p>
<p>В этом разделе описано применение операций к типам, для которых
  они не являются перегруженными. Перегрузка операций не может изменить
  правила применения операций к типам, для которых такое применение
  предусмотрено в самом языке.</p>
<p>Порядок вычисления подвыражений определяется приоритетом и порядком
  применения операций. Обычные математические правила ассоциативности
  и коммутативности операций действуют только, если операции
  действительно ассоциативны или коммутативны. За исключением
  оговоренных случаев порядок вычисления операндов конкретной операции
  неопределен. В частности, если в выражении значение изменяется
  дважды, результат выражения неопределен, если только порядок
  выполнения не обеспечивается самими операциями, например:</p>
<pre>
      i = v[i++];  // the value of `i' is undefined
      i=7,i++,i++; // `i' becomes 9
</pre>
<p>Реакция на переполнение и деление на нуль при вычислении выражения
  зависит от реализации. В большинстве существующих реализаций С++
  игнорируется переполнение целых. Реакция на деление на нуль и
  ошибки операций над числами с плавающей точкой варьируется от
  машины к машине и обычно связана с соответствующими библиотечными
  функциями.</p>
<p>Кроме оговоренных случаев, операнды типа const T, volatile T,
  T&, const T& и volatile T& можно использовать, как если бы они
  имели тип просто T. Аналогично, операнды типа T* const, T*volatile
  можно использовать, как если бы они имели тип просто T*, за
  исключением оговоренных случаев. Аналогично, просто тип T можно
  использовать всюду, где требуется тип volatile T или const T.
  Эти правила может применять в комбинации, так что const T* volatile
  можно использовать там, где требуется T*, за исключением оговоренных
  случаев. При рассмотрении разрешения перегрузки (п.<a href="#R.13.2">R.13.2</a>) такое
  использование операций не считается стандартным преобразованием
  операндов.</p>
<p>Если выражение имеет тип "ссылка на T" (п.<a href="#R.8.2.2">R.8.2.2</a>, п.<a href="#R.8.4.3">R.8.4.3</a>),
  значение выражение есть объект типа "T", на который настроена
  ссылка. Выражение является адресом. Ссылку можно представлять как
  имя объекта.</p>
<p>Допустимы определенные пользователем преобразования объектов
  класса в (и обратно) основные типы, указатели и т.д. (п.<a href="#R.12.3">R.12.3</a>)
  Если они недвусмысленны (п.<a href="#R.13.2">R.13.2</a>), такие преобразования могут
  применяться транслятором всегда, когда появляется объект типа класса
  в качестве операнда операции, в качестве инициализирующего
  выражения (п.<a href="#R.8.4">R.8.4</a>), в качестве выражения, задающего условие (п.<a href="#R.6.4">R.6.4</a>),
  или в качестве выражения, используемого в операторе цикла (п.<a href="#R.6.5">R.6.5</a>),
  или в качестве значения, возвращаемого функцией (п.<a href="#R.6.6.3">R.6.6.3</a>),
  или в качестве параметра функции (п.<a href="#R.5.2.2">R.5.2.2</a>).</p>

<a name="#R.5.1"></a><h5>R.5.1 Первичные выражения</h5>
<p>Первичными выражениями являются литералы, имена и имена, определенные
  с помощью операции разрешения области видимости ::.</p>
<pre>
       первичное-выражение:
            литерал
            this
            :: идентификатор
            :: имя-функции-операции
            :: уточненное-имя
            ( выражение )
            имя
</pre>
<p>Литерал является первичным выражением. Его тип определяется
  его видом (п.<a href="#R.2.5">R.2.5</a>).</p>
<p>В теле нестатической функции-члене (п.<a href="#R.9.3">R.9.3</a>) служебное слово
  this обозначает указатель на объект, к которому относится вызов
  функции. Служебное слово this нельзя использовать вне тела
  функции-члена класса.</p>
<p>Операция :: , за которой следует идентификатор или
  имя-операции-функции или уточненное-имя являются первичным
  выражением. Его тип задается описанием идентификатора, имени
  или имени-функции-операции. Результатом является идентификатор,
  имя или имя-функции-операции. Результат является адресом, если
  идентификатор является адресом. Идентификатор или имя-функции-операции
  должны иметь файловую область видимости. С помощью операции ::
  можно обращаться к типу, объекту, функции или элементу перечисления,
  даже если обозначающий их идентификатор является скрытым (п.<a href="#R.3.2">R.3.2</a>).</p>
<p>Выражение в скобках является первичным выражением, тип и значение
  которого идентичны им же у выражения без скобок. Наличие скобок
  не влияет на то, является выражение адресом или нет.</p>
<p>Понятие имя - это определенное первичное-выражение, которое
  может появляться только после . и -> (п.<a href="#R.5.2.4">R.5.2.4</a>):</p>
<pre>
       имя:
          идентификатор
          имя-функции-операции
          имя-функции-преобразования
          ~имя-класса
          уточненное-имя
</pre>
<p>Идентификатор есть имя, при условии что он описан надлежащим образом
  (п.<a href="#R.7">R.7</a>). Понятие имя-функции-операции описано в (п.<a href="#R.13.4">R.13.4</a>), а
  понятие имя-функции-преобразования в (п.<a href="#R.12.3.2">R.12.3.2</a>). Конструкция
  ~имя-класса обозначает деструктор (п.<a href="#R.12.4">R.12.4</a>).</p>
<pre>
         уточненное-имя:
                  уточняющее-имя-класса :: имя
</pre>
<p>Понятие уточняющее-имя-класса, за которым следует :: и имя члена
  этого класса (п.<a href="#R.9.2">R.9.2</a>), или члена базового по отношению к данному
  класса (п.<a href="#R.10">R.10</a>) является уточненное-имя. Его тип есть
  тип члена, а результат выражения есть этот член. Результат является
  адресом, если таковым является член. Имя класса может быть скрыто
  другим именем (не типа), в таком случае все равно имя класса
  доступно и его можно использовать. Если используется
  имя-класса::имя-класса или имя-класса::~имя-класса, оба понятия
  имя-класса должны обозначать один и тот же класс. С помощью такой
  записи обозначаются конструкторы (п.<a href="#R.12.1">R.12.1</a>) и деструкторы (п.<a href="#R.12.4">R.12.4</a>)
  соответственно. Можно использовать уточняющие имена
  неоднократно, например, N1::N2::N3::n, чтобы обозначать вложенные
  типы (п.<a href="#R.9.7">R.9.7</a>).</p>

<a name="#R.5.2"></a><h5>R.5.2 Постфиксные выражения</h5>
<p>Постфиксные выражения применяются слева направо.</p>
<pre>
        постфиксное-выражение:
               первичное-выражение
               постфиксное-выражение [ выражение ]
               постфиксное-выражение ( список-выражений opt )
               имя-простого-типа     ( список-выражений opt )
               постфиксное-выражение .  имя
               постфиксное-выражение -> имя
               постфиксное-выражение ++
               постфиксное-выражение --
        список-выражений:
              выражение-присваивания
              список-выражений , выражение-присваивания
</pre>

<a name="#R.5.2.1"></a><h6>R.5.2.1 Индексация</h6>
<p>Постфиксное выражение, за которым следует выражение в квадратных
  скобках, является постфиксным выражением. Интуитивный смысл его
  индексирование. Первое из выражений должно иметь тип "указатель на T",
  а второе быть целочисленного типа. Тип результата есть "T". Выражение
  E1[E2] совпадает (по определению) с выражением *((E1) + (E2)).
  Подробности операций * и + даны в п.<a href="#R.5.3">R.5.3</a>  и п.<a href="#R.5.7">R.5.7</a>, а массивы
  обсуждаются в п.<a href="#R.8.2.4">R.8.2.4.</a></p>

<a name="#R.5.2.2"></a><h6>R.5.2.2 Вызов функции</h6>
<p>Вызов функции является постфиксным выражением, за которым следует,
  возможно пустой, список выражений в скобках, разделенных запятой.
  Эти выражения образуют фактические параметры функции. Постфиксное
  выражение должно иметь тип "функция, возвращающая T", "указатель на
  функцию, возвращающую T" или "ссылка на функцию, возвращающую T",
  а результат операции вызова имеет тип "T".</p>
<p>При вызове функции происходит инициализация каждого формального
  параметра (п.<a href="#R.8.4.3">R.8.4.3</a>, п.<a href="#R.12.8">R.12.8</a>, п.<a href="#R.12.1">R.12.1</a>) фактическим параметром.
  Производятся стандартные (п.<a href="#R.4">R.4</a>) и заданные пользователем (п.<a href="#R.12.3">R.12.3</a>)
  преобразования типа. В функции может изменяться значения непостоянных
  формальных параметров, но эти изменения не могут повлиять на значения
  фактических параметров, кроме того случая, когда формальный параметр
  имеет тип ссылки без спецификации const (п.<a href="#R.8.2.2">R.8.2.2</a>). Если формальный
  параметр имеет тип ссылки при необходимости может создаваться
  временная переменная (п.<a href="#R.7.1.6">R.7.1.6</a>, 
  п.<a href="#R.2.5">R.2.5</a>, п.<a href="#R.2.5.4">R.2.5.4</a>, 
  п.<a href="#R.8.2.4">R.8.2.4</a>,
  п.<a href="#R.12.2">R.12.2</a>). Добавим, что возможно изменение непостоянных объектов с
  помощью параметров-указателей.</p>
<p>Функцию можно описать таким образом, что она сможет использовать
  меньшее число параметров (определив параметры по умолчанию 
  п.<a href="#R.8.2.6">R.8.2.6</a>)
  или большее число параметров (с помощью эллипсиса ... 
  п.<a href="#R.8.2.5">R.8.2.5</a>),
  чем было указано при определении функции (п.<a href="#R.8.3">R.8.3</a>).</p>
<p>Функцию можно вызвать только, если описание ее доступно в той области
  видимости, где происходит вызов. Отсюда следует, всякий формальный
  параметр, соответствующий некоторому фактическому параметру, должен
  быть доступен, если не считать эллипсис (...).</p>
<p>Перед вызовом всякий фактический параметр типа float, для которого
  нет формального параметра, преобразуется к типу double,  а типа
  char, short, перечисления или битовое поле, для которого нет
  формального параметра, преобразуется к типу int или unsigned
  согласно стандартным преобразованиям целочисленных (
  п.<a href="#R.4.1">R.4.1</a>).
  Объект, являющийся классом и не имеющий описания формального параметра,
  передается при вызове как структура данных.</p>
<p>Объект, являющийся классом и имеющий описание формального
  параметра передается с помощью инициализации формального параметра
  фактическим параметром, которая происходит перед выполнением
  функции посредством вызова конструктора (п.<a href="#R.12.2">R.12.2</a>, 
  п.<a href="#R.12.8">R.12.8</a>).</p>
<p>Порядок вычислений параметров неопределен и учтите, что он
  может быть различен у разных трансляторов. Все побочные эффекты
  выражений фактических параметров могут происходить перед началом
  выполнения функции. Порядок вычисления постфиксных выражений и
  списка выражений параметров неопределен.</p>
<p>Допустимы рекурсивные вызовы.</p>
<p>Операция вызова функции порождает адрес только, если тип
  результата есть адрес.</p>

<a name="#R.5.2.3"></a><h6>R.5.2.3 Явные преобразования типа</h6>
<p>Конструкция имя-простого-типа (п.<a href="#R.7.1.6">R.7.1.6</a>), за которой следует
  список-выражений в скобках образует значение указанного типа
  с учетом списка выражений. Если список выражений содержит более
  одного значения, тип должен быть классом с конструктором, описанным
  соответствующим образом (п.<a href="#R.8.4">R.8.4</a>, п.<a href="#R.12.1">R.12.1</a>).</p>
<p>Конструкция имя-простого-типа (п.<a href="#R.7.1.6">R.7.1.6</a>), за которой следует
  пара скобок (пустая), образует значение указанного типа. Если тип
  является классом с конструктором, описанным соответствующим образом,
  будет вызван этот конструктор, в противном случае результатом
  будет неопределенное значение указанного типа, см. так же (п.<a href="#R.5.4">R.5.4</a>).</p>

<a name="#R.5.2.4"></a><h6>R.5.2.4 Доступ к члену класса</h6>

<p>Постфиксное выражение, за которым следует точка (.) и имя, является
  постфиксным выражением. Первое выражение должно быть объектом типа
  класс, а имя должно быть именем члена этого класса. Результатом будет
  поименованный член объекта и он будет адресом, если член является
  адресом.</p>
<p>Постфиксное выражение, за которым следует стрелка (->)  и имя,
  является постфиксным выражением. Первое выражение должно быть
  указателем на объект типа класс, а имя должно быть именем члена
  этого класса. Результатом будет поименованный член объекта, на
  который настроен указатель и он будет адресом, если член является
  адресом. Значит выражение E1->MOS тоже самое, что (*E1).MOS.</p>
<p>Обратите внимание, что "объекты типа класс" могут быть
  структурами (п.<a href="#R.9.2">R.9.2</a>) или объединениями (п.<a href="#R.9.5">R.9.5</a>). Классы обсуждаются
  в п.<a href="#R.9">R.9</a>.</p>

<a name="#R.5.2.5"></a><h6>R.5.2.5 Инкремент и декремент</h6>
<p>Значение, получаемое в результате применения постфиксной операции ++,
  есть значение операнда. Операнд должен быть изменяемым адресом.
  Тип операнда должен быть арифметический или тип указателя. После
  выборки результата (для дальнейшего использования) объект увеличивается
  на 1. Тип результата совпадает с типом операнда, но не является
  адресом (см. так же п.<a href="#R.5.7">R.5.7</a> и п.<a href="#R.5.17">R.5.17</a>).</p>
<p>Постфиксная операция -- сводится к операции декремента (уменьшение
  на 1) и аналогична операции ++.</p>

<a name="#R.5.3"></a><h5>R.5.3 Унарные операции</h5>
<p>Выражения с унарными операциями выполняются справа налево.</p>
<pre>
      унарное-выражение:
           постфиксное-выражение
           ++ унарное выражение
           -- унарное выражение
           унарная-операция выражение-приведения
           sizeof унарная-операция
           sizeof ( имя-типа )
           выражение-размещения
           выражение-освобождения
       унарная-операция: один из
            *  &  +  -  !  ~
</pre>
<p>Унарная операция * означает косвенность: выражение должно быть
  указателем, а результат является адресом, ссылающимся на объект, на
  который указывает выражение. Если тип выражения есть "указатель на T",
  то тип результата будет "T".</p>
<p>Результатом унарной операции & будет указатель на ее операнд.
  Операнд должен быть функцией или адресом или конструкцией
  уточненное-имя. Для первых двух случаев, если тип выражения
  есть "T", то тип результата будет "указатель на T". В частности,
  адрес объекта типа const T имеет тип const T*, тоже верно для
  volatile. Для случая уточненное имя если член класса "C" не является
  статическим и имеет тип "T", то тип результата операции будет
  "указатель на член C типа T". Для статических членов типа T
  результатом будет обычный "указатель на T". Адрес перегруженной
  функции (п.<a href="#R.13">R.13</a>) можно брать только при инициализации или
  присваивании, в котором левая часть однозначно определяет какая
  версия перегруженной функции имеется ввиду (п.<a href="#R.13.3">R13.3</a>).</p>
<p>Операнд унарной операции + должен быть арифметического типа
  или типа указатель и результатом будет значение операнда. Для
  целочисленных операндов  производится стандартное преобразование
  целочисленных. Тип результата есть тип преобразованного операнда.</p>
<p>Операнд унарной операции - должен иметь арифметический тип и
  результатом будет изменение знака операнда. Для целочисленных
  операндов выполняется стандартное преобразование целочисленных.
  Операция для беззнаковых величин выполняется с помощью вычитания
  значения операнда из 2**n, где n число битов в представлении
  преобразованного операнда. Тип результата есть преобразованного
  операнда.</p>
<p>Операнд операции логического отрицания ! должен иметь
  арифметический тип или быть указателем, результат равен 1, если
  значение операнда есть 0, и равен 0, если операнд не равен 0.
  Тип результата есть int.</p>
<p>Операнд операции ~ должен иметь целочисленный тип, результатом
  будет обращение двоичного представления операнда. Выполняются
  стандартные преобразования целочисленных. Тип результата есть
  тип преобразованного операнда.</p>

<a name="#R.5.3.1"></a><h6>R.5.3.1 Инкремент и декремент</h6>
<p>Операнд префиксной операции ++ увеличивается на 1. Операнд должен
  быть изменяемым адресом. Тип операнда должен быть арифметическим
  или указателем. Результатом является новое значение операнда,
  оно считается адресом. Выражение ++x эквивалентно x+=1. Для
  уточнения преобразований можно обратиться к описанию сложения
  (п.<a href="#R.5.7">R.5.7</a>) и операций присваивания (п.<a href="#R.5.17">R.5.17</a>).</p>
<p>Префиксная операция -- сводится к уменьшению на 1 и выполняется
  аналогично префиксной операции ++.</p>

<a name="#R.5.3.2"></a><h6>R.5.3.2 Операция sizeof</h6>
<p>Операция sizeof вычисляет размер своего операнда в байтах. Операнд
  должен быть или выражением, которое не вычисляется, или именем типа
  в скобках. Операцию sizeof нельзя применять к функции, битовому полю,
  неопределенному классу, типу void или к массиву с неуказанными
  границами индексов. Байт никак не определяется языком, кроме как
  результата операции sizeof, именно sizeof(char) есть 1.</p>
<p>Если операция применяется к ссылке, результатом будет размер
  объекта, на который настроена ссылка. Если она применяется к классу,
  результатом будет размер объекта этого класса в байтах с учетом
  всех дополнительных байтов, которые потребуется для размещения
  такого объекта в массиве. Размер любого класса или объекта класса
  больше нуля. В случае массива операция выдает полное число байтов
  в массиве. Отсюда следует, что размер массива из n элементов равен
  размеру элемента, умноженному на n.</p>
<p>Операция sizeof может применяться к указателю на функцию, но не
  к самой функции.</p>
<p>Результатом операции будет константа типа size_t. Этот тип
  определен в стандартном заголовочном файле <stddef.h> и является
  зависящим от реализации беззнаковым целочисленным типом.</p>

<a name="#R.5.3.3"></a><h6>R.5.3.3 Операция new</h6>
<p>Операция new предназначена для создания объекта типа имя-типа
  (п.<a href="#R.8.1">R.8.1</a>). Этот тип должен быть типом объекта и функции нельзя
  размещать с ее помощью, хотя указатели на функции можно.</p>
<pre>
       выражение-размещения:
            ::opt new параметры-new opt имя-типа-new инициализатор-new
            ::opt new параметры-new opt ( имя-типа ) инициализатор-new
       параметры-new:
            ( список-выражений )
       имя-типа-new:
            список-спецификаций-типа описатель-new opt
       описатель-new:
            * список-спецификаций-cv opt описатель-new opt
            имя-класса :: список-спецификаций-cv opt описатель-new opt
            описатель-new opt [ выражение ]
       инициализатор-new:
            ( список-инициализаторов opt )
</pre>
<p>Время жизни объекта, созданного с помощью new, не ограничивается
  областью видимости, в которой он был создан. Операция new возвращает
  указатель на созданный объект. Если объект является массивом,
  возвращается указатель на начальный элемент массива. Например,
  обе операции new int и new int[1] возвратят int* , а типом
  new int[i][10] будет int(*)[10]. Если описывается тип массива
  (п.<a href="#R.8.2.4">R.8.2.4</a>), все размерности, кроме первой, должны быть выражениями-
  константами (п.<a href="#R.5.19">R.5.19</a>) с положительным значением. Первая размерность
  массива может задаваться произвольным выражением, даже если
  используется имя-типа (здесь нарушается общее требование, чтобы
  размерности массива в конструкции имя-типа были
  выражениями-константами (п.<a href="#R.5.19">R.5.19</a>)).</p>
<p>Допускается, чтобы вызывалась функция operator new() с параметром
  нуль. В таком случае возвращается указатель на объект. При повторении
  таких вызовов будут возвращаться указатели на разные объекты.</p>
<p>Конструкция список-спецификаций-типа не должна содержать const,
  volatile, описание класса или перечисления.</p>
<p>Для резервирования памяти операция new обращается к функции
  operator new() (п.<a href="#R.12.5">R.12.5</a>). При размещении объекта типа T ей в
  качестве первого параметра передается sizeof(T). Конструкция
  параметры-new используется для передачи дополнительных параметров.
  Например, операция new T приводит к вызову operator new(sizeof(T)),
  а операция new(2,f) T  приводит к вызову operator new(sizeof(T),2,f).</p>
<p>Конструкция параметры-new может использоваться только, если
  описана функция operator new() с параметрами соответствующих типов.</p>
<p>Если с помощью операции new создается объект не типа класс
  (в том числе и массив объектов типа класс), то вызывается глобальная
  функция ::operator new(). Если с помощью new создается объект класса
  T, вызывается функция T::operator new(), если она существует
  (используя обычные правила просмотра при поиске членов класса и его
  базовых классов, п.<a href="#R.10.1.1">R.10.1.1</a>), иначе вызывается глобальная функция
  ::operator new(). Использование операции ::new() гарантирует, что
  будет вызываться глобальная функция ::operator new(), даже если
  существует T::operator new().</p>
<p>Конструкция выражение-размещения может содержать инициализатор-new.
  Для объектов классов с конструкторами (п.<a href="#R.12.1">R.12.1</a>) задаваемый ею
  список параметров будет использоваться при вызове конструктора, в
  других случаях конструкция инициализатор-new должна иметь вид
  ( выражение ) или ( ). Если выражение присутствует, оно используется
  для инициализации объекта, если его нет, объект начнет существование
  с неопределенным значением.</p>
<p>Если класс имеет конструктор, объект этого класса можно создать
  с помощью new только при условии, что заданы подходящие параметры,
  или, что класс имеет стандартный конструктор (п.<a href="#R.12.1">R.12.1</a>).
  Отводит ли память при создании объекта типа класс сама функция
  operator new, или оставляет это на конструктор, зависит от реализации.
  Как для конструктора, так и для функции operator new() проводится
  проверка возможности доступа и однозначности (п.<a href="#R.12">R.12</a>).</p>
<p>Для массивов нельзя задавать инициализаторы. Массивы объектов
  типа класса с конструктором можно создавать с помощью операции new
  только, если конструктор класса является стандартным (п.<a href="#R.12.1">R.12.1</a>).
  В этом случае стандартный конструктор будет вызываться для каждого
  элемента массива.</p>
<p>Инициализация производится только в том случае, когда функция
  operator new() возвращает ненуль. Если она возвращает 0 (пустой
  указатель), значение выражения есть 0.</p>
<p>Порядок вычисления выражения вызова operator new() для получения
  памяти и порядок вычисления параметров конструктора неопределен.
  Так же неопределено вычисляются ли параметры конструктора, если
  функция operator new() возвратила 0.</p>
<p>В конструкции имя-типа-new скобки использовать необязательно.<br>
  Тогда обращение</p>
<pre>
      new int (*[10])();   // error
</pre>
<p>может привести к ошибке, т.к. операции применяются в таком порядке</p>
<pre>
      (new int) (*[10])(); // error
</pre>
<p>Объекты сложного типа можно задать в операции new с помощью явно
  указанных скобок, например, обращение</p>
<pre>
      new (int (*[10])());
</pre>
<p>размещает массив из 10 указателей на функции (не имеющие параметров
  и возвращающие int).</p>
<p>Конструкции имя-типа-new в выражение-размещения должна быть
  самой длинной из возможных последовательностей конструкций
  описатель-new. Это предотвращает коллизии между операциями из
  описателей &, *, [] и их двойниками из выражения, например,</p>
<pre>
       new int* i;   // syntax error: parsed as `(new int*) i'
                     //               not s `(new int)*i'
</pre>
<p>Символ * используется в описателе указателя, а не в качестве
  операции умножения.</p>

<a name="#R.5.3.4"></a><h6>R.5.3.4 Операция delete</h6>
<p>Операция delete уничтожает объект, созданный с помощью new.</p>
<pre>
         выражение-освобождения:
            ::opt delete выражение-приведения
            ::opt delete [] выражение-приведения
</pre>
<p>Результат имеет тип void. Операндом delete должен быть указатель,
  который возвращает new. Эффект применения операции delete к указателю,
  который не получен в результате операции new без задания
  параметры-new, считается неопределенным и обычно приводит к опасным
  последствиям. Однако гарантируется, что удаление по указателю с
  нулевым значением безопасно.</p>
<p>Результат попытки доступа к удаленному объекту неопределен, а
  удаление объекта может изменить его значение. Более того, если
  выражение, задающее объект, является изменяемым адресом, его
  значение после удаления неопределено.</p>
<p>Нельзя удалять указатель на константу.</p>
<p>Операция delete вызывает деструктор (если он есть п.<a href="#R.12.4">12.4</a>)
  для объекта, на который настроен ее операнд.</p>
<p>Для освобождения памяти, отведенной под указываемый объект,
  операция delete вызывает функцию operator delete (п.<a href="#R.12.5">R.12.5</a>).
  Для объектов, не имеющих тип класс (в том числе и для массивов
  классов), используется глобальная функция ::operator delete().
  Для объекта типа класс T вызывается функция T::operator delete(),
  если она есть (используя обычные правила просмотра при поиске
  членов класса и производных от него классов, п.<a href="#R.10.1.1">R.10.1.1</a>), в
  противном случае вызывается глобальная функция ::operator delete().
  Обращение ::delete гарантирует, что будет вызываться глобальная
  функция ::operator delete(), даже если существует T::operator delete().<br>
  Для удаления массивов используется обращение вида</p>
<pre>
        delete [ ] выражение-приведения
</pre>
<p>Здесь выражение должно указывать на массив. Если есть деструкторы,
  они будут вызываться для удаления указанных объектов.</p>
<p>Результат удаления массива с помощью простого обращения delete
  неопределен, так же как и удаление одиночного объекта с помощью
  delete [].</p>

<a name="#R.5.4"></a><h5>R.5.4 Явное преобразование типа</h5>
<p>Явное преобразование типа можно задать с помощью функциональной
  записи (п.<a href="#R.5.2.3">R.5.2.3</a>) или с помощью операции приведения.</p>
<pre>
         выражение-приведения:
             унарное-выражение
             ( имя-типа ) выражение-приведения
</pre>
<p>Задание с помощью операции приведения используется для обозначения
  преобразования к типу, который не является конструкцией
  имя-простого-типа.</p>
<p>В операции приведения нельзя определять типы.</p>
<p>Всякое преобразование типа, не упомянутое здесь и не являющееся
  преобразованием явно определенным пользователем (п.<a href="#R.12.3">R.12.3</a>), считается
  ошибкой.</p>
<p>Любой тип, который можно преобразовать в другой с помощью
  стандартного преобразования (п.<a href="#R.4">R.4</a>), можно также преобразовать
  с помощью явного преобразования (приведения) и смысл преобразования
  будет тот же.</p>
<p>Указатель можно преобразовать к любому целочисленному типу,
  достаточно большому, чтобы вместить значение указателя. Алгоритм
  преобразования зависит от реализации, но предполагается, что он
  будет естественным для того, кто знает систему адресации, используемой
  машины.</p>
<p>Значение целочисленного типа может быть явно преобразовано в
  указатель. Указатель, преобразованный в целое достаточного размера
  (если такие есть в реализации), и преобразованный обратно к типу
  указателя, должен иметь свое первоначальное значение. Все другие
  детали перевода указателя в целое и обратно зависят от реализации.</p>
<p>Указатель на объект одного типа может быть преобразован в
  указатель на объект другого типа (с соблюдением ограничений, указанных
  здесь). Использование получившегося указателя может вызвать
  особую адресную ситуацию ("неверный адрес"), если преобразуемый
  указатель не
  настроен на объект, правильным образом выравненный в памяти.
  Гарантируется, что указатель на объект данного размера можно
  преобразовать в указатель на объект равного или меньшего размера
  и провести обратное преобразование без изменения значения указателя.
  На различных машинах двоичное представление указателей может быть
  различно как и требования на выравнивания объектов. Составные
  объекты выравниваются по самой строгой границе, требуемой их
  составляющими. Указатель типа void* считается совместимым с
  указателем на объект любого типа.</p>
<p>Указатель на класс B можно преобразовать в указатель на класс D,
  для которого класс B является прямо или опосредованно базовым
  классом, если существует однозначное преобразование из D в B
  (п.<a href="#R.4.6">R.4.6</a>, п.<a href="#R.10.1.1">.R.10.1.1</a>) и если B является виртуальным базовым классом
  (п.<a href="#R.10.1">R.10.1</a>). Такое приведение от базового класса к производному
  классу предполагает, что объект базового класса является вложенным
  по отношению к объекту производного класса. В результате получится
  указатель, настроенный на объемлющий объект производного класса.
  Если объект базового класса не содержится ни в каком объекте
  производного класса, такая операция приведения может вызвать
  особую ситуацию.</p>
<p>Пустой указатель (0) преобразуется сам в себя.</p>
<p>Пока еще неопределенный класс можно использовать в операции
  приведения указателя, в этом случае никаких допущений о структуре
  класса не делается (п.<a href="#R.10.1">R.10.1</a>).</p>
<p>Любой объект можно явно преобразовать к типу ссылки X&, если
  указатель на этот объект можно явно преобразовать в тип X*.
  В результате приведения к ссылке не происходит вызовов конструкторов
  или функций преобразований. Преобразование ссылки на базовый класс
  в ссылку на производный класс рассматривается аналогично
  преобразованию указателя на базовый класс в указатель на
  производный класс, учитывая вопросы однозначности, виртуальных
  классов и т.д.</p>
<p>Результатом приведения к ссылке является адрес, в отличие от всех
  остальных приведений. Результат приведения указателя или ссылки
  настроен на тот же объект, что и исходное выражение без операции
  приведения.</p>
<p>Указатель на функцию можно явно преобразовать в указатель на
  некоторый объект при условии, что тип указателя на этот объект
  достаточно велик, чтобы хранить указатель на функцию. Указатель
  на некоторый объект можно явно преобразовать в указатель на функцию
  при условии, что тип указателя на функцию достаточно велик, чтобы
  хранить указатель на этот объект. В обоих случаях, использование
  указателя, получившегося в результате преобразования, может
  вызвать особую адресную ситуацию, или что-нибудь похуже,
  если исходный указатель не настроен на соответствующий объект.</p>
<p>Указатель на функцию одного типа можно явно преобразовать в
  указатель на функцию другого типа. Результат вызова функции с
  помощью указателя на функцию, тип которой отличен от типа,
  использованного при определении первой функции, неопределен
  (см. так же п.<a href="#R.4.6">R.4.6</a>).</p>
<p>Объект или значение можно преобразовать в объект типа класс
  только при условии, что определен подходящий конструктор или
  операция преобразования (п.<a href="#R.12.3">R.12.3</a>).</p>
<p>Указатель на член можно явно преобразовать в указатель на другой
  член, если оба участвующих типа являются типами указателей
  на члены одного класса, или, если оба типа являются указателями
  на функцию-член классов, один из которых получается как однозначное
  производное от другого (п.<a href="#R.4.8">R.4.8</a>).</p>
<p>Указатель на объект с типом, имеющим спецификацию const, можно
  привести к указателю с типом без спецификации const. Получившийся
  в результате указатель будет настроен на исходный объект.
  Объект с типом, имеющим спецификацию const, или ссылку на объект
  такого типа можно привести в ссылку на объект с типом без const.
  Получившаяся в результате ссылка будет настроена на исходный
  объект. В результате попытки изменить этот объект с помощью
  такой ссылки или указателя может возникнуть особая ситуация или
  он будет таким же, как при обращении с помощью исходной ссылки
  или указателя к объекту, тип которого не содержит const. Возникнет
  ли особая адресная ситуация зависит от реализации.</p>
<p>Указатель на объект типа со спецификацией volatile можно привести
  к указателю на объект типа без volatile. В результате получится
  указатель, настроенный на исходный объект. Объект типа с volatile
  или ссылку на такой объект можно привести к ссылке на объект с типом
  без volatile.</p>

<a name="#R.5.5"></a><h5>R.5.5 Операции указатель-на-член</h5>
<p>Операции указатель-на-член применяются слева направо.</p>
<pre>
       выражение-pm:
          выражение-приведения
          выражение-pm .*  выражение-приведения
          выражение-pm ->* выражение-приведения
</pre>
<p>Бинарная операция .* связывает свой второй операнд, который должен
  иметь тип "указатель на член класса T", с первым операндом, имеющим
  тип класс T или такой класс, для которого T является однозначно
  определенным и достижимым базовым классом. Результатом будет объект
  или функция с типом, задаваемым вторым операндом.</p>
<p>Бинарная операция ->* связывает свой второй операнд, который должен
  иметь тип "указатель на член класса T", с первым операндом, имеющим
  тип "указатель на T" или тип "указатель на класс, для которого T
  является однозначно определенным и достижимым базовым классом".
  Результатом будет объект или функция с типом, задаваемым вторым
  операндом.</p>
<p>Если результат .* или ->* есть функция, то его можно использовать
  только в качестве операнда операции вызова функции (), например,
  операция</p>
<pre>
       (ptr_to_obj->*ptr_to_mfct)(10);
</pre>
<p>приводит к вызову функции-члена, обозначенной ptr_to_mfct, для
  объекта, на который настроен указатель ptr_to_obj. Результат
  операции .* или ->* является адресом, если второй операнд есть
  адрес.</p>

<a name="#R.5.6"></a><h5>R.5.6 Мультипликативные операции</h5>
<p>Мультипликативные операции *, /, и % выполняются слева направо.</p>
<pre>
      Мультипликативное-выражение:
             выражение-pm
             мультипликативное-выражение * выражение-pm
             мультипликативное-выражение / выражение-pm
             мультипликативное-выражение % выражение-pm
</pre>
<p>Операнды операций * и / должны иметь арифметический тип, операнды
  для % должны быть целочисленного типа. Обычные арифметические
  преобразования (п.<a href="#R.4.5">R.4.5</a>) производятся над операндами и определяют
  тип результата.</p>
<p>Бинарная операция * обозначает умножение.</p>
<p>Бинарная операция / вычисляет частное, а бинарная операция %
  вычисляет остаток от деления первого выражения на второе. Если
  второй операнд у / или % есть 0, результат неопределен, иначе
  (a/b)*b + a%b должно равняться a. Если оба операнда неотрицательны,
  то таким же будет и результат, в противном случае знак результата
  определяется реализацией.</p>

<a name="#R.5.7"></a><h5>R.5.7 Аддитивные операции</h5>
<p>Аддитивные операции + и - выполняются слева направо, при этом
  происходят обычные арифметические преобразования (п.<a href="#R.4.5">R.4.5</a>)
  операндов арифметического типа.</p>
<pre>
      аддитивное-выражение:
            мультипликативное-выражение
            аддитивное выражение + мультипликативное-выражение
            аддитивное-выражение - мультипликативное-выражение
</pre>
<p>Операнды должны быть арифметического типа или типа указателя.
  Результатом операции + является сумма операндов. Можно складывать
  указатель на объект в массиве и значение любого целочисленного типа.
  Результатом будет указатель того же типа, что и исходный указатель,
  но он будет настроен на другой объект массива
  с заданным смещением от исходного объекта. Так, если P
  есть указатель на объект массива, выражение P+1 является указателем
  на следующий объект массива. Если же получившийся в результате
  сложения указатель вышел за границы  массива, результат будет
  неопределенным, кроме случая, когда указатель настроен на первый адрес
  больший верхней границы массива.</p>
<p>Результатом операции - будет разность операндов. Значение
  любого целочисленного типа можно вычитать из указателя, при этом
  применяются те же преобразования, что и для операции +.</p>
<p>Никакие другие сочетания типов для указателей не допустимы.</p>
<p>Если вычитаются два указателя на объекты одного типа, результатом
  будет целочисленное значение со знаком, которое показывает на сколько
  объектов этого типа отстоят друг от друга указуемые объекты. Указатели
  на соседние элементы массива отстоят на 1. Тип результата зависит от
  реализации, но он должен быть определен как ptrdiff_t в стандартном
  заголовочном файле <stddef.h>. Результат не определен, если указатели
  не настроены на элементы одного массива. Если P есть указатель
  на последний элемент массива, то (P+1) - 1 есть P.</p>

<a name="#R.5.8"></a><h5>R.5.8 Операции сдвига</h5>
<p>Операции сдвигов << и >> выполняются слева направо.</p>
<pre>
        сдвиговое-выражение:
            аддитивное-выражение
            сдвиговое-выражение << аддитивное выражение
            сдвиговое-выражение >> аддитивное выражение
</pre>
<p>Операнды должны быть целочисленного типа, и над ними производятся
  стандартные целочисленные преобразования. Тип результата совпадает
  с типом преобразованного левого операнда. Результат не определен,
  если правый операнд отрицателен или больше или равен числу разрядов
  в двоичном представлении преобразованного левого операнда.
  Значением выражения E1<<E2 будет E1 (рассматриваемое как набор
  разрядов), сдвинутое влево на E2 разрядов, причем освободившиеся
  разряды заполняются нулями. Значением выражения E1>>E2 будет E1,
  сдвинутое вправо на E2 разрядов. Если E1 беззнакового типа или
  имеет неотрицательное значение, гарантируется, что сдвиг вправо
  - логический (заполнение нулями), иначе результат зависит от реализации.</p>

<a name="#R.5.9"></a><h5>R.5.9 Операции отношения</h5>
<p>Операции отношения выполняются слева направо, но этот факт мало что
  дает, ибо выражение a<b<c означает (a<b)<c, а вовсе не (a<b)&&(b<c).</p>
<pre>
         выражение-отношения:
            сдвиговое-выражение
            выражение-отношения <  сдвиговое-выражение
            выражение-отношения >  сдвиговое-выражение
            выражение-отношения <= сдвиговое-выражение
            выражение-отношения >= сдвиговое-выражение
</pre>
<p>Операнды должны быть арифметического типа или типа указателей.
  Операции < (меньше чем), > (больше чем), <= (меньше или равно) и
  >= (больше или равно) дают результат 0, если указанное отношение
  не выполняется, и 1, если оно выполняется. Тип результата int.</p>
<p>Над арифметическими операндами выполняются обычные арифметические
  преобразования. Над указателями выполняются обычные преобразования
  указателей. Предполагается, что любой указатель можно сравнить
  с выражением, имеющим результат 0, и любой указатель можно сравнить
  с указателем, имеющим тип void* (в этом случае указатель сначала
  преобразуется к типу void*). Указатели на объекты или функции
  одного типа (после преобразования указателей) можно сравнивать,
  результат зависит от взаимного расположения в памяти объектов или
  функций.</p>
<p>Два указателя на один и тот же объект считаются равными. Если
  два указателя настроены на нестатические члены одного объекта, то
  указатель, настроенный на член, описанный позднее, считается
  большим, при условии, что члены не имеют разных спецификаций
  указатель-доступа (п.<a href="#R.11.1">R.11.1</a>), а класс не является объединением.
  Если два указателя настроены на нестатические члены одного объекта
  и спецификации указателей-доступа (п.<a href="#R.11.1">R.11.1</a>) этих членов различны,
  результат будет не определен. Если два указателя настроены на члены
  (данные) одного и того же объединения, они считаются равными. Если два
  указателя настроены на элементы одного массива или смотрят за границу
  массива, то указатель, настроенный на элемент с большим индексом,
  будет большим. Все другие сравнения указателей определяются
  реализацией.</p>

<a name="#R.5.10"></a><h5>R.5.10 Операции сравнения на равенство</h5>
<pre>
       выражение-равенства:
             выражение-отношения
             выражение-равенства == выражение-отношения
             выражение-равенства != выражение-отношения
</pre>
<p>Операции == (равно) и != (не равно) аналогичны операциям
  отношения, за исключением того, что их приоритет ниже. (Таким образом,
  операция a&lt;b == c&lt;d дает результат 1, если выражения a&lt;b и c&lt;d
  имеют одно и то же значение.)</p>
<p>Кроме этого, можно сравнивать указатели на члены одного типа.
  Производятся преобразования указателя на член (п.<a href="#R.4.8">R.4.8</a>). Указатель
  на член можно сравнить с выражением-константой, которое дает
  результат 0.</p>

<a name="#R.5.11"></a><h5>R.5.11 Поразрядная операция И</h5>
<pre>
       выражение-И:
            выражение-равенства
            выражение-И & выражение-равенства
</pre>
<p>Выполняются обычные арифметические преобразования, результат -
  поразрядная функция И от операндов.  Операция применима только к
  целочисленным операндам.</p>

<a name="#R.5.12"></a><h5>R.5.12 Поразрядная (исключающая) операция ИЛИ</h5>
<pre>
            выражение-исключающего-ИЛИ:
                 выражение-И
                 выражение-исключающего-ИЛИ ^ выражение-И
</pre>
<p>Выполняются обычные арифметические преобразования, результат -
  поразрядная исключающая функция ИЛИ от операндов. Операция применима
  только к целочисленным операндам.</p>

<a name="#R.5.13"></a><h5>R.5.13 Поразрядная (включающая) операция ИЛИ</h5>
<pre>
        выражение-ИЛИ:
             выражение-исключающего-ИЛИ
             выражение-ИЛИ | выражение-исключающего-ИЛИ
</pre>
<p>Выполняются обычные арифметические преобразования, результат -
  поразрядная функция ИЛИ от операндов. Операция применима только
  к целочисленным типам.</p>

<a name="#R.5.14"></a><h5>R.5.14 Логическая операция И</h5>
<pre>
          логическое-выражение-И:
               выражение-ИЛИ
               логическое-выражение-И && выражение-ИЛИ
</pre>
<p>Операции && выполняются слева направо. Такая операция дает результат
  1, если оба операнда ее отличны от нуля, иначе результат - 0. В
  отличие от & при операции && гарантируется вычисление слева направо,
  более того, второй операнд не вычисляется, если первый операнд равен 0.</p>
<p>Операнды не обязательно имеют одинаковый тип, но каждый должен быть
  арифметического типа или типа указателя. Тип результата int. Все
  побочные эффекты вычисления первого выражения могут возникать до
  вычисления второго выражения.</p>

<a name="#R.5.15"></a><h5>R.5.15 Логическая операция ИЛИ</h5>
<pre>
          логическое-выражение-ИЛИ:
               логическое-выражение-И
               логическое-выражение-ИЛИ || логическое-выражение-И
</pre>
<p>Операции || выполняются слева направо. Результат операции 1, если
  один из ее операндов отличен от нуля, иначе результат - 0. В отличие
  от | при операции || гарантируется вычисление слева направо, более
  того, второй операнд не вычисляется, если значение первого операнда
  отлично от нуля.</p>
<p>Операнды не обязательно имеют одинаковый тип, но каждый должен быть
  арифметического типа или типа указателя. Тип результата int. Все
  побочные эффекты вычисления первого выражения могут возникать до
  вычисления второго выражения.</p>

<a name="#R.5.16"></a><h5>R.5.16 Операция условия</h5>
<pre>
          выражение-условия:
               логическое-выражение-ИЛИ
               логическое-выражение-ИЛИ ? выражение : выражение-условия
</pre>
<p>Условные выражения выполняются слева направо. Первое выражение должно
  быть арифметического типа или типа указателя. Оно вычисляется, и,
  если результат его отличен от нуля, то результатом условного выражения
  будет значение второго выражения, иначе результат - значение третьего
  выражения. Все побочные эффекты вычисления первого выражения могут
  возникать до вычисления второго или третьего выражения.</p>
<p>Если второе и третье выражение арифметического типа, и типы их
  совпадают, то таким же будет и тип результата, если они различаются, то
  выполняются обычные арифметические преобразования, чтобы привести их
  к общему типу. Если второе и третье выражение являются
  указателями или выражением-константой, дающим результат 0, выполняются
  преобразования указателей, чтобы привести результаты выражений к
  общему типу. Если второе и третье выражение являются ссылками,
  выполняется преобразование ссылок, чтобы привести их к общему типу.
  Если второе и третье выражение имеют тип void, общий тип
  будет void. Если второе и третье выражение имеют один тип
  класс T, общим типом будет T. Иначе, выражение считается недопустимым.
  Тип результата есть общий тип. Вычисляется только второе или третье
  выражение (но не оба). Результат будет адресом, если второй и
  третий операнд одного типа и являются адресами.</p>

<a name="#R.5.17"></a><h5>R.5.17 Операции присваивания</h5>
<p>Существует несколько операций присваивания, все они выполняются
  справа налево. Для всех них требуется, чтобы левым операндом был
  изменяемый адрес. Тип выражения присваивания совпадает с типом
  левого операнда. Результат операции присваивание - значение,
  хранящееся в левом операнде после того как произошло присваивание.
  Результат является адресом.</p>
<pre>
    выражение-присваивания:
       выражение-условия
       унарное-выражение операция-присваивания выражение-присваивания
       операция-присваивания: один из
            =  *=  /=  %=  +=  -=  >>=  <<=  &=  ^=  |=
</pre>
<p>При простом присваивании (=) значение выражения заменяет собой значение
  объекта, с которым сопоставляется левый операнд. Если оба операнда
  арифметического типа, правый операнд, прежде чем произойдет
  присваивание, преобразуется к типу левого операнда. Неявные
  преобразования к типу перечисления (п.<a href="#R.7.2">R.7.2</a>) не производятся, поэтому
  если левый операнд имеет тип перечисления, правый операнд должен
  быть таким же. Если левый операнд имеет тип указателя, правый
  операнд должен быть типа указателя или выражением-константой, дающим
  результат 0. Правый операнд преобразуется к типу левого операнда,
  прежде выполнения присваивания.</p>
<p>Указатель типа T* const можно присваивать указателю типа T*, но
  обратное присваивание считается незаконным (п.<a href="#R.7.1.6">R.7.1.6</a>). Объекты
  типа const T или volatile T можно присваивать по адресу типа T или
  volatile T (см. так же п.<a href="#R.8.4">R.8.4</a>).</p>
<p>Если левый операнд имеет тип указателя на член, правый операнд
  должен быть типа указатель на член или выражением-константой,
  дающим результат 0; перед присваиванием правый операнд преобразуется
  к типу левого операнда.</p>
<p>Присваивание объектам класса X (п.<a href="#R.9">R.9</a>) задается функцией
  X::operator=() (п.<a href="#R.13.4.3">R.13.4.3</a>). Если пользователь не определил
  свою функцию X::operator=(), для присваивания используется
  стандартный вариант (п.<a href="#R.12.8">R.12.8</a>).  Отсюда следует, что объект класса,
  который является прямым или непрямым производным от X,  и
  однозначно описан как производный в части public (п.<a href="#R.4.6">R.4.6</a>),
  можно присвоить объекту X.</p>
<p>Указатель на член класса B можно присваивать указателю на член
  того же типа класса D при условии, что D является прямым или
  непрямым производным класса B, и однозначно описан как
  производный в части public (п.<a href="#R.10.1.1">R.10.1.1</a>).</p>
<p>Присваивание объекту типа "ссылка на T" сводится к присваиванию
  объекту типа T, который обозначается ссылкой.</p>
<p>Выполнение выражение вида E1 op= E2 эквивалентно выполнению
  E1 = E1 op (E2), однако E1 вычисляется лишь один раз. В операциях
  += и -= левый операнд может быть указателем, в этом случае правый
  (целочисленный) операнд преобразуется так, как объяснялось в п.<a href="#R.5.7">R.5.7</a>.
  Все правые операнды и все левые операнды, не являющиеся ссылками,
  должны быть арифметического типа.</p>
<p>Для объектов класса присваивание в общем случае не совпадает с
  инициализацией (п.<a href="#R.8.4">R.8.4</a>, п.<a href="#R.12.1">R.12.1</a>, 
  п.<a href="#R.12.6">R.12.6</a>, п.<a href="#R.12.8">R.12.8</a>).</p>

<a name="#R.5.18"></a><h5>R.5.18 Операция запятая</h5>
<p>Операции запятая выполняются слева направо.</p>
<pre>
         выражение:
              выражение-присваивания
              выражение, выражение-присваивания
</pre>
<p>Пара выражений, разделенных запятой, вычисляется слева направо и
  значение левого выражения уничтожается. Все побочные эффекты вычисления
  левого выражения могут возникать до вычисления правого выражения.
  Тип и значение результата совпадают с типом и значением правого
  выражения. Результат является адресом, если таковым является
  правое выражение.</p>
<p>В контекстах, где запятая имеет специальное значение, скажем
  в списке фактических параметров функции (п.<a href="#R.5.2.2">R.5.2.2</a>) или в списке
  инициализаторов (п.<a href="#R.8.4">R.8.4</a>), описанная здесь операция запятая
  может появляться только в скобках, например, вызов функции</p>
<pre>
       f(a, (t=3,t+2), c);
</pre>
<p>содержит три параметра, причем второй имеет значение 5.</p>

<a name="#R.5.19"></a><h5>R.5.19 Выражения-константы</h5>
<p>В нескольких местах описания С++ требуются выражения, которые
  дают в результате целочисленную константу, например: в задании границ
  массива (п.<a href="#R.8.2.4">R.8.2.4</a>), в выражениях case (п.<a href="#R.6.4.2">R.6.4.2</a>),
  для задания длины битового поля (п.<a href="#R.9.6">R.9.6</a>) и как инициализирующее
  значение элемента перечисления (п.<a href="#R.7.2">R.7.2</a>).</p>
<pre>
         выражение-константа:
               выражение-условия
</pre>
<p>В конструкции выражение-константа могут участвовать: литералы
  (п.<a href="#R.2.5">R.2.5</a>), элементы перечисления, значения целочисленного типа со
  спецификацией const, инициализированные выражением-константой
  (п.<a href="#R.8.4">R.8.4</a>) и выражения sizeof. Константы с плавающей точкой (п.<a href="#R.2.5.3">R.2.5.3</a>)
  должны быть приведены к целочисленному типу. Допустимы только
  преобразования типа к целочисленному типу. В частности не допустимы
  функции, объекты классов, указатели и ссылки, если не считать их
  использования в sizeof. Операция запятая и операция присваивания
  не допустимы в выражении-константе.</p>

<a name="#R.6"></a><h4>R.6 Операторы</h4>
<p>Все операторы, за исключением оговоренных случаев, выполняются
  один за другим.</p>
<pre>
       оператор:
         помеченный-оператор
         оператор-выражение
         составной-оператор
         выбирающий-оператор
         оператор-цикла
         оператор-перехода
         оператор-описания
</pre>

<a name="#R.6.1"></a><h5>R.6.1 Помеченный оператор</h5>
<p>Оператор можно снабдить меткой.</p>
<pre>
         помеченный-оператор:
             идентификатор : оператор
             case выражение-константа : оператор
             default : оператор
</pre>
<p>Использование идентификатора в качестве метки является ее определением.
  Идентификатор метки может использоваться помимо этого только в качестве
  указания перехода в операторе goto. Областью видимости метки является
  функция, в которой она появилась. Метки нельзя повторно описывать
  в пределах одной функции. Нельзя использовать метку в операторе goto
  до ее определения. Метки имеют свое пространство именования и
  они не вступают в коллизию с другими идентификаторами.</p>
<p>Метки в case или default могут встречаться только в операторе
  переключателя.</p>

<a name="#R.6.2"></a><h5>R.6.2 Оператор-выражение</h5>
<p>Чаще всего операторами бывают выражения; в этом случае оператор
  имеет такой вид:</p>
<pre>
          оператор-выражение:
              выражение opt ;
</pre>
<p>Обычно операторы-выражения являются присваиваниями или вызовами
  функций. Все побочные эффекты выполнения оператора-выражения
  происходят до выполнения следующего оператора. Оператор-выражение с
  отсутствующим выражением называется пустым оператором. Он
  может пригодиться, если необходимо поставить метку перед самым концом
  составного оператора ({) или для задания пустого тела оператора
  цикла while (п.<a href="#R.6.5.1">R.6.5.1</a>).</p>

<a name="#R.6.3"></a><h5>R.6.3 Составной оператор или блок</h5>
<p>Для тех случаев, когда вместо одного оператора нужно использовать
  несколько, предусмотрен составной оператор (иногда его называют
  "блок").</p>
<pre>
             составной-оператор:
                 { список-операторов opt }

             список-операторов:
                  оператор
                  список-операторов оператор
</pre>
<p>Отметим, что описание считается оператором 
(п.<a href="#R.6.7">R.6.7</a>).</p>

<a name="#R.6.4"></a><h5>R.6.4 Выбирающий оператор</h5>
<p>Выбирающие операторы выбирают одну из нескольких структур управления.</p>
<pre>
          выбирающий-оператор:
               if ( выражение ) оператор
               if ( выражение ) оператор else оператор
               switch ( выражение ) оператор
</pre>
<p>Оператор в выбирающем-операторе не может быть описанием.</p>

<a name="#R.6.4.1"></a><h6>R.6.4.1 Оператор if</h6>
<p>Выражение должно быть арифметического типа, или типа указателя, или
  типа класс, для которого существует однозначное преобразование
  в арифметический тип или тип указателя (п.<a href="#R.12.3">R.12.3</a>).</p>
<p>Вычисляется выражение, и если оно имеет отличный от нуля результат,
  выполняется первый вложенный оператор. Если использована конструкция
  else и выражение дает результат 0, выполняется второй вложенный
  оператор. Неоднозначность в случае нескольких конструкциями else
  разрешается путем отнесения else к последнему встретившемуся if,
  для которого не было else.</p>

<a name="#R.6.4.2"></a><h6>R.6.4.2 Оператор переключателя</h6>
<p>Оператор переключателя вызывает передачу управления на один из
  нескольких операторов в зависимости от значения выражения.</p>
<p>Выражение должно быть целочисленного типа или типа класса, для
  которого существует однозначное преобразование к целочисленному
  типу (п.<a href="#R.12.3">R.12.3</a>). Выполняются стандартные целочисленные преобразования.
  Любой из операторов переключателя можно пометить одним или несколькими
  префиксами, имеющими вид:</p>
<pre>
       case выражение-константа :
</pre>
<p>Здесь выражение-константа 
  (п.<a href="#R.5.19">R.5.19</a>) приводится к преобразованному
  типу выражения переключателя. Никакие две константы из case одного
  переключателя не должны иметь одинаковое значение.</p>
<p>В переключателе может быть только один префикс вида</p>
<pre>
       default:
</pre>
<p>Операторы переключателя могут быть вложенными, тогда метки из
  case или default относятся к самому первому переключателю,
  объемлющему их.</p>
<p>При выполнении оператора переключателя вычисляется выражение,
   и его значение сравнивается с каждой из констант вариантов (case).
  Если одна из этих констант равна значению выражения, то управление
  передается в оператор, идущий за этой константой. Если ни одна из
  констант не совпала со значением выражения, но есть префикс
  default, то управление передается на оператор с этим префиксом.
  Если префикса default нет, и совпадения не было, то не выполняется
  ни один из операторов переключателя.</p>
<p>Если операторы, выполняемые в результате выбора, не приводят
  к каким-либо передачам управления, то программа продолжает выполняться
  "по меткам case и default" беспрепятственно. Выход из переключателя
  возможен с помощью оператора break (см. п.<a href="#R.6.6.1">R.6.6.1</a>).</p>
<p>Обычно оператор, с которым имеет дело переключатель, бывает
  составным. Описания могут появиться в операторах переключателя.
  Однако переход ниже описания, в котором была явная или неявная
  инициализация, считается незаконным, если только описание не
  находится во внутреннем блоке, который обходится (т.е. полностью
  обходится при передаче управления, п.<a href="#R.6.7">R.6.7</a>). Отсюда следует,
  что описание с явной или неявной инициализацией должно содержаться
  во внутреннем блоке.</p>

<a name="#R.6.5"></a><h5>R.6.5 Операторы цикла</h5>
<p>Эти операторы задают виды цикла.</p>
<pre>
     оператор-цикла:
      while ( выражение ) оператор
      do оператор  while (выражение)
      for ( оператор-иниц выражение opt ; выражение opt ) оператор
      оператор-иниц:
              оператор-выражение
              оператор-описание
</pre>
<p>Обратите внимание, что конструкция оператор-иниц кончается точкой с
  запятой.</p>
<p>Оператор в операторе-цикла не должен быть описанием.</p>

<a name="#R.6.5.1"></a><h6>R.6.5.1 Оператор while</h6>
<p>В операторе while вложенный оператор выполняется до тех пор,
  пока значение выражения не станет равным нулю. Проверка происходит
  перед каждым выполнением оператора.</p>
<p>Выражение должно быть арифметического типа, или типа указателя, или
  типа класс, для которого существует однозначное преобразование в
  арифметический тип или тип указателя (п.<a href="#R.12.3">R.12.3</a>).</p>

<a name="#R.6.5.2"></a><h6>R.6.5.2 Оператор do</h6>
<p>В операторе do вложенный оператор выполняется до тех пор,
  пока значение выражения не станет равным нулю. Проверка происходит
  после каждого выполнения оператора.</p>
<p>Выражение должно быть арифметического типа, или типа указателя,
  или типа класс, для которого существует однозначное преобразование
  в арифметический тип или тип указателя (п.<a href="#R.12.3">R.12.3</a>).</p>

<a name="#R.6.5.3"></a><h6>R.6.5.3 Оператор for</h6>
<p>Оператор for</p>
<pre>
   for (оператор-иниц выражение-1 opt ; выражение-2 opt ) оператор
   эквивалентен конструкции
     оператор-иниц
     while (выражение-1) {
           оператор
           выражение-2 ;
     }
</pre>
<p>за исключением того факта, что оператор continue в операторе for
  вызовет выполнение выражение-2 перед тем& как начать повторное
  вычисление выражения-1. Таким образом, первый оператор задает
  инициализацию для цикла, первое выражение производит проверку,
  выполняемую перед каждым шагом цикла, так что цикл завершается, когда
  выражение становится нулем, а второе выражение обычно задает
  приращение, и оно добавляется после каждого шага цикла. Первое
  выражение должно иметь арифметический тип, или тип указателя, или
  тип класса, для которого существует однозначное преобразование
  к арифметическому типу или типу указателя 
  (п.<a href="#R.12.3">R.12.3</a>).</p>
<p>Могут быть опущены одно или оба выражения. Если отсутствует
  выражение-1, то эквивалентный цикл с while имеет условие while (1).</p>
<p>Если оператор-иниц является описанием, область видимости имен,
  описанных в нем, простирается до конца блока, закрывающего оператор
  for.</p>

<a name="#R.6.6"></a><h5>R.6.6 Операторы перехода</h5>
<p>Операторы перехода делают безусловную передачу управления.</p>
<pre>
       оператор-перехода:
             break ;
             continue ;
             return выражение opt ;
             goto идентификатор ;
</pre>
<p>По выходе из области видимости (каким бы образом это не произошло)
  вызываются деструкторы (п.<a href="#R.12.4">R.12.4</a>) для всех объектов классов,
  построенных в этой области, которые еще не были уничтожены. Это
  относится как к явно описанным объектам, так и ко временным объектам
  (п.<a href="#R.12.2">R.12.2</a>).</p>

<a name="#R.6.6.1"></a><h6>R.6.6.1 Оператор break</h6>
<p>Оператор break может встретиться только в операторе цикла или
  переключателе, он приводит к окончанию ближайшего из объемлющих
  его операторов цикла или переключателей. Управление передается на
  оператор, следующий непосредственно за заканчиваемым, если такой есть.</p>

<a name="#R.6.6.2"></a><h6>R.6.6.2 Оператор continue</h6>
<p>Оператор continue может встретиться только в операторе цикла и
  приводит к передаче управления в заголовок ближайшего
  из объемлющих операторов цикла, т.е. в конец цикла. Более точно
  можно сказать, что в каждом из операторов:</p>
<pre>
      while (foo) {      do  {           for (;;) {
      // ...             // ...          // ...
      contin: ;          contin: ;       contin: ;
      }                  } while (foo);  }
</pre>
<p>оператор continue, не относящийся ко внешним операторам цикла,
  эквивалентен оператору goto contin.</p>

<a name="#R.6.6.3"></a><h6>R.6.6.3 Оператор return</h6>
<p>Возврат из функции в обратившуюся к ней функцию происходит с помощью
  оператора return.</p>
<p>Оператор return без выражения можно использовать только в
  функциях, которые не возвращают значение, т.е. в функциях,
  возвращающих значение типа void, или в конструкторах (п.<a href="#R.12.1">R.12.1</a>)
  и деструкторах (п.<a href="#R.12.4">R.12.4</a>). Оператор return с выражением можно
  использовать только в функциях, которые возвращают значение. Значение
  выражения передается в ту функцию,которая вызвала данную функцию. Если
  нужно, значение преобразуется к типу функции, в которой выполняется
  return, по тем же правилам как при инициализации. Это может привести
  к вызову конструктора или копированию временных объектов (п.<a href="#R.12.2">R.12.2</a>).
  Выход из функции по концу эквивалентен возврату без выдаваемого
  значения, что является незаконным для функции, возвращающей
  значение.</p>

<a name="#R.6.6.4"></a><h6>R.6.6.4 Оператор goto</h6>
<p>Оператор goto безусловно передает управление на оператор,
  помеченный идентификатором. Идентификатор должен быть меткой
  (п.<a href="#R.6.1">R.6.1</a>), находящейся в текущей функции.</p>

<a name="#R.6.7"></a><h5>R.6.7 Оператор описания</h5>
<p>Оператор описания заводит в блоке новый идентификатор и имеет
  вид:</p>
<pre>
       оператор-описания:
      описание
</pre>
<p>Если идентификатор, введенный с помощью описания, уже был ранее
  описан во внешнем блоке, внешнее описание становится скрытым до
  конца блока, после чего оно опять вступает в силу.</p>
<p>Все инициализации автоматических (auto) и регистровых (register)
  переменных производятся каждый раз, когда выполняется
  оператор-описание. Уничтожение локальных переменных, описанных в
  блоке, происходит при выходе из блока (п.<a href="#R.6.6">R.6.6</a>). Уничтожение
  автоматических переменных, определенных в цикле, происходит
  на каждом шаге цикла. Например, переменная Index j создается и
  уничтожается каждый раз в течение цикла по i:</p>
<pre>
       for (int i = 0; i&lt;100; i++)
    for (Index j = 0; j&lt;100; j++) {
    // ...
    }
</pre>
<p>Выход из цикла или из блока или переход, минуя инициализацию
  автоматических переменных, приводит к уничтожению автоматических
  переменных, описанных в точке, откуда происходит переход, но не
  в точке, куда происходит переход.</p>
<p>Переход в блок возможен при условии, что он не приводит к
  пропуску инициализации. Считается незаконным переход, обходящий
  описание с явной или неявной инициализацией, кроме случаев, когда
  оно находится во внутреннем блоке, который пропускается (т.е. в него
  никогда не попадает управление) или переход происходит из той точки,
  где уже была инициализация переменной. Например,</p>
<pre>
       void f()
       {
   // ...
   goto lx;  //ошибка: переход, минуя инициализацию
   // ...
       ly:
    X a = 1;
    // ...
       lx:
    goto ly; // нормально, за переходом будет вызов
             // деструктора для `a'
       }
</pre>
<p>Автоматическая переменная, которая была создана при некотором
   условии, уничтожается при выполнении этого условия, и не может
   быть доступна вне проверки этого условия. Например,</p>
<pre>
   if (i)
           for (int j = 0; j&lt;100; j++) {
           // ...
   }
   if (j!=100)  // ошибка: обращение вне условия
    // ...
    ;
</pre>
<p>Инициализация локального объекта с классом памяти static (п.<a href="#R.7.1.1">R.7.1.1</a>)
  производится прежде, чем управление  пройдет через область его
  описания. Если статическая переменная инициализируется выражением,
  которое не является выражением-константой, то перед первым входом
  в блок происходит стандартная инициализация нулем, приведенным
  к нужному типу (п.<a href="#R.8.4">R.8.4</a>).</p>
<p>Деструктор для локального статического объекта будет вызываться
  в том и только в том случае, если переменная была создана с помощью
  конструктора. Деструктор должен вызываться сразу перед вызовом или
  как составная часть вызова функций, заданных в atexit() (п.<a href="#R.3.4">R.3.4</a>).</p>

<a name="#R.6.8"></a><h5>R.6.8 Разрешение неоднозначности</h5>
<p>Существует неоднозначность в грамматике языка, касающаяся
  оператора-выражения и описания, а именно, оператор-выражение,
  содержащий как самое левое подвыражение явное преобразование типа,
  заданное в функциональном стиле (п.<a href="#R.5.2.3">R.5.2.3</a>), может быть не отличим от
  описания, в котором первый описатель начинается со (. В таких случаях
  оператор считается описанием.</p>
<p>Для разрешения неоднозначности следует исследовать весь оператор,
  чтобы определить является он оператором-выражением или описанием.
  Так устраняется неоднозначность во многих случаях. Например, пусть
  T - имя-простого-типа (п.<a href="#R.7.1.6">R.7.1.6</a>), тогда имеем</p>
<pre>
      T(a)->m = 7;       // оператор-выражение
      T(a)++;            // оператор-выражение
      T(a,5)&lt;&lt;c;         // оператор-выражение

      T(*e)(int);        // описание
      T(f)[];            // описание
      T(g) = {1, 2 };    // описание
      T(*d)(double(3));  // описание
</pre>
<p>Остальные случаи представляют описания. Например,</p>
<pre>
      T(a);         // описание
      T(*b)();      // описание
      T(c)=7;       // описание
      T(d),e,f=3;   // описание
      T(g)(h,2);    // описание
</pre>
<p>Неоднозначность здесь чисто синтаксическая, т.е. на ее
  разрешение не влияет тот факт, является ли имя именем-типа или нет.</p>
<p>Есть другой вид коллизии между оператором-выражением и описанием,
  который разрешается требованием, чтобы описание функции в блоке
  (п.<a href="#R.6.3">R.6.3</a>) сопровождалось именем-типа, например:</p>
<pre>
      void g()
      {
        int f();  // описание
        int a;    // описание
        f();      // оператор-выражение
        a;        // оператор-выражение
     }
</pre>

<a name="#R.7"></a><h4>R.7 Описания</h4>
<p>Описания используются для интерпретации каждого из идентификаторов;
  необязательно, чтобы они сопровождались выделением памяти,
  сопоставляемой с идентификатором. Описания имеют вид</p>
<pre>
      описания:
            спецификации-описания opt список-описателей opt ;
            описание-asm
            определение-функции
            спецификация-связи
</pre>
<p>Описатели в списке-описателей (п.<a href="#R.8">R.8</a>) содержат описываемые
  идентификаторы. Конструкция спецификации-описания может отсутствовать
  только в определении функций (п.<a href="#R.8.3">R.8.3</a>) или в описании функций.
  Список-описателей может быть пустым, только при описании класса (п.<a href="#R.9">R.9</a>)
  или перечисления (п.<a href="#R.7.2">R.7.2</a>), т.е. когда спецификация-описания есть
  спецификация-класса или спецификация-перечисления.</p>
<p>Конструкция описание-asm объясняется в п.<a href="#R.7.3">R.7.3</a>, а спецификация-связи
  в п.<a href="#R.7.4">R.7.4</a>. Описание происходит в определенной области видимости
  (п.<a href="#R.3.2">R.3.2</a>), правила области видимости приводятся в п.<a href="#R.10.4">R.10.4</a>.</p>

<a name="#R.7.1"></a><h5>R.7.1 Спецификации</h5>
<p>В описании можно использовать следующие спецификации:</p>
<pre>
          спецификация-описания:
               спецификация-класса-памяти
               спецификация-типа
               спецификация-fct
               спецификация-шаблона-типа
               friend
               typedef
          спецификации-описания:
               спецификации-описания opt спецификация-описания
</pre>
<p>Самая длинная последовательность конструкций спецификация-описания,
  которая, возможно, является именем типа, образует в описании конструкцию
  спецификации-описания. Последовательность должна быть согласованной,
  что объясняется ниже. Например,</p>
<pre>
        typedef char* Pc;
        static Pc;        // ошибка: нет имени
</pre>
<p>Здесь описание static Pc является незаконным, поскольку не указано
  никакого имени статической переменной типа Pc. Чтобы иметь
  переменную типа int с именем Pc, необходимо задать
  спецификацию-типа int, чтобы показать, что (пере)определяется
  имя Pc из typedef, а не просто Pc является одним из элементов
  последовательности конструкций спецификация-описания, например,</p>
<pre>
        void f(const Pc);      // void f(char* const)
        void g(const int Pc);  // void g(const int)
</pre>
<p>Укажем, что поскольку signed, unsigned, long и short по
  умолчанию трактуются как int, конструкция имя-typedef, которая
  появляется после одной из перечисленных спецификаций типа,
  должна задавать (пере)определяемое имя, например,</p>
<pre>
        void h(unsigned Pc);     // void h(unsigned int)
        void k(unsigned int Pc); // void k(unsigned int)
</pre>

<a name="#R.7.1.1"></a><h6>R.7.1.1 Спецификации класса памяти</h6>
<p>Спецификации класса памяти могут быть такие:</p>
<pre>
        спецификация-класса-памяти:
             auto
             register
             static
             extern
</pre>
<p>Спецификации auto и register могут применяться только для
  имен объектов, которые описаны в блоке (п.<a href="#R.6.3">R.6.3</a>), или для формальных
  параметров (п.<a href="#R.8.3">R.8.3</a>). Почти всегда спецификация auto избыточна и
  используется не часто, так, auto используется, чтобы явно отделить
  оператор-описание от оператора-выражения (п.<a href="#R.6.2">R.6.2</a>).</p>
<p>Описание register является описанием auto, которое подсказывает
  транслятору, что описываемые переменные будут использоваться
  достаточно интенсивно. Подсказка может быть проигнорирована, и во
  многих реализациях она игнорируется в том случае, когда берется
  адрес переменной.</p>
<p>Описание объекта считается определением, если только оно не
  содержит спецификации extern и инициализации (п.<a href="#R.3.1">R.3.1</a>).</p>
<p>Определение приводит к выделению памяти соответствующего
  размера и выполнению соответствующей инициализации (п.<a href="#R.8.4">R.8.4</a>).</p>
<p>Спецификации static и extern могут применяться только к именам
  объектов или функций или к анонимным объединениям. Внутри блока
  недопустимы описания функций со спецификацией static или
  формальных параметров со спецификацией static или extern.
  Статические члены класса описываются в п.<a href="#R.9.4">R.9.4</a>. Спецификация
  extern недопустима для членов класса.</p>
<p>Имя со спецификацией static подлежит внутреннему связыванию.
  Объекты, описанные как const, подлежат внутреннему связыванию,
  если только они не были описаны с внешней связью. Имя со
  спецификацией extern подлежит внешнему связыванию, если только ранее
  оно не было описано с внутренней связью. Имя с файловой областью
  видимости и без спецификации-класса-памяти подлежит внешнему
  связыванию, если только ранее оно не было описано с внутренней
  связью или со спецификацией const. В смысле связывания для функций,
  не являющихся членами, спецификация inline эквивалентна static
  (п.<a href="#R.3.3">R.3.3</a>). Для одного имени все его спецификации, определяющие
  связывание, должны быть согласованы. Например,</p>
<pre>
     static char* f();     // f() имеет внутреннее связывание
     char* f()             // f() все еще внутреннее
        { /* ... */ }

     char* g();            // g() имеет внешнее связывание
     static char* g()      // ошибка: противоречие в связывании
        { /* ... */ }

      static int a;        // `a' имеет внутреннее связывание
      int a;               // ошибка: второе определение

      static int b;        // `b' имеет внутреннее связывание
      extern int b;        // `b' все еще внутреннее

      int c;               // `c' имеет внешнее связывание
      static int c;        // ошибка: противоречие в связывании

      extern int d;        // `d' имеет внешнее связывание
      static int d;        // ошибка: противоречие в связывании
</pre>
<p>Имя неопределенного класса можно использовать в описании
  extern. Однако, такое описание нельзя использовать прежде, чем
  класс будет определен, например,</p>
<pre>
      struct S;
      extern S a;
      extern S f();
      extern void g(S);

      void h()
      {
        g(a);    // ошибка: S неопределено
        f();     // ошибка: S неопределено
      }
</pre>

<a name="#R.7.1.2"></a><h6>R.7.1.2 Спецификации функций</h6>
<p>Некоторые спецификации можно использовать только в описании функций.</p>
<pre>
      спецификация-fct:
           inline
           virtual
</pre>
<p>Спецификация inline подсказывает транслятору, что необходимо
  произвести подстановку тела функции вместо обычной реализации
  вызова функции. Подсказка может игнорироваться. В случае функций,
  не являющихся членами, спецификация inline дополнительно устанавливает
  для функции внутреннее связывание (п.<a href="#R.3.3">R.3.3</a>). Функция (п.<a href="#R.5.2.2">R.5.2.2</a>,
  п.<a href="#R.8.2.5">R.8.2.5</a>), определенная в описании класса, имеет по умолчанию
  спецификацию inline.</p>
<p>Функция-член со спецификацией inline должна иметь в точности
  такое же определение в каждой единице трансляции, где она появляется.
     Функцию-член не обязательно явно описывать со спецификацией
  inline при описании класса, чтобы она трактовалась как подстановка.
  Если спецификации inline не было, связывание будет внешним,
  если только определение со спецификацией inline не появится перед
  первым вызовом функции.</p>
<pre>
       class X {
       public:
         int f();
         inline int g();   // X::g() имеет внутреннее связывание
         int h();
       };

       void k(X* p)
       {
         int i = p->f();   // теперь X::f() внешнее связывание
         int j = p->g();
         // ...
       }

      inline int X::f()    // ошибка: вызов до определения
                           // как inline
      {
        // ...
      }

     inline int X::g()
     {
       // ...
     }

     inline int X::h()     // теперь X::h() имеет внутреннее связывание
     {
       // ...
     }
</pre>
<p>Спецификация virtual может использоваться только в описаниях
  нестатических функций-членов при описании класса (см. п.<a href="#R.10.2">R.10.2</a>).</p>

<a name="#R.7.1.3"></a><h6>R.7.1.3 Спецификация typedef</h6>
<p>Описания со спецификацией typedef задают идентификаторы, которые
  позднее могут использоваться для обозначения основных или
  производных типов. Спецификация typedef недопустима в определении-функции
  (п.<a href="#R.8.3">R.8.3</a>).</p>
<pre>
      имя-typedef:
            идентификатор
</pre>
<p>В пределах области видимости (п.<a href="#R.3.2">R.3.2</a>) описания typedef любой
  идентификатор, появляющийся в части любого из описателей,
  становится синтаксически эквивалентным служебному слову и обозначает тип,
  связанный с данным идентификатором, как описано в п.<a href="#R.8">R.8</a>. Таким образом,
  имя-typedef является синонимом другого типа. В отличие от описания
  класса (п.<a href="#R.9.1">R.9.1</a>) имя-typedef не добавляет нового типа. Например,
  после описания</p>
<pre>
          typedef int MILES, *KLICKSP;
</pre>
<p>конструкции</p>
<pre>
      MILES distance;
      extern KLICKSP metricp;
</pre>
<p>являются законными описаниями, тип distance есть int, а у metricp
  тип "указатель на int".</p>
<p>С помощью typedef можно переопределить имя так, чтобы оно опять
  обозначало тип, на который уже ссылалось, причем даже в той области
  видимости, в которой тип был первоначально описан, например,</p>
<pre>
       typedef struct s { /* ... */ } s;
       typedef int I;
       typedef int I;
       typedef I I;
</pre>
<p>Безымянный класс, который определяется в typedef, получает в
  качестве своего имени имя, использованное в typedef, например,</p>
<pre>
       typedef struct { /* .... */ } S; // имя структуры стало S
</pre>
<p>С помощью описания typedef нельзя переопределить имя типа,
  описанного в этой же области видимости, так, чтобы оно обозначало
  другой тип, например,</p>
<pre>
      class complex { /* ... */ };
      typedef int complex;   // ошибка: переопределение
</pre>
<p>Аналогично, нельзя описывать класс с именем типа, описанного
  в этой же области видимости, так, чтобы он обозначал другой
  тип, например,</p>
<pre>
      typedef int complex;
      class complex { /* ... */ };  // ошибка: переопределение
</pre>
<p>Имя-typedef, которое обозначает класс, является именем-класса
  (п.<a href="#R.9.1">R.9.1</a>). Синоним нельзя использовать после 
  следующих префиксов:
  class, struct и union, а также в именах конструкторов и
  деструкторов в описании самого класса, например,</p>
<pre>
      struct S {
          S();
         ~S();
      };

      typedef struct S T;
      S a = T();    // нормально
      struct T* p;  // ошибка

</pre>

<a name="#R.7.1.4"></a><h6>R.7.1.4 Спецификация шаблона типа</h6>
<p>Спецификация шаблона типа используется для задания семейства типов
  или функций (см. п.<a href="#R.14">R.14</a>).</p>

<a name="#R.7.1.5"></a><h6>R.7.1.5 Спецификация friend</h6>
<p>Спецификация friend используется для задания доступа к членам класса
  (см. п.<a href="#R.11.4">R.11.4</a>).</p>

<a name="#R.7.1.6"></a><h6>R.7.1.6 Спецификация типа</h6>
<p>К спецификации типа относятся:</p>
<pre>
       спецификация-типа:
           имя-простого-типа
           спецификация-класса
           спецификация-перечисления
           спецификация-сложного-типа
           :: имя-класса
           const
           volatile
</pre>
<p>При описании объекта служебные слова const и volatile можно добавить
  к любой законной спецификации-типа. Во всех других случаях в описании
  может присутствовать не более одной спецификации-типа. Объект со
  спецификацией const можно инициализировать, но его значение не
  должно изменяться в дальнейшем. Объект со спецификацией const, если
  только он не был явно описан как extern, не подлежит внешнему
  связыванию и должен инициализироваться (п.<a href="#R.8.4">R.8.4</a>, п.<a href="#R.12.1">R.12.1</a>). Целое
  со спецификацией const, инициализированное выражением-константой,
  может использоваться в выражении-константе (п.<a href="#R.5.19">R.5.19</a>). Каждый
  элемент массива со спецификацией const имеет ту же спецификацию,
  а каждый нестатический член, не являющийся функцией, из объекта класса
  со спецификацией const сам считается const (п.<a href="#R.9.3.1">R.9.3.1</a>). Объект типа
  без конструктора или деструктора, который имеет спецификацию const,
  может быть помещен в память, доступную только по чтению. Попытка
  записи в любую часть такого объекта или приведет к особой адресной
  ситуации, или пройдет бесследно, как если бы объект не имел
  спецификации const.</p>
<p>Не существует не зависящего от реализации объяснения объектов со
  спецификацией volatile. Она служит подсказкой транслятору избегать
  слишком активной оптимизации, связанной с этим объектом, поскольку
  значение объекта может изменяться способами, скрытыми от
  транслятора. Каждый элемент массива со спецификацией volatile
  имеет ту же спецификацию и каждый нестатический член, не являющийся
  функцией, из объекта класса со спецификацией volatile сам считается
  volatile (п.<a href="#R.9.3.1">R.9.3.1</a>).</p>
<p>Если спецификация-типа отсутствует в описании, она считается
  заданной как int.</p>
<pre>
       имя-простого-типа:
             полное-имя-класса
             уточненное-имя-типа
             char
             short
             int
             long
             signed
             unsigned
             float
             double
             void
</pre>
<p>Вместе с int нельзя задавать более одного служебного слова long
  или short. Они могут использоваться и поодиночке, тогда считается,
  что тип есть int. Служебное слово long может появиться вместе с
  double. Вместе с char, short, int или long нельзя задавать более
  одного служебного слова signed или unsigned. Они могут
  использоваться и поодиночке, тогда считается, что тип есть int.
  Спецификация signed указывает, что объекты типа char и битовые
  поля являются знаковыми, для других целочисленных типов эта
  спецификация избыточна.</p>
<p>Конструкции спецификация-класса и спецификация-перечисления
  определяются в п.<a href="#R.9">R.9</a> и п.<a href="#R.7.2">R.7.2</a> соответственно.</p>
<pre>
       спецификация-сложного-типа:
             служебное-слово-класса имя-класса
             служебное-слово-класса идентификатор

       служебное-слово-класса:
             class
             struct
             union
</pre>
<p>Если задан идентификатор, спецификация-сложного-типа описывает
  его как имя-класса (см. п.<a href="#R.9.1">R.9.1</a>).</p>
<p>Если определено имя, которое описывается с помощью спецификации
  union, то оно должно быть определено как объединение. Если определено
  имя, которое описывается с помощью спецификации class, то оно должно
  быть определено с помощью спецификаций class или struct. Если
  определено имя, которое описывается с помощью спецификации struct,
  оно должно быть определено с помощью спецификации class или
  struct. Имена вложенных типов (п.<a href="#R.9.7">R.9.7</a>) должны уточняться именем
  объемлющего класса:</p>
<pre>
            уточненное-имя-типа:
                 имя-typedef
                 имя-класса :: уточненное-имя-типа

            полное-имя-класса:
                 уточненное-имя-класса
                 :: уточненное-имя-класса

            уточненное-имя-класса:
                 имя-класса
                 имя-класса :: уточненное-имя-класса
</pre>
<p>Имя, уточненное именем-класса должно быть типом, определенным в
  этом классе или в базовом классе этого класса. Как обычно, имя,
  описанное в производном классе, делает невидимыми члены с этим
  именем из базовых классов (см. п.<a href="#R.3.2">R.3.2</a>).</p>

<a name="#R.7.2"></a><h5>R.7.2 Описание перечисления</h5>
<p>Перечисление является отдельным целочисленным типом (п.<a href="#R.3.6.1">R.3.6.1</a>)
  с константами-именами. Его имя в своей области видимости становится
  конструкцией имя-перечисления, т.е. служит зарезервированным словом.</p>
<pre>
            имя-перечисления:
                идентификатор

            спецификация-перечисления:
                enum идентификатор opt { список-перечисления }

            список-перечисления:
                элемент-перечисления
                список-перечисления , элемент-перечисления

            элемент-перечисления:
                идентификатор
                идентификатор = выражение-константа
</pre>
<p>Все идентификаторы из списка-перечисления считаются описанными
  как константы и могут появляться всюду, где требуются константы.
  Если не было элементов перечисления с =, то значения констант
  начинаются с нуля и последовательно увеличиваются на единицу
  по мере продвижения в списке слева направо. Если элемент
  перечисления встретился с =, то его идентификатор принимает заданное
  значение, а последующие идентификаторы без инициализирующей части
  будут получать возрастающие значения, начиная с заданного. Значение
  элемента перечисления должно быть типа int или значением, которое
  можно привести к int с помощью стандартных целочисленных
  преобразований (п.<a href="#R.4.1">R.4.1</a>).</p>
<p>Имена элементов перечисления должны быть отличны от имен обычных
  переменных и других элементов перечисления той же области
  видимости. Значения элементов перечисления не обязаны отличаться
  друг от друга. Считается, что элемент перечисления описан с момента
  появления его идентификатора или инициализирующего значения,
  (если оно есть). Например, в определениях</p>
<pre>
        enum { a, b, c=0 };
        enum { d, e, f=e+2 };
</pre>
<p>значения a, c, и d заданы как 0, b и e как 1, а f как 3.</p>
<p>Каждое перечисление является целочисленным типом, который
  отличен от всех других целочисленных типов. Типом элемента перечисления
  считается данное перечисление. Значение элемента перечисления или
  объекта типа перечисления преобразуется к целому с помощью
  стандартных целочисленных преобразований (п.<a href="#R.4.1">R.4.1</a>). 
  Например, в следующем фрагменте:</p>
<pre>
        enum color { red, yellow, green=20, blue };
        color col = red;
        color* cp = &col;
        if (*cp == blue ) // ...
</pre>
<p>color задан как целочисленный тип, описывающий разные цвета,
  col описан как объект этого типа, а cp как указатель на объект
  этого типа. Возможными значениями объекта типа color являются
  red, yellow, green, blue. Эти значения можно преобразовать
  в целые значения 0, 1, 20 и 21. Поскольку каждое перечисление - это
  отдельный тип, объекту типа color можно присваивать только значения
  типа color, например,</p>
<pre>
  color c = 1;  // ошибка: несоответствие типов
                // нет преобразования от int в color

  int i=yellow; // нормально: yellow преобразуется в int со значением 1
                // стандартное целочисленное преобразование
</pre>
<p>Обратитесь также к п.<a href="#R.18.3">R.18.3</a>.</p>
<p>Элементы перечисления, определенные в классе (п.<a href="#R.9">R.9</a>), относятся
  к области видимости этого класса, и к ним можно обращаться извне
  функций-членов этого класса только с помощью явного уточнения
  именем класса (п.<a href="#R.5.1">R.5.1</a>). Имя самого типа перечисления локально
  в этом классе (п.<a href="#R.9.7">R.9.7</a>), например,</p>
<pre>
        class X {
        public:
            enum direction { left='l', right='r' };
            int f(int i)
                { return i==left ? 0 : i==right ? 1 : 2; }
        };

        void g(X* p)
        {
          direction d;        // ошибка: `direction' вне
          int i;              // области видимости
          i = p->f(left);     // ошибка: `left' тоже невидим
          i = p->f(X::right); // нормально
          // ...
        }
</pre>

<a name="#R.7.3"></a><h5>R.7.3 Описания asm</h5>
<p>Описание asm имеет вид:</p>
<pre>
         описание-asm:
             asm ( строка-литерал) ;
</pre>
<p>Назначение описания asm определяется реализацией. Обычно оно
  используется для передачи информации от транслятора к ассемблеру.</p>

<a name="#R.7.4"></a><h5>R.7.4 Спецификации связи</h5>
<p>С помощью спецификации-связи можно связать (п.<a href="#R.3.3">R.3.3</a>) фрагменты
  программ на С++ и на другом языке:</p>
<pre>
       спецификация-связи:
           extern строка-литерал { список-описаний opt }
           extern строка-литерал описание

       список-описаний:
           описание
           список-описаний описание
</pre>
<p>Требуемое связывание задается с помощью строки-литерала. Ее назначение
  определяется реализацией. Но во всех реализациях должно быть
  предусмотрено связывание с функцией на языке С ("С") и с функцией
  на языке С++ ("С++"). По умолчанию связывание задается как "С++",
  например,</p>
<pre>
        complex sqrt(complex);   // по умолчанию связывание с C++
        extern "C" {
            double sqrt(double); // связывание с C
        }
</pre>
<p>Спецификации связи могут быть вложенными. Спецификация связи
  не задает область видимости. Спецификация-связи может встретиться
  только в файловой области видимости (п.<a href="#R.3.2">R.3.2</a>). Спецификация-связи
  для класса относится к объектам, описанным в нем, и функциям, не
  являющимся членами. Спецификация-связи, относящаяся к некоторой
  функции, относится и ко всем объектам и функциям, описанным в ней.
  Описание связи, содержащее неизвестную для реализации строку,
  считается ошибочным.</p>
<p>Если функция имеет более одной спецификации-связи, то они должны
  быть согласованы, т.е. задавать одну и ту же строку-литерал.
  Описание функции без указания спецификации-связи не должно
  предшествовать первому указанию спецификации связи для этой функции.
  Функция может быть описана без указания спецификации связи даже
  после явного указания спецификации связи, но связывание, явно заданное
  в более раннем описании, не будет устранено таким описанием функции.</p>
<p>Из множества перегруженных функций (п.<a href="#R.13">R.13</a>) с данным именем
  не более одной может иметь связывание с языком С, см. п.<a href="#R.7.4">R.7.4</a>.</p>
<p>Связывание можно установить для объектов, например:
<pre>
       extern "C" {
          // ...
          _iobuf_iob[_NFILE];
          // ...
          int _flsbuf(unsigned,_iobuf*);
          // ...
       }
</pre>
<p>Когда задается спецификация связи, то функции и объекты можно описать как
  статические внутри { }. Для таких функций или объектов команда
  связывания игнорируется. Иначе, функция, описанная при задании связи,
  трактуется, как если бы она была явно описана как extern, например,
  ниже второе описание ошибочно (п.<a href="#R.7.1.1">R.7.1.1</a>):</p>
<pre>
       extern "C" double f();
       static double f();     // ошибка
</pre>
<p>Объект, описанный внутри конструкции</p>
<pre>
       extern "C" {  /* ... */ }
</pre>
<p>все же считается определенным, а не просто описанным.</p>
<p>Связывание объектов на С++ с объектами, определенными на других
  языках, так же как и обратное связывание, зависит от языков и
  реализации. Такое связывание возможно только в том случае, когда
  алгоритмы размещения объектов в памяти являются достаточно схожими
  для двух языков.</p>
<p>Если для задания связи в строке-литерале из спецификации-связи
  используется имя языка программирования, то рекомендуется, чтобы
  написание этого имени копировалось из документа, определяющего данный
  язык, например, Ada (а не ADA) и Fortran (а не FORTRAN).</p>

<a name="#R.8"></a><h4>R.8 Описатели</h4>
<p>Список-описателей, фигурирующий в описании, - это последовательность
  через запятую описателей, каждый из которых может иметь
  инициализатор.</p>
<pre>
        список-описаний:
             описатель-с-инициализатором
             список-описаний , описатель-с-инициализатором

        описатель-с-инициализатором:
             описатель инициализатор opt
</pre>
<p>Описание состоит из двух частей: спецификации (спецификация-описания;
  см. п.<a href="#R.7.1">R.7.1</a>) и описателей (список-описателей). Спецификации задают
  основной тип, класс памяти или другие свойства описываемых объектов
  и функций. Описатели задают имя этих объектов и функций, а также,
  возможно, изменяют тип с помощью таких операций, как * (указатель на)
  и () (функция возвращающая). В описателе также можно задать начальные
  значения, инициализация обсуждается в п.<a href="#R.8.4">R.8.4</a>  и п.<a href="#R.12.6">R.12.6</a>.</p>
<p>Описатели имеют такой синтаксис:</p>
<pre>
   описатель:
     имя-в-описателе
     операция-ptr описатель
     описатель (список-описаний-параметров) список-спецификаций-cv opt
     описатель [ выражение-константа opt]
     ( описатель )

  операция-ptr:
     * список-спецификаций-cv opt
     & список-спецификаций-cv opt
     полное-имя-класса :: * список-спецификаций-cv opt

  список-спецификаций-cv:
     const
     volatile

  имя-в-описателе:
      имя
      имя-класса
      ~имя-класса
      имя-typedef
      уточненное-имя-типа
</pre>
<p>Конструкция имя-класса имеет определенное назначение при описании
  класса с этим именем, она же используется как уточнение в операции ::
  для разрешения коллизий в области видимости (п.<a href="#R.12.1">R.12.1</a>, п.<a href="#R.12.4">R.12.4</a>).</p>

<a name="#R.8.1"></a><h5>R.8.1 Имена типов</h5>
<p>Имя типа необходимо указывать при задании операции явного
  преобразования типа или в качестве параметра в операциях sizeof
  или new. Для этого служит конструкция имя-типа, которая синтаксически
  эквивалентна описанию объекта или функции этого типа, в котором
  отсутствует имя объекта или функции.</p>
<pre>
    имя-типа:
      список-спецификаций-типа абстрактный-описатель opt

    список-спецификаций-типа:
      спецификация-типа список-спецификаций-типа

    абстрактный-описатель:
      операция-ptr абстрактный-описатель opt

 абстрактный-описатель opt ( список-описаний-параметров ) 
    список-спецификаций cv opt
      абстрактный-описатель opt [ выражение-константа opt ]
      ( абстрактный-описатель )
</pre>
<p>Можно однозначно указать, в каком месте абстрактного-описателя
  нужно добавить идентификатор, чтобы конструкция стала описателем,
  допустимым в описании. Тогда поименованный тип будет тем же, что и
  тип гипотетического идентификатора. Например, описания</p>
<pre>
          int             // int i
          int *           // int *pi
          int *[3]        // int *p[3]
          int (*)[3]      // int (*p3i)[3]
          int *()         // int *f()
          int (*)(double) // int (*pf)(double)
</pre>
<p>задают соответственно такие типы: "целое", "указатель на целое",
  "массив из 3 указателей на целое", "указатель на массив из 3 целых",
  "функция без параметров, возвращающая указатель на целое",
  "указатель на функцию с параметром типа double, возвращающую целое".</p>

<a name="#R.8.1.1"></a><h6>R.8.1.1 Устранение неоднозначности</h6>
<p>Неоднозначность, отмеченная в п.<a href="#R.6.8">R.6.8</a>, которая возникает из-за сходства
  между приведением, заданным в функциональном стиле, и описанием,
  может также появиться в контексте описания. В этом контексте она
  проявляется как сходство между описанием функции, в котором есть
  избыточные скобки вокруг имени параметра, и описанием объекта, в
  котором в качестве инициализатора используется операция приведения,
  заданная в функциональном стиле. Как и для операторов, неоднозначность
  устраняется правилом, согласно которому следует считать описанием любую
  конструкцию, которая может служить таковым. Можно явно устранить
  неоднозначность в описании или с помощью приведения, заданного не в
  функциональном стиле, или с помощью операции = для обозначения
  инициализации, например,</p>
<pre>
       struct S {
          S(int);
       };

      void foo(double a)
      {
        S x(int(a));   // описание функции
        S y((int)a);   // описание объекта
        S z = int(a);  // описание объекта
      }
</pre>

<a name="#R.8.2"></a><h5>R.8.2 Смысл описателей</h5>
<p>Список описателей следует после (возможно пустого) списка
  спецификаций-описания (п.<a href="#R.7.1">R.7.1</a>). Каждый описатель содержит в точности
  одно имя-из-описателя, которое задает описываемый идентификатор.
  Если не считать описаний некоторых специальных функций (п.<a href="#R.12.3">R.12.3</a>,
  п.<a href="#R.13.4">R.13.4</a>), имя-из-описателя является просто идентификатором.
  Спецификации auto, static, extern, register, friend, inline, virtual
  или typedef относятся непосредственно к каждому имени-из-описателя из
  списка описателей. Тип каждого имени-из-описателя определяется как
  спецификацией-описания (п.<a href="#R.7.1">R.7.1</a>), так и его описателем.</p>
<p>Таким образом, описание некоторого идентификатора имеет вид</p>
<pre>
           T D
</pre>
<p>где T обозначает тип, а D - описатель. Если в описании D есть
  идентификатор без скобок, то тип этого идентификатора есть T.</p>
<p>В описании, где D имеет вид</p>
<pre>
           ( D1 )
</pre>
<p>тип D1 такой же, как и тип D. Наличие скобок не меняет типа заключенного
  в них имени-из-описателя, но для сложных описателей оно может повлиять
  на порядок применения операций.</p>

<a name="#R.8.2.1"></a><h6>R.8.2.1 Указатели</h6>
<p>В описании T D, в котором D имеет вид</p>
<pre>
        * список-спецификаций-cv opt D1
</pre>
<p>тип описываемого идентификатора есть
  "... список-спецификаций-cv указатель на T". Конструкция
  список-спецификаций-cv относится к указателю, а не к указуемому
  объекту.</p>
<p>Например, в описаниях</p>
<pre>
        const ci = 10, *pc = &ci, *const cpc = pc;
        int i *p, *const cp = &i;
</pre>
<p>определяются: ci как константа целое; pc как указатель на константу
  целое; cpc как константа указатель на константу целое; i как целое;
  p как указатель на целое; и cp как константа указатель на целое.
  После инициализации значения ci, cpc и cp не могут быть изменены.
  Значение pc можно изменять так же, как и значение объекта, на который
  указывает cp. Приведем примеры допустимых операций:</p>
<pre>
        i = ci;
        *cp = ci;
        pc++;
        pc = cpc;
        pc = p;
</pre>
<p>Недопустимы следующие операции:</p>
<pre>
        ci = 1;    // ошибка
        ci++;      // ошибка
        *pc = 2;   // ошибка
        cp = &ci;  // ошибка
        cpc++;     // ошибка
        p = pc;    // ошибка
</pre>
<p>Каждая из этих операций недопустима или потому, что она изменяет значение
  объекта, описанного со спецификацией const, или потому, что делает
  такое изменение возможным позднее с помощью указателя, настроенного
  на объект без спецификации const.</p>
<p>Аналогична ситуация со спецификацией volatile.</p>
<p>Обратитесь к п.<a href="#R.5.17">R.5.17</a> и п.<a href="#R.8.4">R.8.4</a>.</p>
<p>Нельзя описывать указатели на ссылки (п.<a href="#R.8.2.2">R.8.2.2</a>) или указатели
  на битовые поля (п.<a href="#R.9.6">R.9.6</a>).</p>

<a name="#R.8.2.2"></a><h6>R.8.2.2 Ссылки</h6>
<p>В описании T D, в котором D имеет вид</p>
<pre>
      & список-спецификаций-cv opt D1
</pre>
<p>тип описываемого идентификатора есть
  "...список-спецификаций-cv ссылка на T". Тип void& недопустим.</p>
<p>Например, во фрагменте</p>
<pre>
      void f(double& a) { a += 3.14; }
      // ...
         double d = 0;
         f(d);
</pre>
<p>a описывается как параметр, являющийся ссылкой, поэтому вызов
  f(d) приведет к увеличению d на 3.14. Во фрагменте</p>
<pre>
      int v[20];
      // ...
      int& g(int i) { return v[i]; }
      // ...
      g(3) = 7;
</pre>
<p>описывается: функция g() возвращает ссылку на целое; поэтому
  оператор g() = 7; присвоит 7 четвертому элементу массива v.
  Рассмотрим следующий программный фрагмент:</p>
<pre>
     struct link {
        link* next;
     };
     link* first;

     void h(link*& p)  // `p' ссылка на указатель
     {
       p->next = first;
       first = p;
       p = 0;
     }

     void k()
     {
       link* q = new link;
       h(q);
     }
</pre>
<p>Здесь p описано как ссылка на указатель на link, поэтому вызов h(q)
  не изменит значение q, равное 0, см. также п.<a href="#R.8.4.3">R.8.4.3</a>.</p>
<p>Недопустимы ссылки на ссылки, ссылки на битовые поля (п.<a href="#R.9.6">R.9.6</a>),
  массивы ссылок и указатели на ссылки. Описание ссылки должно содержать
  инициализатор (п.<a href="#R.8.4.3">R.8.4.3</a>), за исключением тех случаев, когда описание
  содержит явную спецификацию extern (п.<a href="#R.7.1.1">R.7.1.1</a>), или является описанием
  члена класса (п.<a href="#R.9.2">R.9.2</a>) при описании самого класса, или является
  описанием параметра или возвращаемого типа (п.<a href="#R.8.2.5">R.8.2.5</a>),
  см. также п.<a href="#R.3.1">R.3.1</a>.</p>

<a name="#R.8.2.3"></a><h6>R.8.2.3 Указатели на члены</h6>
<p>В описании T D, в котором D имеет вид</p>
<pre>
    полное-имя-класса :: * список-спецификаций-cv opt D1
</pre>
<p>тип описываемого идентификатора есть
  "... список-спецификаций-cv указатель на член класса полное-имя-класса типа T".
  Например, во фрагменте</p>
<pre>
       class X {
       public:
          void f(int);
          int a;
       };

       int X::* pmi = &X::a;
       void (X::* pmf)(int) = &X::f;
</pre>
<p>pmi и pmf описываются как указатель на член X типа T и указатель на
  член X типа void(int) соответственно. Эти объекты можно использовать
  так:</p>
<pre>
      X obj;
      // ...
      obj.*pmi = 7;   // присвоить 7 члену obj типа int
      (obj.*pmf)(7);  // вызвать функцию-член obj
                      // с параметром 7
</pre>
<p>Отметим, что указатель на член нельзя настроить на статический
  член класса (п.<a href="#R.9.4">R.9.4</a>), см. также п.<a href="#R.5.5">R.5.5</a> и п.<a href="#R.5.3">R.5.3</a>.</p>

<a name="#R.8.2.4"></a><h6>R.8.2.4 Массивы</h6>
<p>В описании T D, в котором D имеет вид</p>
<pre>
      D1 [ выражение-константа opt ]
</pre>
<p>описывается идентификатор типа " ... массив T". Если
  выражение-константа присутствует (п.<a href="#R.5.19">R.5.19</a>), то оно должно иметь
  целочисленный тип и значение, большее 0. Это выражение задает число
  элементов массива. Если значение выражения-константы есть N, то
  массив имеет N элементов с индексами от 0 до N-1.</p>
<p>Массив можно образовывать из: одного из основных типов (за исключением
  void), указателя, указателя на члены, класса, перечисления или из
  другого массива.</p>
<p>Если подряд идут несколько спецификаций "массив ...", образуется
  многомерный массив, причем выражение-константа, задающее границы
  массива, может отсутствовать только для первого массива. Такое умолчание
  полезно в случае параметров функции типа массив, а также когда массив
  является внешним, а его определение, с которым связано резервирование
  памяти, находится в другом месте. Первое выражение-константа может
  быть пропущено и в том случае, если за описателем следует
  список-инициализаторов (п.<a href="#R.8.4">R.8.4</a>). Тогда размер массива определяется
  числом элементов, приведенных в инициализаторе (п.<a href="#R.8.4.1">R.8.4.1</a>).</p>
<p>В описании</p>
<pre>
          float fa[17], *afp[17];
</pre>
<p>описаны массив чисел типа float и массив указателей на числа типа float,
  а в описании</p>
<pre>
          static int x3d[3][5][7];
</pre>
<p>описан статический трехмерный массив целых размера 3x5x7. Строго
  говоря, x3d является массивом из трех элементов, каждый из которых
  есть массив из пяти массивов, а каждый из последних является массивом
  из семи целых. В выражении допустимо появление любого из следующих
  выражений: x3d, x3d[i], x3d[i][j], x3d[i][j][k].</p>
<p>Если в выражении участвует идентификатор типа массив, то, исключая
  случаи операнда в операциях sizeof или & и инициализатора для
  ссылки (п.<a href="#R.8.4.3">R.8.4.3</a>), его тип преобразуется в указатель на первый
  элемент массива. Несмотря на это преобразование, массивы не являются
  изменяемыми адресами. Если не считать случай использования массива
  при описании класса (п.<a href="#R.13.4.5">R.13.4.5</a>), операция индексации определяется
  так, что E1[E2] совпадает с *((E1) + (E2)). С учетом правил
  преобразования типов для операции +, если E1 есть массив, а E2
  целое, то E1[E2] указывает на E2-элемент из E1. Поэтому, несмотря
  на свой асиметричный вид, индексация - коммутативная операция.</p>
<p>Аналогичное правило действует и для многомерных массивов. Если
  E - n-мерный массив размера ixjx...xk, то в выражении он
  преобразуется в указатель на (n-1)-мерный массив размера jx...xk.
  Если к этому указателю явно или неявно в результате индексации применяется
  операция *, указуемый (n-1)-мерный массив сам немедленно преобразуется
  в указатель.</p>
<p>Например, рассмотрим описание</p>
<pre>
      int x[3][5];
</pre>
<p>Здесь описан массив из 3x5 целых. Если в выражении появляется x, то
  оно преобразуется в указатель на первый массив из пяти целых.
  Если в выражении появляется x[i], что эквивалентно *(x+i), в начале
  x преобразуется в указатель, как было сказано выше, затем x+i
  преобразуется к типу x, для чего необходимо i умножить на размер объекта,
  на который указывает x, т.е. на размер пяти целых. Затем происходит
  сложение и применяется косвенность, после чего получим массив (из пяти
  целых), который в свою очередь преобразуется в указатель на первое из
  целых. Если есть еще одна индексация, процесс повторяется, и на этот раз
  мы получим в результате целое.</p>
<p>Из всего этого следует, что массивы В С++ хранятся по строкам
  (последний индекс изменяется быстрее всего), а значение первого
  индекса из описания позволяет вычислить размер памяти, необходимой
  для массива, однако при вычислении индексного выражения первый индекс
  роли не играет.</p>

<a name="#R.8.2.5"></a><h6>R.8.2.5 Функции</h6>
<p>В описании T D, в котором D имеет вид</p>
<pre>
     D1 (список-описаний-параметров ) список-спецификаций-cv opt

     описываемый идентификатор имеет тип</br>
  "...список-спецификаций-cv функция с параметрами типа
  список-описаний-параметров возвращающая T".

     список-описаний-параметров:
          список-описаний-парам opt ... opt
          список-описаний-парам , ...

     список-описаний-парам:
          описание-параметра
          список-описаний-парам , описание-параметра

     описание-параметра:
          спецификации-описания описатель
          спецификации-описания описатель = выражение
          спецификации-описания абстрактный-описатель opt
          спецификации-описания абстрактный-описатель opt = выражение
</pre>
<p>Если список-описаний-параметров завершается эллипсисом (...),
  про число параметров известно только то, что оно больше или равно
  числа заданных параметров, если список параметров пуст, то функция
  параметров не имеет. Список параметров void эквивалентен пустому
  списку параметров. Не считая этого случая, void не может быть типом
  параметра (хотя типы, получаемые из void, такие как void*, допустимы).</p>

<a name="#R.8.3"></a><h5>R.8.3 Определения функций</h5>
<p>Определения функций имеют вид</p>
<pre>
    определение-функции:
спецификации-описания opt описатель инициализатор-ctor тело-функции

    тело-функции:
       составной-оператор
</pre>
<p>Конструкция описатель из определения-функции должна содержать описатель
  вида</p>
<pre>
       D1 ( список-описаний-параметров ) список-спецификаций-cv  opt
</pre>
<p>в соответствии с определениями из п.<a href="#R.8.2.5">R.8.2.5</a></p>
<p>Формальные параметры относятся к области видимости самого
  большого блока тела-функции.</p>
<p>Приведем пример полного определения функции.</p>
<pre>
        int max( int a, int b, int c)
        {
          int m = (a > b) ? a : b;
           return (m > c) ? m : c;
        }
</pre>
<p>Здесь int представляет спецификации-описания, max(int a, int b, int c)
  - описатель, а { /* ... */ } - тело-функции.</p>
<p>Конструкция инициализатор-ctor используется только в конструкторах,
  см. п.<a href="#R.9.3.1">R.9.3.1</a> и п.<a href="#R.12.6">R.12.6</a>.</p>
<p>Конструкция список-спецификаций-cv может участвовать:
  в описании нестатической функции-члена, в определении нестатической
  функции-члена или в описании указателя на функцию-член, см. п.<a href="#R.9.3.1">R.9.3.1</a>.
  Она относится к типу функции.</p>
<p>Отметим, что неиспользуемым формальным параметрам имена можно
  не давать, например,</p>
<pre>
       void print(int a, int)
       {
         printf("a = %d\n",a);
       }
</pre>

<a name="#R.8.4"></a><h5>R.8.4 Инициализаторы</h5>
<p>За описателем может идти начальное значение описываемого идентификатора.</p>
<pre>
     инициализатор:
           = выражение-присваивания
           = { список-инициализаторов , opt }
           ( список-выражений )

     список-инициализаторов:
           выражение-присваивания
           список-инициализаторов , выражение-присваивания
           { список-инициализаторов , opt }
</pre>
<p>Автоматические, регистровые, статические и внешние переменные
  можно инициализировать произвольными выражениями, содержащими
  константы и описанные ранее переменные и функции.</p>
<pre>
       int f(int);
       int a = 2;
       int b = f(a);
       int c(b);
</pre>
<p>Указатель типа const T*, т.е. указатель на константу T, может
  инициализироваться указателем типа T*, но инициализация для указателей
  в обратном порядке незаконна. Объекты типа T можно инициализировать
  объектами типа T независимо от использования спецификаций const или
  volatile в типах инициализируемой переменной или инициализатора,
  например,</p>
<pre>
       int a;
       const int b = a;
       int c = b;

       const int* p0 = &a;
       const int* p1 = &b;
       int* p2 = &b;        // ошибка: указатель без const
                            // настраивается на объект const
       int *const p3 = p2;
       int *const p4 = p1;  // ошибка: указатель без const
                            // настраивается на объект const
       const int* p5 = p1;
</pre>
<p>Здесь причина обеих ошибок одна: если допустить подобную инициализацию,
  она позволит изменять с помощью указателя без соответствующей
  спецификации значение чего-то, что было описано как const.</p>
<p>На выражения для стандартных значений параметров накладывается
  больше ограничений, см. п.<a href="#R.8.2.6">R.8.2.6</a>.</p>
<p>Инициализация объектов классов с помощью конструкторов описывается
  в п.<a href="#R.12.6.1">R.12.6.1</a>. Копирование объектов классов описывается в п.<a href="#R.12.8">R.12.8</a>.
  Порядок инициализации статических объектов определяется в п.<a href="#R.3.4">R.3.4</a>
  и п.<a href="#R.6.7">R.6.7</a>.</p>
<p>Гарантируется, что переменные статического класса памяти (п.<a href="#R.3.5">R.3.5</a>),
  которые не были инициализированы, в качестве начального значения
  получат 0, приведенный к нужному типу. То же справедливо для статических
  членов объектов класса. Начальные значения автоматических и
  регистровых переменных, которые не были инициализированы, неопределены.</p>
<p>Если инициализатор относится к указателю или объекту арифметического
  типа, он состоит из одного выражения (возможно в скобках). В качестве
  начального значения объекта берется значение выражения, происходят
  такие же преобразования типа, как и в случае присваивания.</p>
<p>Заметим, что поскольку () не является инициализатором,
  описание</p>
<pre>
      X a();
</pre>
<p>задает не объект a типа класс X, а является описанием функции без
  параметров, возвращающей X.</p>
<p>Инициализатор для статического члена принадлежит области
  видимости члена класса, например,</p>
<pre>
        int a;

        struct X {
           static int a;
           static int b;
        };

        int X::a = 1;
        int X::b = a;  // X::b = X::a
</pre>

<a name="#R.8.4.1"></a><h6>R.8.4.1 Агрегат</h6>
<p>Агрегатом называется массив или объект типа класс (п.<a href="#R.9">R.9</a>), не имеющий
  конструкторов (п.<a href="#R.12.1">R.12.1</a>), частных или защищенных членов (п.<a href="#R.11">R.11</a>),
  базовых классов (п.<a href="#R.10">R.10</a>) и виртуальных функций (п.<a href="#R.10.2">R.10.2</a>). Если
  агрегат инициализируется, то инициализатором должен быть
  список-инициализаторов, который состоит из заключенного в фигурные
  скобки списка, разделенного запятыми, инициализаторов для членов
  агрегата. Инициализаторы идут в возрастающем порядке индексов или
  членов агрегата. Если агрегат содержит вложенные агрегаты, это
  правило применяется рекурсивно для членов вложенных агрегатов. Если
  инициализаторов в списке меньше, чем членов агрегата, то он
  дополняется нулевыми значениями соответствующих типов.</p>
<p>Например, в следующем фрагменте</p>
<pre>
         struct S { int a; char* b; int c; }
         S ss = { 1, "asdf" };
</pre>
<p>ss.a инициализируется значением 1, ss.b - "asdf", а ss.c - 0.</p>
<p>Кроме того, агрегат, являющийся классом, можно инициализировать
  объектом этого класса или класса, являющегося общим производным
  от него (п.<a href="#R.12.8">R.12.8</a>).</p>
<p>Фигурные скобки разбираются следующим образом. Если
  список-инициализаторов начинается левой фигурной скобкой, то
  список инициализаторов, разделенных запятыми, задает
  значения членам агрегата, причем считается ошибкой, если
  инициализаторов больше, чем членов. Иначе, если список-инициализаторов
  или вложенный агрегат не начинается левой фигурной скобкой, то
  из списка используется такое число элементов, которое нужно для
  инициализации членов текущего агрегата; все оставшиеся элементы
  используются для инициализации членов следующего агрегата, в который
  вложен текущий агрегат.</p>
<p>Например, в определении</p>
<pre>
         int x[] = { 1, 3, 5 };
</pre>
<p>массив x инициализируется как одномерный массив из трех элементов,
  поскольку размер массива не указан, и приведено три инициализатора.</p>
<p>Приведем пример инициализации с полной скобочной структурой.</p>
<pre>
         float y[4][3] = {
            { 1, 3, 5 },
            { 2, 4, 6 },
            { 3, 5, 7},
         };
</pre>
<p>Здесь значения 1, 3, 5 инициализируют первую строку массива y[0],
  т.е. y[0][0], y[0][1] и y[0][2]. Аналогично, следующие две строки
  инициализируют y[1] и y[2]. Инициализаторы приведены не полностью,
  поэтому y[3] инициализируется нулями. Точно такого же результата
  можно достичь с помощью такой инициализации:</p>
<pre>
         float y[4][3] = {
            1, 3, 5, 2, 4, 6, 3, 5, 7,
         };
</pre>
<p>Последний (самый правый) индекс изменяется быстрее всего.</p>
<p>В последнем примере инициализатор для y начинается левой фигурной
  скобкой, но для y[0] скобки не задано, поэтому из списка используется
  три элемента, также по три последовательных элемента используется для
  y[1] и y[2]. В следующем примере</p>
<pre>
         float y[4][3] = {
         { 1 }, { 2 }, { 3 }, { 4 }
         };
</pre>
<p>инициализируется первый столбец y (который рассматривается как
  двумерный массив), а остальные столбцы принимают значение 0.</p>
<p>Инициализация массива объектов типа класс с помощью конструкторов
  описывается в п.<a href="#R.12.6.1">R.12.6.1</a>.</p>
<p>Инициализатор для объединения без конструктора должен быть
  или отдельным выражением типа объединения, или заключенным в фигурные
  скобки, инициализатором первого члена объединения, например,</p>
<pre>
         union u { int a; char* b; };

         u a = { 1 };
         u b = a;
         u c = 1;             // ошибка
         u d = { 0, "asdf" }; // ошибка
         u e = { "asdf" };    // ошибка
</pre>
<p>Число инициализаторов не должно превышать числа членов или
  элементов, которые инициализируются. Например, следующая
  инициализация ошибочна:</p>
<pre>
         char cv[4] = { 'a', 's', 'd', 'f', 0 };  // ошибка
</pre>

<a name="#R.8.4.2"></a><h6>R.8.4.2 Символьные массивы</h6>
<p>Массив символов (неважно, знаковых или беззнаковых) можно
  инициализировать строкой-литералом: символы строки последовательно
  инициализируют элементы массива. Следующее определение дает пример
  символьного массива, элементы которого инициализируются строкой:</p>
<pre>
         char msg[] = "Syntax error on line %s\n";
</pre>
<p>Заметим, что поскольку '\n' задает один символ, и поскольку добавляется
  завершающий символ '\0', sizeof(msg) равно 25.</p>
<p>Нельзя задавать больше инициализаторов, чем есть элементов в массиве,
  поэтому следующий пример ошибочен: здесь нет места для подразумевающегося
  символа конца строки ('\0'):</p>
<pre>
         char cv[4] = "asdf";  // ошибка
</pre>

<a name="#R.8.4.3"></a><h6>R.8.4.3 Ссылки</h6>
<p>Переменная, описанная как T&, т.е. "ссылка на тип T" (п.<a href="#R.8.2.2">R.8.2.2</a>),
  должна инициализироваться объектом типа T или объектом, который
  можно преобразовать к типу T, например,</p>
<pre>
         void f()
         {
           int i;
           int& r = i;  // `r' ссылается на `i'
           r = 1;       // `i' принимает значение 1
           int* p = &r; // `p' указывает на `i'
           int& rr = r; // `rr' ссылается на то, на что ссылалось `r',
                        //  т.е. на `i'
         };
</pre>
<p>Ссылку после инициализации нельзя изменять так, чтобы она
  обозначала другой объект. Отметим, что инициализация ссылки
  трактуется совсем не так, как присваивание ссылке. Передача
  параметра (п.<a href="#R.5.2.2">R.5.2.2</a>) и операция возврата значения функции (п.<a href="#R.6.6.3">R.6.6.3</a>)
  считаются инициализацией.</p>
<p>Инициализатор для ссылки можно опускать только в описании
  параметра (п.<a href="#R.8.2.5">R.8.2.5</a>), в описании возвращаемого функцией типа,
  в описании члена класса при описании самого класса (п.<a href="#R.9.2">R.9.2</a>) и там,
  где явно использована спецификация extern, например,</p>
<pre>
         int& r1;        // ошибка: нет инициализации
         extern int& r2; // нормально
</pre>
<p>Если инициализатор для ссылки на тип T является адресом типа T
  или типом, производным от T (п.<a href="#R.10">R.10</a>), для которого T служит
  доступным базовым типом (п.<a href="#R.4.6">R.4.6</a>), ссылка будет обозначать значение,
  заданное инициализатором. Иначе, в том и только том случае, когда
  ссылка обозначает объект со спецификацией const, будет создан объект
  типа T  и проинициализирован значением, заданным инициализатором.</p>
<p>Теперь ссылка играет роль имени этого объекта, например,</p>
<pre>
          double d = 1.0;

          double& rd = d;        // rd ссылается на `d'
          const double& rcd = d; // rcd ссылается на `d'

          double& rd2 = 1;       // ошибка: несоответствие типа
          const double& rcd2 = 1;// rcd2 ссылается на временный объект
                                 // со значением `1'
</pre>
<p>Ссылку на volatile T можно инициализировать объектом типа
  volatile T или просто T, но не const T. Ссылку на const T можно
  инициализировать const T, просто T или чем-то, что можно преобразовать
  в тип T, но не volatile T. Ссылку на тип T (без const или volatile)
  можно инициализировать только объектом типа T.</p>
<p>Время жизни временного объекта, созданного при описанной
  инициализации, определяется текущей областью видимости, в которой
  он был создан (п.<a href="#R.3.5">R.3.5</a>). Отметим, что ссылку на класс B можно
  инициализировать объектом класса D при условии, что В является
  однозначно определенным и доступным базовым классом для D (тогда
  говорят, что "D есть B"), см. п.<a href="#R.4.7">R.4.7</a>.</p>

<a name="#R.9"></a><h4>R.9 Классы</h4>
<p>Класс есть тип. Его имя используется как имя-класса (п.<a href="#R.9.1">R.9.1</a>), т.е.
  становится зарезервированным словом в его области видимости.</p>
<pre>
         имя-класса:
             идентификатор
</pre>
<p>Для образования конструкции имя-класса используются спецификации-класса
  и спецификации-сложного-типа (п.<a href="#R.7.1.6">R.7.1.6</a>). Объект класса состоит из
  последовательности (возможно пустой) членов.</p>
<pre>
      спецификация-класса:
        заголовок-класса { список-членов opt }

      заголовок-класса:
        служебное-слово-класса идентификатор opt спец-базовых opt
        служебное-слово-класса имя-класса спец-базовых opt

      служебное-слово-класса:
         class
         struct
         union
</pre>
<p>Имя класса можно использовать в качестве конструкции имя-класса
  даже в списке-членов самого этого класса. Обычно спецификацию-класса
  называют описанием класса. Класс считается определенным, как только
  появится спецификация-класса, несмотря на то, что его функции-члены
  могут быть еще неопределены.</p>
<p>Объекты пустого класса имеют ненулевой размер.</p>
<p>Объекты типа класс можно присваивать, передавать в качестве
  параметров функций и получать в качестве значения, возвращаемого
  функцией (за исключением объектов тех классов, для которых копирование
  ограничено, см. п.<a href="#R.12.8">R.12.8</a>). Другие возможные операции, такие, как
  сравнение на равенство, могут определяться пользователем, см. п.<a href="#R.13.4">R.13.4</a>.</p>
<p>Структурой называется класс, описанный со служебным-словом-класса
  struct; ее члены и базовые классы (п.<a href="#R.10">R.10</a>) считаются общими по
  определению (п.<a href="#R.11">R.11</a>). Объединением называется класс, описанный со
  служебным-словом-класса union; его члены считаются общими по
  определению, и в любой момент времени объединение содержит только
  один член (п.<a href="#R.9.5">R.9.5</a>).</p>

<a name="#R.9.1"></a><h5>R.9.1 Имена класса</h5>
<p>Описание класса порождает новый тип. Например, ниже описываются
  три переменные трех различных типов:</p>
<pre>
        struct X { int a; };
        struct Y { int a; };
        X a1;
        Y a2;
        int a3;
</pre>
<p>Отсюда следует, что такие присваивания приводят к несоответствию
  типов:</p>
<pre>
        a1 = a2;   // ошибка: Y присваивается X
        a1 = a3;   // ошибка: int присваивается X
</pre>
<p>Ниже описывается перегрузка (п.<a href="#R.13">R.13</a>) функции f(), а не просто
  повторное описание той же функции:</p>
<pre>
        int f(X);
        int f(Y);
</pre>
<p>По той же причине нельзя дважды определять класс, это видно из
  примера ниже, где дважды определен S:</p>
<pre>
        struct S { int a; };
        struct S { int a; };  // ошибка, повторное определение
</pre>
<p>Описание класса включает имя класса в ту область видимости, внутри
  которой оно произошло, и закрывает любой класс, объект, функцию или
  другое описание этого имени в объемлющей области видимости (п.<a href="#R.3.2">R.3.2</a>).
  Если имя класса описано в такой области видимости, где уже был
  описан объект с таким же именем, функция или элемент перечисления, то
  обращаться к классу можно только с помощью конструкции
  спецификация-сложного-типа (п.<a href="#R.7.1.6">R.7.1.6</a>), например:</p>
<pre>
        struct stat {
           // ...
        };

        stat gstt;              // просто `stat' используется для
                                // определения переменной
        int stat(struct stat*); // переопределение `stat' как функции

        void f()
        {
           struct stat* ps;     // нужен префикс struct
                                // для задания структуры stat
           // ...
           stat(ps);            // вызов stat()
           // ...
        }
</pre>
<p>Конструкция спецификация-сложного-типа вместе со
  служебным-словом-класса, но без описания объекта или функции также
  может служить для задания имени класса, как и описание класса, однако
  в этом случае класс не считается определенным, например:</p>
<pre>
        struct s { int a; };

        void g()
        {
          struct s;  // скрывает глобальную структуру `s'
          s* p;      // используется локальная структура `s'
          struct s { char* p; };  // описание локальной структуры `s'
        }
</pre>
<p>Такие правила позволяют классам ссылаться друг на друга при их
  описании, пример,</p>
<pre>
        class vector;

        class matrix {
            // ...
            friend vector operator*(matrix&, vector&);
        };

       class vector {
           // ...
            friend vector operator*(matrix&, vector&);
       };
</pre>
<p>Описание friend (дружественные функции) обсуждается в п.<a href="#R.11.4">R.11.4</a>, а
  функция operator в п.<a href="#R.13.4">R.13.4</a>. Если класс, указанный как друг, пока
  еще не описан, его имя считается принадлежащим той же области
  видимости, в которой находится имя класса, содержащего описание
  friend (п.<a href="#R.11.4">R.11.4</a>).</p>
<p>В описании объектов или функций можно также использовать
  конструкцию спецификация-сложного-типа (п.<a href="#R.7.1.6">R.7.1.6</a>). Ее использование
  отличается от описания класса тем, что если класс, чье имя указано
  в спецификации, находится в текущей области видимости, то имя из
  этой спецификации будет ссылаться на него, например:</p>
<pre>
        struct s { int a; }

        void g()
        {
           struct* s p = new s;  // обращение к глобальной `s'
           p->a = 1;
        }
</pre>
<p>Имя считается описанным сразу же после появления его идентификатора
  в описании. Отсюда следует, что в описании</p>
<pre>
        class A * A;
</pre>
<p>A в начале задается, как имя класса, а затем оно переопределяется
  как имя указателя на объект этого класса, поэтому для обозначения этого
  класса следует использовать спецификацию-сложного типа class A. Такое
  "трюкачество" с именами может вызвать недоумение, и лучше его избегать.</p>
<p>Конструкция имя-typedef (п.<a href="#R.7.1.3">R.7.1.3</a>) обозначает класс и считается
  именем-класса, см. также п.<a href="#R.7.1.3">R.7.1.3</a>.</p>

<a name="#R.9.2"></a><h5>R.9.2 Члены класса</h5>
<pre>
     список-членов:
        описание-члена список-членов opt
        спецификация-доступа : список-членов opt

     описание-члена:
        спецификации-описания opt список-описателей-членов opt ;
        определение-функции ; opt
        уточненное-имя ;

     список-описателей-членов:
        описатель-члена
        список-описателей-членов , описатель-члена

     описатель-члена:
        описатель спецификация-чистой opt
        идентификатор opt : выражение-константа

     спецификация-чистой:
        = 0
</pre>
<p>С помощью конструкции список-членов можно описать данные, функции,
  классы, элементы перечисления (п.<a href="#R.7.2">R.7.2</a>), битовые поля, друзей
  (п.<a href="#R.11.4">R.11.4</a>) и имена типов (п.<a href="#R.7.1.3">R.7.1.3</a>, п.<a href="#R.9.1">R.9.1</a>). Кроме того,
  список-членов может содержать описания, устанавливающие доступ к
  именам членов, см. п.<a href="#R.11.3">R.11.3</a>. Никакой член не может быть дважды
  описан в списке-членов. Список-членов определяет все множество
  членов данного класса, т.е. нельзя добавить еще один член в каком-либо
  другом описании.</p>
<p>Отметим, что одно имя может обозначать несколько функций-членов
  при условии, что их типы достаточно отличаются друг от друга (п.<a href="#R.13">R.13</a>).
  Укажем, что описатель-члена не может содержать инициализатора (п.<a href="#R.8.4">R.8.4</a>).
  Инициализация члена возможна с помощью конструктора, см. п.<a href="#R.12.1">R.12.1.</a>
</p>
<p>Член не может иметь спецификацию auto, extern или register.</p>
<p>Конструкция спецификации-описания может отсутствовать только в
  описании функции. Конструкция список-описателей-членов может
  опускаться только после конструкций спецификация-класса,
  спецификация-перечисления или спецификация-описания, если последняя
  имеет вид friend спецификация-сложного-типа. Конструкция
  спецификация-чистой используется только при описании виртуальной
  функции (п.<a href="#R.10.2">R.10.2</a>).</p>
<p>Если члены являются объектами классов, то эти классы должны
  быть ранее описаны. В частности, класс C1 не может содержать объект
  класса C1, но может содержать указатель или ссылку на класс C1.
  Если в типе нестатического члена используется массив, то все
  размеры всех индексов массива должны быть указаны.</p>
<p>Приведем простой пример описания класса:</p>
<pre>
      struct tnode {
          char tword[20];
          int count;
          tnode *left;
          tnode *right;
      };
</pre>
<p>Здесь класс содержит массив из двадцати символов, целое и два
  указателя на ту же структуру. После появления такого описания
  следующее:</p>
<pre>
      tnode s, *sp;
</pre>
<p>задает s как объект типа tnode и sp как указатель на tnode. С учетом
  этих описаний s->count обозначает член count структуры, на которую
  указывает sp; s.left обозначает указатель left на поддерево
  структуры s; s.right->tword[0] обозначает первый символ члена
  tword поддерева структуры s, на которую указывает right.</p>
<p>Нестатические члены класса, представляющие данные и описанные
  подряд и без использования спецификации-доступа, размещаются внутри
  объекта типа класс так, что позже описанные члены имеют большие адреса.
  Порядок размещения таких членов, если их описание перемежается
  описаниями со спецификацией-доступа, зависит от реализации (п.<a href="#R.11.1">R.11.1</a>).
  Принятые в реализации правила выравнивания могут привести к тому,
  что два соседних члена не будут располагаться сразу друг за другом.
  К этому же могут привести правила выделения памяти для виртуальных
  функций (п.<a href="#R.10.2">R.10.2</a>) и виртуальных базовых классов (п.<a href="#R.10.1">R.10.1</a>);
  см. также п.<a href="#R.5.4">R.5.4</a>.</p>
<p>Функция-член (п.<a href="#R.9.3">R.9.3</a>), имя которой совпадает с именем класса,
  является конструктором (п.<a href="#R.12.1">R.12.1</a>). Имя статического члена данных,
  элемента перечисления, члена безымянного объединения или вложенного
  типа не может совпадать с именем класса.</p>

<a name="#R.9.3"></a><h5>R.9.3 Функции-члены</h5>
<p>Функция, описанная как член (без спецификации friend п.<a href="#R.11.4">R.11.4</a>),
  называется функция-член и вызывается в соответствии с синтаксисом
  члена класса (п.<a href="#R.5.2.4">R.5.2.4</a>), например:</p>
<pre>
        struct tnode {
           char tword[20];
           int count;
           tnode *left;
           tnode *right;
           void set(char*, tnode* l, tnode *r);
        };
</pre>
<p>Здесь set является функцией-членом и может вызываться так:</p>
<pre>
        void f(tnode n1, tnode n2)
        {
           n1.set("abc",&n2,0);
           n2.set("def",0,0);
         }
</pre>
<p>Считается, что определение функции-члена принадлежит области
  видимости ее класса. Это означает, что в функции-члене (если она
  нестатическая, п.<a href="#R.9.4">R.9.4</a>) можно непосредственно использовать имена
  членов ее класса. В статической функции-члене можно непосредственно
  использовать имена только статических членов, элементов перечисления
  и вложенных типов. Если определение функции-члена находится вне
  описания класса, ее имя следует уточнить именем класса с помощью
  операции ::, например:</p>
<pre>
         void tnode::set(char* w, tnode* l, tnode* r)
         {
           count = strlen(w)+1;
           if (sizeof(tword)<=count)
              error("tnode string too long");
           strcpy(tword,w);
           left = 1;
           right = r;
         }
</pre>
<p>Обозначение tnode::set указывает, что функция set является членом и
  находится в области видимости класса tnode. Имена членов tword,
  count, left и right относятся к членам того объекта, с именем
  которого вызывалась Поэтому в вызове n1.set("abc",&n2,0) tword
  обозначает n1.tword, а в вызове n2.set("def",0,0) tword обозначает
  n2.tword. Функции strlen, error и strcpy должны быть описаны где-то
  в программе.</p>
<p>Члены можно определять (п.<a href="#R.3.1">R.3.1</a>) вне описания класса; если в
  описании класса они были описаны, но не определены, их не следует
  описывать заново, см. п.<a href="#R.3.3">R.3.3</a>. После определения класса
  функции-члены этого класса можно использовать при описании друзей.
  Всякая вызываемая в программе функция-член должна иметь в точности
  одно определение.</p>
<p>Результат вызова нестатической функции-члена (п.<a href="#R.9.4">R.9.4</a>) класса X,
  когда она вызывается не с объектом класса X, неопределен.</p>

<a name="#R.9.3.1"></a><h6>R.9.3.1 Указатель this</h6>
<p>В нестатической (п.<a href="#R.9.3">R.9.3</a>) функции-члене служебное слово this обозначает
  указатель на объект, с которым эта функция вызывалась. В функции-члене
  класса X тип this есть X *const, если только функция-член не описана
  со спецификацией const или volatile; для этих случаев this имеет
  тип const X *const или volatile X *const соответственно. Если
  функция описана с указанием const и volatile, то тип this будет
  const volatile X *const, см. также п.<a href="#R.18.3.3">R.18.3.3</a>. Приведем пример:</p>
<pre>
       struct s {
          int a;
          int f() const;
          int g() { return a++; }
          int h() const { return a++; }  // ошибка
       };

       int s::f() const { return a; }
</pre>
<p>Операция a++ в теле функции s::h ошибочна, поскольку с ее помощью
  делается попытка изменить объект (часть его), с которым вызывалась
  функция s::h(). Это недопустимо для функции-члена, описанной со
  спецификацией const, т.к. this является указателем на const, иными
  словами, *this имеет спецификацию const.</p>
<p>Функция-член const (т.е. функция-член, описанная со спецификацией
  const) может вызываться как для объектов const, так и для объектов
  без спецификации const, тогда как функция-член без спецификации
  const может вызываться только для объектов без спецификации const,
  например:</p>
<pre>
       void k(s& x, const s& y)
       {
         x.f();
         x.g();
         y.f();
         y.g();   // ошибка
       }
</pre>
<p>Здесь вызов y.g() является ошибкой, т.к. y есть const, а s::g() -
  функция-член без спецификации const, которая может изменять
  (и изменяет) объекты, для которых она вызывалась.</p>
<p>Аналогично, только функция-член volatile (т.е. функция-член,
  описанная со спецификацией volatile) может вызываться для объектов
  со спецификацией volatile. Функция-член может быть одновременно
  const и volatile.</p>
<p>Для объектов const или volatile могут вызываться конструкторы
  (п.<a href="#R.12.1">R.12.1</a>) и деструкторы (п.<a href="#R.12.4">R.12.4</a>). Конструкторы (п.<a href="#R.12.1">R.12.1</a>) и
  деструкторы (п.<a href="#R.12.4">R.12.4</a>) нельзя описывать со спецификациями const
  или volatile.</p>

<a name="#R.9.3.2"></a><h6>R.9.3.2 Функции-члены со спецификацией inline</h6>
<p>Функцию-член можно определить (п.<a href="#R.8.3">R.8.3</a>) в описании класса, в
  таком случае она считается подстановкой (inline, п.<a href="#R.7.1.2">R.7.1.2</a>).
  Определять функцию в описании класса - это эквивалентно тому,
  чтобы описывать функцию и определять ее со спецификацией inline
  сразу же после описания класса. Считается, что такой перенос
  определения функции происходит после препроцессорной обработки
  до стадии синтаксического анализа и контроля типов. Поэтому
  программный фрагмент</p>
<pre>
        int b;
        struct x {
           char* f() { return b; }
           char* b;
        };
</pre>
<p>эквивалентен</p>
<pre>
        int b;
        struct x {
           char* f();
           char* b;
        };

        inline char* x::f() { return b; } // перенос
</pre>
<p>Здесь в функции x::f() используется x::b, а не глобальное b.</p>
<p>Функции-члены можно определять даже в описании локальных или
  вложенных классов, где такой перенос будет синтаксически незаконным.
  Локальные классы обсуждаются в R.9.8, а вложенные классы в п.<a href="#R.9.7">R.9.7</a>.</p>

<a name="#R.9.4"></a><h5>R.9.4 Статические члены</h5>
<p>Для члена класса, представляющего данные или функцию, можно при описании
  класса задать спецификацию static. Для статического члена,
  представляющего данные, в программе существует только один экземпляр,
  которым владеют все объекты этого класса. Статический член не является
  частью объекта класса. Статические члены глобального класса
  подлежат внешнему связыванию (п.<a href="#R.3.3">R.3.3</a>). Описание статического члена,
  представляющего данные, в описании класса не считается определением.
  Определение должно быть дано в другом месте, см. также. п.<a href="#R.18.3">R.18.3</a>.</p>
<p>Статическая функция-член не имеет указатель this, поэтому для
  доступа к нестатическим членам своего класса она должна использовать
  операции . или ->. Статическая функция-член не может быть виртуальной.
  Недопустимы статические и нестатические функции-члены с одним именем
  и одинаковыми типами параметров.</p>
<p>Статические члены локального класса (п.<a href="#R.9.8">R.9.8</a>) не подлежат
  связыванию и не могут определяться вне описания класса. Отсюда
  следует, что локальные классы не могут иметь статических членов,
  представляющих данные.</p>
<p>К статическому члену mem класса c1 можно обращаться как c1::mem
  (п.<a href="#R.5.1">R.5.1</a>), т.е. независимо ни от какого объекта. К нему также можно
  обращаться с помощью операций доступа к членам . и  ->. Если к
  статическому члену происходит обращение с помощью операций доступа,
  выражения, стоящие слева от . или -> не эквивалентны. Статический
  член mem существует даже, если не создано ни одного объекта класса
  c1. В примере ниже run_chain, idle и другие члены существуют даже,
  если не было создано ни одного объекта класса process:</p>
<pre>
          class process {
            static int no_of_process;
            static process* run_chain;
            static process* running;
            static process* idle;
            // ...
          public:
            // ...
            int state();
            static void reshedule();
            // ...
          };
</pre>
<p>Здесь к функции reshedule можно обратиться без указания объекта
  класса process таким образом:</p>
<pre>
          void f()
          {
            process::reshedule();
          }
</pre>
<p>Статические члены глобальных классов инициализируются точно так же
  как глобальные объекты, но область их видимости - файл, например:</p>
<pre>
          void process::reshedule() { /* ... */ };
          int process::no_of_process = 1;
          process* process::running = get_main();
          process* process::run_chain = process::running;
</pre>
<p>Статические члены подчиняются обычным правилам доступа к членам
  класса (п.<a href="#R.11">R.11</a>), за исключением того, что их можно инициализировать
  в файловой области видимости.</p>
<p>В типе статического члена не участвует имя класса, так тип
  process::no_of_process есть int, а тип &process::reshedule() -
  void(*)().</p>

<a name="#R.9.5"></a><h5>R.9.5 Объединения</h5>
<p>Объединение можно представить как структуру, все члены имеют
  нулевое смещения, а размер ее достаточно велик, чтобы
  вмещать любой из ее членов. В любой момент времени объединение
  может содержать только один член. В объединении могут быть
  функции-члены (в том числе конструкторы и деструкторы), но не
  виртуальные функции (п.<a href="#R.10.2">R.10.2</a>). Объединение не может иметь базовых
  классов и не может само использоваться в качестве базового класса.
  Членом объединения не может быть объект класса с конструктором или
  деструктором, а также с определенной пользователем операцией
  присваивания (п.<a href="#R.13.4.3">R.13.4.3</a>). Объединение не может содержать статических
  членов, представляющих данные.</p>
<p>Объединение вида</p>
<pre>
          union { список-членов }
</pre>
<p>называется безымянным объединением, оно определяет объект без имени
  (и без типа). Имена всех членов безымянного объединения должны
  отличаться от других имен в той области видимости, в которой описано
  объединение; их можно использовать в этой области видимости
  непосредственно, без обычных операций доступа к членам (п.<a href="#R.5.2.4">R.5.2.4</a>).<br>
  Приведем пример:</p>
<pre>
         void f()
         {
           union { int a; char* p; };
           a = 1;
           // ...
           p = "Jennifer";
           // ...
          }
</pre>
<p>Здесь a и p используются как обычные переменные (не члены), но поскольку
  они входят в одно объединение, их адреса совпадают.</p>
<p>Глобальные безымянные объединения можно описать со спецификацией
  static. Безымянные объединения не должны содержать частных или
  защищенных членов (п.<a href="#R.11">R.11</a>), а также функций-членов.</p>
<p>Если описаны объекты объединения или указатели на него, то
  оно не считается безымянным, например,</p>
<pre>
          union { int aa; char* p; } obj, *ptr=&obj;
          aa = 1;      // ошибка
          ptr->aa = 1; // нормально
</pre>
<p>Здесь присваивание простому имени aa незаконно, т.к. имя члена не
  привязано ни к какому объекту.</p>
<p>Инициализация объединений, не имеющих конструкторов, описывается
  в п.<a href="#R.8.4.1">R.8.4.1</a>.</p>

<a name="#R.9.6"></a><h5>R.9.6 Битовые поля</h5>
<p>Конструкция описатель-члена, имеющая вид,
<pre>
       идентификатор opt : выражение-константа
</pre>
<p>задает битовое поле, длина которого отделяется от его имени
  двоеточием. Размещение битовых полей в объекте класса зависит от
  реализации. Поля упаковываются в некоторые адресуемые элементы
  памяти. На одних машинах поля могут выходить за границы этих
  элементов, на других - нет. Выравнивание битовых полей тоже определяется
  реализацией. На одних машинах значения помещаются в битовые поля
  справа налево, на других - слева направо.</p>
<p>Чтобы установить заданное расположение полей с помощью дополнения
  нулями, используют безымянные битовые поля. Особый случай, когда
  используется безымянное поле нулевой длины. Оно задает выравнивание
  следующего битового поля по границе элемента памяти, используемого
  при размещении полей.</p>
<p>Безымянное поле не является членом и не может инициализироваться.</p>
<p>Битовые поля должны иметь целочисленный тип (п.<a href="#R.3.6.1">R.3.6.1</a>). Их
  интерпретация зависит от того, считается ли значение поля с обычным типом
  int (т.е. без явного использования signed или unsigned) знаковым
  или беззнаковым. Операция взятия адреса & не применима к битовым
  полям, так что не может быть ни указателей на битовые поля, ни ссылок
  на них.</p>

<a name="#R.9.7"></a><h5>R.9.7 Вложенные описания классов</h5>
<p>Класс можно описать в описании другого класса. Такой класс называют
  вложенным. Имя вложенного класса локально по отношению к
  объемлющему классу. Вложенный класс находится в области видимости
  объемлющего класса. Если не считать явного использования указателей,
  ссылок или имен объектов, то в описаниях вложенного класса допустимы
  только имена типов, статических членов и элементов перечисления
  из объемлющего класса.</p>
<pre>
          int x;
          int y;

          class enclose {
          public:
           int x;
           static int s;

           class inner {

              void f(int i)
              {
                x = i;   // ошибка: присваивание enclose::x
                s = i;   // нормально: присваивание enclose ::s
                ::x = i; // нормально: присваивание глобальному x
                y = i;   // нормально: присваивание глобальному y
              }

              void g(enclose* p, int i)
              {
                p->x = i; // нормально: присваивание enclose ::x
              }

            };
          };
          inner* p = 0;   // ошибка: `inner' вне области видимости
</pre>
<p>Функции-члены вложенного класса не имеют особых прав доступа к членам
  объемлющего класса, они подчиняются обычным правилам доступа (п.<a href="#R.11">R.11</a>).
  Аналогично, функции-члены объемлющего класса не имеют особых прав
  доступа к членам вложенного класса и подчиняются обычным правилам
  доступа, например:</p>
<pre>
           class E {
              int x;
              class I {
                 int y;
                 void f(E* p, int i)
                 {
                   p->x = i;  // ошибка: E::x частный член
                 }
               };

               int g(I* p)
               {
                 return p->y;  // ошибка: I::y частный член
               }
             };
</pre>
<p>Функции-члены и представляющие данные, статические члены из вложенного
  класса можно определить в глобальной области видимости, например:</p>
<pre>
             class enclose {
                class inner {
                   static int x;
                   void f(int i);
                };
              };

              typedef enclose::inner ei;
              int ei::x = 1;

              void enclose::inner::f(int i) { /* ... */ }
</pre>
<p>Подобно функции-члену дружественная функция, определенная в данном
  классе, находится в области видимости этого класса. Она подчиняется
  тем же правилам связывания имен, что и функции-члены (они указаны выше
  и в п.<a href="#R.10.4">R.10.4</a>), и не имеет так же как они особых прав доступа к
  членам объемлющего класса и к локальным переменным функций этого
  класса (п.<a href="#R.11">R.11).</p>

<a name="#R.9.8"></a><h5>R.9.8 Описания локальных классов</h5>
<p>Класс можно описать в определении функции, такой класс называется
  локальным. Имя локального класса считается локальным в объемлющей
  области видимости, а областью видимости локального класса является
  объемлющая область видимости. В описаниях локального класса из
  объемлющей области видимости можно использовать только имена типов,
  статических переменных, внешних переменных и функций, а также
  элементы перечисления. Приведем пример:</p>
<pre>
           int x;
           void f()
           {
             static int s;
             int x;
             extern int g();
             struct local {
                int h() { return x; }   // ошибка: `x' автоматическая
                int j() { return s; }   // нормально
                int k() { return ::x; } // нормально
                int l() { return g(); } // нормально
             }
           }
</pre>
<p>Объемлющая функция не имеет особых прав доступа к членам локального
  класса, она подчиняется обычным правилам доступа (п.<a href="#R.11">R.11</a>).
  Функцию-член локального класса следует определять в определении этого
  класса. Локальный класс не может иметь статических членов,
  представляющих данные.</p>

<a name="#R.9.9"></a><h5>R.9.9 Имена локальных типов</h5>
<p>Имена типов подчиняются точно таким же правилам областей видимости,
  как и другие имена. В частности, имена типов, определенные в описании
  класса, нельзя использовать вне этого класса без уточнения, например:</p>
<pre>
          class X {
          public:
            typedef int I;
            class Y { /* ... */ }
            I a;
          };

          I b;    // ошибка
          Y c;    // ошибка
          X::Y d; // ошибка
</pre>
<p>Следующее положение ограничивает зависимость от контекста правил
  описания членов класса, а так же правила переноса тела функций,
  являющихся подстановками. После использования в описании класса
  имя константы, имя-класса или имя-typedef не может переопределяться в
  описании этого класса. Имя, не являющееся именем-класса или именем-typedef
  не может быть определено в описании класса как имя-класса или имя-typedef,
  если оно уже использовалось иначе в описании этого класса.
  Рассмотрим пример:</p>
<pre>
          typedef int c;
          enum { i = 1 };
          class X {
            char v[i];
            int f() { return sizeof(c); }
            char c;          // ошибка: имя typedef
                             // переопределяется после использования
            enum { i = 2 };  // ошибка: `i' переопределяется после
                             // использования в задании типа `char[i]'
          };

         typedef char* T;

         struct Y {
           T a;
           typedef long T;  // ошибка: имя T уже использовано
           T b;
         };
</pre>

<a name="#R.10"></a><h4>R.10 Производные классы</h4>
<p>В описании класса можно указать список базовых классов с помощью
  следующих конструкций:</p>
<pre>
         спец-базовых:
             : список-базовых

         список-базовых:
             спецификация-базовых
             список-базовых , спецификация-базовых

         спецификация-базовых:
             полное-имя-класса
             virtual спецификация-доступа opt полное-имя-класса
             спецификация-доступа virtual opt полное-имя-класса

         спецификация-доступа:
             private
             protected
             public
</pre>
<p>Конструкция имя-класса в спецификации-базовых должна обозначать
  ранее описанный класс (п.<a href="#R.9">R.9</a>), который называется базовым по
  отношению к определяемому классу. Говорят, что класс является
  производным от своих базовых классов. Назначение конструкции
  спецификация-доступа объясняется в п.<a href="#R.11">R.11</a>. К членам базового класса,
  если только они не переопределены в производном классе, можно обращаться
  так, как будто они являются членами производного класса. Говорят,
  что производный класс наследует члены базового класса. С помощью
  операции разрешения области видимости :: (п.<a href="#R.5.1">R.5.1</a>) к члену базового
  класса можно обращаться явно. Такое обращение возможно и в том случае,
  когда имя члена базового класса переопределено в производном классе.
  Производный класс сам может выступать как базовый при контроле
  доступа, см. п.<a href="#R.11.2">R.11.2</a>. Указатель на производный класс может неявно
  преобразовываться в указатель на однозначно определенный и доступный
  базовый класс (п.<a href="#R.4.6">R.4.6</a>). Ссылка на производный класс может неявно
  преобразовываться в ссылку на однозначно определенный и доступный
  базовый класс (п.<a href="#R.4.7">R.4.7</a>).</p>
<p>Рассмотрим пример:</p>
<pre>
          class base {
          public:
             int a, b;
          };

         class derived : public base {
         public:
            int b, c;
         };

         void f()
         {
           derived d;
           d.a = 1;
           d.base::b = 2;
           d.b = 3;
           d.c = 4;
          base* bp = &d;  // стандартное преобразование derived* в base*
         }
</pre>
<p>Здесь присваиваются значения четырем членам d, а bp настраивается
  на d.</p>
<p>Класс называется прямым базовым, если он находится в списке-базовых,
  и косвенным базовым, если сам не являясь прямым базовым, он служит
  базовым для одного из классов списка-базовых.</p>
<p>Отметим, что в обозначении имя-класса :: имя конструкция, имя может
  быть именем члена косвенного базового класса. Такое обозначение
  просто указывает класс, в котором следует начинать поиск этого имени.
  Приведем пример:</p>
<pre>
         class A { public: void f(); }
         class B : public A { };
         class C : public B { public: void f(); }

         void C::f()
         {
           f();    // вызов f() из C
           A::f(); // вызов f() из A
           B::f(); // вызов f() из A
         }
</pre>
<p>Здесь дважды вызывается A::f(), поскольку это единственная функция f()
  в классе B.</p>
<p>Инициализация объектов, представляющих базовые классы, задается
  в конструкторах, см. п.<a href="#R.12.6.2">R.12.6.2</a>.</p>

<a name="#R.10.1"></a><h5>R.10.1 Множественные базовые классы</h5>
<p>Класс может быть производным по отношению к любому числу базовых
  классов. Приведем пример:</p>
<pre>
         class A { /* ... */ };
         class B { /* ... */ };
         class C { /* ... */ };
         class D : public A, public B, public C { /* ... */ };
</pre>
<p>Использование более, чем одного прямого базового класса называется
  множественным наследованием.</p>
<p>Порядок наследования не важен, если не учитывать вопросов,
  связанных со стандартной инициализацией с помощью конструктора
  (п.<a href="#R.12.1">R.12.1</a>), уничтожением (п.<a href="#R.12.4">R.12.4</a>) и размещением в памяти
  (п.<a href="#R.5.4">R.5.4</a>, п.<a href="#R.9.2">R.9.2</a>, п.<a href="#R.11.1">R.11.1</a>). Порядок выделения памяти для базовых
  классов определяется реализацией.</p>
<p>Нельзя указывать класс в качестве прямого базового по отношению
  к производному классу более одного раза, но косвенным базовым классом
  он может быть неоднократно.</p>
<pre>
         class B { /* ... */ };
         class D : public B, public B { /* ... */ }; // недопустимо

         class L { /* ... */ };
         class A : public L { /* ... */ };
         class B : public L { /* ... */ };
         class C : public A, public B { /* ... */ }; // нормально
</pre>
<p>Здесь объект класса C будет иметь два вложенных объекта класса L.</p>
<p>К спецификации базового класса можно добавить служебное слово
  virtual. Отдельный объект виртуального базового класса V разделяется
  между всеми базовыми классами, которые указали V при задании сво