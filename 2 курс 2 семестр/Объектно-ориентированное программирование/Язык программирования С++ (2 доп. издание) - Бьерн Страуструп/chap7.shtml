<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 7<br>
Перегрузка операций в С++</h3>

<p align="right"><i>Если я выбираю слово, оно значит только то,<br>
что я решу, ни больше и ни меньше.<br>
- Шалтай Болтай</i></p>
<p>Глава содержит описание механизма перегрузки операций в С++.
   Программист может задать интерпретацию операций, когда они
   применяются к объектам определенного класса. Помимо арифметических,
   логических и операций отношения можно переопределить вызов
   функций (), индексацию [], косвенное обращение ->, а также
   присваивание и инициализацию. Можно определить явные и скрытые
   преобразования между пользовательскими и основными типами. Показано,
   как определить класс, объект которого можно копировать и
   уничтожать только с помощью специальных, определенных пользователем
   функций.</p>

<a name="#introduct"></a><h4>7.1. Введение</h4>
<p>Обычно в программах используются объекты, являющиеся конкретным
   представлением абстрактных понятий. Например, в С++ тип данных int
   вместе с операциями +, -, *, / и т.д. реализует (хотя и ограниченно)
   математическое понятие целого. Обычно с понятием связывается набор
   действий, которые реализуются в языке в виде основных операций над
   объектами, задаваемых в сжатом, удобном и привычном виде.
   К сожалению, в языках программирования непосредственно представляется
   только малое число понятий. Так, понятия комплексных чисел, алгебры
   матриц, логических сигналов и строк в С++ не имеют непосредственного
   выражения. Возможность задать представление сложных объектов вместе
   с набором операций, выполняемых над такими объектами,
   реализуют в С++ классы. Позволяя программисту определять операции
   над объектами классов, мы получаем более удобную и традиционную
   систему обозначений для работы с этими объектами по сравнению с той,
   в которой все операции задаются как обычные функции. Приведем пример:</p>
<pre>
           class complex {
             double re, im;
           public:
             complex(double r, double i) { re=r; im=i; }
             friend complex operator+(complex, complex);
             friend complex operator*(complex, complex);
          };
</pre>
<p>Здесь приведена простая реализация понятия комплексного числа, когда
   оно представлено парой чисел с плавающей точкой двойной точности,
   с которыми можно оперировать только с помощью операций + и *.
   Интерпретацию этих операций задает программист в определениях функций
   с именами operator+ и operator*. Так, если b и c имеют тип complex,
   то b+c означает (по определению) operator+(b,c). Теперь можно
   приблизиться к привычной записи комплексных выражений:</p>
<pre>
         void f()
         {
           complex a = complex(1,3.1);
           complex b = complex(1.2,2);
           complex c = b;

           a = b+c;
           b = b+c*a;
           c = a*b+complex(1,2);
         }
</pre>
<p>Сохраняются обычные приоритеты операций, поэтому второе выражение
   выполняется как b=b+(c*a), а не как b=(b+c)*a.</p>

<a name="#operfunc"></a><h4>7.2. Операторные функции</h4>
<p>Можно описать функции, определяющие интерпретацию следующих операций:</p>
<pre>
        +    -    *    /    %    ^    &    |    ~    !
        =    <    >    +=   -=   *=   /=   %=   ^=   &=
        |=   <<   >>   >>=  <<=  ==   !=   <=   >=   &&
        ||   ++   --   ->*  ,    ->   []   ()   new  delete
</pre>
<p>Последние пять операций означают: косвенное обращение (
   п.<a href="#indirect">7.9</a>),
   индексацию (п.<a href="#index">7.7</a>), вызов функции (п.<a href="#call">7.8</a>), размещение в свободной
   памяти и освобождение (п.<a href="chap3.shtml#freemem">3.2.6</a>). Нельзя изменить приоритеты этих
   операций, равно как и синтаксические правила для выражений. Так,
   нельзя определить унарную операцию % , также как и бинарную операцию
   !. Нельзя ввести новые лексемы для обозначения операций, но если
   набор операций вас не устраивает, можно воспользоваться привычным
   обозначением вызова функции. Поэтому используйте pow(), а не ** .
   Эти ограничения можно счесть драконовскими, но более свободные
   правила легко приводят к неоднозначности. Допустим, мы определим
   операцию ** как возведение в степень, что на первый взгляд кажется
   очевидной и простой задачей. Но если как следует подумать, то
   возникают вопросы: должны ли операции ** выполняться слева направо
   (как в Фортране) или справа налево (как в Алголе)? Как
   интерпретировать выражение a**p как a*(*p) или как (a)**(p)?</p>
<p>Именем операторной функции является служебное слово operator, за
   которым идет сама операция, например, operator<<. Операторная
   функция описывается и вызывается как обычная функция. Использование
   символа операции является просто краткой формой записи вызова
   операторной функции:</p>
<pre>
           void f(complex a, complex b)
           {
             complex c = a + b;           // краткая форма
             complex d = operator+(a,b);  // явный вызов
           }
</pre>
<p>С учетом приведенного описания типа complex инициализаторы в этом
   примере являются эквивалентными.</p>

<a name="#binar"></a><h5>7.2.1 Бинарные и унарные операции</h5>
<p>Бинарную операцию можно определить как функцию-член с одним
   параметром, или как глобальную функцию с двумя параметрами. Значит,
   для любой бинарной операции @ выражение aa @ bb интерпретируется
   либо как aa.operator(bb), либо как operator@(aa,bb). Если определены обе
   функции, то выбор интерпретации происходит по правилам сопоставления
   параметров (п.<a href="referenc.shtml#R.13.2">R.13.2</a>). Префиксная или постфиксная унарная операция
   может определяться как функция-член без параметров, или как глобальная
   функция с одними параметром. Для любой префиксной унарной операции
   @ выражение @aa интерпретируется либо как aa.operator@(), либо как
   operator@(aa). Если определены обе функции, то выбор интерпретации
   происходит по правилам сопоставления параметров (п.<a href="referenc.shtml#R.13.2">R.13.2</a>). Для
   любой постфиксной унарной операции @ выражение @aa интерпретируется
   либо как aa.operator@(int), либо как operator@(aa,int). Подробно
   это объясняется в п.<a href="#increm">7.10</a>. Если определены обе функции, то выбор
   интерпретации происходит по правилам сопоставления параметров
   (п.<a href="chap13.shtml#concret">13.2</a>). Операцию можно определить только в соответствии с
   синтаксическими правилами, имеющимися для нее в грамматике С++.
   В частности, нельзя определить % как унарную операцию, а + как
   тернарную. Проиллюстрируем сказанное примерами:</p>
<pre>
       class X {
         // члены (неявно используется указатель `this'):

         X* operator&();        // префиксная унарная операция &
                                // (взятие адреса)
         X operator&(X);        // бинарная операция & (И поразрядное)
         X operator++(int);     // постфиксный инкремент
         X operator&(X,X);      // ошибка: & не может быть тернарной
         X operator/();         // ошибка: / не может быть унарной
       };

      // глобальные функции (обычно друзья)

       X operator-(X);          // префиксный унарный минус
       X operator-(X,X);        // бинарный минус
       X operator--(X&,int);    // постфиксный инкремент
       X operator-();           // ошибка: нет операнда
       X operator-(X,X,X);      // ошибка: тернарная операция
       X operator%(X);          // ошибка: унарная операция %
</pre>
<p>Операция [] описывается в 
   п.<a href="#index">7.7</a>, операция () в п.<a href="#call">7.8</a>, операция ->
   в п.<a href="#indirect">7.9</a>, а операции ++ и -- в п.<a href="#increm">7.10</a>.</p>

<a name="#predeterm"></a><h5>7.2.2 Предопределенные свойства операций</h5>
<p>Используется только несколько предположений о свойствах пользовательских
   операций. В частности, operator=, operator[], operator() и
   operator-> должны быть нестатическими функциями-членами. Этим
   обеспечивается то, что первый операнд этих операций является адресом.</p>
<p>Для некоторых встроенных операций их интерпретация определяется
   как комбинация других операций, выполняемых над теми же операндами.
   Так, если a типа int, то ++a означает a+=1, что в свою очередь
   означает a=a+1. Такие соотношения не сохраняются для пользовательских
   операций, если только пользователь специально не определил их с такой
   целью. Так, определение operator+=() для типа complex нельзя вывести
   из определений complex::operator+() и complex operator=().</p>
<p>По исторической случайности оказалось, что операции = (присваивание),
   &(взятие адреса) и , (операция запятая) обладают предопределенными
   свойствами для объектов классов. Но можно закрыть от произвольного
   пользователя эти свойства, если описать эти операции как частные:</p>
<pre>
           class X {
              // ...
           private:
              void operator=(const X&);
              void operator&();
              void operator,(const X&);
              // ...
           };

           void f(X a, X b)
           {
              a= b;   // ошибка: операция = частная
              &a;     // ошибка: операция & частная
              a,b     // ошибка: операция , частная
           }
</pre>
<p>С другой стороны, можно наоборот придать с помощью соответствующих
   определений этим операциям иное значение.</p>

<a name="#usertype"></a><h5>7.2.3 Операторные функции и пользовательские типы</h5>
<p>Операторная функция должна быть либо членом, либо иметь по крайней
   мере один параметр, являющийся объектом класса (для функций,
   переопределяющих операции new и delete, это не обязательно). Это
   правило гарантирует, что пользователь не сумеет изменить
   интерпретацию выражений, не содержащих объектов пользовательского
   типа. В частности, нельзя определить операторную функцию, работающую
   только с указателями. Этим гарантируется, что в С++ возможны
   расширения, но не мутации (не считая операций =, &, и , для объектов
   класса).</p>
<p>Операторная функция, имеющая первым параметр основного типа,
   не может быть функцией-членом. Так, если мы прибавляем комплексную
   переменную aa к целому 2, то при подходящем описании функции-члена
   aa+2 можно интерпретировать как aa.operator+(2), но 2+aa так
   интерпретировать нельзя, поскольку не существует класса int, для
   которого + определяется как 2.operator+(aa). Даже если бы это было
   возможно, для интерпретации aa+2 и 2+aa пришлось иметь дело с двумя
   разными функциями-членами. Этот пример тривиально записывается
   с помощью функций, не являющихся членами.</p>
<p>Каждое выражение проверяется для выявления неоднозначностей.
   Если пользовательские операции задают возможную интерпретацию
   выражения, оно проверяется в соответствии с правилами п.<a href="referenc.shtml#R.13.2">R.13.2</a>.</p>

<a name="#useroper"></a><h4>7.3. Пользовательские операции преобразования типа</h5>
<p>Описанная во введении реализация комплексного числа является слишком
   ограниченной, чтобы удовлетворить кого-нибудь, и ее надо расширить.
   Делается простым повторением описаний того же вида, что уже были
   применены:</p>
<pre>
          class complex {
            double re, im;
          public:
            complex(double r, double i) { re=r; im=i; }

            friend complex operator+(complex, complex);
            friend complex operator+(complex, double);
            friend complex operator+(double, complex);

            friend complex operator-(complex, double);
            friend complex operator-(complex, double);
            friend complex operator-(double, complex);
            complex operator-();  // унарный -

            friend complex operator*(complex, complex);
            friend complex operator*(complex, double);
            friend complex operator*(double, complex);

            // ...
          };
</pre>
<p>Имея такое определение комплексного числа, можно писать:</p>
<pre>
         void f()
         {
           complex a(1,1), b(2,2), c(3,3), d(4,4), e(5,5);
           a = -b-c;
           b = c*2.0*c;
           c = (d+e)*a;
         }
</pre>
<p>Все-таки утомительно, как мы это только что делали для operator*()
    писать для каждой комбинации complex и double свою функцию. Более
    того, разумные средства для комплексной арифметики должны
    предоставлять десятки таких функций (посмотрите, например, как
    описан тип complex в &lt;complex.h>).</p>

<a name="#construct"></a><h5>7.3.1 Конструкторы</h5>
<p>Вместо того, чтобы описывать несколько функций, можно описать
    конструктор, который из параметра double создает complex:</p>
<pre>
           class complex {
              // ...
              complex(double r) { re=r; im=0; }
           };
</pre>
<p>Этим определяется как получить complex, если задан double. Это
    традиционный способ расширения вещественной прямой до комплексной
    плоскости.</p>
<p>Конструктор с единственным параметром не обязательно вызывать
    явно:</p>
<pre>
           complex z1 = complex(23);
           complex z2 = 23;
</pre>
<p>Обе переменные z1 и z2 будут инициализироваться вызовом complex(23).</p>
<p>Конструктор является алгоритмом создания значения заданного типа.
    Если требуется значение некоторого типа и существует строящий его
    конструктор, параметром которого является это значение, то тогда
    этот конструктор и будет использоваться. Так, класс complex можно
    было описать следующим образом:</p>
<pre>
           class complex {
              double re, im;
           public:
              complex(double r, double i =0) {  re=r; im=i; }

              friend complex operator+(complex, complex);
              friend complex operator*(complex, complex);

              complex operator+=(complex);
              complex operator*=(complex);

              // ...
           };
</pre>
<p>Все операции над комплексными переменными и целыми константами
    с учетом этого описания становятся законными. Целая константа
    будет интерпретироваться как комплексное число с мнимой частью,
    равной нулю. Так, a=b*2 означает
           a = operator*(b, complex( double(2), double(0) ) )
    Новые версии операций таких, как + , имеет смысл определять только,
    если практика покажет, что повышение эффективности за счет отказа
    от преобразований типа стоит того. Например, если выяснится, что
    операция умножения комплексной переменной на вещественную
    константу является критичной, то к множеству операций можно
    добавить operator*=(double):</p>
<pre>
          class complex {
            double re, im;
          public:
            complex(double r, double i =0) { re=r; im=i; }

            friend complex operator+(complex, complex);
            friend complex operator*(complex, complex);

            complex& operator+=(complex);
            complex& operator*=(complex);
            complex& operator*=(double);

            // ...
          };
</pre>
<p>Операции присваивания типа *= и += могут быть очень полезными
    для работы с пользовательскими типами, поскольку обычно запись
    с ними короче, чем с их обычными "двойниками" * и + , а кроме того
    они могут повысить скорость выполнения программы за счет
    исключения временных переменных:</p>
<pre>
           inline complex& complex::operator+=(complex a)
           {
              re += a.re;
              im += a.im;
              return *this;
           }
</pre>
<p>При использовании этой функции не требуется временной переменной
    для хранения результата, и она достаточно проста, чтобы транслятор
    мог "идеально" произвести подстановку тела. Такие простые операции
    как сложение комплексных тоже легко задать непосредственно:</p>
<pre>
           inline complex operator+(complex a, complex b)
           {
             return complex(a.re+b.re, a.im+b.im);
           }
</pre>
<p>Здесь в операторе return используется конструктор, что дает транслятору
    ценную подсказку на предмет оптимизации. Но для более сложных
    типов и операций, например таких, как умножение матриц, результат
    нельзя задать как одно выражение, тогда операции * и + проще
    реализовать с помощью *= и += , и они будут легче поддаваться
    оптимизации:</p>
<pre>
           matrix& matrix::operator*=(const matrix& a)
           {
              // ...
              return *this;
           }

           matrix operator*(const matrix& a, const matrix& b)
           {
             matrix prod = a;
             prod *= b;
             return prod;
           }
</pre>
<p>Отметим, что в определенной подобным образом операции не нужных
    никаких особых прав доступа к классу, к которому она применяется,
    т.е. эта операция не должна быть другом или членом этого класса.</p>
<p>Пользовательское преобразование типа применяется только в том
    случае, если оно единственное(п.<a href="#ambiguit">7.3.3</a>).</p>
<p>Построенный в результате явного или неявного вызова конструктора,
    объект является автоматическим, и уничтожается при первой
    возможности,- как правило сразу после выполнения оператора, в
    котором он был создан.</p>

<a name="#transform"></a><h5>7.3.2 Операции преобразования</h5>
<p>Конструктор удобно использовать для преобразования типа, но возможны
    нежелательные последствия:</p>
<ol>
<li>Неявные преобразования от пользовательского типа к основному
          невозможны (поскольку основные типы не являются классами).
<li>Нельзя задать преобразование из нового типа в старый, не
          изменяя описания старого типа.
<li>Нельзя определить конструктор с одним параметром, не определив
          тем самым и преобразование типа.
</ol>
<p>Последнее не является большой проблемой, а первые две можно
    преодолеть, если определить операторную функцию преобразования
    для исходного типа. Функция-член X::operator T(), где T - имя
    типа, определяет преобразование типа X в T. Например, можно
    определить тип tiny (крошечный), значения которого находятся в
    диапазоне 0..63, и этот тип может в арифметических операциях практически
    свободно смешиваться с целыми:</p>
<pre>
            class tiny {
              char v;
              void assign(int i)
              { if (i>63) { error("выход из диапазона"); v=i&~63;  }
                v=i;
              }
            public:
              tiny(int i) { assign(i) }
              tiny(const tiny& t) { v = t.v; }
              tiny& operator=(const tiny& t)
                 { v = t.v; return *this; }
              tiny& operator=(int i) { assign(i); return *this; }
              operator int() { return v; }
            };
</pre>
<p>Попадание в диапазон проверяется как при инициализации объекта
    tiny, так и в присваивании ему int. Один объект tiny можно
    присвоить другому без контроля диапазона. Для выполнения обычных
    операций с целыми для переменных типа tiny определяется функция
    tiny::operator int(), производящая неявное преобразование типа
    из tiny в int. Там, где требуется int, а задана переменная типа
    tiny, используется преобразованное к int значение:</p>
<pre>
         void main()
         {
           tiny c1 = 2;
           tiny c2 = 62;
           tiny c3 = c2 -c1;  // c3 = 60
           tiny c4 = c3;      // контроля диапазона нет (он не нужен)
           int i = c1 + c2;   // i = 64
           c1 = c2 + 2 * c1;  // выход из диапазона: c1 = 0 (а не 66)
           c2 = c1 - i;       // выход из диапазона: c2 = 0
           c3 = c2;           // контроля диапазона нет (он не нужен)
         }

</pre>
<p>Более полезным может оказаться вектор из объектов tiny, поскольку
   он позволяет экономить память. Чтобы такой тип было удобно
   использовать, можно воспользоваться операцией индексации [].</p>
<p>Пользовательские операции преобразования типа могут пригодиться
  для работы с типами, реализующими нестандартные представления чисел
  (арифметика с основанием 100, арифметика чисел с фиксированной точкой,
  представление в двоично-десятичной записи и т.д.). При этом обычно
  приходится переопределять такие операции, как + и *.</p>
<p>Особенно полезными функции преобразования типа оказываются для
 работы с такими структурами данных, для которых чтение (реализованное
 как операция преобразования) является тривиальным, а присваивание и
 инициализация существенно более сложные операции.</p>
<p>Функции преобразования нужны для типов istream и ostream, чтобы
 стали возможными, например, такие операторы:</p>
<pre>
           while (cin>>x) cout&lt;&lt;x;
</pre>
<p>Операция ввода cin>>x возвращает значение istream&. Оно неявно
 преобразуется в значение, показывающее состояние потока cin, которое
 затем проверяется в операторе while (см. 
 п.<a href="chap10.shtml#state">10.3.2</a>). Но все-таки
 определять неявное преобразование типа, при котором можно потерять
 преобразуемое значение, как правило, плохое решение.</p>
<p>Вообще, лучше экономно пользоваться операциями преобразования.
 Избыток таких операций может вызывать большое число неоднозначностей.
 Транслятор обнаруживает эти неоднозначности, но разрешить их может
 быть совсем непросто. Возможно вначале лучше для преобразований
 использовать поименованные функции, например, X::intof(), и только
 после того, как такую функцию как следуют опробуют, и явное
 преобразование типа будет сочтено неэлегантным решением, можно
 заменить операторной функцией преобразования X::operator int().</p>

<a name="#ambiguit"></a><h5>7.3.3 Неоднозначности</h5>
<p>Присваивание или инициализация объекта класса X является законным,
 если присваиваемое значение имеет тип X, или если существует
 единственное преобразование его в значение типа X.</p>
<p>В некоторых случаях значение нужного типа строится с помощью
 повторных применений конструкторов или операций преобразования.
 Это должно задаваться явным образом, допустимо неявное пользовательское
 преобразование только одного уровня вложенности. В некоторых случаях
 существует несколько способов построения значения нужного типа, но
 это является незаконным. Приведем пример:</p>
<pre>
     class x { /* ... */ x(int); x(char*); };
     class y { /* ... */ y(int); };
     class z { /* ... */ z(x); };

     x f(x);
     y f(y);

     z g(z);

     void k1()
     {
       f(1);      // недопустимо, неоднозначность: f(x(1)) или f(y(1))
       f(x(1));
       f(y(1));
       g("asdf"); // недопустимо, g(z(x("asdf"))) не используется
     }
</pre>
<p>Пользовательские преобразования типа рассматриваются только в том
  случае, когда без них нельзя однозначно выбрать вызываемую функцию:</p>
<pre>
          class x { /* ... */ x(int); };

          void h(double);
          void h(x);

          void k2()
          {
            h(1);
          }
</pre>
<p>Вызов h(1) можно интерпретировать либо как h(double(1)), либо как
   h(x(1)), поэтому в силу требования однозначности его можно счесть
   незаконным. Но поскольку в первой интерпретации используется
   только стандартное преобразование, то по правилам, указанным в 
   п.<a href="chap4.shtml#tranship">4.6.6</a>
   и п.<a href="referenc.shtml#R.13.2">R.13.2</a>, выбирается оно.</p>
<p>Правила на преобразования типа не слишком просто сформулировать
   и реализовать, не обладают они и достаточной общностью. Рассмотрим
   требование единственности законного преобразования. Проще всего
   разрешить транслятору применять любое преобразование, которое он
   сумеет найти. Тогда для выяснения корректности выражения не нужно
   рассматривать все существующие преобразования. К сожалению, в таком
   случае поведение программы будет зависеть от того, какое именно
   преобразование найдено. В результате поведение программы будет
   зависеть от порядка описаний преобразований. Поскольку часто эти
   описания разбросаны по разным исходным файлам (созданным, возможно,
   разными программистами), то результат программы будет зависеть
   в каком порядке эти файлы сливаются в программу. С другой стороны,
   можно вообще запретить неявные преобразования, и это самое
   простое решение. Но результатом будет некачественный интерфейс,
   определяемый пользователем, или взрывной рост перегруженных
   функций и операций, что мы и видели на примере класса complex
   из предыдущего раздела.</p>
<p>При самом общем подходе учитываются все сведения
   о типах и рассматриваются все существующие преобразования.
   Например, с учетом приведенных описаний в присваивании aa=f(1)
   можно разобраться с вызовом f(1), поскольку тип aa задает
   единственное преобразование. Если aa имеет тип x, то единственным
   преобразованием будет f(x(1)), поскольку только оно дает нужный
   для левой части тип x. Если aa имеет тип y, будет использоваться
   f(y(1)). При самом общем подходе удается разобраться и с вызовом
   g("asdf"), поскольку g(z(x("asdf))) является его единственной
   интерпретацией. Трудность этого подхода в том, что требуется
   доскональный разбор всего выражения, чтобы установить интерпретацию
   каждой операции и вызова функции. В результате трансляция
   замедляется, вычисление выражения может произойти странным образом
   и появляются загадочные сообщения об ошибках, когда транслятор
   учитывает определенные в библиотеках преобразования и т.д.
   В результате транслятору приходится учитывать больше информации,
   чем известно самому программисту! Выбран подход, при котором
   проверка является строго восходящим процессом, когда в каждый
   момент рассматривается только одна операция с операндами, типы
   которых уже прошли проверку.</p>
<p>Требование строго восходящего разбора выражения предполагает,
   что тип возвращаемого значения не учитывается при разрешении
   перегрузки:</p>
<pre>
            class quad {
               // ...
            public:
               quad(double);
               // ...
            };

            quad operator+(quad,quad);

            void f(double a1, double a2)
            {
              quad r1 = a1+a2;       // сложение с двойной точностью
              quad r2 = quad(a1)+a2; // вынуждает использовать
                                     // операции с типами quad
            }
</pre>
<p>В проектировании языка делался расчет на строго восходящий разбор,
   поскольку он более понятный, а кроме того, не дело транслятора
   решать такие вопросы, какую точность для сложения желает
   программист.</p>
<p>Однако, надо отметить, что если определились типы обеих частей
   в присваивании и инициализации, то для их разрешения используется
   они оба:</p>
<pre>
            class real {
               // ...
            public:
               operator double();
               operator int();
               // ...
            };

            void g(real a)
            {
              double d = a;  // d = a.double();
              int i = a;     // i = a.int();

              d = a;         // d = a.double();
              i = a;         // i = a.int();
            }
</pre>
<p>В этом примере выражения все равно разбираются строго восходящим
   методом, когда в каждый момент рассматриваются только одна операция
   и типы ее операндов.</p>

<a name="#liter"></a><h4>7.4. Литералы</h4>
<p>Для классов нельзя определить литеральные значения, подобному
   тому как 1.2 и 12e3 являются литералами типа double. Однако,
   для интерпретации значений классов могут использоваться вместо
   функций-членов литералы основных типов. Общим средством для
   построения таких значений служат конструкторы с единственным
   параметром. Если конструктор достаточно простой и реализуется
   подстановкой, вполне разумно представлять его вызов как
   литерал. Например, с учетом описания класса complex в <complex.h>
   в выражении zz1*3+zz2*complex(1,2) произойдет два вызова функций,
   а не пять. Две операции * приведут к вызову функции, а операция
   + и вызовы конструктора для построения complex(3) и complex(1,2)
   будут реализованы подстановкой.</p>

<a name="#largeobg"></a><h4>7.5. Большие объекты</h4>
<p>При выполнении любой бинарной операции для типа complex реализующей
   эту операцию функции будут передаваться как параметры копии обоих
   операндов. Дополнительные расходы, вызванные копированием двух
   значений типа double, заметны, хотя по всей видимости допустимы.
   К сожалению представление не всех классов является столь удобно
   компактным. Чтобы избежать избыточного копирования, можно
   определять функции с параметрами типа ссылки:</p>
<pre>
             class matrix {
                double m[4][4];
             public:
                matrix();
                friend matrix operator+(const matrix&, const matrix&);
                friend matrix operator*(const matrix&, const matrix&);
             };
</pre>
<p>Ссылки позволяют без излишнего копирования использовать
   выражения с обычными арифметическими операциями и для больших
   объектов. Указатели для этой цели использовать нельзя, т.к.
   невозможно переопределить интерпретацию операции, если она
   применяется к указателю. Операцию плюс для матриц можно определить
   так:</p>
<pre>
             matrix operator+(const matrix& arg1, const& arg2)
             {
                matrix sum;
                for (int i = 0; i&lt;4; i++)
                    for (int j=0; j&lt;4; j++)
                        sum.m[i] [j] = arg1.m[i][j] + arg2.m[i][j];
                return sum;
             }
</pre>
<p>Здесь в функции operator+() операнды выбираются по ссылке, а
   возвращается само значение объекта. Более эффективным решением
   был бы возврат тоже ссылки:</p>
<pre>
             class matrix {
                // ...
                friend matrix& operator+(const matrix&, const matrix&);
                friend matrix& operator*(const matrix&, const matrix&);
             };
</pre>
<p>Это допустимо, но возникает проблема с выделением памяти. Поскольку
   ссылка на результат операции будет передаваться как ссылка на
   возвращаемое функцией значение, оно не может быть автоматической
   переменной этой функции. Поскольку операция может использоваться
   неоднократно в одном выражении, результат не может быть и
   локальной статической переменной. Как правило, результат будет
   записываться в отведенный в свободной памяти объект. Обычно
   бывает дешевле (по затратам на время выполнения и память данных
   и команд) копировать результирующее значение, чем размещать его
   в свободной памяти и затем в конечном счете освобождать выделенную
   память. К тому же этот способ проще запрограммировать.</p>

<a name="#assign"></a><h4>7.6. Присваивание и инициализация</h4>
<p>Рассмотрим простой строковый класс string:</p>
<pre>
               struct string {
                  char* p;
                  int size;  // размер вектора, на который указывает p

                  string(int size) { p = new char[size=sz]; }
                  ~string() { delete p; }
               };
</pre>
<p>Строка - это структура данных, содержащая указатель на вектор
   символов и размер этого вектора. Вектор создается конструктором и
   удаляется деструктором. Но как мы видели в 
   п.<a href="chap5.shtml#locvar">5.5.1</a> здесь могут
   возникнуть проблемы:</p>
<pre>
               void f()
               {
                 string s1(10);
                 string s2(20)
                 s1 = s2;
               }
</pre>
<p>Здесь будут размещены два символьных вектора, но в результате
    присваивания s1 = s2 указатель на один из них будет уничтожен,
    и заменится копией второго. По выходе из f() будет вызван для s1
    и s2 деструктор, который дважды удалит один и тот же вектор,
    результаты чего по всей видимости будут плачевны. Для решения
    этой проблемы нужно определить соответствующее присваивание
    объектов типа string:</p>
<pre>
               struct string {
                 char* p;
                 int size;   // размер вектора, на который указывает p

                 string(int size) { p = new char[size=sz]; }
                 ~string() { delete p; }
                 string& operator=(const string&);
               };

               string& string::operator=(const string& a)
               {
                 if (this !=&a) {   // опасно, когда s=s
                    delete p;
                    p = new char[size=a.size];
                    strcpy(p,a.p);
                 }
                 return *this;
               }
</pre>
<p>При таком определении string предыдущий пример пройдет как
   задумано. Но после небольшого изменения в f() проблема возникает
   снова, но в ином обличии:</p>
<pre>
               void f()
               {
                 string s1(10);
                 string s2 = s1;  // инициализация, а не присваивание
               }
</pre>
<p>Теперь только один объект типа string строится конструктором
   string::string(int), а уничтожаться будет две строки. Дело в
   том, что пользовательская операция присваивания не применяется
   к неинициализированному объекту. Достаточно взглянуть на функцию
   string::operator(), чтобы понять причину этого: указатель p
   будет тогда иметь неопределенное, по сути случайное значение.
   Как правило, в операции присваивания предполагается, что ее
   параметры проинициализированы. Для инициализации типа той, что
   приведена в этом примере это не так по определению. Следовательно,
   чтобы справиться с инициализацией нужна похожая, но своя функция:</p>
<pre>
               struct string {
                 char* p;
                 int size;   // размер вектора, на который указывает p

                 string(int size) { p = new char[size=sz]; }
                 ~string() { delete p; }
                 string& operator=(const string&);
                 string(const string&);
               };

               string::string(const string& a)
               {
                    p=new char[size=sz];
                    strcpy(p,a.p);
               }

</pre>
<p>Инициализация объекта типа X происходит с помощью конструктора
   X(const X&). Мы не перестаем повторять, что присваивание и
   инициализация являются разными операциями. Особенно это важно в тех
   случаях, когда определен деструктор. Если в классе X есть нетривиальный
   деструктор, например, производящий освобождение объекта в свободной
   памяти, вероятнее всего, в этом классе потребуется полный набор
   функций, чтобы избежать копирования объектов по членам:</p>
<pre>
               class X {
                  // ...
                  X(something);        // конструктор, создающий объект
                  X(const X&);         // конструктор копирования
                  operator=(const X&); // присваивание:
                                       // удаление и копирование
                  ~X();                // деструктор, удаляющий объект
               };
</pre>
<p>Есть еще два случая, когда приходится копировать объект:
   передача параметра функции и возврат ею значения. При передаче
   параметра неинициализированная переменная, т.е. формальный параметр
   инициализируется. Семантика этой операции идентична другим видам
   инициализации. Тоже происходит и при возврате функцией значения,
   хотя этот случай не такой очевидный. В обоих случаях используется
   конструктор копирования:</p>
<pre>
              string g(string arg)
              {
                return arg;
              }

              main()
              {
                string s = "asdf";
                s = g(s);
              }
</pre>
<p>Очевидно, после вызова g() значение s должно быть "asdf". Не трудно
   записать в параметр s копию значения s, для этого надо вызвать
   конструктор копирования для string. Для получения еще одной копии
   значения s по выходе из g() нужен еще один вызов конструктора
   string(const string&). На этот раз инициализируется временная
   переменная, которая затем присваивается s. Для оптимизации одну,
   но не обе, из подобных операций копирования можно убрать. Естественно,
   временные переменные, используемые для таких целей, уничтожаются
   надлежащим образом деструктором string::~string() (см. п.<a href="referenc.shtml#R.12.2">R.12.2</a>).</p>
<p>Если в классе X операция присваивания X::operator=(const X&)
   и конструктор копирования X::X(const X&) явно не заданы программистом,
   недостающие операции будут созданы транслятором. Эти созданные
   функции будут копировать по членам для всех членов класса X. Если
   члены принимают простые значения, как в случае комплексных чисел,
   это, то, что нужно, и созданные функции превратятся в простое и
   оптимальное поразрядное копирование. Если для самих членов
   определены пользовательские операции копирования, они и будут
   вызываться соответствующим образом:</p>
<pre>
             class Record {
               string name, address, profession;
               // ...
             };

             void f(Record& r1)
             {
               Record r2 = r1;
             }
</pre>
<p>Здесь для копирования каждого члена типа string из объекта r1
    будет вызываться string::operator=(const string&). В нашем первом
    и неполноценном варианте строковый класс имеет член-указатель
    и деструктор. Поэтому стандартное копирование по членам для
    него почти наверняка неверно. Транслятор может предупреждать
    о таких ситуациях.</p>

<a name="#index"></a><h4>7.7. Индексация</h4>
<p>Операторная функция operator[] задает для объектов классов
   интерпретацию индексации. Второй параметр этой функций (индекс) может
   иметь произвольный тип. Это позволяет, например, определять
   ассоциативные массивы. В качестве примера можно переписать
   определение из п.<a href="chap2.shtml#ref">2.3.10</a>, где ассоциативный массив использовался
   в небольшой программе, подсчитывающей число вхождений слов в файле.
   Там для этого использовалась функция. Мы определим настоящий тип
   ассоциативного массива:</p>
<pre>
       class assoc {
         struct pair {
             char* name;
             int val;
          };

          pair* vec;
          int max;
          int free;

          assoc(const assoc&);            // предотвращает копирование
          assoc& operator=(const assoc&); // предотвращает копирование
       public:
          assoc(int);
          int& operator[](const char*);
          void print_all();
        };
</pre>
<p>В объекте assoc хранится вектор из структур pair размером max.
   В переменной free хранится индекс первого свободного элемента
   вектора.</p>
<p>Чтобы предотвратить копирование объектов assoc, конструктор
   копирования и операция присваивания описаны как частные. Конструктор
   выглядит так:</p>
<pre>
              assoc::assoc(int s)
              {
                max = (s&lt;16) ? 16 : s;
                free = 0;
                vec = new pair[max];
              }
</pre>
<p>В реализации используется все тот же неэффективный алгоритм поиска,
   что и в п.<a href="chap2.shtml#ref">2.3.10</a>. Но теперь, если вектор переполняется, объект
   assoc увеличивается:</p>
<pre>
              #include <string.h>

              int& assoc::operator[](const char* p)
              /*
                работает с множеством пар (структур pair):
                проводит поиск p, возвращает ссылку на
                целое значение из найденной пары,
                создает новую пару, если p не найдено
              */
              {
                register pair* pp;

                for (pp=&vec[free-1]; vec<=pp; pp-- )
                    if (strcmp(p,pp->name) == 0) return pp->val;
                if (free == max) { //переполнение: вектор увеличивается
                   pair* nvec = new pair[max*2];
                   for (int i=0; i<max; i++) nvec[i] = vec[i];
                   delete vec;
                   vec = nvec;
                   max = 2*max;
                }

                pp = &vec[free++];
                pp->name = new char[strlen(p)+1];
                strcpy(pp->name,p);
                pp->val = 0;    // начальное значение = 0
                return pp->val;
              }
</pre>
<p>Поскольку представление объекта assoc скрыто от пользователя, нужно
   иметь возможность напечатать его каким-то образом. В следующем разделе
   будет показано как определить настоящий итератор для такого объекта.
   Здесь же мы ограничимся простой функцией печати:</p>
<pre>
              void assoc::print_all()
              {
                for (int i = 0; i&lt;free; i++)
                    cout << vec[i].name << ": " << vec[i].val << '\n';
              }
</pre>
<p>Наконец, можно написать тривиальную программу:</p>
<pre>
              main() // подсчет числа вхождений во входной
                     // поток каждого слова
              {
                const MAX = 256;  // больше длины самого длинного слова
                char buf[MAX];
                assoc vec(512);
                while (cin>>buf) vec[buf]++;
                vec.print_all();
              }
</pre>
<p>Опытные программисты могут заметить, что второй комментарий можно
   легко опровергнуть. Решить возникающую здесь проблему предлагается
   в упражнении п.<a href="#7.14.20">7.14 [20]</a>. Дальнейшее развитие понятие ассоциативного
   массива получит в п.<a href="chap8.shtml#associad">8.8</a>.</p>
<p>Функция operator[]() должна быть членом класса. Отсюда следует,
   что эквивалентность x[y] == y[x] может не выполняться, если
   x объект класса. Обычные отношения эквивалентности, справедливые
   для операций со встроенными типами, могут не выполняться для
   пользовательских типов (п.<a href="#predeterm">7.2.2</a>, см. также 
   п.<a href="#indirect">7.9</a>).</p>

<a name="#call"></a><h4>7.8. Вызов функции</h4>
<p>Вызов функции, т.е. конструкцию выражение(список-выражений), можно
   рассматривать как бинарную операцию, в которой выражение является
   левым операндом, а список-выражений - правым. Операцию вызова
   можно перегружать как и другие операции. В функции operator()()
   список фактических параметров вычисляется и проверяется по типам
   согласно обычным правилам передачи параметров. Перегрузка операции
   вызова имеет смысл прежде всего для типов, с которыми возможна
   только одна операция, а также для тех типов, одна из операций над
   которыми имеет настолько важное значение, что все остальные в
   большинстве случаев можно не учитывать.</p>
<p>Мы не дали определения итератора для ассоциативного массива
   типа assoc. Для этой цели можно определить специальный класс
   assoc_iterator, задача которого выдавать элементы из assoc в некотором
   порядке. В итераторе необходимо иметь доступ к данным, хранимым
   в assoc, поэтому он должен быть описан как friend:</p>
<pre>
              class assoc {
              friend class assoc_iterator;
                  pair* vec;
                  int max;
                  int free;
              public:
                  assoc(int);
                  int& operator[](const char*);
              };
</pre>
<p>Итератор можно определить так:</p>
<pre>
              class assoc_iterator {
                 const assoc* cs;   // массив assoc
                 int i;             // текущий индекс
              public:
                 assoc_iterator(const assoc& s) { cs = &s; i = 0; }
                 pair* operator()()
                   { return (i<cs->free)? &cs->vec[i++] : 0; }
              };
</pre>
<p>Массив assoc объекта assoc_iterator нужно инициализировать, и при каждом
  обращении к нему с помощью операторной функции () будет возвращаться
  указатель на новую пару (структура pair) из этого массива. При достижении
  конца массива возвращается 0:</p>
<pre>
              main()  // подсчет числа вхождений во входной
                      // поток каждого слова
              {
                const MAX = 256;  // больше длины самого длинного слова
                char buf[MAX];
                assoc vec(512);
                while (cin>>buf) vec[buf]++;
                assoc_iterator next(vec);
                pair* p;
                while ( p = next(vec) )
                    cout << p->name << ": " << p->val << '\n';
              }
</pre>
<p>Итератор подобного вида имеет преимущество перед набором
  функций, решающим ту же задачу: итератор может иметь собственные
  частные данные, в которых можно хранить информацию о ходе итерации.
  Обычно важно и то, что можно одновременно запустить сразу несколько
  итераторов одного типа.</p>
<p>Конечно, использование объектов для представления итераторов
  непосредственно никак не связано с перегрузкой операций. Одни
  предпочитают использовать тип итератора с такими операциями, как
  first(), next() и last(), другим больше нравится перегрузка операции
  ++ , которая позволяет получить итератор, используемый как указатель
  (см. п.<a href="chap8.shtml#associad">8.8</a>). Кроме того, операторная функция operator() активно
  используется для выделения подстрок и индексации многомерных массивов.</p>
<p>Функция operator() должна быть функцией-членом.</p>

<a name="#indirect"></a><h4>7.9. Косвенное обращение</h4>
<p>Операцию косвенного обращения к члену -> можно определить как унарную
  постфиксную операцию. Это значит, если есть класс</p>
<pre>
             class Ptr {
               // ...
               X* operator->();
             };
</pre>
<p>объекты класса Ptr могут использоваться для доступа к членам класса
  X также, как для этой цели используются указатели:</p>
<pre>
            void f(Ptr p)
            {
              p->m = 7;  // (p.operator->())->m = 7
            }
</pre>
<p>Превращение объекта p в указатель p.operator->() никак не зависит от
  члена m, на который он указывает. Именно по этой причине operator->()
  является унарной постфиксной операцией. Однако, мы не вводим новых
  синтаксических обозначений, так что имя члена по-прежнему должно
  идти после -> :</p>
<pre>
             void g(Ptr p)
             {
                X* q1 = p->;  // синтаксическая ошибка
                X* q2 = p.operator->(); // нормально
             }
</pre>
<p>Перегрузка операции -> прежде всего используется для создания
  "хитрых указателей", т.е. объектов, которые помимо использования как
  указатели позволяют проводить некоторые операции при каждом обращении
  к указуемому объекту с их помощью. Например, можно определить класс
  RecPtr для организации доступа к объектам класса Rec, хранимым на
  диске. Параметром конструктора RecPtr является имя, которое будет
  использоваться для поиска объекта на диске. При обращении к объекту
  с помощью функции RecPtr::operator->() он переписывается в основную
  память, а в конце работы деструктор RecPtr записывает измененный
  объект обратно на диск.</p>
<pre>
              class RecPtr {
                 Rec* in_core_address;
                 const char* identifier;
                 // ...
              public:
                 RecPtr(const char* p)
                 : identifier(p) { in_core_address = 0; }
                 ~RecPtr()
                    { write_to_disc(in_core_address,identifier); }
                 Rec* operator->();
              };

              Rec* RecPtr::operator->()
              {
                if (in_core_address == 0)
                    in_core_address = read_from_disc(identifier);
                return in_core_address;
              }
</pre>
<p>Использовать это можно так:</p>
<pre>
              main(int argc, const char* argv)
              {
                for (int i = argc; i; i--) {
                    RecPtr p(argv[i]);
                    p->update();
                }
              }
</pre>
<p>На самом деле, тип RecPtr должен определяться как шаблон типа
  (см. п.<a href="chap8.shtml">8</a>), а тип структуры Record будет его параметром. Кроме
  того, настоящая программа будет содержать обработку ошибок и
  взаимодействие с диском будет организовано не столь примитивно.</p>
<p>Для обычных указателей операция -> эквивалентна операциям,
  использующим * и []. Так, если описано</p>
<pre>
              Y* p;
</pre>
<p>то выполняется соотношение</p>
<pre>
              p->m == (*p).m == p[0].m
</pre>
<p>Как всегда, для определенных пользователем операций такие соотношения
  не гарантируются. Там, где все-таки такая эквивалентность требуется,
  ее можно обеспечить:</p>
<pre>
              class X {
                Y* p;
              public:
                Y* operator->() { return p; }
                Y& operator*() { return *p; }
                Y& operator[](int i) { return p[i]; }
              };
</pre>
<p>Если в вашем классе определено более одной подобной операции,
  разумно будет обеспечить эквивалентность, точно так же, как разумно
  предусмотреть для простой переменной x некоторого класса, в котором
  есть операции ++, += = и +, чтобы операции ++x и x+=1 были
  эквивалентны x=x+1.</p>
<p>Перегрузка -> как и перегрузка [] может играть важную роль для
  целого класса настоящих программ, а не является просто экспериментом
  ради любопытства. Дело в том, что в программировании понятие
  косвенности является ключевым, а перегрузка -> дает ясный, прямой
  и эффективный способ представления этого понятия в программе.
  Есть другая точка зрения на операцию ->, как на средство задать
  в С++ ограниченный, но полезный вариант понятия делегирования
  (см. п.<a href="chap12.shtml#progrel">12.2.8</a> и 
  <a href="chap13.shtml#manager">13.9</a>).</p>

<a name="#increm"></a><h4>7.10. Инкремент и декремент</h4>
<p>Если мы додумались до "хитрых указателей", то логично попробовать
  переопределить операции инкремента ++ и декремента -- , чтобы
  получить для классов те возможности, которые эти операции дают для
  встроенных типов. Такая задача особенно естественна и необходима, если
  ставится цель заменить тип обычных указателей на тип "хитрых указателей",
  для которого семантика остается прежней, но появляются некоторые
  действия динамического контроля. Пусть есть программа с распространенной
  ошибкой:</p>
<pre>
             void f1(T a)   // традиционное использование
             {
               T v[200];
               T* p = &v[10];
               p--;
               *p = a;   // Приехали: `p' настроен вне массива,
                         // и это не обнаружено
               ++p;
               *p = a;   // нормально
             }
</pre>
<p>Естественно желание заменить указатель p на объект класса
  CheckedPtrToT, по которому косвенное обращение возможно только
  при условии, что он действительно указывает на объект. Применять
  инкремент и декремент к такому указателю будет можно только в том
  случае, что указатель настроен на объект в границах массива и
  в результате этих операций получится объект в границах того же
  массива:</p>
<pre>
             class CheckedPtrToT {
                // ...
             };

             void f2(T a)  // вариант с контролем
             {
               T v[200];
               CheckedPtrToT p(&v[0],v,200);
               p--;
               *p = a;  // динамическая ошибка:
                        // `p' вышел за границы массива
               ++p;
               *p = a;  // нормально
             }
</pre>
<p>Инкремент и декремент являются единственными операциями в С++,
  которые можно использовать как постфиксные и префиксные операции.
  Следовательно, в определении класса CheckedPtrToT мы должны
  предусмотреть отдельные функции для префиксных и постфиксных операций
  инкремента и декремента:</p>
<pre>
             class CheckedPtrToT {
               T* p;
               T* array;
               int size;
             public:
                    // начальное значение `p'
                    // связываем с массивом `a' размера `s'
                 CheckedPtrToT(T* p, T* a, int s);
                    // начальное значение `p'
                    // связываем с одиночным объектом
                 CheckedPtrToT(T* p);

                 T* operator++();     // префиксная
                 T* operator++(int);  // постфиксная

                 T* operator--();     // префиксная
                 T* operator--(int);  // постфиксная

                 T& operator*();      // префиксная
              };
</pre>
<p>Параметр типа int служит указанием, что функция будет вызываться
  для постфиксной операции. На самом деле этот параметр является
  искусственным и никогда не используется, а служит только для различия
  постфиксной и префиксной операции. Чтобы запомнить, какая версия
  функции operator++ используется как префиксная операция, достаточно
  помнить, что префиксной является версия без искусственного параметра,
  что верно и для всех других унарных арифметических и логических
  операций. Искусственный параметр используется только для "особых"
  постфиксных операций ++ и --.</p>
<p>С помощью класса CheckedPtrToT пример можно записать так:</p>
<pre>
               void f3(T a)  // вариант с контролем
               {
                 T v[200];
                 CheckedPtrToT p(&v[0],v,200);
                 p.operator--(1);
                 p.operator*() = a; // динамическая ошибка:
                                    // `p' вышел за границы массива
                 p.operator++();
                 p.operator*() = a; // нормально
               }
</pre>
<p>В упражнении п.<a href="#7.14.19">7.14 [19]</a> предлагается завершить определение класса
  CheckedPtrToT, а другим упражнением (
  п.9.10[2]) является
  преобразование его в шаблон типа, в котором для сообщений о
  динамических ошибках используются особые ситуации. Примеры использования
  операций ++ и -- для итераций можно найти в п.<a href="chap8.shtml#associad">8.8</a>.</p>

<a name="#strclass"></a><h4>7.11. Строковый класс</h4>
<p>Теперь можно привести более осмысленный вариант класса string.
   В нем подсчитывается число ссылок на строку, чтобы минимизировать
   копирование, и используются как константы стандартные строки C++.</p>
<pre>
              #include <iostream.h>
              #include <string.h>

              class string {
                 struct srep {
                   char* s;       // указатель на строку
                   int n;         // счетчик числа ссылок
                   srep() { n = 1; }
                 };
                 srep *p;

              public:
                string(const char *);   // string x = "abc"
                string();               // string x;
                string(const string &); // string x = string ...
                string& operator=(const char *);
                string& operator=(const string &);
                ~string();
                char& operator[](int i);

                friend ostream& operator<<(ostream&, const string&);
                friend istream& operator>>(istream&, string&);

                friend int operator==(const string &x, const char *s)
                  { return strcmp(x.p->s,s) == 0; }

                friend int operator==(const string &x, const string &y)
                  { return strcmp(x.p->s,y.p->s) == 0; }

                friend int operator!=(const string &x, const char *s)
                  { return strcmp(x.p->s,s) != 0; }

                friend int operator!=(const string &x, const string &y)
                  { return strcmp(x.p->s,y.p->s) != 0; }
             };
</pre>
<p>Конструкторы и деструкторы тривиальны:</p>
<pre>
             string::string()
             {
               p = new srep;
               p->s = 0;
             }

             string::string(const string& x)
             {
               x.p->n++;
               p = x.p;
             }

             string::string(const char* s)
             {
               p = new srep;
               p->s = new char[ strlen(s)+1 ];
               strcpy(p->s, s);
             }

             string::~string()
             {
               if (--p->n == 0) {
                  delete[]  p->s;
                  delete p;
               }
             }
</pre>
<p>Как и всегда операции присваивания похожи на конструкторы. В них
   нужно позаботиться об удалении первого операнда, задающего левую
   часть присваивания:</p>
<pre>
            string& string::operator=(const char* s)
            {
              if (p->n > 1) {  // отсоединяемся от старой строки
                  p->n--;
                  p = new srep;
              }
              else    // освобождаем строку со старым значением
                  delete[] p->s;

              p->s = new char[ strlen(s)+1 ];
              strcpy(p->s, s);
              return *this;
            }

            string& string::operator=(const string& x)
            {
              x.p->n++;  // защита от случая ``st = st''
              if (--p->n == 0) {
                 delete[] p->s;
                 delete p
              }
              p = x.p;
              return *this;
            }
</pre>
<p>Операция вывода показывает как используется счетчик числа ссылок.
   Она сопровождает как эхо каждую введенную строку (ввод происходит
   с помощью операции << , приведенной ниже):</p>
<pre>
            ostream& operator<<(ostream& s, const string& x)
            {
               return s << x.p->s << " [" << x.p->n << "]\n";
            }
</pre>
<p>Операция ввода происходит с помощью стандартной функции ввода
   символьной строки (п.<a href="chap10.shtml#inbuild">10.3.1</a>):</p>
<pre>
            istream& operator>>(istream& s, string& x)
            {
               char buf[256];
               s >> buf;   // ненадежно: возможно переполнение buf
                           // правильное решение см. в п.<a href="chap10.shtml#inbuild">10.3.1</a>
               x = buf;
               cout << "echo: " << x << '\n';
               return s;
             }
</pre>
<p>Операция индексации нужна для доступа к отдельным символам.</p>
<p>Индекс контролируется:</p>
<pre>
            void error(const char* p)
            {
              cerr << p << '\n';
              exit(1);
            }

           char& string::operator[](int i)
          {
           if (i<0 || strlen(p->s)<i) error("недопустимое значение индекса");
             return p->s[i];
          }
</pre>
<p>В основной программе просто даны несколько примеров применения
   строковых операций. Слова из входного потока читаются в строки,
   а затем строки печатаются. Это продолжается до тех пор, пока не
   будет обнаружена строка done, или закончатся строки для записи
   слов, или закончится входной поток. Затем печатаются все строки
   в обратном порядке и программа завершается.</p>
<pre>
           int main()
           {
             string x[100];
             int n;

             cout << " здесь начало \n";

             for ( n = 0; cin>>x[n]; n++) {
                 if (n==100) {
                    error("слишком много слов");
                    return 99;
                 }
                 string y;
                 cout << (y = x[n]);
                 if (y == "done") break;

             }
             cout << "теперь мы идем по словам в обратном порядке \n";
             for (int i=n-1; 0<=i; i--) cout << x[i];
             return 0;
           }

</pre>
<a name="#friend"></a><h4>7.12. Друзья и члены</h4>
<p>В заключении можно обсудить, когда при обращении в закрытую часть
   пользовательского типа стоит использовать функции-члены, а когда
   функции-друзья. Некоторые функции, например конструкторы, деструкторы
   и виртуальные функции (п.<a href="referenc.shtml#R.12">R.12</a>), обязаны быть членами, но для других
   есть возможность выбора. Поскольку, описывая функцию как член, мы
   не вводим нового глобального имени, при отсутствии других доводов
   следует использовать функции-члены.</p>
<p>Рассмотрим простой класс X:</p>
<pre>
            class X {
               // ...

              X(int);

              int m1();
              int m2() const;

              friend int f1(X&);
              friend int f2(const X&);
              friend int f3(X);
           };
</pre>
<p>Вначале укажем, что члены X::m1() и X::m2() можно вызывать только
   для объектов класса X. Преобразование X(int) не будет применяться
   к объекту, для которого вызваны X::m1() или X::m2():</p>
<pre>
            void g()
            {
               1.m1();  // ошибка: X(1).m1() не используется
               1.m2();  // ошибка: X(1).m2() не используется
            }
</pre>
<p>Глобальная функция f1() имеет то же свойство (
   п.<a href="chap4.shtml#param">4.6.3</a>), поскольку
   ее параметр - ссылка без спецификации const. С функциями f2() и
   f3() ситуация иная:</p>
<pre>
            void h()
            {
              f1(1);  // ошибка: f1(X(1)) не используется
              f2(1);  // нормально: f2(X(1));
              f3(1);  // нормально: f3(X(1));
            }
</pre>
<p>Следовательно операция, изменяющая состояние объекта класса,
   должна быть членом или глобальной функцией с параметром-ссылкой
   без спецификации const. Операции над основными типами, которые
   требуют в качестве операндов адреса (=, *, ++ и т.д.),
   для пользовательских типов естественно определять как члены.</p>
<p>Обратно, если требуется неявное преобразование типа для всех
   операндов некоторой операции, то реализующая ее функция должна
   быть не членом, а глобальной функцией и иметь параметр типа ссылки
   со спецификацией const или нессылочный параметр. Так обычно обстоит
   дело с функциями, реализующими операции, которые для основных
   типов не требуют адресов в качестве операндов (+, -, || и т.д.).</p>
<p>Если операции преобразования типа не определены, то нет
   неопровержимых доводов в пользу функции-члена перед функцией-другом
   с параметром-ссылкой и наоборот. Бывает, что программисту просто
   одна форма записи вызова нравится больше, чем другая.
   Например, многим для обозначения функции обращения матрицы m больше
   нравится запись inv(m), чем m.inv(). Конечно, если функция
   inv() обращает саму матрицу m, а не возвращает новую, обратную m,
   матрицу, то inv() должна быть членом.</p>
<p>При всех прочих равных условиях лучше все-таки остановиться
   на функции-члене. Можно привести такие доводы. Нельзя гарантировать,
   что когда-нибудь не будет определена операция обращения. Нельзя во
   всех случаях гарантировать, что будущие изменения не повлекут за
   собой изменения в состоянии объекта. Запись вызова функции-члена
   ясно показывает программисту, что объект может быть изменен, тогда
   как запись с параметром-ссылкой далеко не столь очевидна. Далее,
   выражения допустимые в функции-члене могут быть существенно
   короче эквивалентных выражений в глобальной функции. Глобальная
   функция должна использовать явно заданные параметры, а в
   функции-члене можно неявно использовать указатель this. Наконец,
   поскольку имена членов не являются глобальными именами, они обычно
   оказываются короче, чем имен глобальных функций.</p>

<a name="#cauting"></a><h4>7.13. Предостережения</h4>
<p>Как и всякое другое языковое средство, перегрузка операций может
   использоваться разумно и неразумно. В частности, возможностью
   придавать новый смысл обычным операциям можно воспользоваться
   так, что программа будет совершенно непостижимой. Представьте,
   каково будет читателю, если в своей программе вы переопределили
   операцию + так, чтобы она обозначала вычитание. Описанный здесь
   механизм перегрузки будет защищать программиста и пользователя от
   таких безрассудств. Поэтому программист не может изменить ни
   смысл операций над основными типами данных, такими, как int, ни
   синтаксис выражений и приоритеты операций для них.</p>
<p>По всей видимости перегрузку операций имеет смысл использовать
   для подражания традиционному использованию операций. Запись с обычным
   вызовом функции можно использовать в тех случаях, когда традиционной
   записи с базовой операцией не существует, или, когда набор операций,
   которые допускают перегрузку, не достаточен, чтобы записать с его
   помощью нужные действия.</p>

<a name="#exercise"></a><h4>7.14. Упражнения</h4>
<ol>
<li>(*2) Определите итератор для класса string. Определите операцию
      конкатенации + и операцию += , значащую "добавить в конец строки".
      Какие еще операции вы хотели бы и смогли определить для этого
      класса?
<li>(*1.5) Определите для строкового класса операцию выделения подстроки
      с помощью перегрузки ().
<li>(*3) Определите класс string таким образом, чтобы операцию
      выделения подстроки можно было применять к левой части
      присваивания. Вначале напишите вариант, в котором строку можно
      присваивать подстроке той же длины, а затем вариант с различными
      длинами строк.
<li>(*2) Разработайте класс string таким образом, чтобы объекты
      его трактовались при передаче параметров и присваивании как
      значения, т.е. чтобы в классе string копировались сами представления
      строк, а не только управляющие структуры.
<li>(*3) Измените класс string из предыдущего упражнения так, чтобы
      строки копировались только при необходимости. Это значит, что
      нужно хранить одно общее представления двух одинаковых строк до
      тех пор, пока одна из них не изменится. Не пытайтесь задать операцию
      выделения подстроки, которую одновременно можно применять и к
      левой части присваивания.
<li>(*4) Определите класс string, обладающий перечисленными в
      предыдущих упражнениях свойствами: объекты его трактуются как
      значения, копирование является отложенным (т.е. происходит только
      при необходимости) и операцию выделения подстроки можно применять
      к левой части присваивания.
<li>(*2) Какие преобразования типа используются в выражениях следующей
      программы?
<pre>
             struct X {
               int i;
               X(int);
               operator+(int);
             };

             struct Y {
               int i;
               Y(X);
               operator+(X);
               operator int();
             };

             extern X operator*(X,Y);
             extern int f(X);

             X x = 1;
             Y y = x;
             int i = 2;

             int main()
             {
               i + 10;     y + 10;    y + 10 * y;
               x + y + i;  x * X +i;  f(7);
               f(y);       y + y;     106 + y;
             }
</pre>
      Определите X и Y как целые типы. Измените программу так, чтобы
      ее можно было выполнить и она напечатала значения всех
      правильных выражений.
<li>(*2) Определите класс INT, который будет эквивалентен типу int.
      Подсказка: определите функцию INT::operator int().
<li>(*1) Определите класс RINT, который будет эквивалентен типу int,
      за исключением того, что допустимыми будут только операции:
      + (унарный и бинарный), - (унарный и бинарный), *, / и %.
      Подсказка: не надо определять RINT::operator int().
<li>(*3) Определите класс LINT, эквивалентный классу RINT, но в
      нем для представления целого должно использоваться не менее 64
      разрядов.
<li>(*4) Определите класс, реализующий арифметику с произвольной
      точностью. Подсказка: Придется использовать память так, как
      это делается в классе string.
<li>(*2) Напишите программу, в которой благодаря макрокомандам и
      перегрузке будет невозможно разобраться. Совет: определите для
      типа INT + как -, и наоборот; с помощью макроопределения задайте
      int как INT. Кроме того, большую путаницу можно создать,
      переопределяя широко известные функции, и используя параметры
      типа ссылки и задавая вводящие в заблуждение комментарии.
<li>(*3) Обменяйтесь решениями упражнения [12] с вашим другом.
      Попробуйте понять, что делает его программа, не запуская ее. Если
      вы сделаете это упражнение, вам станет ясно, чего надо избегать.
<li>(*2) Перепишите примеры с классами complex (
      п.<a href="#useroper">7.3</a>), tiny
      (п.<a href="#transform">7.3.2</a>) и string (п.<a href="#strclass">7.11</a>), не используя дружественные функции.
      Используйте только функции-члены. Проверьте новые версии этих
      классов. Сравните их с версиями, в которых используются
      дружественные функции. Обратитесь к упражнению 5.3.
<li>(*2) Определите тип vec4 как вектор из четырех чисел с плавающей
      точкой. Определите для него функцию operator[]. Для комбинаций
      векторов и чисел с плавающей точкой определите операции:
      +, -, *, /, =, +=, -=, *= и /=.
<li>(*3) Определите класс mat4 как вектор из четырех элементов типа
      vec4. Определите для него функцию operator[], возвращающую vec4.
      Определите для этого типа обычные операции с матрицами. Определите
      в mat4 функцию, производящую преобразование Гаусса с матрицей.
<li>(*2) Определите класс vector, аналогичный классу vec4, но здесь
      размер вектора должен задаваться как параметр конструктора
      vector::vector(int).
<li>(*3) Определите класс matrix, аналогичный классу mat4, но здесь
      размерности матрицы должны задаваться как параметры конструктора
      matrix::matrix(int,int).
<li><a name="7.14.19"></a>(*3) Завершите определение класса CheckedPtrToT из п.<a href="#increm">7.10</a> и
      проверьте его. Чтобы определение этого класса было полным,
      необходимо определить, по крайней мере, такие операции: *, ->,
      =, ++ и --. Не выдавайте динамическую ошибку, пока действительно
      не произойдет обращение по указателю с неопределенным значением.
<li><a name="7.14.20"></a>(*1.5) Перепишите пример с программой подсчета слов из п.<a href="#index">7.7</a>
      так, чтобы в ней не было заранее заданной максимальной длины
      слова.
</ol>


<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap8.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>