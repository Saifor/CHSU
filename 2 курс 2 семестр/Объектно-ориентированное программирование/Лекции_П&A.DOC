

             Государственный комитет Российской Федерации по
                       высшему образованию
   ─────────────────────────────────────────────────────────────
      Череповецкий государственный индустриальный институт
             Кафедра информатики и программирования








                   ЕРШОВ ЕВГЕНИЙ ВАЛЕНТИНОВИЧ





                  Конспект лекций по дисциплине

           "ПРОГРАММИРОВАНИЕ И ОСНОВЫ АЛГОРИТМИЗАЦИИ"













                         Череповец, 1995

.
                              - 2 -


















     Конспект лекций по дисциплине "ПРОГРАММИРОВАНИЕ И ОСНОВЫ АЛ-
ГОРИТМИЗАЦИИ" составлен в соответствии с Государственным  образо-
вательным  стандартом  по направлению 5502 - "Автоматизация и уп-
равление".


















.
                              - 3 -


                           СОДЕРЖАНИЕ

  Введение
     В.1. Предмет курса и его связь со смежными дисциплинами
     В.2. Принципы программирования
     В.3. Общие сведения о языке Си
     В.4. Основные элементы программирования
  1. Директивы препроцессора, комментарии, идентификаторы
     1.1. Препроцессор, компилятор и загрузчик
     1.2. Комментарии
     1.3. Директива include
     1.4. Директива define
     1.5. Идентификаторы
  2. Средства ввода- вывода информации
     2.1. Вывод информации
          2.1.1. Функция printf
          2.1.2. Функции puts и putchar для вывода
     2.2. Ввод информации
          2.2.1. Функция scanf
          2.2.2. Функции gets и getch для ввода
          2.2.3. Ошибки при передаче по адресу
  3. Основы типизации данных
     3.1. Понятие типа данных, абстракция данных
     3.2. Обобщенные характеристики данных:  класс памяти,  меха-
          низмы хранения и доступа
          3.2.1. Автоматические переменные
          3.2.2. Регистровые переменные
          3.2.3. Внешние переменные и функции
          3.2.4. Статические переменные и функции
          3.2.5. Переменные класса volatile
          3.2.6. Правила видимости
     3.3. Основные типы данных
     3.4. Описание простейших типов
          3.4.1. Вещественные
          3.4.2. Три типа целых
          3.4.3. Беззнаковые
          3.4.4. Символьные
          3.4.5. Типы со знаком

                              - 4 -

     3.5. Тип enum-перечислимый
     3.6. Тип void
     3.7. Расширенные описания - использование директивы typedef
     3.8. Иерархия типов, совместимость и преобразование типов в Си
          3.8.1. Преобразование типов char, int и enum
          3.8.2. Преобразование указателей
          3.8.3. Арифметические преобразования
  4. Операции и управляющие конструкции
     4.1. Пространство операций над простейшими типами
          4.1.1. Операция присваивания
          4.1.2. Арифметические операции
          4.1.3. Операции приращения (++) и уменьшения (--)
          4.1.4. Побитовые операции
          4.1.5. Комбинированные операции
          4.1.6. Адресные операции
          4.1.7. Операции сравнения
          4.1.8. Логические операции
          4.1.9. Операция следования (запятая)
          4.1.10.Приоритет и порядок выполнения операций
     4.2. Операторы присваивания
     4.3. Операторы условного перехода
          4.3.1. Оператор if-else
          4.3.2. Условный оператор (?:)
     4.4. Оператор выбора (switch)
     4.5. Циклические конструкции в Си-программах
          4.5.1. Оператор while
          4.5.2. Оператор for
          4.5.3. Оператор do...while
     4.6. Операторы передачи управления
          4.6.1. Оператор return
          4.6.2. Оператор break
          4.6.3. Оператор continue
          4.6.4. Оператор goto
  5. Структура программ
     5.1. Структура Си-программы
     5.2. Функции
          5.2.1. Анализ программы
          5.2.2. Использование  классов  памяти  при  организации
                 доступа к данным

                              - 5 -

          5.2.3. Описание функции
          5.2.4. Определение функции
     5.3. Типизация функции
          5.3.1. Модификатор функции pascal
          5.3.2. Модификатор функции cdecl
          5.3.3. Модификатор функции interrupt
          5.3.4. Прототипы функции
     5.4. Механизмы передачи параметров
     5.5. Понятие рекурсии
  6. Структуризация данных
     6.1. Указатели
          6.1.1. Динамическое распределение памяти
          6.1.2. Модификаторы типа указателей: near, far, huge
          6.1.3. Указатели как формальные параметры функции
          6.1.4. Указатели на функции
          6.1.5. Адресная арифметика в Си
          6.1.6. Использование неинициализированных указателей
     6.2. Массивы и их реализация
          6.2.1. Описание массивов
          6.2.2. Инициализация массивов
          6.2.3. Строки и операции над ними
          6.2.4. Многомерные массивы
          6.2.5. Массивы и функции
          6.2.6. Свободные массивы
     6.3. Структуры
          6.3.1. Описание структур
          6.3.2. Битовые поля
          6.3.3. Инициализация структур
          6.3.4. Массивы структур
     6.4. Объединения
     6.5. Файлы и их типизация
          6.5.1. Определение файла
          6.5.2. Текстовые и двоичные типы файлов
          6.5.3. Функции работы с файлами
  7. Сложные модели данных
     7.1. Линейные ссылочные структуры
          7.1.1. Стек
          7.1.2. Очередь
          7.1.3. Связанные списки

                              - 6 -

     7.2. Обобщенные (родовые) структуры данных
          7.2.1. Родовой список
          7.2.2. Родовое дерево поиска
  8. Организация программных средств
     8.1. Архитектура программных средств и библиотеки
          8.1.1. Включаемые файлы Турбо Си
          8.1.2. Библиотека подпрограмм по категориям
     8.2. Управление процессами компиляции, директивы компиляции
          8.2.1. Замена лексем
          8.2.2. Включение файла
          8.2.3. Условная компиляция
          8.2.4. Директива error
          8.2.5. Директива pragma
          8.2.6. Директива null
          8.2.7. Встроенные макроимена
          8.2.8. Встроенные макросы Турбо Си
  9. Объектно-ориентированное программирование
     9.1. Основные концепции ООП
     9.2. Классы
     9.3. Конструкторы и деструкторы
     9.4. Функции-члены
          9.4.1. Указатель this
          9.4.2. Функции-члены static и const
     9.5. Наследование
     9.6. Множественное наследование
     9.7. Вызов конструкторов
     9.8. Абстрактный базовый класс
     9.9. Указатель на член класса
10. Процесс проектирования алгоритмов
    10.1. Этапы построения алгоритма
          10.1.1. Постановка задачи
          10.1.2. Построение модели
          10.1.3. Разработка алгоритма
          10.1.4. Правильность алгоритма
          10.1.5. Реализация алгоритма
          10.1.6. Анализ алгоритма и его сложности
          10.1.7. Проверка программы
          10.1.8. Документация


                              - 7 -

    10.2. Методы разработки алгоритмов
          10.2.1. Методы  частных целей,  подъема и отрабатывания
                  назад
          10.2.2. Эвристики
          10.2.3. Программирование с отходом назад
          10.2.4. Метод ветвей и границ
          10.2.5. Рекурсия и итерация
          10.2.6. Моделирование
    Литература
.
                              - 8 -
                            Введение

     В.1. Предмет курса и его связь со смежными дисциплинами

     Предметом курса "Программирование и  основы  алгоритмизации"
являются  общие принципы программирования и проектирования эффек-
тивных структур данных и алгоритмов их  программной  обработки  с
использованием языка Си, типизации и структуризации данных, мето-
дологии проектирования прикладного программного обеспечения, инс-
трументальные средства и методы их использования в процессах соп-
ровождения программного обеспечения.
     Результатом изучения этого курса является овладение навыками
программирования для решения прикладных задач,  составляющих  со-
держание смежных дисциплин, определяющих подготовку в области ин-
формационных технологий применительно к задачам управления, таких
как,"Системное программное обеспечение","Информационное обеспече-
ние в системах управления","Вычислительные машины и системы" и др.

     В.2. Принципы программирования

     Структурное программирование - это процесс пошагового разби-
ения алгоритма на более мелкие части с целью получения таких эле-
ментов, для которых можно легко написать конкретные команды.
     Процедурное программирование - это процесс создания  функций
с целью упорядочения алгоритмов и организации программ.
     Модульное программирование - это процесс  объединения  взаи-
мосвязанных процедур и тех данных,  которыми эти процедуры опери-
руют с целью ограничения доступа к данным.
     Объектно-ориентированное программирование  - это процесс оп-
ределения необходимых типов данных и полного набора операций  для
каждого типа.

     В.3. Общие сведения о языке Си

     Язык Си - это структурированный,  модульный,  компилируемый,
универсальный язык, традиционно используемый для системного прог-
раммирования. Это переносимый язык,т.е. прикладные программы, на-
писанные на нем,  могут быть легко перенесены с одного компьютера
на  другой.  Си может использоваться практически для любых задач.
Однако,  если другие компиляторы работают достаточно медленно, то

                              - 9 -

Турбо Си обрабатывает 7000 строк в минуту, оставляя больше време-
ни для тестирования и совершенствования программ.
     Турбо Си  работает на всех компьютерах действительно совмес-
тимых с IBM PC,  включая ХТ и АТ. Он работает в операционной сис-
теме  DOS версии 2.0 и выше при наличии не менее 384К оперативной
памяти (RAM),  с любым дисплеем, строка которого содержит 80 сим-
волов.  Минимально  необходимым является один дисковод для гибких
дисков,  хотя лучше использовать два таких дисковода или же  один
винчестер с одним дисководом для гибких дисков.
     Турбо Си поддерживает проект стандарта языка Си,  предложен-
ный  Американским  национальным  институтом стандартов (ANSI),  а
также определение Кернигана и Ритчи (K&R),  кроме этого имеет не-
которые  дополнительные качества,  которые позволяют использовать
возможности IBM PC.
     Турбо Си включает две различные версии компилятора языка Си:
интегрированное программное средство и отдельный автономный  ком-
пилятор, использующий командную строку.


     В.4. Основные элементы программирования

     Целью большинства программ является решение задач. Программа
решает задачи, манипулируя информацией или данными. Вы должны на-
учиться:
     - вводить информацию в программу;
     - выделять место для хранения информации;
     - задавать инструкции по обработке информации;
     - выводить  информацию  обратно  из  программы  пользователю
       (обычно, вам);

     Вы можете организовать ваши инструкции так, что:

     - некоторые из них будут выполнятся только тогда, когда спе-
       циальное условие (или набор условий) истинно;
     - другие  будут повторяться несколько раз;
     - третьи разбиты на группы, которые могут выполняться в раз-
       личных местах вашей программы.



                             - 10 -

     Таким образом,  мы  описали основные элементы программирова-
ния: ввод, тип данных, операции, вывод, условное выполнение, цик-
лы и подпрограммы.
     Приведем обзорное описание каждого элемента:

    - вывод означает запись информации на экран,  на диск  или  в
      порт ввода-вывода;
    - типы данных - это константы,  переменные и структуры, кото-
      рые содержат числа (целые и вещественные), текст (символы и
      строки) или адреса (переменных и структур).

     Операции присваивают одно значение другому, комбинируют зна-
чения (складывают,  делят и т.д.),  и сравнивают значения (равно,
не равно и т.д.).
     Ввод означает  чтение значений с клавиатуры,  с диска или из
порта ввода-вывода.
     Условное выполнение  относится  к выполнению набора инструк-
ций,  если заданное условие истинно (и пропуску их, если оно лож-
но).
     Циклы выполняют набор инструкций некоторое фиксированное ко-
личество раз или пока истинно некоторое условие.
     Подпрограммы являются отдельно поименованными наборами  инс-
трукций,  которые  могут быть выполнены в любом месте программы с
помощью ссылки по имени.
     Теперь мы рассмотрим,  как использовать эти элементы в Турбо
Си.

  1. Директивы препроцессора, комментарии, идентификаторы

     1.1. Препроцессор, компилятор и загрузчик

     Для того, чтобы исходная программа на Турбо Си была оттранс-
лирована и переведена в исполняемый машинный код (файл с расшире-
нием .EXE в операционной системе MS DOS), она должна пройти через
три процесса: препроцессирование, компиляцию и загрузку (сборку).
     В задачи  препроцессора входит подключение при необходимости
к данной программе на Турбо Си внешних  файлов,  указываемых  при
помощи  директивы  #include  (см.разд.1.3),  и  расширение  макро
(см.разд.1.4).

                             - 11 -

     Компилятор за несколько этапов транслирует то, что вырабаты-
вает препроцессор в объектный файл (файл с расширением .OBJ), со-
держащий  оптимизированный  машинный  код,  при  условии,  что не
встречались синтаксические и семантические ошибки.  Если в исход-
ном  файле  с  программой  на Турбо Си обнаруживаются ошибки,  то
программисту выдается их список, в котором ошибки привязываются к
номеру  строки,  в которой они появились.  Программист циклически
выполняет действия по редактированию/компиляции до тех пор,  пока
не будут устранены все ошибки в исходном файле.
     Загрузчик связывает между собой объектный  файл,  получаемый
от компилятора, с программами из требуемых библиотек и, возможно,
с другими файлами. В результате сборки получается файл с расшире-
нием EXE (EXE-файл),  который  может  быть  исполнен компьютером.
EXE-файл может быть запущен на  выполнение  из  командной  строки
DOS.


     1.2. Комментарии

     Текст на Турбо Си,  заключенный между символами /* и */, яв-
ляется комментарием и компилятором игнорируется.
     Комментарии служат двум целям:  документировать код и облег-
чить отладку.  Так, если в программе на Турбо Си используется не-
который специальный алгоритм,  то будет уместен комментарий,  со-
держащий ссылку на книгу или статью,  в которой описывается  этот
алгоритм. Вообще говоря, в программу следует вносить любой текст,
проясняющий код. Но комментариями не нужно и злоупотреблять. Сде-
лать  код на Турбо Си самодокументированным можно,  используя ра-
зумные соглашения по именованию переменных,  функций и т.д. Турбо
Си разрешает вложение комментариев.
     Вложенные комментарии особенно полезны при отладке  програм-
мы.  Если программа работает не так, как надо, то иногда оказыва-
ется полезным закомментировать часть кода (т.е. вынести ее в ком-
ментарий),  заново скомпилировать программу и выполнить ее.  Если
теперь программа начнет работать правильно, то, значит, закоммен-
тированный  код  содержит  ошибку  и должен быть исправлен.  Если
программа не заработает, отключаются новые фрагменты. Поскольку и
сам исходный текст может содержать комментарии,  то рассматривае-
мая возможность Турбо Си,  позволяющая превращать  в  комментарий

                             - 12 -

код,  уже содержащий комментарий,  позволяет быстро удалить фраг-
мент кода из текста программы.

     1.3. Директива include

     Как правило,  в программы на Турбо Си подставляются один или
несколько файлов, часто в самое начало кода главной программы ma-
in. Появление директив
     #include <файл_1>
     #include "файл_2"
     ...
     #include <файл_n>
приводит к  тому,  что препроцессор подставляет на место этих ди-
ректив тексты файлов файл_1, файл_2,..., файл_n соответственно.
     Если имя файла заключено в угловые скобки <>, то поиск файла
производится в специальном каталоге подстановочных файлов. Обычно
в этот каталог помещаются все файлы с расширением .h.  Если в ка-
талоге отсутствует искомый файл, то препроцессор выдает сообщение
об ошибке и трехступенчатый процесс, описанный в разд. 1.1 преры-
вается.
     Если имя  файла заключено в двойные кавычки (как,  например,
"файл_2"), то поиск файла производится в начале в текущем катало-
ге. Если здесь файл не обнаруживается, то система переходит к по-
иску файла в каталоге подстановок. Если и здесь требуемый файл не
будет найден, то препроцессор выдаст сообщение об ошибке и трехс-
тупенчатый процесс будет прерван.
     В отличие  от  многих  других  операторов Турбо Си директива
include не должна оканчиваться точкой с запятой.

     1.4. Директива define

     С помощью директивы #define,  вслед за которой  пишутся  имя
макро и значения макро,  оказывается возможным указать препроцес-
сору,  чтобы он при любом появлении в исходном файле на Турбо  Си
данного  имени  макро заменял это имя на соответствующее значение
макро.
     Макро могут иметь параметры. Например, макро
                     #define cube(x)((x)*(x)*(x))
задает замену  символа cube(аргумент) на значение (аргумент)*(ар-

                             - 13 -

гумент)*(аргумент).
     Часто макро используют для того, чтобы увязать идентификатор
и значение.  Как только препроцессор встречает идентификатор,  он
заменяет его на соответствующее значение. Например, директива
                         #define pi 3.1415926
связывает идентификатор pi со значением 3.1415962.
     Не следует оканчивать значение макро  (например,  3.1415962)
точкой  запятой.  Значение макро подставляется вместо имени макро
полностью.  Если точка с запятой присутствует, то она будет подс-
тавлена вместе с числом.

     1.5. Идентификаторы

     Имена, которые вы даете константам, типам данных, переменным
и функциям называются идентификаторами. Примеры идентификаторов:

     char, int, float       предопределенные типы данных
     main                   главная функция программы
     name,a,b,sum,msg,ratio переменные, определенные пользовате-
                            лем
     scanf, printf, puts    стандартные библиотечные функции

     В Турбо  Си имеется несколько правил записи идентификаторов:

     1. Все идентификаторы  должны  начинаться  с  буквы  (a...z,
        A...Z) или с подчеркивания (_).
     2. Остальная  часть  идентификатора  может состоять из букв,
        подчеркиваний и/или цифр (0...9).  Никакие другие символы
        не разрешены.
     3. Идентификаторы являются чувствительными от типа букв. Это
        означает, что строчные буквы (a...z) - это не тоже самое,
        что прописные  буквы  (A...Z).  Например,  идентификаторы
        indx, Indx, INDX различны и отличаются друг от друга.
     4. Значимыми являются первые 32 символа идентификатора.

     Примечание: Турбо  Си  также разрешает вам использовать знак
доллара ($). В Турбо Си вы можете изменить число символов иденти-
фикатора  с помощью опции компилятора -i#,  где # является числом
значащих символов. 32 символа являются значащими также и для гло-

                             - 14 -

бальных идентификаторов,  берущихся из других модулей. Однако, вы
имеете опцию разрешающую определять или  нет  чувствительность  к
регистрам  этих  идентификаторов,  используя опцию Case sensitive
link..ON из подменю  Options/Linker  или  /c  опция  компоновщика
TLINK,  запускаемого с командной строки. Идентификаторы типа pas-
cal никогда не чувствительны к регистру во время компоновки.

  2. Средства ввода-вывода информации

     2.1. Вывод информации

     Может показаться странным, что мы начинаем разговор именно с
вывода, однако программ которые ничего не выводят, почти нет. Под
выводом обычно понимают форму информации,  записываемой: на экран
(слова и картинки),  на запоминающее устройство (гибкий или жест-
кий  диск)  или в порт ввода-вывода (последовательный порт,  порт
принтера).

     2.1.1.Функция printf

     Наиболее распространенная функция вывода в Си - подпрограмма
printf.  Ее целью является запись информации на экран.  Ее формат
выглядит так:
       printf(<строка формата>, <объект>, <объект>, ...);
     Строка формата  - это строка которая начинается и заканчива-
ется двойными кавычками ("как  эта");  цель  printf  запись  этой
строки на экран.  Перед выводом printf заменяет все дополнительно
перечисленные объекты в строке в соответствии  со  спецификациями
формата,  указанными в самой строке. Например, рассмотрим следую-
щий оператор printf:
                  printf("Сумма = %d \n",sum);
     %d в строке формата - это спецификация формата. Все специфи-
кации формата начинаются с символа процента (%) и (обычно) сопро-
вождаются одной буквой,  обозначающей тип данных и способ их пре-
образования.
     Вы должны  иметь для каждого объекта только одну,  соответс-
твующую ему,  спецификацию формата. Если объект имеет тип данных,
не  соответствующий спецификации формата,  то Турбо Си попытается
выполнить нужное преобразование.

                             - 15 -

     Сами объекты могут быть переменными, константами, выражения-
ми,  вызовами функций.  Короче говоря, они могут быть чем угодно,
что дает соответствующее значение спецификации формата.
     %d, используемое в спецификации, говорит о том, что ожидает-
ся некоторое целое число.
     Вы можете задать ширину поля,  помещая ее между %  и буквой;
например,  десятичное поле шириной 4 задается,  как %4d. Значение
будет напечатано сдвинутым вправо (впереди пробелы),  так что об-
щая ширина поля равна 4.
     Если нужно напечатать знак %, то вставьте %%. \n в строке не
является спецификацией формата,  а употребляется (по историческим
мотивам) как управляющая (escape) последовательность, и представ-
ляет специальный символ,  вставляемый в строку.  В этом случае \n
вставляет символ в начале  новой  строки,  поэтому  после  вывода
строки курсор передвинется к началу новой строки.
    Список управляющих последовательностей представлен в табл.2.1.
     Таблица 2.1. Escape последовательности Турбо Си
-----------------------------------------------------------------
Последовательность  Значение  Символ     Что делает
-----------------------------------------------------------------

* \a                  0x07     BEL       Звуковой сигнал
  \b                  0x08     BS        <-╞ (Забой)
  \f                  0x0C     FF        Перевод страницы
  \n                  0x0A     LF        Перевод строки
  \r                  0x0D     CR        Возврат каретки
  \t                  0x09     HT        Горизонтальная табуляция
  \v                  0x0B     VT        Вертикальная табуляция
  \\                  0x5c     \         Обратный слеш
  \'                  0x2c     '         Апостроф
  \"                  0x22     "         Двойная кавычка
  \?                  0x3F     ?         Вопросительный знак
  \DDD                       любой       DDD = от 1 до 3
                                         восьмиричных цифр
  \xHHH               0xHHH  любой       HHH = от 1 до 3
                                         шестнадцатиричных цифр

----------------------------------------------------------------
* Расширение ANSI к K&R

                             - 16 -

     Если вам нужно напечатать обратную косую черту,  то вставьте
\\.
     Более формально спецификацию %  можно  определить  следующим
образом:
          %[флаг(и)][ширина][.точность][l,L] символ_формата
где l  или L используются для указания длинных типов,  а ширина -
минимальный размер поля вывода.

Значение флага                    Назначение
----------------------------------------------------------------
      -           Выравнивание по левому краю поля
      +           Вывести знак значения - как плюс, так и минус
   Пусто          Для неотрицательных значений вместо знака плюс
                  вывести пробелы
----------------------------------------------------------------


   Тип значения                     Точность
 ---------------------------------------------------------------
    Целое                 Число цифр
    Вещественное          Число цифр после десятичной точки
    Строка                Число символов
 ---------------------------------------------------------------


Символ                 Тип выводимого объекта
формата
 ----------------------------------------------------------------
%с    символ (char)
%s    строка (char*)
%d    целое число (int)
%o    целое число в восьмеричном виде (int)
%x    целое число в шестнадцатеричном виде (int)
%u    целое число без знака (unsigned int)
%ld   длинное целое число в десятичном виде (long)
%lo   длинное целое число в восьмеричном виде (long)
%lx   длинное целое число в шестнадцатеричном виде (long)
%lu   длинное целое число без знака (unsigned long)
%f    вещественное число в фиксированной точкой (float/double)

                             - 17 -

%e    вещественное число в экспоненциальной форме (float/double)
%g    вещественное число  в  виде f или  e  в  зависимости  от
      значения (float/double)
%lf   длинное  вещественное  число  с   фиксированной   точкой
      (long float)
%le   длинное   вещественное  число  в  экспоненциальной форме
      (long float)
%lg   вещественное число  в  виде  f  или  e  в зависимости от
      значения (long float)
%p    значение указателя
-----------------------------------------------------------------

     Ниже приведена программа,  демонстрирующая некоторые возмож-
ности Турбо Си по выводу информации на экран

     /* Использование функции printf*/

  #include <stdio.h>
  #define square(x) ((x)*(x))
  #define pi 3.1415926

  main()
  {
   float x=2.5;
   int i=11;
   int j=119;

   printf("\nЗначение квадрата 2.5 = %10.4f", square(x));
   printf("\nЧисло пи = %10.4f", pi);
   printf("\nЗначение 2*пи = %10.4f", 2.0*pi);
   printf("\n\nШестнадцатеричный вид числа 11 = %x", i);
   printf("\n\nШестнадцатеричный вид числа 119 = %x", j);
   printf("\n\nВосьмеричный вид числа 119 = %o\n", j);
  }

     2.1.2. Функции puts и putchar для вывода

     Имеются две другие функции вывода:  puts и putchar.  Функция
puts выводит строку на экран и  завершает  вывод  символом  новой

                             - 18 -

строки, например:
     main ()
     {
       puts("Hello, world");
     }
     Заметим, что в конце строки опущен \n; это не нужно, так как
puts сама добавляет этот символ.
     Наоборот, функция putchar выводит единственный символ на эк-
ран  и не добавляет \n.  Оператор putchar(ch) эквивалентен printf
("%c",ch).
     Зачем же   нужно  использовать  puts  и/или  putchar  вместо
printf?  Одним из доводов является то, что программа, реализующая
printf, гораздо больше; если вы не нуждаетесь в ней (для числово-
го вывода или специального форматирования),  то, используя puts и
putchar, можно сделать свою программу меньше и быстрее. Например,
файл .EXE,  использующий puts,  значительно меньше, чем файл .EXE
для версии, использующей printf.

     2.2. Ввод информации

     В Си  имеется несколько функций ввода;  некоторые производят
ввод из файла или из входного потока, другие - с клавиатуры.

     2.2.1. Функция scanf

     Для интерактивного режима ввода можно использовать  в  боль-
шинстве случаев функцию scanf. Scanf это функция ввода, по смыслу
эквивалентная printf; ее формат выглядит так:

           scanf(<строка формата>,<адрес>,<адрес>,...)

     В scanf используются многие из тех же спецификаторов формата
%<буква>,  что и у функции printf: %d - для целых, %f - для чисел
с плавающей точкой, %s - для строк и т.д.
     Однако scanf имеет одно очень важное отличие:  объекты, сле-
дующие за строкой формата, должны быть адресами, а не значениями:

                     scanf("%d %d", &a, &b);


                             - 19 -

     Этот вызов сообщает программе, что она должна ожидать от вас
ввода двух десятичных (целых) чисел, разделенных пробелом; первое
будет присвоено а,  а второе b.  Заметим,  что здесь используется
операция  определения адреса (&) для передачи адресов а и b функ-
ции scanf.
     Промежуток между двумя командами формата %d фактически озна-
чает больше,  чем просто промежуток.  Он означает,  что вы можете
иметь любое количество "белых полей" между значениями.
     Что такое белое поле? Это любая комбинация пробелов, табуля-
ций и символов новой строки. В большинстве ситуаций компиляторы и
программы Си обычно игнорируют белое поле.
     Но что же надо делать,  если вы хотите разделить числа запя-
той вместо пробела? Необходимо лишь изменить строку ввода:

                    scanf ("%d, %d", &a, &b);

     Это позволяет вам ввести значения, разделенные запятой.

     Для ввода строки (последовательности символов) можно исполь-
зовать следующую программу:
     main ()
     {
       char name[30];

       printf("Как Вас зовут: ");
       scanf("%s", name);
       printf ("Привет, %s\n", name);
     }
     Поскольку name  является массивом символов,  значение name -
это адрес самого массива. По этой же причине перед именем name не
используется  адресный  оператор &,  вы просто пишете scanf("%s",
name);
     Обратите внимание, что мы использовали массив символов (char
name [30];),  вместо указателя на символ (char  *name;).  Почему?
Причиной  этого служит тот факт,  что объявление массива на самом
деле резервирует память для хранения его элементов,  а при объяв-
лении ссылки этого не происходит.  Если бы мы использовали объяв-
ление char *name,  тогда нам бы пришлось явным образом резервиро-
вать память для хранения переменной *name.

                             - 20 -


     2.2.2. Функции gets и getch для ввода

     Использование scanf,  однако, порождает другую проблему. Об-
ратимся к последней программе,  но теперь введем имя  и  фамилию.
Заметьте, что программа использует в своем ответе только имя. По-
чему?  Потому,  что введенный после  имени  пробел  сигнализирует
scanf о конце вводимой строки.
     Возможны два способа решения этой проблемы.  Вот  первый  из
них:
    main ()
     {
       char first[20],middle[20],last[20];
       printf("Как Вас зовут:");
       scanf("%s %s %s",first,middle,last);
       printf("Дорогой %s, или %s?\n",last,first);
     }
     Это означает,  что  имеется три компоненты имени;  в примере
функция scanf не пойдет дальше,  пока вы действительно не введете
три строки. Но что, если необходимо прочитать полное имя, как од-
ну строку, включая пробелы? Вот второй способ решения:
     main ()
     {
       char name [60];
       printf("Как вас зовут: ");
       gets (name);
       printf ("Привет, %s\n", name);
     }

     Функция gets читает все,  что вы набираете,  до тех пор пока
не нажмете "Ввод".  Она не помещает "Ввод" в строку; однако в ко-
нец строки добавляет нулевой символ (\0).
     Наконец, есть  еще функция getch().  Она читает единственный
символ с клавиатуры,  не выдавая его на экран (в отличии от scanf
и  gets).  Заметим,  что  у нее нет параметра ch;  getch является
функцией типа char,  ее значение может быть непосредственно прис-
воено ch.



                             - 21 -

     2.2.3. Ошибки при передаче по адресу

     Рассмотрим следующую программу:
          main()
          {
              int a,b,sum;
              printf("Введите два значения:");
              scanf("%d %d",a,b);
              sum = a + b;
              printf("Сумма значений равна: %d\n",sum);
          }

      Ошибка находится в операторе
                    scanf("%d %d",a,b);

     Scanf требует передачи адресов, а не значений!
     То же самое относится к любым функциям, содержащим в качест-
ве формальных параметров указатели.  Программа,  написанная выше,
оттранслируется и выполнится,  но при этом scanf возьмет какие-то
случайные значения (мусор),  находящиеся в a и b и использует  их
как адреса, по которым будут записаны введенные вами значения.
     Правильно этот оператор необходимо записать так:
                     scanf("%d %d", &a, &b);

     Здесь функции  scanf  передаются  адреса a и b,  и введенные
значения правильно запоминаются в этих переменных по их адресам.


  3. Основы типизации данных

     3.1. Понятие типа данных, абстракция данных

     Абстрактные типы  данных  характеризуются набором допустимых
значений и соответствующим наборам операций над этими значениями.
Для  действительно  абстрактного  типа данных правильность их ис-
пользования гарантируется тем, что над данными указанного базово-
го  типа  разрешаются только те операции,  которые присутствуют в
заданном наборе. Такой подход называют инкапсуляцией данных.
     Таким образом,  тип  задается  набором допустимых значений и

                             - 22 -

набором действий,  которые можно совершать над каждой  переменной
рассматриваемого типа.
     Считается, что переменная или выражение принадлежит к данно-
му типу,  если его значение принадлежит области допустимых значе-
ний этого типа.
     Переменные типизируются  посредством их описаний.  Выражения
типизируются посредством содержащихся в них операций.
     В Турбо  Си имеется множество предопределенных типов данных,
включая несколько видов целых, вещественных, указателей, перемен-
ных, массивов, функций, объединений, структур и тип void  (отсут-
ствие типа). Тип void не имеет ни значений, ни действий.
     Целые типы  включают  несколько  разновидностей целых и сим-
вольных данных. Арифметические типы объединяют целые и веществен-
ные. Скалярные типы включают арифметические типы, указатели и пе-
речислимые типы. Агрегаты или структурные типы, включают массивы,
структуры и объединения. Функции представляют особый класс.
     Типы Турбо Си представлены на рис. 3.1.

  ┌────────────┐ ┌────────────┐  ┌────────────┐   ┌─────────────┐
  │  Скалярные │ │ Тип void   │  │  Функции   │   │  Агрегатные │
  │    типы    │ │            │  │            │   │    типы     │
  └─────┬──────┘ └────────────┘  └────────────┘   └──────┬──────┘
        │                                                │
        V                                                │
   ┌───────────┬────────────────┬──────────────┐         │
   │ Указатель │  Арифметический│ Перечислимый │         │
   └───────────┴────────┬───────┴──────────────┘         V
                        │      ┌───────┬──────────┬─────────────┐
                        V      │ Массив│ Структура│ Объединение │
   ┌──────────────┬────────┐   └───────┴──────────┴─────────────┘
   │ Вещественный │ Целый  │
   └──────────────┴────────┘

                      Рис. 3.1. Типы в Турбо Си.

     В каждой реализации Си всякий тип занимает определенное чис-
ло единиц памяти.  За такую единицу принимается память, требуемая
для  хранения одного символа;  и обычно она составляет один байт.
Сказанное верно и для Турбо Си.  Все объекты одного типа занимают

                             - 23 -

одно и то же количество единиц памяти (байтов).  Число единиц па-
мяти,  требуемое для размещения элемента данного типа, может быть
вычислено операцией определения размера sizeof(тип).
     В табл.  3.1 представлены типы данных Турбо Си,  указаны  их
размеры в байтах и заданы диапазоны значений (наборы значений).
     Таблица 3.1. Типы данных в Турбо Си, их размеры и диапазоны
                  значений

-----------------------------------------------------------------
   Тип             Размер (в байтах)        Диапазон

-----------------------------------------------------------------

 unsigned char           1                   0 - 255
 char                    1                -128 - 127
 enum                    2              -32768 - 32767
 unsigned short          2                   0 - 65535
 short                   2              -32768 - 32767
 unsigned int            2                   0 - 65535
 int                     2              -32768 - 32767
 unsigned long           4                   0 - 4294967295

 long                    4         -2147483648 - 2147483647

 float                   4             3.4E-38 - 3.4E+38
 double                  8            1.7E-308 - 1.7E+308
 long double             8            1.7E-308 - 1.7E+308

 pointer                 2      (указатели near,_cs,_ds,_es,_ss)
 pointer                 4      (указатели far, huge)
-----------------------------------------------------------------
     Примечание: тип long double допускается,  но трактуется  как
double.

     3.2. Обобщенные характеристики данных:  класс памяти,  меха-
          низмы хранения и доступа

     Каждая переменная и функция,  описанная в программе на Турбо
Си,  принадлежит к какому-либо классу памяти.  Класс памяти пере-

                             - 24 -

менной определяет время ее существования и область видимости.
     Класс памяти для переменной задается либо по расположению ее
описания, либо при помощи специального спецификатора класса памя-
ти, помещаемого перед обычным описанием. Класс памяти для функции
всегда extern,  если только перед описанием функции не стоит спе-
цификатор static.
     Все переменные  Турбо Си можно отнести к одному из следующих
классов памяти:
     auto            (автоматическая, локальная)
     register        (регистровая)
     extern          (внешняя)
     static          (статическая)

     3.2.1. Автоматические переменные

     Автоматические переменные можно  описывать  явно,  используя
спецификатор класса памяти auto.  Но такой способ описания приме-
няется редко.  Обычно указание на то, что переменная является ав-
томатической,  задается неявно и следует из положения в программе
точки описания такой переменной.
     По умолчанию принимается,  что всякая переменная,  описанная
внутри функции (локальная переменная) или внутри  блока,  ограни-
ченного фигурными скобками, и не имеющая явного указания на класс
памяти, относится к классу памяти для автоматических переменных.
     Поле видимости автоматической переменной начинается от точки
ее описания и заканчивается в конце блока,  в котором  переменная
описана.  Доступ к таким переменным из внешнего блока невозможен.
Память для автоматических  переменных  отводится  динамически  во
время  выполнения  программы при входе в блок,  в котором описана
соответствующая переменная.  При выходе из блока память, отведен-
ная под все его автоматические переменные, автоматически освобож-
дается. Теперь понятно происхождение термина автоматические пере-
менные.  Доступ  к  автоматической  переменной возможен только из
блока,  где переменная описана,  так как до момента входа в  блок
переменная  вообще  не  существует (т.е.  под нее не отведена па-
мять).
     Применение автоматических переменных внутри локальных блоков
позволяет приближать описание таких переменных к месту их исполь-
зования, делая программу более наглядной и иногда облегчая отлад-

                             - 25 -

ку.
     Скалярные автоматические переменные при их описании не обну-
ляются.  Пользователь должен сам указать начальное  значение  для
переменных в точке их описания.
     Согласно стандарту Си, не разрешается инициализировать авто-
матические структурные переменные,  такие, как массивы, структуры
и объединения. В Турбо Си такой вид инициализации разрешен, одна-
ко при этом может быть нарушена мобильность полученного кода. Бе-
зопаснее такие структурные переменные описывать как внешние.

     3.2.2. Регистровые переменные

     Спецификатор памяти register может использоваться только для
автоматических  переменных или для формальных параметров функции.
Такой спецификатор указывает компилятору на то,  что пользователь
желает разместить переменную не в оперативной памяти,  а на одном
из быстродействующих регистров компьютера.  Компилятор не  обязан
выполнить  такое  требование.  На большинстве компьютеров имеется
только небольшое число регистров, способных удовлетворить желание
пользователя.
     Спецификацию register рекомендуется использовать  для  пере-
менных,  доступ к которым в функции выполняется часто. Полученный
в результате код будет выполняться быстрее и  станет  более  ком-
пактным.
     Существует некоторое ограничение в использовании регистровых
переменных,  самое  существенное  из  которых состоит в том,  что
нельзя обращаться к адресу таких переменных.  Регистровыми  пере-
менными могут быть объявлены только автоматические переменные.  В
Турбо Си в регистры могут  быть  помещены  лишь  переменные  типа
short и int, а также близкие указатели.

     3.2.3. Внешние переменные и функции

     Любая переменная, описанная в файла вне какой-либо функции и
не имеющая спецификатора памяти,  по умолчанию относится к классу
памяти  для внешних переменных.  Такие переменные называются гло-
бальными.
     Для глобальных  переменных область видимости простирается от
точки их описания до конца файла,  где они описаны.  Если  внутри

                             - 26 -

блока описана автоматическая переменная,  имя которой совпадает с
именем глобальной переменной, то внутри блока глобальная перемен-
ная маскируется локальной.  Это означает,  что внутри данного ло-
кального блока будет видна именно автоматическая переменная.
     Для внешних  переменных память отводится один раз и остается
занятой до окончания выполнения программы.  Если пользователь  не
укажет  инициирующее значение глобальным переменным,  то им будет
присвоено начальное значение нуль.
     Структурные внешние  переменные - массивы,  структуры и объ-
единения - могут инициализироваться пользователем в точке их опи-
сания.
     Внешние переменные видны загрузчику,  осуществляющему сборку
выполняемой  программы  из множества объектных файлов.  Для того,
что переменную можно было использовать в другом  файле,  для  нее
следует задать спецификатор памяти extern.
     Если описание  extern   для  переменной  расположено  внутри
функции,  то его действие распространяется только на данную функ-
цию.  Если описание extern находится вне функции, то его действие
распространяется от точки описания до конца файла.
     Таким образом,  сочетание внешних переменных и функций в од-
ном  файле и описаний extern в других файлах позволяет объединять
в один выполняемый  файл  несколько  независимо  скомпилированных
программ.
     Возможность видеть внешние переменные извне файла,  где  они
описываются, предоставляет программистам на Турбо Си исключитель-
ную гибкость в организации физической структуры программной  сис-
темы.
     Рекомендуется для каждого файла реализации программы  (файла
с расширением .с),  если в нем используются внешние объекты, дос-
туп к которым будет осуществляться из  других  файлов,  создавать
интерфейсные  файлы (файлы с расширением .h) и помещать туда опи-
сание внешних переменных. Тогда для обеспечения доступа к внешним
переменным  из  файлов-потребителей требуется лишь включить в эти
файлы соответствующий интерфейсный файл.
     По умолчанию считается,  что все функции внешние. Местом оп-
ределения функций является та точка программы, где задаются пара-
метры функций и записывается ее тело.  Ко всем функциям, не имею-
щим спецификатора класса памяти static,  обращение из других фай-
лов оказывается возможным, если там функция описывается как внеш-

                             - 27 -

няя.  Таким образом, функция определяется один раз, но может быть
описана много раз (с использованием спецификатора extern).

     3.2.4. Статические переменные и функции

     Для упрятывания функций и переменных от загрузчика использу-
ется спецификатор памяти static.  Функции и переменные, для кото-
рых указан такой класс памяти, видимы лишь от точки описания и до
конца файла.
     Если пользователь  не  указал инициализирующие значения,  то
все статические переменные, как и внешние, инициализируются  зна-
чением нуль. Инициализация структурных статических переменных вы-
полняется по тем же правилам, что и инициализация внешних.
     Если статическая  переменная описана внутри функции,  то она
первый раз инициализируется при входе в  блок  функции.  Значение
переменной сохраняется от одного вызова функции до другого. Таким
образом,  статические переменные можно использовать для  хранения
значений  внутри  функции на протяжении времени работы программы,
причем такие переменные будут невидимы вне файла, где они опреде-
ляются.
     Спецификатор static в определении функции делает ее  невиди-
мой для загрузчика, т.е. недоступной из других файлов.

     3.2.5. Переменные класса volatile

     Спецификатор volatile,  введенный  в новый стандарт ANSI для
Си и реализованный в Турбо Си,  указывает компилятору на то,  что
переменная может изменяться не только программой (как обычная пе-
ременная), но и вне программы, например при обработке прерывания.
Для переменных, специфицированных как в volatile, компилятор не в
праве сделать какое-нибудь предположение об их значениях при  вы-
числении  выражений,  поскольку такие переменные могут измениться
даже в момент вычисления выражения. Компилятору запрещено перево-
дить переменную типа volatile в регистровый класс памяти.

     3.2.6. Правила видимости

     1. Переменные,  имена новых типов, описываемых с помощью ty-
pedef,  и перечисленные члены должны быть уникальными внутри бло-

                             - 28 -

ка,  в котором они описаны. Идентификаторы, объявленные внешними,
должны быть уникальными среди переменных, описанных как внешние.
     2. Имена  структур,  объединений  и перечислений должны быть
уникальными внутри блока,  в котором они описаны. Эти имена, опи-
санные  вне  пределов  какой-либо функции,  должны быть уникальны
среди всех соответствующих имен, описанных как внешние.
     3. Имена членов структуры и объединения должны быть уникаль-
ны в структуре или объединении, в которых они описаны. Не сущест-
вует  никаких ограничений на тип или смещение для членов с одина-
ковыми именами в различных структурах.
     4. Метки  на  которые  ссылаются  операторы goto должны быть
уникальными внутри функции, в которой они определены.

     3.3. Основные типы данных

     При написании программы,  вы работаете с некоторым видом ин-
формации, большинство которой попадает в один из 4-х основных ти-
пов: целые числа, числа с плавающей точкой, текст и указатели.
     Целые - это числа, которые используются для счета ( 1, 2, 5,
-21 и 752, например).
     Числа с  плавающей  точкой могут содержать дробные разряды и
экспоненту (5.4567*10^65).  Иногда  их  называют  действительными
(вещественными) числами (real).
     Текст состоит из символов (а,  Z, !, 3) и строк ("Это просто
проверка").
     Указатели не хранят информацию;  вместо этого каждый из  них
содержит адрес памяти ЭВМ, в которой хранится информация.


     3.4. Описание простейших типов

     3.4.1. Вещественные

     Рассмотрим программу, использующую вещественный тип float:
     main()
     {
        int a,b;
        float ratio;
        printf("Введите два числа:  ");

                             - 29 -

        scanf("%d %d,&a,&b);
        ratio = a / b;
        printf("Отношение = %f \n", ratio);
     }

     Введя два значения (такие,  как 10 и 3),  получим  результат
(3.000000). Вероятно, вы ожидали ответа 3.333333; почему же ответ
оказался только 3?  Потому, что a и b имеют тип int, отсюда и ре-
зультат тоже типа int. Он был преобразован к типу float при прис-
ваивании его ratio,  но преобразование имело место после, а не до
деления.  Необходимо изменить тип a и b на float;  а также строку
формата "%d %d" в scanf на "%f %f". Результат будет 3.333333, как
и ожидалось.
     Имеется также версия типа float, известная как double. Пере-
менные  типа double в два раза больше переменных типа float.  Это
означает, что они могут иметь больше значащих цифр и больший диа-
пазон значений экспоненты.

     3.4.2. Три типа целых

     В дополнение к типу int,  Си поддерживает версии short int и
long int, обычно сокращаемые до short и long. Фактические размеры
short,  int и long зависят от реализации; все, что гарантирует Си
- это то,  что переменная типа short не будет больше (то есть  не
займет больше байтов), чем типа long. В Турбо Си эти типы занима-
ют 16 битов (short), 16 битов (int) и 32 бита (long).

     3.4.3. Беззнаковые

     Си позволяет вам объявлять некоторые типы (сhar, short, int,
long) беззнаковыми (unsigned).  Это означает,  что вместо отрица-
тельных значений эти типы имеют  только  неотрицательные  (больше
или  равные  нулю).  Переменные такого типа могут поэтому хранить
большие значения,  чем знаковые типы.  Например, в Турбо Си пере-
менная типа int может содержать значения от -32768 до 32767;  пе-
ременная же типа insigned int может содержать значения  от  0  до
65535. Обе занимают одно и тоже место в памяти (16 битов в данном
случае);  но используют ее по-разному.


                             - 30 -

     3.4.4. Символьные

     Турбо Си поддерживает двухсимвольные данные, например, 'An',
'\n\t' и '\007\007'.  Они имеют 16-битное представление типа int,
причем первый символ находится в младшем байте,  а второй в стар-
шем. Такие данные не переносимы в другие компиляторы Си.
     Одиночные символы,  такие как 'A', '\t' и '\007' также имеют
16 битное представление типа int.  В этом случае младший байт яв-
ляется сигналом переполнения в старшем байте; т.е., если десятич-
ное значение больше чем 127, то старший байт устанавливается в -1
[=0xFF].  Это  может быть запрещено объявлением,  что тип char по
умолчанию является незначащим для этого (используется опция  ком-
пилятора -k или конструкция Default char type...Unsigned в подме-
ню Options/Compiler/Source,  делающая старший  байт  нулевым,  не
считаясь со значением младшего байта).
     Турбо Си поддерживает ANSI расширение,  допускающее шестнад-
цатиричное представление кодов символов,  например, '\x1F','\x82'
и так далее. Кроме того допустима запись x и X, а также использо-
вание от одной до трех цифр.

     3.4.5. Типы со знаком

     Классический Си подразумевает, что все int-типы являются ти-
пами со знаком, и потому включает модификатор типа unsigned чтобы
специфицировать обратное.  По умолчанию переменные типа char счи-
таются signed (со знаком),  что подразумевает изменение их значе-
ний от -128 до 127.
     Однако, в настоящее время большинство компиляторов Си,  реа-
лизованных для современных моделей компьютеров,  воспринимают тип
данных char как unsigned.  В связи с этим,  для повышения мобиль-
ности  программ на Турбо Си,  в компилятор пакета включена опция,
позволяющая компилировать тип данных char как unsigned по умолча-
нию.  В  противном  случае вы можете объявить символьную знаковую
переменную как signed char.

     3.5. Тип enum-перечислимый

     Турбо Си  поддерживает все перечислимые типы ANSI стандарта.
Перечислимый тип данных  используется  для  описания  дискретного

                             - 31 -

множества целых значений. Например, вы можете объявить следующее:
       enum days { sun, mon, tues, wed, thur, fri, sat };

     Имена, перечисленные  в  days,  являются целыми константами:
первая (sun) автоматически установлена в ноль, а каждая следующая
имеет значение на единицу больше, чем предыдущая (mon = 1, tues=2
и т.д.).  Однако,  вы можете присвоить константам и  определенные
значения;  следующие имена, без конкретных значений, будут тогда,
как и раньше,  иметь значения предыдущих элементов с  увеличением
на единицу. Например,
      enum coins {penny=1, nickle=5, dime=10, quarter=25};

     Переменной перечислимого  типа  может  быть  присвоено любое
значение типа int - проверка типа не производится.


     3.6. Тип void

     У K&R каждая функция возвращает значение; если тип не объяв-
лен,  то функция принадлежит типу int.  В Турбо Си поддерживается
тип void,  определенный в ANSI стандарте. Он используется для яв-
ного описания функций, не возвращающих значений. Аналогично, пус-
той  список параметров может быть объявлен зарезервированным сло-
вом void. Например,
 void putmsg(void)
 {
      printf("Hello, world\n");
 }
 main()
 {
      putmsg();
 }
     Вы можете  преобразовывать  выражение к типу void,  для того
чтобы явно указать,  что значение, возвращаемое функцией, игнори-
руется.  Например,  если вы хотите приостановить выполнение прог-
раммы до тех пор пока пользователь не нажмет какую-либо  клавишу,
вы можете написать:
                         (void) getch();


                             - 32 -

     Наконец, вы можете объявить указатель на объект  типа  void.
Данный указатель не будет указателем на ничто; а будет указателем
на любой тип данных, причем конкретный тип этих данных знать нео-
бязательно.  Вы можете присваивать любой указатель указателю типа
void (и наоборот) без приведения типов.  Однако вы не можете  ис-
пользовать оператор косвенной адресации (*) с указателем void, т.
к. используемый тип неопределен.

     3.7. Расширенные описания - использование директивы typedef

     В классическом Си  определенные  пользователем  типы  данных
именуются  редко,  за  исключением структур и объединений - перед
любым объявлением которых вы ставите ключевые  слова  struct  или
union.
     В современном Си обеспечивается другой уровень  информацион-
ной  содержательности путем использования директивы typedef.  Она
позволяет связать нужный тип данных (включая struct и enum) с не-
которым  именем,  а  затем объявить переменные этого типа.  Далее
представлен пример определения типа и определение переменных это-
го нового, введенного пользователем, типа данных:

             typedef int *intptr;
             typedef char namestr[30];
             typedef enum ( male, female, unknown) sex;
             typedef struct {
                 namestr  last, first;
                 char     ssn[9];
                 sex      gender;
                 short    age;
                 float    gpa;
             } student;
             typedef student class[100];
             class   hist104,ps102;
             student valedictorian;
             intptr  iptr;

     Использование typedef делает программу более читабельной,  а
также  позволяет  вам  не ограничиваться одним участком программы
для определения типов данных,  а распространить их определение на

                             - 33 -

всю программу по мере их появления и использования в ней.

     3.8. Иерархия типов, совместимость и преобразование типов в Си

     3.8.1. Преобразование типов char, int и enum

     Преобразование символьной  константы к целому типу имеет ре-
зультатом 16-битное значение,  поскольку и одно, и двухсимвольные
константы представляются 16-битным значением.  Результат преобра-
зования символьного объекта (такого как переменная) к целочислен-
ному объекту автоматически получает знаковое расширение,  если вы
не сделали по умолчанию тип char беззнаковым,  используя при ком-
пиляции опцию -k.  Объекты типа signed char при преобразовании их
в int всегда используют знаковое расширение;  объекты типа unsig-
ned char всегда устанавливают старший байт в ноль.
     Значения типа enum преобразуются в int без модификации; ана-
логично значения, имеющие тип int, могут преобразовываться в зна-
чения перечислимого типа enum, а символы преобразуются в int зна-
чения и обратно.

     3.8.2. Преобразование указателей

     В Турбо  Си различные указатели вашей программы,  могут быть
различных размеров,  в зависимости от используемой модели  памяти
или используемого модификатора типа указатель. Например, когда вы
компилируете программу, используя конкретную модель памяти, адре-
суемые модификаторы (near, far, huge, _cs, _ds, _es, _ss) в вашем
исходном тексте могут изменять размер указателя,  заданный данной
моделью памяти.
     Указатель должен быть объявлен как  указатель  на  некоторый
конкретный  тип,  даже если данный тип - void (который в действи-
тельности означает указатель на ничего). Однако, будучи объявлен-
ным, такой указатель может указывать на объект любого другого ти-
па. Турбо Си позволяет вам переназначать указатели, но компилятор
будет  предупреждать вас,  в случаях переназначения,  если только
предварительно этот указатель не был объявлен  как  указатель  на
тип void. Однако, указатели на типы данных не могут быть преобра-
зованы в указатели на функции, и наоборот.


                             - 34 -


     3.8.3. Арифметические преобразования

     В Турбо  Си определяются обычные арифметические преобразова-
ния определяющие,  что произойдет с любыми величинами,  использо-
ванными в арифметических выражениях (операнд, оператор, операнд).
Здесь приведены шаги,  используемые Турбо Си,  для преобразования
операндов в арифметических выражениях:
   1. Любой не integer и не double тип преобразуется в  соответс-
твии с таблицей 3.2. После этого любые два значения, объединенные
оператором,  являются целыми - int (включая long и unsigned моди-
фикаторы) или с плавающей точкой - double.
   2. Если какой-либо операнд имеет тип double, то другой операнд
тоже преобразуется в double.
   3. В случае,  если один из операндов имеет тип unsigned  long,
то другой операнд тоже преобразуется в unsigned long.
   4. В случае,  если один из операндов имеет тип long, то другой
операнд тоже преобразуется в long.
   5. В случае,  если какой-либо из операндов имеет тип unsigned,
то другой операнд тоже преобразуется в unsigned.
   6. В последнем варианте, оба операнда являются типа int.

     Результат выражения определяется типами обоих операндов.


     Таблица 3.2. Методы, используемые для определения результата
                  в арифметических  преобразованиях
-----------------------------------------------------------------
    Тип         Преобразуется в          Метод
-----------------------------------------------------------------

 char               int                 со знаком
 unsigned char      int         нулевой старший байт (всегда)
 signed char        int                 со знаком (всегда)
 short              int         если unsigned, то unsigned int
 enum               int                 тоже значение
 float              double      мантисса дополняется нулями
-----------------------------------------------------------------


                             - 35 -

  4. Операции и управляющие конструкции

     4.1. Пространство операций над простейшими типами

     4.1.1. Операция присваивания

     Самой общей операцией является присваивание, например, ratio
= a/b или ch = getch(). В Си присваивание обозначается одним зна-
ком равенства (=);  при этом значение справа от  знака  равенства
присваивается переменной слева.
     Можно применять также последовательные присваивания,  напри-
мер: sum = a = b. В таких случаях присваивание производится спра-
ва налево,  то есть b будет присвоено a,  которая в свою очередь,
будет присвоена sum, так что все три переменных получат одно и то
же значение (а именно, начальное значение b).

     4.1.2. Арифметические операции

     Си поддерживает обычный набор арифметических операций:
     - умножение (*)
     - деление (/)
     - остаток от деления целого на целое (%)
     - сложение (+)
     - вычитание (-)

     Турбо Си поддерживает одноместный минус (a + (-b)),  который
выполняет двоичное дополнение;  как в расширении ANSI. Кроме это-
го, Турбо Си поддерживает одноместный плюс (a + (+b)).
     Стараясь создать эффективно компилируемые  выражения,  Турбо
Си  обычно выполняет перегруппировку выражения с переупорядочива-
нием коммутативных операторов (таких как * и бинарный +). Однако,
Турбо  Си не будет переупорядочивать выражения с унарным операто-
ром +. Этим качеством вы можете управлять в вычислениях с плаваю-
щей точкой, которые чувствительны к ошибкам точности и переполне-
ния.  То есть можете включать в отдельные выражения промежуточные
преобразования с унарным оператором +,  без разделения преобразо-
вания.  Например, если a, b, c и f имеют тип float, тогда выраже-
ние
                       f = a + + (b + c);

                             - 36 -

заставит сначала  оценить  значение (b+c),  а затем прибавить ре-
зультат к a.

     4.1.3. Операции приращения (++) и уменьшения (--)

     В Си имеются некоторые специальные одноместные и  двуместные
операции.  Наиболее известными являются одноместные операции при-
ращения (++) и уменьшения (--).  Они позволяют  вам  использовать
единственную операцию,  которая добавляет 1 или вычитает 1 из лю-
бого значения;  сложение и вычитание может быть выполнено в сере-
дине выражения,  причем вы можете даже решить, сделать это до или
после вычисления выражения.  Рассмотрим следующие строки програм-
мы:
                         sum = a + b++;
                         sum = a + ++b;

     Первая означает:  "сложить a и b,  присвоить результат sum и
увеличить b на единицу".
     Вторая означает:  "увеличить b на единицу,  сложить a и b, и
присвоить результат sum".
     Это очень  мощные  операции,  расширяющие возможности языка,
однако перед их использованием нужно убедиться, что вы хорошо по-
нимаете их действие.
     Пример программы, использующей операции ++ и --. Попытайтесь
определить, что она выведет:
     main()
     {
         int a,b,sum;
         char *format;
         format = "a = %d    b = %d   sum = %d \n";
         a = b = 5;
         sum = a   + b; printf(format,a,b,sum);
         sum = a++ + b; printf(format,a,b,sum);
         sum = ++a + b; printf(format,a,b,sum);
         sum = --a + b; printf(format,a,b,sum);
         sum = a-- + b; printf(format,a,b,sum);
         sum = a   + b; printf(format,a,b,sum);
     }


                             - 37 -

     4.1.4. Побитовые операции

     Для обработки на уровне битов Си имеет следующие операции:
     - сдвиг влево (<<)
     - сдвиг вправо (>>)
     - И (&)
     - ИЛИ (|)
     - исключающее ИЛИ (^)
     - НЕ (~)

     Они позволяют вам производить операции очень низкого уровня.
Для того, чтобы понять эффект этих операций, рассмотрим следующую
программу:
     main()
     {
         int a,b,c;
         char *format1, *format2;
         format1 = " %04X %s %04X = %04X\n";
         format2 = " %c%04X = %04X\n";
         a = 0x0FF0; b = 0xFF00;
         c = a<<4;   printf(format1,a,"<<",4,c);
         c = a>>4;   printf(format1,a,">>",4,c);
         c = a & b;  printf(format1,a,"& ",b,c);
         c = a | b;  printf(format1,a,"| ",b,c);
         c = a ^ b;  printf(format1,a,"^ ",b,c);
         c = ~a;     printf(format2,`~`,a,c);
         c = -a;     printf(format2,`-`,a,c);
     }
     Опять же,  попробуйте предугадать то, что будет выводить эта
программа. Заметим, что спецификаторы ширины поля выравнивают вы-
водимые значения;  спецификатор %04X указывает  на  использование
нулей  в  начале  числа,  на ширину поля вывода четыре цифры и на
шестнадцатиричное представление (основание 16).

     4.1.5. Комбинированные операции

     Си позволяет использовать некоторые сокращения при написании
выражений,  содержащих  многочисленные  операции,  описанные выше
(одноместные,  двуместные,  приращение,  уменьшение и побитовые).

                             - 38 -

Так, любое выражение вида
     <переменная> = <переменная> <операция> <выражение>;
может быть заменено на
     <переменная> <операция> = <выражение>;

     Ниже приводятся некоторые примеры таких выражений и  способы
их сокращения:
     a = a + b;  сокращается до  a += b;
     a = a - b;  сокращается до  a -= b;
     a = a * b;  сокращается до  a *= b;
     a = a / b;  сокращается до  a /= b;
     a = a % b;  сокращается до  a %= b;
     a = a << b; сокращается до  a <<= b;
     a = a >> b; сокращается до  a >>= b;
     a = a & b;  сокращается до  a &= b;
     a = a | b;  сокращается до  a |= b;
     a = a ^ b;  сокращается до  a ^= b;


     4.1.6. Адресные операции

     Си поддерживает две специальные адресные операции:  операцию
определения адреса (&) и операцию обращения по адресу(*).
     Операция & возвращает адрес данной переменной;  если sum яв-
ляется переменной типа int,  то &sum является адресом (расположе-
ния в памяти) этой переменной. С другой стороны, если msg являет-
ся указателем на тип char,  то *msg является символом, на который
указывает msg. Рассмотрим следующую программу:
     main()
     {
        int sum;
        char *msg;
        sum = 5 + 3;
        msg = "Hello, thore\n";
        printf(" sum = %d &sum = %p \n", sum, &sum);
        printf("*msg = %c  msg = %p \n", *msg, msg);
     }
     В первой строке печатается два значения:  значение sum (8) и
адрес sum (назначаемый компилятором).  Во второй строке также пе-

                             - 39 -

чатается два значения:  символ,  на который указывает msg (H),  и
значение msg,  которое является адресом этого символа (также наз-
начен компилятором).


     4.1.7. Операции сравнения

     Операции сравнения позволяют сравнивать два значения,  полу-
чая результат в зависимости от того, дает ли сравнение истину или
ложь.  Если сравнение дает ложь, то результирующее значение равно
нулю; если значение истина, то результат равен 1. Вот список опе-
раций Си для сравнения:
     > больше
     >= больше или равно
     <  меньше
     <= меньше или равно
     == равно
     != не равно

     Почему нас  должно  заботить,  является ли нечто истиной или
ложью? Рассмотрим программу:

     main ()
     {
       float a,b,ratio;
       printf("Введите два числа: ");
       scanf("%f %f",&a,&b);
       if (b == 0.0)
          printf("Отношение не определено\n");
       else {
          ratio= a / b;
          printf("Отношение = %f \n",ratio);
       }
     }

     Оператор, находящийся  в  двух следующих за оператором scanf
строках известен,  как условный оператор if.  Вы можете  понимать
его  так:"Если значение выражения (b == 0.0) истинно,  сразу выз-
вать printf.  Если значение выражения ложно,  присвоить a/b пере-

                             - 40 -

менной ratio, затем вызвать printf."
     Теперь, если вы введете 0 в качестве  второго  значения,  то
ваша программа напечатает сообщение
                       Отношение не определено.

     Если второе значение ненулевое, то программа вычисляет и пе-
чатает ratio.


     4.1.8. Логические операции

     Имеется также три логические операции: И (&&), ИЛИ (||) и НЕ
(!).  Их  не следует путать с описанными выше битовыми операциями
(&,|,~).  Логические операции работают с  логическими  значениями
(истина или ложь) и позволяют составлять логические выражения.

     Как же их отличать от соответствующих битовых операций?

    - Эти  логические  операции всегда дают в результате значение
либо 0 (ложь), либо 1 (истина), в то время как поразрядные опера-
торы  выполняются  путем последовательной обработки цепочки битов
до тех пор, пока не станет ясен результат.
    - Логические  операторы  && и !!  известны как операторы типа
"short circuit".  Выполнение операторов такого типа  прекращается
как только становится ясно, будет ли результат иметь значение ис-
тина или ложь. Предположим, что вы имеете выражение вида:
                          exp1 && exp2

     Если exp1 - ложь,  значит и все выражение ложь.  Таким обра-
зом, exp2 никогда не будет вычисляться. Аналогично, если мы имеем
выражение вида
                          exp1 !! exp2

то exp2 никогда не будет вычисляться, если exp1 верно.

     4.1.9. Операция следования (запятая)

     Вы можете  использовать операцию запятая (,) для организации
множественных выражений, расположенных внутри круглых скобок. Вы-

                             - 41 -

ражение  внутри  скобок вычисляется слева направо и все выражение
принимает значение,  которое было вычислено последним.  Например,
если oldch и ch имеют тип char, то выражение
                   (oldch = ch, ch = getch())
присваивает переменной oldch значение ch, затем считывает символ,
вводимый с клавиатуры,  и запоминает его в ch.  Результатом всего
выражения, в итоге, будет значение введенного с клавиатуры симво-
ла. Приведем еще один пример:
              ch='a';
              if((oldch = ch, ch = 'b') == 'a')
                puts("Это символ 'a'\n");
              else
                puts("Это символ 'b'\n");

     Как вы считаете, какое сообщение будет выведено на экран ва-
шего дисплея в результате выполнения приведенной выше программы?


     4.1.10. Приоритет и порядок выполнения операций

     Если в  выражении  не используются круглые скобки,  задающие
порядок выполнения операций,  то группировка операндов для опера-
ций производится с учетом приоритета операций.  Например, в выра-
жении
                    first *= second <= third
операнд second группируется с операцией <=, поскольку операция <=
имеет более высокий приоритет, чем операция *=. Приведенное выра-
жение эквивалентно следующему:
                   first *= (second <= third).
     Заметьте, что выражение (second <=  third)  может  принимать
значение нуль или единица.
     В следующем примере
                     first = second -= third
операции = и -= имеют одинаковый приоритет, однако операнд second
группируется  с операцией справа от него,  поскольку операции = и
-= являются правоассоциируемыми (выполняются справа налево).
     Все двухместные и трехместные операции являются левоассоции-
руемыми (выполняются слева направо), за исключением условных опе-
раций и операций присваивания, являющихся правоассоциируемыми.

                             - 42 -

     В табл.4.1 приведены операции Турбо Си  в  порядке  убывания
приоритета.

     Таблица 4.1. Операции Турбо Си в порядке убывания приоритета
-----------------------------------------------------------------
Операция                          Назначение
-----------------------------------------------------------------
[]          Задание элемента массива
()          Вызов функции
.           Выбор поля структуры
->          Выделение поля структуры с помощью указателя
++,--       Постфиксное/префиксное увеличение и уменьшение на 1 -
            если и то и другое встречается в одном выражении,  то
            постфиксное имеет более высокий приоритет
sizeof      Определение размера переменной в байтах
(тип)       Приведение к типу
~           Побитовое отрицание
!           Логическое НЕ
-           Унарный минус
&           Определение адреса
*           Обращение по адресу
*,/,%       Умножение, деление и остаток - одинаковый приоритет
+, -        Сложение, вычитание -  одинаковый приоритет
<<,>>       Сдвиг влево, сдвиг вправо - одинаковый приоритет
<,>,<=,>=   Сравнение - одинаковый приоритет
==,!=       Равенство, неравенство - одинаковый приоритет
&           Побитовое И
^           Побитовое исключающее ИЛИ
|           Побитовое ИЛИ
&&          Логическое И
||          Логическое ИЛИ
?:          Условный оператор
=,+=,-=,*=, Присваивание и  замещение - одинаковый приоритет
/=,<<=,>>=,
&=,^=,|=
,           Операция запятая, которая предписывает последователь-
            ное вычисление выражений
-----------------------------------------------------------------


                             - 43 -


     4.2. Операторы присваивания

     Любой оператор присваивания,  заключенный в круглые  скобки,
является выражением с определенным значением,  которое получается
в результате этого присваивания.
     Например, выражение  (sum  = 5+3) имеет значение 8,  поэтому
выражение ((sum = 5+3) <= 10) будет всегда иметь значение  "исти-
на" (т.к. 8 <= 10). Более экзотичен следующий пример:

                if ((ch=getch()) == 'q')
                    puts("До свидания! Программа завершена.\n");
                else
                    puts("Продолжаем работу!\n");

     Как работает эта конструкция?  Если в программе используется
выражение ((ch=getch()) == 'q'),  то она, дойдя до него, останав-
ливается и переходит в состояние ожидания ввода символа с клавиа-
туры.  После того, как вы введете символ, осуществляется присваи-
вание введенного символа переменной ch  и  выполняется  сравнение
введенного  символа  с символом 'q'.  Если введенный символ равен
'q', то на экран будет выведено сообщение "До свидания! Программа
завершена.", в противном случае будет выведено сообщение "Продол-
жаем работу!".
     В языках Паскаль и Бейсик проверка на равенство производится
выражением
                          if (a = b).

                   if (a = b) puts("Равно");
                      else  puts("Не равно");

     Если это программа на Паскале  или  Бейсике,  то  вы  можете
предполагать, что будет напечатано "Равно", если a и b имеют оди-
наковое значение и "Не равно" в противном случае.
     Иначе происходит с программой на Си, где выражение a = b оз-
начает "Присвоить значение b переменной a",  и все выражение при-
нимает значение b. Поэтому во фрагменте, приведенном выше на язы-
ке Си,  присвоится значение b переменной a,  а затем напечатается
"Равно",  если b имеет нулевое значение, в противном случае - "Не

                             - 44 -

равно".
     Правильное решение следующее:

                   if (a == b) puts("Равно");
                      else puts("Не равно");


     4.3. Операторы условного перехода

     4.3.1. Оператор if-else

     Обратимся теперь  опять к оператору if,  который фигурировал
при рассмотрении предыдущих примеров. Оператор if имеет следующий
основной формат:
             if (значение)
                оператор1;
             else
                оператор2;

где "значение" является любым выражением,  которое приводится или
может быть приведено к целочисленному значению.  Если  "значение"
отлично от нуля ("истина"), то выполняется "оператор1", в против-
ном случае выполняется "оператор2".
     Дадим пояснение относительно двух важных моментов по исполь-
зованию оператора if-else.
     Во-первых, часть  "else  оператор2"  является необязательной
частью оператора if;  другими  словами,  правомерно  употребление
следующей формы оператора if:
                          if (значение)
                           оператор1;

     В этой  конструкции  "оператор1"  выполняется тогда и только
тогда,  когда "значение" отлично от нуля.  Если "значение"  равно
нулю, "оператор1" пропускается и программа продолжает выполняться
дальше.
     Во-вторых, что  делать если вы хотите выполнить более одного
оператора в зависимости от того ложно или истинно выражение, ука-
занное в операторе if? Ответ: используйте составной оператор if.
     Составной оператор состоит из:

                             - 45 -

     - левой или открывающей фигурной скобки ({)
     - последовательности  операторов,  разделенных  между  собой
       точкой с запятой (;)
     - правой или закрывающей фигурной скобки (})
     В приведенном  ниже  примере  в  предложении if используется
один оператор
                          if (b == 0.0)
              printf("Отношение не определено\n");
а в предложении else - составной оператор
          else {
             ratio = a/b;
             printf( "Значение отношения равно %f\n", ratio);
          }
     Вы можете так же заметить, что тело вашей программы (функции
main) является подобием составного оператора if.

     4.3.2. Условный оператор (?:)

     В некоторых  случаях необходимо произвести выбор между двумя
альтернативами (и результирующими значениями),  основанный на не-
котором условии.  Обычно это реализуется оператором if ...  else,
например, так:
                      if (a < b) return(a);
                      else       return(b);
     Но, как оказывается,  для реализации такого типа выбора дос-
таточно одной специальной конструкции. Ее формат следующий:
           выражение 1 ? выражение 2 : выражение 3.

     А смысл таков: "если выражение 1 верно, то вычисляется выра-
жение 2 и все выражение получает его значение;  иначе вычисляется
выражение  3 и передается его значение".  Используя эту конструк-
цию, приведенный выше фрагмент программы можно представить следу-
ющим образом:
                    return((a < b) ? a : b );

более того,  такие действия по определению минимального  из  двух
чисел можно реализовать как строку макроса:
               #define imin(a,b) ((a < b) ? a : b)


                             - 46 -

     Теперь, где  бы  ваша  программа  ни   встретила   выражение
imin(e1,e2), она замещает его на ((e1<e2) ? e1 : e2) и продолжает
вычисления.  Это в действительности наиболее общее  решение,  так
как  a и b больше не ограничены типом int;  они могут быть любого
типа, с которым можно выполнить операцию сравнения.

     4.4. Оператор выбора

     Часто бывает необходимо построить длинные конструкции типа
                 *done = 0;
                 do {
             cmd = toupper(getch());
                {  if (cmd == 'F') do_file_menu(done);
               else if (cmd == 'R') run_program();
               else if (cmd == 'C') do_compile();
               else if (cmd == 'M') do_make();
               else if (cmd == '?') do_project_menu();
               else if (cmd == 'O') do_option_menu();
               else if (cmd == 'E') do_error_menu();
               else handle_others(cmd,done);
                 } while (!*done);
             }

     Подобная ситуация встречается настолько часто, что в Си была
введена специальная управляющая структура которая носит  название
оператор switch. Вот та же функция, но записанная с использовани-
ем оператора switch :
             #include <ctype.h>
             do_main_menu(short *done)
             {
                 char cmd;
                 *done = 0;
                 do {
             cmd = toupper(getch());
                             switch(cmd) {
                         case 'F' : do_file_menu(done); break;
                         case 'R' : run_program(); break;
                         case 'C' : do_compile(); break;
                         case 'M' : do_make(); break;

                             - 47 -

                         case '?' : do_project_menu(); break;
                         case 'O' : do_option_menu(); break;
                         case 'E' : do_error_menu(); break;
                         default  : handle_others(cmd,done);
                 } while (!*done);
             }

     Эта функция организует цикл,  в котором символ  считывается,
преобразуется к значению на верхнем регистре, а затем запоминает-
ся в переменной cmd. Потом введенный символ обрабатывается опера-
тором switch на основе значения cmd.
     Цикл повторяется до тех пор,  пока выражение *done не станет
равным  1 (предположительно в функции do_file_menu или handle_ot-
hers).
     Оператор switch  получает  значение  cmd  и сравнивает его с
каждым значением метки case.  Если они совпадают,  начинается вы-
полнение  операторов  данной метки,  которое продолжается либо до
ближайшего оператора break,  либо до конца оператора switch. Если
ни одна из меток не совпадает, и вы включили метку default в опе-
ратор switch,  то будут выполняться операторы  этой  метки;  если
метки default нет, оператор switch целиком игнорируется.
     Значение value,  используемое в  switch(value)  должно  быть
приведено к целому значению. Другими словами, это значение должно
легко преобразовываться в целое для таких типов данных как  char,
разновидности enum и,  конечно,  int, а также всех его вариантов.
Нельзя использовать в операторе switch вещественные  типы  данных
(такие как float и double),  указатели, строки и другие структуры
данных, но разрешается использовать элементы структур данных сов-
местимых с целыми значениями.
     Хотя (value) может быть выражением  (константа,  переменная,
вызов функции,  и другие комбинации их), метки case должны содер-
жать константы.  Кроме того,  в качестве ключевого значения  case
может быть только одно значение.  Если бы do_main_menu не исполь-
зовало функцию toupper для преобразования  cmd,  оператор  switch
мог бы выглядеть следующим образом:
             switch (cmd) {
                 case 'f' :
                 case 'F' : do_file_menu(done);
                      break;

                             - 48 -

                 case 'r' :
                 case 'R' : run_program();
                      break;
                 ...

     Этот оператор  выполняет  функцию do_file_menu независимо от
того,  в каком регистре поступает значение cmd, аналогично выпол-
няются действия для других альтернатив значения cmd.
     Запомните, что для завершения данного case вы должны исполь-
зовать оператор break.  В противном случае будут выполняться пос-
ледовательно все операторы,  относящиеся к другим меткам (до  тех
пор пока не встретится оператор break).
     Если вы уберете оператор break после вызова do_file_menu, то
при вводе символа F будет вызываться do_file_menu,  а затем будет
вызвана функция run_program.
     Однако иногда вам нужно сделать именно так.  Рассмотрим сле-
дующий пример:
     typedef enum( sun, mon, tues, wed, thur, fri, sat, ) days;
     main()
     {
         days today;
         ...
         swith (today) {
             case mon  :
             case tues :
             case wed  :
             case thur :
             case fri  : puts("Иди работать!");break;
             case sat  : printf("Убери во дворе и ");
             case sun  : puts("Расслабься!");
     }

     В этом операторе switch для значений от mon до fri  выполня-
ется одна и та же функции puts, после которой оператор break ука-
зывает на выход из switch. Однако, если today равно sat, выполня-
ется  соответствующая  функция  printf,  а затем выполняется puts
("Расслабься!"); если же today равно sun, выполняется только пос-
ледняя функция puts.


                             - 49 -

     4.5. Циклические конструкции в Си-программах

     Наряду с операторами (или группами операторов),  которые мо-
гут выполняться в зависимости от каких-либо  условий,  существуют
еще и операторы,  которые могут выполняться несколько раз в одной
и той же последовательности.  Такой вид конструкции  в  программе
известен как цикл.  Существуют три основных типа циклов (хотя два
из них можно рассматривать как разновидность  одного).  Это  цикл
while  ("пока"),  цикл for ("для") и цикл do...while ("делать ...
пока"). Рассмотрим их по порядку.

     4.5.1. Оператор while

     Цикл while является наиболее общим и может использоваться  вместо
двух  других типов циклических конструкций.  В принципе можно сказать,
что по-настоящему для программирования необходим только цикл while,  а
другие типы циклических конструкций служат лишь для удобства написания
программ.
     Рассмотрим пример программы:
    #inсlude <stdio.h>
     main()
     {
        char ch;
        int len;
        len=0;
        puts("Наберите предложение, затем нажмите <Ввод>");
          while ((ch=getch()) != '\n')  {
             putchar(ch);
             len++;
             }
      printf("\nВаше предложение имеет длину %d символов\n",len);
     }

     Эта программа позволяет ввести предложение  с  клавиатуры  и
подсчитать при этом,  сколько раз вы нажали на клавиши клавиатуры
до тех пор,  пока не нажали на клавишу <Ввод> (соответствует спе-
циальному  символу конца строки - '\n').  Затем программа сообщит
вам сколько символов (символ '\n' не  подсчитывается)  вы  ввели.
Для  отображения вводимых символов на экране дисплея используется

                             - 50 -

функция putchar,  так как функция getch  не  обеспечивает  режима
"эхо" для вводимых с ее помощью символов.
     Заметьте, что в условном выражении оператора while использу-
ется оператор присваивания.  Это позволяет программе читать и од-
новременно сравнивать считанные символы с символом, соответствую-
щим клавише <Ввод>. Если считанный символ не <Ввод>, то программа
отображает его на экране дисплея и увеличивает на единицу  значе-
ние len.
     Оператор while имеет следующий формат:

            while (выражение)
                оператор;

где "выражение"  принимает нулевое или отличное от нуля значение,
а "оператор" может представлять собой как один  оператор,  так  и
группу операторов.
     В процессе выполнения цикла while, вычисляется значение "вы-
ражения".  Если оно истинно, то "оператор", следующий за ключевым
словом while,  выполняется и "выражение" вычисляется снова.  Если
"выражение" ложно,  то цикл while завершается и программа продол-
жает выполняться дальше. Обратите внимание на другой пример цикла
while:

    main()
    {
       char *msg;
       int indx;
       msg = "Здравствуй, мир";
       indx = 1 ;
       while (indx <= 10 ) {
          printf("Время # %2d: %s\n", indx,msg);
          indx++;
          }
    }


     После компиляции и выполнения этой программы на экране будут
отображены строки со следующей информацией:


                             - 51 -

          Время # 1 : Здравствуй, мир
          Время # 2 : Здравствуй, мир
          Время # 3 : Здравствуй, мир
            ........................
          Время # 9 : Здравствуй, мир
          Время # 10 : Здравствуй, мир

     Очевидно, что оператор printf был выполнен ровно десять раз,
при этом значение параметра цикла indx изменилось от 1 до 10.
     Возможно переписать этот  цикл  несколько компактнее:
             indx = 0 ;
             while (indx++ < 10 )
                printf("Время #%2d: %s\n",indx,msg);

     4.5.2. Оператор for

     Цикл for является одним из основных  видов  циклов,  которые
имеются  во  всех универсальных языках программирования,  включая
Си.  Однако, версия цикла for, используемая в Си, как вы увидите,
обладает большей мощностью и гибкостью.
     Основная идея, заложенная в его функционирование, заключает-
ся в том,  что операторы,  находящиеся внутри цикла,  выполняются
фиксированное число раз, в то время как переменная цикла (извест-
ная еще как индексная переменная) пробегает определенный ряд зна-
чений. Например, модифицируем программу, о которой говорилось вы-
ше, в следующую:

     main()
     {
        char  *msg;
        int indx;
        msg = "Здравствуй, мир";
        for (indx = 1; indx <= 10; indx++ )
           printf("Время #%2d: %s\n",indx,msg);
     }

     Эта программа делает те же действия,  что и программа с цик-
лом while, которую мы уже разобрали, и является точным эквивален-
том первого ее варианта.

                             - 52 -

     Теперь приведем основной формат цикла for:
                     for (выр1; выр2; выр3)
                            оператор;
     Так же,  как и в цикле while,  "оператор" в теле  цикла  for
обычно является одним из операторов программы, но может использо-
ваться  и  составной  оператор,  заключенный  в  фигурные  скобки
({...}).
     Заметим, что параметры  цикла  for,  заключенные  в  скобки,
должны разделяться точкой с запятой (позиционный параметр), кото-
рая делит, в свою очередь, пространство внутри скобок на три сек-
тора.  Каждый параметр, занимающий определенную позицию, означает
следующее:
     - выр1 - обычно задает начальное значение индексной перемен-
              ной;
     - выр2 - условие продолжения цикла;
     - выр3 - обычно задает  некоторую  модификацию  (приращение)
              индексной переменной за каждое выполнение цикла.
     Основной вариант цикла for эквивалентен следующей  конструк-
ции, реализованной с помощью цикла while:
              выр1;
                while (выр2) {
                   оператор;
                выр3;
                }

     Вы можете опускать одно,  несколько или даже все выражения в
операторе for,  однако о необходимости наличия точек с запятой вы
должны помнить всегда. Если вы опустите "выр2", то это будет рав-
носильно  тому,  что значение выражения "выр2" всегда будет иметь
значение 1 (истина) и цикл никогда не завершится (такие циклы из-
вестны еще как бесконечные).
     Во многих случаях вам поможет использование операции запятая
(,),  которая  позволяет  вводить  составные выражения в оператор
цикла for. Вот, например, еще одна правильная модификация выраже-
ний в операторе for:
    main()
    {
       char *msg;
       int up,down;

                             - 53 -

       msg = "Здравствуй, мир";
       for (up = 1, down = 9; up <= 10; up++, down--)
        printf("%s: %2d растет, %2d уменьшается \n",msg,up,down);
    }
     Заметьте, что и первое,  и последнее выражение в этом  цикле
for состоит из двух выражений,  инициализирующих и модифицирующих
переменные up и down. Вы можете сделать эти выражения сколь угод-
но сложными.  Возможно вы слышали о легендарных хаккерах Си (hac-
ker - программист, способный писать программы без предварительной
разработки  спецификаций и оперативно вносить исправления в рабо-
тающие программы, не имеющие документации) которые включают боль-
шинство  своих  программ  в три условных выражения оператора for,
оставляя в теле цикла лишь несколько операторов.

     4.5.3. Оператор do...while

     Последним видом цикла является цикл  do...while.  Рассмотрим
программу:
     main()
     {
        float a,b,ratio;
        char ch;
        do {
          printf("Введите два числа: ");
          scanf("%f %f", &a, &b);
          if (b == 0.0)
             printf("\nВнимание! Деление на ноль!");
          else {
             ratio = a/b;
             printf("\nРезультат деления двух чисел: %f",ratio);
          }
          printf("\nНажми 'q' для выхода или любую клавишу для
                  продолжения")
        } while (( ch = getch()) != 'q');
     }
     Эта программа  вычисляет  результат  деления одного числа на
другое. Оба числа вводятся по запросу программы с клавиатуры. Ес-
ли вы введете символ 'q',  то выражение в операторе цикла while в
конце программы примет значение "ложь" и цикл (а значит  и  прог-

                             - 54 -

рамма) завершится.  Если вы введете какой-либо другой символ, от-
личный от 'q',  то выражение будет иметь значение "истина" и цикл
повторится.
     Формат цикла do...while можно представить в виде:
                    do оператор; while (выр);

     Основное отличие  между  циклом  while и циклом do...while в
том,  что операторы внутри do...while всегда выполняются хотя  бы
один  раз (т.к.  проверка условия выполнения цикла осуществляется
после выполнения последовательности операторов составляющих  тело
цикла).  Это похоже на цикл repeat...until в Паскале с одним, од-
нако,  различием:  цикл   repeat   выполняется  д о  т е х  п о р
(until), пока  его  условие "ложь"; а цикл do...while выполняется
п о к а (while) его условие "истина".

     4.6. Операторы передачи управления

     Это дополнительные операторы,  предназначенные для использо-
вания  в  управляющих операторах или для моделирования других уп-
равляющих структур.  Оператор return позволяет вам досрочно выйти
из функции.  Операторы break и continue предназначены для исполь-
зования в цикле  и  позволяют  пропустить  последующие  операторы
программы.
     Один совет:  подумайте дважды перед  использованием  каждого
оператора передачи управления (за исключением,  конечно, return).
Используйте их в тех случаях,  когда они  представляют  наилучшее
решение,  но  помните,  что чаще всего вы можете решить возникшую
перед вами проблему без их помощи.  Особенно избегайте  оператора
goto:  операторы return, break или continue наверняка заменят его
вам.

     4.6.1. Оператор return

     Существует два основных способа использования оператора  re-
turn.
     Во-первых, в том случае,  когда функция возвращает значение,
и  вам  необходимо использовать его в зависимости от того,  какое
значение возвращается в вызывающую программу, например:
              int  imax(int a, int b)

                             - 55 -

              {
                if (a > b) return(a);
                else       return(b);
              }

     Здесь функция  использует  оператор  return  для возвращения
максимального из двух переданных ей значений.
     Второй способ  использования оператора return состоит в воз-
можности выxода из функции в некоторой точке  до  ее  завершения.
Например,  функция может определить условие, по которому произво-
дится прерывание. Вместо того, чтобы помещать все основные опера-
торы  функции внутрь оператора if,  для выхода можно использовать
оператор return.  Если функция имеет тип VOID (т.е. не возвращает
никакого значения),  можно написать return без возвращаемого зна-
чения.
     Рассмотрим фрагмент программы:
              int imin(int list[], int size)
              {
                int i, minindx, min;
                if (size <= 0) return(-1);
                ...
              }
     В этом примере,  если параметр size меньше либо равен  нулю,
то массив list пуст, в связи с чем оператор return вызывает выход
из функции.
     Заметим, что в случае ошибки возвращается значение -1.  Т.к.
-1 никогда не может быть индексом массива,  вызывающая  программа
регистрирует факт возникновения ошибки.

      4.6.2. Оператор break

     Иногда бывает  необходимо  выйти из цикла до его завершения.
Рассмотрим следующую программу:
         #define LIMIT 100
         #define MAX  10
         main()
         {
           int i,j,k,score;
           int scores[LIMIT][MAX];

                             - 56 -

           for (i = 0; i < LIMIT; i++) {
                   j = 0;
                   while (j < MAX-1) {
                    printf("Введите следующее значение #%d: ",j);
                           scanf("%d", score);
                           if (score < 0)
                                  break;
                           scores[i][++j] = score;
                   }
                   scores[i][0] = j;
           }
         }
     Рассмотрим оператор if (score < 0) break;. Он указывает, что
если пользователь введет отрицательное значение score, цикл while
прерывается.  Переменная j используется и в качестве индекса sco-
res и в качестве счетчика общего количества  элементов  в  каждой
строке; это значение записывается в первом элементе строки.
     Вспомните, пожалуйста,  использование оператора break в опе-
раторе switch, представленное ранее. Там break указывает програм-
ме выйти из оператора switch;  здесь он указывает программе выйти
из  цикла  и  продолжить работу.  Кроме оператора switch оператор
break может быть использован во всех трех циклах (for, while и do
...  while),  однако его нельзя использовать в конструкции if ...
else или в теле главной процедуры main для выхода из нее.

     4.6.3. Оператор continue

     Иногда нужно не выходить из цикла, а пропустить ряд операто-
ров в теле цикла и начать его заново.  В этом случае можно приме-
нить оператор continue, предназначенный специально для этого. Об-
ратите внимание на следующую программу:
              #define LIMIT 100
              #define MAX  10
              main()
              {
                int i,j,k,score;
                int scores[LIMIT][MAX];
                for (i = 0; i < LIMIT; i++) {
                        j = 0;

                             - 57 -

                        while (j < MAX-1) {
                    printf("Введите следующее значение #%d: ",j);
                           scanf("%d", score);
                           if (score < 0)
                                   continue;
                           scores[i][++j] = score;
                        }
                        scores[i][0] = j;
                }
              }
     Когда выполняется оператор  continue,  программа  пропускает
остаток цикла и начинает цикл сначала. В результате эта программа
работает иначе,  чем предыдущая. При вводе пользователем числа -1
считается что была сделана ошибка, и вместо выхода из внутреннего
цикла цикл while начинается сначала. Поскольку значение j не было
увеличено, программа снова просит ввести то же значение.

     4.6.4. Оператор goto

     Формат оператора goto: goto метка,
где "метка" - любой идентификатор, связанный с определенным выра-
жением.  Однако наиболее разумное решение при программировании на
Си - обойтись без использования оператора goto. Для этого предус-
мотрено  три оператора цикла.  Подумайте внимательно,  прежде чем
использовать оператор goto,  действительно ли он вам нужен в соз-
давшейся  ситуации  и  может  быть его можно заменить на оператор
цикла?


  5. Структура программ

     5.1. Структура Си-программы

     Турбо Си предоставляет необычно высокую гибкость  для  физи-
ческой  организации программы или программных систем.  Рассмотрим
типичную организацию программы на Турбо Си.  Заметим,  что обычно
(но не обязательно) первой по порядку в тексте программы функцией
является функция main.


                             - 58 -

     /*Заголовки и комментарии, описывающие программу*/

     /*Директивы include*/
     #include имя_файла_1
     ...
     #include имя_файла_n

     /*Макро*/
     #define макро_1 значение_1
     ...
     #define макро_n значение_n

     /*Описание глобальных переменных*/
     тип_данных глобальная_переменная_1;
     ...
     тип_данных глобальная_переменная_n;

     main()
     {
     /*Описания extern, обеспечивающие ссылку вперед на функции
       и используемые в теле функции main*/

     /*Описания локальных переменных*/
     тип_данных локальная_переменная_1;
     ...
     тип_данных локальная_переменная_m;

     /*Тело функции main*/
     ...
     }

     /*Функции, используемые в программе main*/

     Тип_данных имя_функции_1 (формальные параметры)
     {
     /*Описания extern, обеспечивающие ссылку вперед на функции
       и используемые в теле данной программы*/

     /*Описания локальных переменных*/

                             - 59 -

     тип_данных локальная_переменная_1;
     ...
     тип_данных локальная_переменная_u;

     /Тело функции - 1*/
     ...
     }
     ...

     Тип_данных имя_функции_n (формальные параметры)
     {
     /*Описания extern, обеспечивающие ссылку вперед на функции
       и используемые в теле данной функции n */

     /*Описания локальных переменных*/
     тип_данных локальная_переменная_1;
     ...
     тип_данных локальная_переменная_r;

     /*Тело функции n */
     ...
     }

     Структура каждой  функции  совпадает  со  структурой главной
программы (main).  Поэтому функции иногда еще называются подпрог-
раммами.  Подпрограммы решают небольшую и специфическую часть об-
щей задачи.

     5.2. Функции

     Процесс разработки  программного  обеспечения   предполагает
расчленение  сложной  задачи на набор более простых задач и зада-
ний.  В Турбо Си поддерживаются функции  как  логические  единицы
(блоки текста программы), служащие для выполнения конкретного за-
дания.  Важным аспектом разработки программного обеспечения явля-
ется  функциональная  декомпозиция,  за последние годы получившая
широкое распространение.  Большинство современных языков програм-
мирования  высокого уровня поддерживают функциональную декомпози-
цию.

                             - 60 -

     Функции имеют нуль или более формальных параметров и возвра-
щают значение скалярного типа,  типа void (пусто) или  указатель.
При  вызове функции значения,  задаваемые на входе,  должны соот-
ветствовать числу или типу формальных параметров в описании функ-
ции.  Если функция не возвращает значения (т.е. возвращает void),
то она служит для того,  чтобы изменять свои параметры  (вызывать
побочный эффект) или глобальные для функции переменные.
     Теоретически, каждая функция возвращает некоторое  значение.
Практически же, значения, возвращаемые большинством функций игно-
рируются и целое семейство новых определений  языка  Си  (включая
проект  стандарта  Си,  предложенный ANSI,  и Турбо Си) позволяют
описывать и использовать в языке функции типа void,  которые  ни-
когда не возвращают значений.
     В Си вы можете и описывать и определять  функцию.  Когда  вы
описываете  функцию,  то даете всем остальным программам (включая
главный модуль main) информацию о том,  каким образом должно осу-
ществляться обращение к этой функции.  Когда вы определяете функ-
цию,  вы присваиваете ей имя,  по которому к ней  будет  осущест-
вляться обращение, и указываете, какие конкретно действия она бу-
дет выполнять. Рассмотрим программу:
     /* Описание функций */

     void  get_parms(float *p1, float *p2);
     float get_ratio(float divident, float divisor);
     void  put_ratio (float quotient);
     const float INFINITY = 3.4E+38;

     /* Главная (main) функция: стартовая точка программы */

     main()
     {
      float a,b,ratio;
      char ch;
       do {
        get_parms(&a,&b);                   /* ввод параметров */
        ratio = get_ratio(a,b);         /* вычисление частного */
        put_ratio(ratio);       /* печать выходного результата */
         printf("Нажми 'q' для выхода или любую клавишу для
                 продолжения\n");

                             - 61 -

           } while ((ch = getch()) != 'q');
     }
     /* конец main */
     /* Определение функций */

     void get_parms(float *p1, float *p2)
     {
        printf("Введите два числа: ");
        scanf("%f %f", p1, p2);
     }
     float get_ratio(float divident, float divisor)
     {
        if (divisor == 0.0)
            return (INFINITY);
        else
            return(divident / divisor);
     }
     void put_ratio(float ratio)
     {
        if (ratio == INFINITY)
           printf("Внимание! Деление на ноль!\n");
        else
           printf("Результат деления двух чисел: %f\n",ratio);
     }

     5.2.1. Анализ программы

     Первые три строки программы - описание функций; они вводятся
для того, чтобы описать как тип функций, так и порядок следования
их параметров с целью избежания ошибок.
     Следующая строка описывает константу с плавающей точкой, ко-
торой  присваивается имя INFINITY (в соответствии с принятым в Си
соглашением имена констант состоят из заглавных букв).  Эта конс-
танта  имеет очень большое положительное значение - наибольшее из
допустимых для типа float,  и используется как флаг возникновения
ситуации деления на ноль (divide-by-zero).
     Заметьте, что несмотря на то,  что константа описана  здесь,
она "видима" внутри всех функций (включая главную функцию).
     Далее следует функция main (главная функция),  которая явля-

                             - 62 -

ется основным телом вашей программы.  Каждая программа на Си обя-
зательно содержит функцию с именем main. Когда ваша программа на-
чинает выполняться, вызывается функция main и дальнейшее выполне-
ние программы продолжается под ее управлением.  Когда  выполнение
функции  с именем main заканчивается,  то завершается и вся прог-
рамма,  после чего управление  передается  интегрированной  среде
Турбо Си или,  если вы выполняли программу непосредственно в DOS,
то монитору DOS.
     Функция main может быть расположена в любом месте программы,
наиболее часто - это первая функция  программы.  Это  обусловлено
тем,  что  расположение функции main в начале программы облегчает
ее чтение, описание прототипов функций и различных глобальных пе-
ременных.  Это, в свою очередь, позволяет облегчить поиск и доку-
ментирование функций во всей программе.
     После main  следует  фактическое  определение  трех функций,
прототипы которых  были  описаны  выше:  get_parms,  get_ratio  и
put_ratio. Рассмотрим отдельно каждое из определений.
     Функция get_parms не возвращает никакого значения,  так  как
ее  тип  мы определили как void.  Это было сделано в связи с тем,
что функция служит лишь для чтения двух значений и сохранения  их
в некотором месте.  В котором?  Сейчас дадим некоторые пояснения.
Итак,  мы передаем в get_parms два параметра.  Эти параметры есть
адреса,  по которым должны быть размещены считанные функцией зна-
чения.  Обратите внимание! Оба параметра не являются данными типа
float,  но являются указателями на переменные типа float. Другими
словами, мы работаем непосредственно с адресами памяти по которым
размещены переменные типа float.
     В соответствии с этим и организовано обращение к функции  из
main:  когда  мы вызываем get_parms из main,  параметрами функции
являются &a и &b (адреса),  а не текущие значения a и b. Заметьте
также,  что вся информация,  используемая при обращении к функции
scanf, находится непосредственно внутри функции get_parms и перед
параметрами  p1  и p2 не стоят знаки операций адресации.  Почему?
Потому, что p1 и p2 уже сами по себе адреса; они являются адреса-
ми переменных a и b.
     Функция get_ratio возвращает результат (типа float) обработ-
ки  двух  значений типа float,  передаваемых ей (divident и divi-
sor). Возвращенный функцией результат зависит от того, равно зна-
чение переменной divisor нулю или нет. Если значение divisor рав-

                             - 63 -

но нулю,  get_ratio возвращает константу  INFINITY.  Если  нет  -
действительное значение частного двух чисел. Обратите внимание на
вид оператора return.
     Функция put_ratio не возвращает значение, т.к. ее тип объяв-
лен как void.  Она имеет ровно один параметр - ratio, который ис-
пользуется  для  того,  чтобы определить,  какое именно сообщение
следует выводить на экран дисплея.  Если  ratio  равно  INFINITY,
значит  значение частного двух чисел считается неопределенным,  в
противном случае значение ratio выводится на  экран  дисплея  как
результат работы программы.

     5.2.2. Использование классов памяти при организации доступа
            к данным

     Константы, типы данных и переменные,  описанные вне  функций
(включая  main),  считаются глобальными ниже точки описания.  Это
позволяет использовать их внутри функций в пределах всей програм-
мы вследствие того,  что они уже описаны и известны во всех функ-
циях ниже точки описания. Если вы переместите описание INFINITY в
функцию main,  то компилятор выдаст сообщение о том, что им обна-
ружены две ошибки:  одна из них -  в  get_ratio,  a  другая  -  в
put_ratio.  Причина ошибок - использование неописанного идентифи-
катора.

     5.2.3. Описание функций

     Вы можете использовать два различных стиля описания  функций
как  классический стиль,  так и современный.  Классический стиль,
который нашел широкое применение в большинстве  программ  на  Си,
имеет следующий формат:

                       тип имя_функции() ;

     Эта спецификация описывает имя функции ("имя_функции") и тип
возвращаемых ею значений ("тип").  Это описание не содержит ника-
кой информации о параметрах функции,  однако это не вызовет обна-
ружение ошибки компилятором или преобразования типов к типу,  уже
принятому  контекстно,  в соответствии с принятыми соглашениями о
преобразовании типов.  Если вы перепишите описания функций в пре-

                             - 64 -

дыдущей программе, используя этот стиль, то вновь полученные опи-
сания приобретут вид:

             void   get_parms();
             float  get_ratio();
             void   put_ratio();

     Современный стиль используется  в  конструкциях  расширенной
версии Си,  предложенной ANSI. При описании функций в этой версии
Си используются специальные средства языка,  известные под назва-
нием  "прототип  функции".  Описание  функции с использованием ее
прототипа содержит дополнительно информацию о ее параметрах:

             тип имя_функции(пар_инф1,пар_инф2,...);

где параметр пар_инф1 имеет один из следующих форматов:

             тип
             тип имя_пар
             ...

     Другими словами,  при использовании прототипа функции должен
быть  описан  тип  каждого формального параметра либо указано его
имя.  Если функция использует переменный  список  параметров,  то
после указания последнего параметра функции в описании необходимо
использовать эллипсис (...).
     Подход к  описанию  функций  с помощью описания ее прототипа
дает возможность компилятору производить проверку на соответствие
количества и типа параметров при каждом обращении к функции.  Это
также позволяет компилятору выполнять по возможности  необходимые
преобразования.
     В начальной версии языка Си каждая функция возвращала значе-
ние некоторого типа;  если же тип не был описан,  то по умолчанию
функции присваивался тип int. Подобно этому функция, возвращающая
"сгенерированные" (нетипичные) указатели,  обычно описывалась как
возвращающая указатель типа char,  только потому,  что она должна
была хоть что-то возвращать.
     В Турбо Си существует стандартный тип void,  который  предс-
тавляется  как разновидность "нулевого" типа.  Любая функция,  не

                             - 65 -

возвращающая явно какое-либо значение,  может быть объявлена  как
функция типа void.  Заметим, что большинство программ, использую-
щих динамическое распределение памяти (например malloc), описыва-
ются как имеющие тип void. Это означает, что они возвращают нети-
пизированный указатель,  значение которого вы затем (в Турбо  Си)
можете присвоить указателю любого типа данных без предварительно-
го преобразования типов (хотя преобразования типов лучше  исполь-
зовать повсеместно, для сохранения совместимости).

     5.2.4. Определение функций

     Так же,  как  и в описании функций,  при определении функций
прослеживается два стиля - классический и современный.
     Классический формат определения функций имеет следующий вид:

            тип имя_функции(имена_параметров)
            определение параметров;
            {
               локальные описания;
               операторы;
            }

     Формат описания в современном стиле предусматривает  опреде-
ление параметров функции в скобках, следующих за "имя_функции":

             тип имя_функции(пар_инф, пар_инф, ...)

     Однако, в  этом  примере определение параметра "пар_инф" со-
держит всю информацию о передаваемом параметре: тип и идентифика-
тор.  Это позволяет рассматривать первую строку определения функ-
ции как часть соответствующего прототипа функции за одним  важным
исключением:  эта  строка определения функции не содержит точку с
запятой (;) в определении,  тогда как прототип функции всегда за-
канчивается  точкой  с  запятой.  Например,  определение  функции
get_parms в классическом стиле выглядит следующим образом:

            void get_parms(p1, p2)
            float *p1; float *p2;
            { ... }

                             - 66 -

     Но приверженец современного  стиля  программирования  на  Си
опишет эту же функцию иначе, с использованием прототипа:

            void get_parms(float *p1, float *p2)
            { ... }

     Заметьте, что ряд описаний (константы, типы данных, перемен-
ные),  содержащихся внутри функции (исключение составляет главная
функция main),  "видимы" или определены только внутри этой  функ-
ции.  Поэтому Си не поддерживает вложенность функций;  т.е. вы не
можете объявить одну функцию внутри другой.
     Функции могут быть размещены в программе в различном порядке
и считаются глобальными для всей  программы,  включая  встроенные
функции,  описанные до их использования. Старайтесь корректно ис-
пользовать функции,  которые еще вами не определены и не описаны;
когда  компилятор обнаружит функцию,  которую прежде он не встре-
чал,  он определит тип значений,  возвращаемый функцией как  int.
Если вы ранее определили тип возвращаемых ею значений как, напри-
мер, char*, то компилятор выдаст ошибку несоответствия типов дан-
ных.


     5.3. Типизация функций

     В Турбо Си описание extern,  заданное внутри функции,  имеет
действие в пределах данного блока.  Описание не  будет  распозна-
ваться вне блока,  в котором оно определено. Однако, Турбо Си бу-
дет запоминать описания, для того чтобы сопоставить их с последу-
ющими описаниями тех же самых объектов.
     Турбо Си поддерживает большинство предложенных ANSI расшире-
ний к определениям функций K&R,  включая,  в частности,  дополни-
тельные модификаторы функций и прототипы функций.  Турбо Си  под-
держивает  также  несколько  собственных расширений и определений
функций, таких как функции типа interrupt (прерывание).
     В дополнение к external и static,  Турбо Си поддерживает ряд
модификаторов,  специфицирующих описания функций:  pascal, cdecl,
interrupt, near, far и huge.



                             - 67 -

     5.3.1. Модификатор функции pascal

     Модификатор pascal,  используемый  в Турбо Си,  предназначен
для функций (и указателей на функции),  которые используют приня-
тую в Паскале последовательность передачи параметров.  Это позво-
ляет вам писать на языке Си функции, которые могут быть вызванны-
ми из программ,  написанных на других языках;  а также обращаться
из ваших Си программ к внешним программам,  написанным на  языках
отличных  от  Си.  Имя функции преобразуется к верхнему регистру,
для правильной работы компоновщика.
     Примечание: использование опции компилятора -p (Calling con-
vention...Pascal) будет вызывать обращение со всеми функциями  (и
указателями  на  эти  функции)  как если бы они были типа pascal.
Кроме того, функции, объявленные типа pascal, могут вызываться из
Си программ, также как и Си программа может быть вызвана из функ-
ции,  имеющей тип pascal. Например, если вы объявили и откомпили-
ровали следующую функцию:

     pascal putnums(unt i, int j, int k)
     {
        printf("And the answers are: %d, %d и %d\n",i,j,k);
     }
другая Си  программа может затем компоноваться с ней и обращаться
к ней, используя описание:

     pascal putnums(int i, int j, int k);
     main()
     {
        putnums(1,4,9);
     }
     Функции типа  pascal не могут иметь различное число аргумен-
тов,  как, например, функция printf. По этой причине вы не можете
использовать эллипсис (...) (т.е.  опускать подразумеваемый пара-
метр) в определении функции типа pascal.

     5.3.2. Модификатор функции cdecl

     Модификатор cdecl также является специфичным для  Турбо  Си.
Как и модификатор pascal,  он используется с функциями или указа-

                             - 68 -

телями на функции. Его действие отменяет директиву компилятора -p
и  разрешает  вызывать функции как обычные функции Си.  Например,
если вы при компиляции вышеприведенной программы установили опцию
-p,  но захотели использовать printf, то должны поступить следую-
щим образом:

     extern cdecl printf();
     putnums(int i, int j, int k);
     cdecl main()
     {
         putnums(1,4,9);
     }
     putnums(int i, int j, int k)
     {
         printf("And the answers are: %d, %d и %d\n",i,j,k);
     }

     Если программа компилируется с опцией -p,  то  все  функции,
используемые из библиотеки времени выполнения,  необходимо объяв-
лять как cdecl.  Если вы посмотрите файлы заголовков  (такие  как
STDIO.H),  то увидите, что каждая функция явно описана как cdecl,
т.е. заранее подготовлена к этому. Заметьте, что главная програм-
ма main должна быть также объявлена как cdecl, поскольку действие
стартового кода программы, написанного на Си, всегда начинается c
вызова модуля main.


     5.3.3. Модификатор функции interrupt

     Модификатор interrupt также является специфическим для Турбо
Си. Функции interrupt специально введены для использования с век-
торами прерываний процессоров типа 8086/8088. Турбо Си будет ком-
пилировать функцию типа interrupt в дополнительную функцию,  вход
и выход которой сохраняется в регистрах AX,  BX,  CX, DX, SI, DI,
ES и DS.  Другие регистры:  BP,  SP,  SS, CS и IP сохраняются как
часть  последовательности Си вызова или как часть самой обработки
прерывания.  Рассмотрим пример типичного определения функции типа
interrupt.


                             - 69 -

     void interrupt myhandler()
     {
          . . .
     }
     Вы можете  объявлять функции прерываний как функции типа vo-
id. Функции прерываний могут объявляться для любой модели памяти.
Для всех моделей, исключая huge, в регистр DS заносится программ-
ный сегмент данных. Для модели huge в DS заносится модульный сег-
мент данных.

     5.3.4. Прототипы функций

     При объявлении  функций в K&R допускается только указание ее
имени,  типа и скобок без параметров.  Параметры (если они  есть)
объявляются только во время явного определения самой функции.
     ANSI стандарт и Турбо Си разрешают вам использовать прототи-
пы функций для объявления функции. Эти объявления включают инфор-
мацию о параметрах функции. Компилятор использует данную информа-
цию для проверки вызовов функций на соответствие данных,  а также
для преобразования аргументов к требуемому типу.  Рассмотрим сле-
дующий фрагмент программы:
     long lmax(long v1, long v2);
     main()
     {
           int limit = 32;
           char ch   = 'A';
           long mval;
           mval = lmax(limit,ch);
     }

     Используя прототип  функции  для  lmax,  эта программа будет
преобразовывать параметры limit и ch к типу long, используя стан-
дартные  правила преобразования,  прежде чем они будут помещены в
стек для обращения к lmax. При отсутствии прототипа функции пара-
метры limit и ch были бы помещены в стек соответственно как целое
значение и символ;  в этом случае в lmax передавались бы парамет-
ры,  не совпадающие по размеру и содержанию с ожидаемыми. Это ве-
дет к возникновению проблем. В то время как Си в K&R не выполняет
никакого  контроля  типа  параметров или их числа,  использование

                             - 70 -

прототипов функций очень помогает выявлять "жучки" и другие ошиб-
ки программистов.
     Прототипы функций также помогают при документировании  прог-
рамм.  Например,  функция  strcpy  имеет два параметра:  исходную
строку и выходную строку.  Вопрос - как их  распознать?  Прототип
функции
            char  *strcpy(char *dest, char *source);

делает это ясным.  Если в файле заголовка имеются прототипы функ-
ций, то вы можете распечатать этот файл и получить большую инфор-
мацию необходимую для написания программы,  вызывающей эти  функ-
ции.
     Описание функции с включенным в скобки  единственным  словом
void означает, что функция совсем не имеет аргументов
                             f(void)
     В противном случае, в скобках указывается список параметров,
разделенных запятыми. Так, объявление может быть сделано в виде:
                       func(int *, long);
или с включением идентификаторов, как ниже:
                  func(int *count, long total);
     В обоих случаях,  указанных выше, функция func принимает два
параметра:  указатель на тип int,  названный count, и целую пере-
менную типа long,  названную total.  Включение  идентификатора  в
объявление  имеет смысл лишь для вывода его в диагностическом со-
общении, в случае возникновения несоответствия типа параметров.
     Прототип обычно определяет функцию как функцию,  принимающую
фиксированное число параметров.  Для Си функций, принимающих раз-
личное число параметров (таких, как printf), прототип функции мо-
жет заканчиваться эллипсисом (...), например
                  f(int *count, long total,...)
     У прототипов такого вида фиксированные параметры проверяются
во время компиляции,  а опущенные передаются,  как при отсутствии
прототипа.
     Рассмотрим несколько  примеров объявления функций и прототи-
пов.

     int f();     /* Функция возвращает величину типа int без */
                 /* информации о параметрах. Это классический */
                                                 /* стиль K&R */

                             - 71 -

     int f(void);    /* Функция возвращает значение типа int, */
                                   /* параметры не передаются */

     int p(int,long); /* Функция возвращает целое, а получает */
                                            /* два параметра; */
                       /* первый имеет тип int, второй - long */
     int pascal q(void); /* Функция типа pascal, возвращающая */
                            /* целое; параметры не передаются */
     char far * s(char *source, int kind); /* Функция возвра- */
                         /* щает указатель типа far на строку,*/
            /*а получает два параметра: типа char* и типа int */
     int printf(char *format,...);      /* Функция возвращает */
                      /* значение типа int, получая указатель */
                       /* на фиксированный параметр типа char */
              /* и любое количество дополнительных параметров */
                                         /* неизвестного типа */
     int (*fp)(int);    /* Указатель на функцию, возвращающую */
                           /* целое и получающую единственный */
                                            /* целый параметр */
     Ниже приводятся правила регламентирующие работу с  модифика-
торами  языка  и  формальными параметрами в вызовах функций Турбо
Си, как использующих прототипы, так и не использующих их:
Правило #1. Модификаторы языка для описания функций должны совпа-
            дать с  модификаторами,  используемыми  в  объявлении
            функции, для всех обращений к функции.
Правило #2.  Функция  может изменять значения формальных парамет-
            ров,  но это не оказывает какого-либо воздействия  на
            значения действительных аргументов в вызывающей прог-
            рамме, за исключением функций прерывания.
     Если прототип функции не объявлен предварительно,  то  Турбо
Си  преобразует  целочисленные  аргументы при обращении к функции
согласно правилам, приведенным в разделе "Арифметические преобра-
зования".  Если прототип объявлен, то Турбо Си преобразует задан-
ные аргументы к типу, назначенному для параметров.
     Если прототип  функции включает эллипсис (...),  то Турбо Си
преобразует все заданные аргументы функции  как  в  любом  другом
прототипе (до эллипсиса).  Компилятор будет расширять любые аргу-
менты, заданные после фиксированного числа параметров по нормаль-
ным правилам для аргументов функций без прототипов.

                             - 72 -

     Если есть прототип,  то число аргументов должно  быть  соот-
ветственным (за исключением случая, когда в прототипе использован
эллипсис). Типы должны быть совместимы только по размеру, для то-
го чтобы корректно производились преобразования типов.  Вы всегда
должны использовать явные преобразования аргументов к  типу,  до-
пустимому для прототипа функции.

     Следующий пример прояснит данные замечания:

   int strcmp(char *s1, char *s2);/* Полный прототип */
   int *strcpy();                 /*Прототип не определен*/
   int samp1(float, int, ...);    /* Полный прототип */
   samp2()
   {
   char *sx, *cp;
   double z;
   long a;
   float q;
   if (strcmp(sx, cp))            /* 1. Верно */
       strcpy(sx,  cp,  44);      /* 2. Верно, но не перено- */
                                  /* симо из Турбо Си */
   samp1(3, a, q);                /* 3. Корректно */
   strcpy(cp);                    /* 4. Ошибка при выполнении */
   samp1(2);                      /* 5. Ошибка при компиляции */
   }

     Пять вызовов (каждый с комментарием)  примера  демонстрируют
различные варианты вызовов функций и прототипов.
     В вызове No 1 использование функции strcmp явно соответству-
ет прототипу, что справедливо для всех случаев.
     В вызове No 2  обращение  к  strcpy  имеет  лишний  аргумент
(strcpy  определена для двух аргументов,  а не для трех).  В этом
случае Турбо Си теряет небольшое количество времени и создает код
для помещения лишнего аргумента в стек.  Это, однако, не является
синтаксической ошибкой, поскольку компилятор не знает о числе ар-
гументов strcpy. Такой вызов не допустим для других компиляторов.
     В вызове No 3 прототип требует,  чтобы первый  аргумент  для
samp1 был преобразован к float,  а второй - к int. Компилятор вы-
даст предупреждение о возможной потере  значащих  цифр  поскольку

                             - 73 -

при преобразовании типа long к типу int отбрасываются старшие би-
ты. (Вы можете избавиться от такого предупреждения, если зададите
явное преобразование к целому.) Третий аргумент, q, соответствует
эллипсису в прототипе.  Он преобразуется к типу  double  согласно
обычному арифметическому преобразованию.  Вызов полностью коррек-
тен.
     В вызове  No 4 снова вызывается strcpy,  но число аргументов
слишком мало. Это вызовет ошибку при выполнении программы. Компи-
лятор  будет  молчать  (если  даже число параметров отличается от
числа параметров в предыдущем вызове той же  функции),  т.к.  для
strcpy не определен прототип функции.
     В вызове No 5 функции samp1 задано слишком мало  аргументов.
Т.к.  samp1 требует минимум два аргумента, этот оператор является
ошибочным.  Компилятор выдаст сообщение о том,  что в  вызове  не
хватает аргументов.
     Важное замечание: если ваш прототип функции не соответствует
действительному определению функции,  то Турбо Си обнаружит это в
том и только в том случае,  если это определение находится в  том
же файле,  что и прототип. Если вы создаете библиотеку программ с
передаваемым набором прототипов (файлом include),  то  вы  должны
учитывать  включение файла с прототипами во время компиляции биб-
лиотеки,  с целью выявления любого противоречия между прототипами
и действительными определениями функций.

     5.4. Механизмы передачи параметров

     В Турбо Си параметры функции, за исключением параметров типа
указатель и массивов,  передаются по значению. При передаче пара-
метра по значению в функции создается локальная копия, что приво-
дит к увеличению объема используемой памяти. При вызове функции в
стеке отводится память для локальных копий параметров,  а при вы-
ходе из функции эта память  освобождается.  Рассмотренный  способ
использования памяти не только требует дополнительного пространс-
тва, но и отнимает часть времени счета.
     Рассмотрим пример программы, демонстрирующей, что при вызове
функции копии создаются для параметров, передаваемых по значению,
а для параметров, передаваемых по ссылке, - не создаются.



                             - 74 -


 #include <stdio.h>
 void test_function (int first, int second, int *third)
 {
  printf("\nАдрес first равен %p", &first);
  printf("\nАдрес second равен %p", &second);
  printf("\nАдрес third равен %p", third);
  *third +=1;
 }
  main()
 { extern void test_function (int first, int second, int *third);
   int a,b;
   int c=24;
   printf("\nАдрес a равен %p", &a);
   printf("\nАдрес b равен %p", &b);
   printf("\nАдрес c равен %p", &c);
   test_function (a,b,&c);
   printf ("\nЗначение c =%d\n", c);
 }

     У функции test_function - два параметра first и second,  пе-
редаваемые по значению,  и один параметр third,  передаваемый  по
ссылке.  Термин "ссылка" здесь означает ссылку на область памяти.
Поскольку параметр third является указателем на тип int,  то  он,
как и все параметры типа указатель и массивы, передается по ссыл-
ке.
     После того как выражение *third в теле функции test_function
увеличивается на единицу, новое значение присваивается переменной
c,  память  под  которую отведена в функции main.  Так получается
значение 25, являющееся результатом работы функции.
     Программа напечатает
     Адрес a равен FEC6
     Адрес b равен FEC8
     Адрес c равен FECA
     Адрес first равен FECO
     Адрес second равен FEC2
     Адрес third равен FECA
     Значение c = 25


                             - 75 -

     В качестве параметров функции можно использовать выражения:
     #include <stdio.h>
     void function_test (int a)
     {
      printf("\na=%d", a);
     }
     main()
     { extern void function_test (int a);
       int c=3,
           d=4,
           e=5,
           f=6;
       function_test (f= (c=d*e)+15);
       printf ("\n\nc =%d\n", c);
     }
     При задании  массива в качестве параметра функции передается
адрес первого элемента массива.  Если в теле  функции  заменяются
значения элементов массива, то изменяется непосредственно сам пе-
редаваемый массив.
     Если в  описании функции задано,  что параметр передается по
ссылке (т.е. он описан как указатель на тип), то в качестве пара-
метра при вызове функции передается адрес переменной.

     5.5. Понятие рекурсии

     Если функция вызывает саму себя,  то говорят,  что возникает
рекурсия. Рекурсию можно рассматривать просто как еще одну управ-
ляющую  структуру - управление из точки рекурсивного вызова пере-
дается на начало функции.  В действительности же рекурсия  -  это
мощный инструмент для разработки программ, с помощью которого да-
же большие объемы действий могут быть записаны всего  несколькими
строками программного кода.
     Рекурсией следует пользоваться осторожно и внимательно.  При
использовании рекурсивного вызова система сохранит в стеке значе-
ния всех автоматических переменных функции и  ее  параметров.  По
завершении рекурсивного вызова значения будут восстановлены и уп-
равление возвратится на оператор, стоящий непосредственно за опе-
ратором вызова.  Для размещения в стеке автоматических переменных
и значений параметров необходимы и память, и время счета.

                             - 76 -

     Рассмотрим пример простого типа рекурсии:
     #include <stdio.h>
     main()
     { extern void write_name (char *name, int count);
       write_name ("Турбо Си удобен и эффективен",3);
       printf ("\n");
     }
     void write_name (char *name, int count)
     {
      if (count>0)
      {
       printf("\n%s", name);
       write_name (name, count - 1);
       }
     }
     Рекурсивный вызов записан в последней  строке  функции  wri-
te_name.  При  возврате из рекурсивного вызова никаких действий в
программе больше не выполняется.  Такой тип рекурсии  практически
эквивалентен итерации. Использование параметра count функции wri-
te_name, передаваемого по значению, ведет к значительному расходу
памяти.  При каждом рекурсивном вызове текущее значение параметра
count заносится в стек.
     Программа выведет следующий текст:
                     Турбо Си удобен и эффективен
                     Турбо Си удобен и эффективен
                     Турбо Си удобен и эффективен



  6. Структуризация данных

     6.1. Указатели

     Переменные содержат данные,  т.е. текущую информацию для ра-
боты  вашей программы.  Но иногда важнее знать место расположения
данных,  чем собственно их значение. Именно для этого и использу-
ются указатели.
     Компьютер содержит в своей памяти (часто  называемой  RAM  -
Random  Access  Memory - память произвольного доступа) вашу прог-

                             - 77 -

рамму и совокупность данных. На самом нижнем уровне память вашего
компьютера  состоит  из бит,  мельчайших электронных схем которые
могут "запомнить" (пока компьютер включен) одно из двух значений,
обычно интерпретируемое как "0" и "1".
     Восемь бит группируются в один БАЙТ. Большим группам бит как
правило,  присваивается  имя:  обычно два байта составляют СЛОВО,
четыре байта составляют ДЛИННОЕ СЛОВО;  и для IBM PC  шестнадцать
байт составляют ПАРАГРАФ.
     Каждый байт в памяти  вашего  компьютера  имеет  собственный
уникальный адрес, так же, как каждый дом на любой улице. Но в от-
личие от большинства домов, последовательные байты имеют последо-
вательные адреса:  если данный байт имеет адрес N,  то предыдущий
байт имеет адрес N-1, а следующий - N+1.
     УКАЗАТЕЛЬ - это переменная,  содержащая адрес некоторых дан-
ных, а не их значение. Зачем это нужно?
     Во-первых, мы  можем использовать указатель места расположе-
ния различных данных и различных структур данных.  Изменением ад-
реса, содержащегося в указателе, вы можете манипулировать (созда-
вать,  считывать,  изменять) информацией в различных ячейках. Это
позволит вам, например, связать несколько зависимых структур дан-
ных с помощью одного указателя.
     Во-вторых, использование  указателей  позволит вам создавать
новые переменные в процессе выполнения  программы.  Си  позволяет
вашей  программе  запрашивать некоторое количество памяти (в бай-
тах), возвращая адреса, которые можно запомнить в указателе. Этот
прием известен как ДИНАМИЧЕСКОЕ РАСПРЕДЕЛЕНИЕ; используя его, ва-
ша программа может приспосабливаться к любому  объему  памяти,  в
зависимости  от  того как много (или мало) памяти доступно вашему
компьютеру.
     В-третьих, вы  можете  использовать  указатели для доступа к
различным элементам структур данных,  таким как  массивы,  строки
или структуры.  Указатель,  в сущности,  указывает место в памяти
вашего компьютера (а используя смещение  относительно  начального
адреса  можно указать целый сегмент памяти),  в котором размещены
те или иные данные.  Индексируя указатель,  вы получаете доступ к
некоторой последовательности байтов,  которая может представлять,
например, массив или структуру.
     Прежде чем  использовать указатели,  их необходимо объявить.
Рассмотрим следующую программу:

                             - 78 -

             main()
             {
               int ivar,*iptr;
               iptr = &ivar;
               ivar = 421;
               printf("Размещение ivar: %p\n",&ivar);
               printf("Содержимое ivar: %d\n", ivar);
               printf("Содержимое iptr: %p\n", iptr);
               printf("Адресуемое значение: %d\n",*iptr);
             }
     В ней объявлены две переменные:  ivar и iptr. Первая, ivar -
это целая переменная,  т.е. содержащая значение типа int. Вторая,
iptr  - это указатель на целую переменную,  следовательно она со-
держит АДРЕС значения типа int. Можно также сказать, что перемен-
ная iptr - это указатель,  так как перед ее описанием стоит звез-
дочка (*). В языке Си эта звездочка называется косвенным операто-
ром.
     В основном, данная программа делает следующее:
        - адрес переменной ivar присваивается iptr
        - целое значение 421 присваивается ivar
     Адресный оператор (&) позволяет получить адрес,  по которому
размещено значение переменной ivar.
     Результат работы программы:
        Размещение ivar: 166E
        Содержимое ivar: 421
        Содержимое iptr: 166E
        Адресуемое значение: 421
     Первые две строки указывают адрес и содержимое ivar.  Третья
представляет адрес,  содержащийся в iptr.  Как видите,  это адрес
переменной ivar,  т.е.  место в памяти, где ваша программа решила
создать переменную с идентификатором ivar. В последней строке пе-
чатается то,  что хранится по этому адресу - те же самые  данные,
которые уже присвоены переменной ivar.
     Заметим, что в третьем обращении к функции printf  использу-
ется выражение iptr,  содержимое которого есть адрес ivar. В пос-
леднем обращении к printf используется выражение  *iptr,  которое
позволяет получить данные, хранящиеся по этому адресу.
     Рассмотрим теперь небольшую вариацию предыдущей программы:


                             - 79 -

             main()
             {
                 int ivar,*iptr;
                 iptr  = &ivar;
                 *iptr = 421;
               printf("Размещение ivar: %p\n",&ivar);
               printf("Содержимое ivar: %d\n", ivar);
               printf("Содержимое iptr: %p\n", iptr);
               printf("Адресуемое значение: %d\n",*iptr);
             }
     В этой  программе  также адрес переменной ivar присваивается
iptr,  но вместо присваивания числа 421 переменной ivar, это зна-
чение присваивается по указателю *iptr.  Каков результат ?  Точно
такой же, как и в предыдущей программе. Почему ? Потому что выра-
жения  *iptr  и  ivar есть одна и та же ячейка памяти - поэтому в
этом случае оба оператора заносят значение 421 в  одну  и  ту  же
ячейку памяти.


     6.1.1. Динамическое распределение памяти

     В операционной  системе MS DOS для микропроцессора семейства
8086 и Турбо Си размер указателя  (число  байтов,  требуемых  для
размещения адреса памяти под указатель) зависит от модели памяти,
задаваемой при компиляции программы.  В Турбо Си программы  можно
компилировать  в расчете на шесть моделей памяти:  крошечная (ti-
ny),  маленькая (small) (модель по умолчанию),  средняя (medium),
компактная (compact), большая (large) и огромная (huge). Програм-
ма,  написанная на Турбо Си для машин семейства IBM PC в  расчете
на  конкретную  модель памяти,  может оказаться немобильной.  Все
синтаксические конструкции Турбо Си,  поддерживающие шесть  пере-
численных моделей памяти, являются расширением стандарта Си.
     Память для программы на Турбо Си требуется для  четырех  це-
лей:  для размещения ее программного кода, для размещения данных,
для динамического использования и для резервирования компилятором
на время выполнения программы.
     Концептуальная модель этих областей приведена на рис. 6.1.



                             - 80 -

     Старшие адреса памяти                 Младшие адреса памяти
┌──────┬─────────┬──────┬───────┬──────┬────────┬───────┬───────┐
│Буфера│Неисполь-│ Стек │Свобод-│ Куча │ Стати- │ Код   │Векторы│
│видео-│зуемая   │ ---> │ная    │ <--- │ ческие │ прог- │преры- │
│память│ о.п.    │      │память │      │ данные │ раммы │ваний  │
│ ПЗУ  │         │      │       │      │        │       │DOS    │
└──────┴─────────┴──────┴───────┴──────┴────────┴───────┴───────┘

            Рис 6.1. Распределение памяти в Турбо Си.

     Область памяти под код программы в процессе работы  остается
неизменным. Неизменной остается и память, отводимая под статичес-
кие данные. Объем памяти для кучи зависит от того, сколько памяти
запрашивает  программист  с  помощью функции calloc и malloc (эти
функции подробно рассматриваются в настоящей главе ниже).  Размер
использованной  памяти стека изменяется при активизации автомати-
ческих (локальных) переменных в функциях,  а также за счет  того,
что при вызовах функции в стек заносятся параметры функций.

     Модели памяти, поддерживаемые в Турбо Си

Крошечная: Во все четыре регистра сегментов (CS,  DS, SS, ES) за-
           сылается один и тот же адрес.  Под код программы, ста-
           тические данные, динамически размещаемые данные и стек
           отводится 64К памяти.  Такая модель налагает на задачу
           серьезные ограничения и используется только в тех слу-
           чаях,  когда особенно ощущается дефицит памяти.  Пере-
           менные  типа  указатель в такой модели памяти занимают
           только два байта (близкие  указатели).  Следовательно,
           переменные  типа  указатель  содержат  смещение внутри
           фиксированного сегмента памяти.
Маленькая: Под  код  программы  отводится  сегмент размером 64 К.
           Стек,  куча и статические данные размещаются  в  одном
           сегменте размером 64 К. Такая модель памяти принимает-
           ся по умолчанию и вполне подходит для многих маленьких
           и средних задач. Переменные типа указатель в такой мо-
           дели памяти занимают только два байта (близкие  указа-
           тели). Следовательно, переменные типа указатель содер-
           жат смещение внутри фиксированного сегмента памяти.

                             - 81 -

Средняя:   Размер памяти под код программы ограничен  1  Мбайтом.
           Это означает,  что в коде программы используются дале-
           кие указатели.  Стек, куча и статические данные, как и
           в случае маленькой модели памяти, размещаются вместе в
           сегменте памяти размером 64 К. Такую модель памяти ре-
           комендуется применять при программировании очень боль-
           ших программ,  не использующих большого объема данных.
           Для адресации (указания) в коде программы служат дале-
           кие указатели (сегмент и смещение),  занимающие четыре
           байта.  Таким образом,  все вызовы функций выполняются
           как далекие вызовы,  и все возвраты функций  считаются
           далекими.  Для  адресации  данных используются близкие
           указатели, занимающие два байта.
Компактная: Под код программы отводится 64 К. Под данные отводит-
           ся 1 Мбайт. Объем статических данных ограничивается 64
           К,  а размер стека,  как и для всех моделей,  не может
           превысить 64 К. Такая модель памяти должна применяться
           при создании малых и средних по размеру программ, тре-
           бующих  большого объема статических данных.  Адресация
           внутри программы выполняется с помощью близких  указа-
           телей  (их  размер - два байта).  Для адресации данных
           используются четырехбайтовые далекие указатели.
Большая:   Размер памяти под код программы ограничен  1  Мбайтом.
           Под статические данные отводится 64 К.  Куча может за-
           нимать до 1 Мбайта памяти. Такую модель приходится ис-
           пользовать  во многих больших задачах.  Как программа,
           так и данные адресуются далекими указателями, занимаю-
           щими четыре байта. В большой модели памяти ни одна от-
           дельная единица данных не может превышать 64 К.
Огромная:  Аналогична большой модели,но суммарный объем статичес-
           ких данных может превышать 64 К. огромная модель памя-
           ти не предусматривает огромных указателей.

     Изменим еще раз нашу программу:
             #include <alloc.h>
             main()
             {
                int *iptr;
                iptr = (int *) malloc(sizeof(int));

                             - 82 -

                *iptr = 421;
                printf("Содержимое iptr: %p\n", iptr);
                printf("Адресуемое значение: %d\n",*iptr);
             }
     Эта версия позволяет вполне обойтись без описания переменной
ivar,  которое  непременно  фигурировало  в  предыдущих примерах.
Вместо адреса этой переменной iptr присваивается  значение  (тоже
адрес  некоторой ячейки памяти),  возвращаемое функцией,  которая
называется malloc, и описана в библиотеке alloc.h (отсюда появле-
ние директивы #include в начале программы). Затем по этому адресу
присваивается значение 421 и выражение *iptr вновь,  как и в пре-
дыдущем примере, принимает значение 421.
     Обратите внимание,  что если вы теперь выполните  программу,
то получите иное значение iptr, чем раньше, но значение *iptr ос-
танется равным 421.
     Разберем теперь, что же делает оператор
               iptr = (int *) malloc(sizeof(int));
     Разобьем его на части:
- выражение sizeof(int) возвращает количество  байтов,  требуемое
  для хранения переменной типа int; для компилятора Турбо Си, ра-
  ботающего на IBM PC, это возвращаемое значение равно 2.
- функция  malloc(num)  резервирует  num  последовательных байтов
  доступной (свободной) памяти в компьютере,  а затем  возвращает
  начальный  адрес  размещения  в  памяти этой последовательности
  байтов.
- выражение (int *) указывает, что этот начальный адрес есть ука-
  затель на данные типа int.  Выражение такого вида известно  как
  выражение приведения типа (type casting). В данном случае Турбо
  Си не требует обязательного его применения.  Но в связи с  тем,
  что  для  других  компиляторов Си это выражение является обяза-
  тельным, при его отсутствии вы получите сообщение об ошибке:
               " Non-portable pointer assignment."
     (Непереносимое в другие системы присваивание указателя)
  Из соображений  переносимости  программного обеспечения,  лучше
  всегда предусматривайте явное приведение типов в своих програм-
  мах.
- наконец,  адрес, полученный с помощью функции malloc, запомина-
  ется в iptr. Таким образом, вами получена динамически созданная
  целая переменная к которой  вы  можете  обращаться  при  помощи

                             - 83 -

  идентификатора *iptr.
     Весь этот оператор можно описать следующим  образом:  "выде-
лить  в  памяти  компьютера некоторый участок для переменной типa
int,  затем присвоить начальный адрес  этого  участка  переменной
iptr, являющейся указателем на переменную типа int".
     Необходимо ли все это?  Да.  Почему?  Потому что без этого у
вас нет гарантии, что iptr указывает на свободный участок памяти.
iptr будет содержать некоторое значение,  которое вы  будете  ис-
пользовать  в качестве адреса,  но вам не будет известно,  не ис-
пользуется ли уже этот раздел памяти для  других  целей.  Правило
использования  указателей простое:  указатель всегда должен иметь
адрес до своего использования в программе.
     Иными словами,  не  присваивайте  целое  значение  выражению
*iptr без предварительного присвоения адреса в iptr.

     6.1.2. Модификаторы типа указателей: near, far, huge

     Турбо Си имеет три модификатора, воздействующих на косвенный
оператор (*),  и,  тем самым, модифицирующих указатели на данные.
Речь идет о near, far и huge.
     Турбо Си  позволяет использовать при компиляции одну из нес-
кольких моделей памяти. Модель, которую вы используете, определя-
ет (среди прочих деталей) внутренний формат указателей на данные.
Если вы используете малую модель памяти  (tiny,  small,  medium),
все указатели имеют длину только 16 бит и задают смещение относи-
тельно регистра сегмента данных (DS). Если вы используете большую
модель (compact, large, huge), все указатели на данные имеют дли-
ну 32 бита и задают адрес сегмента и смещение.
     Иногда, когда  используется модель данных одного размера,  у
вас может возникнуть желание объявить указатель  с  размером  или
форматом  другим  нежели у используемого по умолчанию.  Вы можете
сделать это с помощью модификаторов near, far и huge.
     Указатель типа near имеет размер 16 бит; он использует теку-
щее содержимое регистра сегмента данных (DS) для определения  ад-
реса  сегмента.  По  умолчанию  он используется для малых моделей
данных.  При использовании указателей  типа  near,  данные  вашей
программы ограничены размером 64 K текущего сегмента данных.
     Указатель типа far имеет размер 32 бита и содержит  как  ад-
рес, так и смещение. По умолчанию он используется для больших мо-

                             - 84 -

делей.  При использовании указателей типа far допускаются  ссылки
на данные в пределах адресуемого пространства 1 Мб процессора In-
tel 8088/8086.
     Указатель типа huge имеет размер 32 бита и аналогично преды-
дущему,  содержит адрес сегмента и смещение, однако, в отличии от
указателей типа far,  указатель huge всегда поддерживается норма-
лизованным:
   - операторы отношения (==, !=, <, >, <=, >=) работают коррект-
но с указателями типа huge; но не с указателями типа far;
   - любые  арифметические  операции над указателем huge воздейс-
твуют как на адрес сегмента,  так и на смещение (из-за нормализа-
ции);  при использовании far указателей - воздействие распростра-
няется только на смещение;
   - заданный  указатель типа huge может быть увеличен в пределах
1 Мб адресного пространства;  указатель типа far, соответственно,
будет циклически переходить на начало сегмента в 64К;
   - при использовании указателей типа  huge  требуется  дополни-
тельное время, т.к. программы нормализации должны вызываться пос-
ле выполнения любой арифметической операции над указателями.

     6.1.3. Указатели как формальные параметры функций

     В разделе 5 мы рассмотрели, как объявлять параметры функций.
Возможно  теперь вам более понятна причина использования указате-
лей в качестве формальных параметров функции, значения которых вы
можете изменять.
     Рассмотрим, например, следующую функцию:
             void swap(int *a, int *b)
             {
                 int temp;
                 temp = *a; *a = *b; *b =temp;
             }
     Эта функция swap (обмен) объявляет два формальных  параметра
a и b,  как указатели на некие данные типа int. Это означает, что
функция swap работает с адресами целых переменных (а не с их зна-
чениями). Поэтому будут обработаны данные, адреса которых переда-
ны функции во время обращения к ней.
     Далее представлена программа, вызывающая swap:


                             - 85 -

             main()
             {   extern void swap(int *a, int *b);
                 int i,j;
                 i = 421;
                 j = 53;
                printf("До обращения: i=%4d, j=%4d\n",i,j);
                 swap(&i,&j);
                printf("После обращения: i =%4d, j=%4d\n",i,j);
             }
     Вы видите, что эта программа действительно заменяет значение
i на значение j (переставляет их местами).  Заменим эту программу
на аналогичную ей, раскрыв процедуру swap в теле программы:
             main()
             {
                 int i,j;
                 int *a,*b,temp;
                 i = 421;
                 j = 53;
                printf("До обработки: i = %4d j = %4d\n",i,j);
                 a = &i;
                 b = &j;
                 temp = *a; *a = *b; *b =temp;
                printf("После обработки: i = %4d j = %4d\n",i,j);
             }
     Эта программа, конечно, приводит к тому же результату, что и
предыдущая,  поскольку не отличается от нее.  При вызове функции,
swap(&i,&j) значения двух фактических параметров (&i,&j) присваи-
ваются двум формальным параметрам (a и b),  обрабатываемым непос-
редственно операторами функции swap.

     6.1.4. Указатели на функции

     Указатель на функцию может быть описан как параметр и  пере-
даваться в функцию наряду с другими данными.
     При использовании указателя в вызываемой функции должна быть
снята ссылка на передаваемую функцию.
     Разрешается определять массивы функций. Указатели на функции
могут быть компонентами структур.
     Массивы функций удобно применять при реализации систем,  уп-

                             - 86 -

равляемых  с  помощью меню.  Каждому пункту меню ставится в соот-
ветствие реализующая его функция, указатель на которую помещается
в массив. После того как пользователь выбрал из меню интересующее
его действие, по индексу, соответствующему такому выбору, из мас-
сива выбирается функция, реализующая действие.
     Рассмотрим синтаксическую конструкцию,  требуемую для описа-
ния указателя на функцию. Она выглядит следующим образом:
                 typedef void (*menu_action) ();
     Здесь идентификатор  menu_action  определен как указатель на
функцию,  не имеющую параметров и возвращающую тип void.  Если бы
определение типа было задано по-другому:
                  typedef void *menu_action ();
то значение конструкции было бы совсем другим. В последнем случае
идентификатор menu_action задавал бы  имя  функции,  возвращающей
указатель на тип void.
     Символ ссылки * имеет более низкий приоритет,  чем  операция
(), и поэтому круглые скобки следует использовать для задания то-
го, что идентификатор menu_action является указателем на функцию,
возвращающую тип void, а не указателем на тип void.
     Теперь рассмотри еще одно определение типа:
              typedef float (*integrand) (float r);
     Здесь сообщено,  что integrand - это указатель на функцию  с
одним  параметром  типа float,  возвращающую значение типа float.
Такое определение типа можно использовать,  например, для написа-
ния универсальной функции интегрирования integral,  заголовок ко-
торой имеет следующий вид:
float integral (integrand f,float lower_limit,float upper_limit);
     Первым параметром функции integral является функция  f  типа
integrand.  Это  означает,  что f - указатель на любую функцию от
одного вещественного  параметра,  возвращающую  тип  float.  Если
функция my_function определена так:
     float my_function(float r)
     {
         return r * r - 3.0;
     }
то вызов функции integral будет выглядеть следующим образом:
          float answer=integral(my_function, 0.0, 5.0);
     Имя функции my_function выступает в  качестве  указателя  на
эту функцию, и поэтому не требуется указания ссылки.

                             - 87 -

     Рассмотрим пример программы,  управляемой с помощью меню  на
основе массива указателей функции.

     #include <stdio.h>
     #include <conio.h>
       typedef void(*menu_action) ();
     menu_action control[6];
     /*
     Внимание: управляющая таблица может быть инициализирована
               статически.
     */
     main()
     {
       extern void build_table (void);
       int choice;
       build_table();
       do
     {
       clrscr();
       printf("\n1 -> Пункт 1");
       printf("\n2 -> Пункт 2");
       printf("\n3 -> Пункт 3");
       printf("\n4 -> Пункт 4");
       printf("\n5 -> Пункт 5");
       printf("\n6 -> Пункт 6");
       printf("\n7 -> Выход из программы");
       printf("\n\n Введите номер пункта:");
       scanf("%d", &choice);
       if (choice >=1 && choice <=6)
          (*contol[choice -1]) ();
     else
         break;
     }
       while (1);     /* Бесконечный цикл */
       printf("\n");
     }
       void build_table(void)
     {
       extern void menu_item_1(void);

                             - 88 -

       extern void menu_item_2(void);
       extern void menu_item_3(void);
       extern void menu_item_4(void);
       extern void menu_item_5(void);
       extern void menu_item_6(void);
       control[0]=menu_item_1;
       control[1]=menu_item_2;
       control[2]=menu_item_3;
       control[3]=menu_item_4;
       control[4]=menu_item_5;
       control[5]=menu_item_6;
     }
       void menu_item_1(void)
     {
       printf("\nВыполнилось действие по пункту 1 меню");
     }
       void menu_item_2(void)
     {
       printf("\nВыполнилось действие по пункту 2 меню");
     }
       void menu_item_3(void)
     {
       printf("\nВыполнилось действие по пункту 3 меню");
     }
       void menu_item_4(void)
     {
       printf("\nВыполнилось действие по пункту 4 меню");
     }
       void menu_item_5(void)
     {
       printf("\nВыполнилось действие по пункту 5 меню");
     }
       void menu_item_6(void)
     {
       printf("\nВыполнилось действие по пункту 6 меню");
     }

     Тип menu_action является указателем на функцию, возвращаемую
тип void и не имеющую параметров.

                             - 89 -

     С помощью оператора
                     menu_action control[6];
задается массив из шести указателей.  В теле функции  build_table
каждому  элементу массива присваивается значение указателя на со-
ответствующую функцию.  В нашем примере каждая из  таких  функций
печатает простое сообщение.
     В функции main выводится меню,  и пользователю  предлагается
либо выбрать один из пунктов меню, либо завершить работу програм-
мы.  Выбор,  сделанный пользователем,  активизирует одну из шести
функций при помощи оператора
                   (*control[choice - 1]) ();
     Приведенный прием  является  удобным  при разработке больших
программ, управляемых с помощью меню. Добавление в такую програм-
му  новых возможностей требует лишь включения в массив указателей
программы build_table имен новых функций.

     6.1.5. Адресная арифметика в Си

     Каким образом вам необходимо поступить, если вы хотите, что-
бы  переменная-указатель  указывала  на три переменных некоторого
типа вместо одной? Рассмотрим одно из возможных решений:

                #include <alloc.h>
                main()
                {
                   #define NUMINTS 3
                   int *list,i;
                   list = (int *) calloc(NUMINTS,sizeof(int));
                   *list = 421;
                   *(list+1) = 53;
                   *(list+2) = 1806;
                   printf("Список адресов :");
                   for (i=0; i<NUMINTS; i++)
                         printf("%4p ",(list+i));
                   printf("\nСписок значений :");
                   for (i=0; i<NUMINTS; i++)
                         printf("%4d ",*(list+i));
                   printf("\n");
                }

                             - 90 -


     Вместо функции malloc эта программа использует функцию  cal-
loc c двумя параметрами:  первый показывает, для скольких элемен-
тов будет происходить резервирование памяти,  второй  -  величину
каждого элемента в байтах. После обращения к функции calloc, list
указывает на участок памяти размером 6 (3*2)  байта,  достаточный
для хранения трех переменных типа int.
     Более подробно рассмотрим следующие  три  оператора.  Первый
оператор вам знаком - *list = 421.  Он означает: "запомнить 421 в
переменной типа int,  расположенной по адресу , хранящемуся в пе-
ременной list".
     Следующий: *(list+1) = 53 - особенно важен для понимания. На
первый  взгляд,  его можно интерпретировать так:  "запомнить 53 в
переменной типа int, расположенной байтом дальше адреса, храняще-
гося в list". Если это так, то вы окажетесь в середине предыдущей
int-переменной (которая имеет длину 2 байта).  Это,  естественно,
испортит ее значение.
     Однако, ваш компилятор с Си не сделает такой ошибки. Он "по-
нимает", что list - это указатель на тип int, и поэтому выражение
list+1 представляет собой адрес байта,  определенного  выражением
list+(1*sizeof(int)),  и, поэтому, значение 53 не испортит значе-
ния 421 (т.е. для этого значения будет выделена другая ячейка па-
мяти).
     Аналогично, *(list+2)=1806    представляет    адрес    байта
list+(2*sizeof(int)) и 1806 запоминается,  не затрагивая два пре-
дыдущих значения.
     В общем, ptr+i для типа int представляет адрес памяти, опре-
деляемый выражением ptr+(i*sizeof(int)).
     Результат работы программы:
                 Список адресов : 066A 066C 066E
                 Список значений:  421   53 1806
     Заметьте, что адреса различаются не в один байт,  а в два, и
все три значения хранятся отдельно.
     Подведем итог: Если вы используете ptr, указатель на тип ty-
pe,  то выражение (ptr+1) представляет адрес памяти (ptr+(1*size-
of(type)),  где sizeof(type) возвращает количество байт, занимае-
мых переменной типа type. Сложение или вычитание указателей всег-
да выполняется в единицах того типа,  к которому относится указа-
тель.

                             - 91 -

     Список допустимых действий над указателями приведен в  табл.
6.1.

                Таблица 6.1. Операции над указателями
-----------------------------------------------------------------
    Операция                     Пояснение

  ptr1 == ptr2             Сравнение на равенство
  ptr1 != ptr2             Сравнение на неравенство
  ptr1 <  ptr2             Сравнение на меньше и
  ptr1 <= ptr2                          меньше или равно
  ptr1 >  ptr2             Сравнение на больше
  ptr1 >= ptr2                          больше или равно
  ptr2 - ptr1              Вычисление числа элементов между ptr2
                           и ptr1
  ptr1+int_val             Вычисление указателя, отстоящего от
                           ptr1 вверх
  ptr1-int_val             или вниз на int_val элементов
-----------------------------------------------------------------

     6.1.6. Использование неинициализированных указателей

     Серьезная опасность таится в присвоении значения по  адресу,
содержащемуся в указателе,  без первоначального присвоения адреса
этому указателю.
     Например:
                  main()
              {
                  int *iptr;
                  *iptr = 421;
                  printf("*iptr = %d\n",*iptr);
              }

     Эта ловушка опасна тем,  что программа, содержащая ее, может
быть "верна" и компилятор может не выдать  никаких  сообщений  во
время компиляции такой программы. В примере, указанном выше, ука-
затель iptr имеет некоторый произвольный адрес, по которому запо-
минается значение 421. Эта программа настолько мала, что шанс что
-нибудь затереть в памяти с ее помощью  ничтожно  мал,  однако  в

                             - 92 -

больших  программах возрастает вероятность разрушения других дан-
ных,  поскольку вполне возможно,  что по адресу iptr уже хранится
другая информация. Если вы используете модель самой маленькой па-
мяти (tiny),  в которой сегменты программы и данных занимают одну
и  ту  же область памяти,  то вы подвергаете себя риску испортить
свой же загрузочный модуль.  Поэтому старайтесь не рубить сук  на
котором вы сами же сидите и внимательно пишите программы, исполь-
зующие указатели.

     6.2. Массивы и их реализация

     6.2.1. Описание массивов

     Большинство языков высокого уровня - включая Си -  позволяют
определять МАССИВЫ,  т.е. индексированный набор данных определен-
ного типа.
     Рассмотрим программу:

             main()
             {
                   #define NUMINTS 3
                   int list[NUMINTS],i;

                   list[0] = 421;
                   list[1] = 53;
                   list[2] = 1806;
                   printf("Список адресов:");
                   for(i=0; i<NUMINTS; i++)
                         printf("%p ",&list[i]);
                   printf("\nСписок значений:");
                   for (i=0; i<NUMINTS; i++)
                         printf("%4d ",list[i]);
                   printf("\n");
              }

     Выражение int list[NUMINTS] объявляет list как массив  пере-
менных типа int,  c объемом памяти, выделяемым для трех целых пе-
ременных.
     К первой  переменной массива можно обращаться как к list[0],

                             - 93 -

второй - как к list[1] и третьей - как к list[2].
     В общем случае описание любого массива имеет следующий вид:
                        type name[size];
                      (тип  имя [размер]);
где type - тип данных элементов массива (любой  из  допустимых  в
           языке),
    name - имя массива.
    Первый элемент массива - это name[0], последний элемент - na-
me[size-1];  общий объем памяти в байтах определяется  выражением
size*(sizeof(type)).
     Описание: type *name[size] определяет массив  name  из  size
указателей на тип type.
     Другое описание: type (*name)[size] определяет указатель na-
me на массив из size элементов типа type.
     Вы, наверное, уже поняли , что существует определенная связь
между массивами и указателями.  Поэтому, если вы выполните только
что рассмотренную программу,  полученный результат будет вам  уже
знаком:
                 список адресов : 163A 163C 163E
                 список значений:  421   53 1806
     Начальный адрес другой,  но это единственное различие. В са-
мом деле, имя массива можно использовать как указатель; более то-
го, вы можете определить указатель как массив. Рассмотрим следую-
щие важные тождества:
                    (list + i) == &(list[i])
                   *(list + i) == list[i]
     В обоих случаях выражение слева эквивалентно выражению спра-
ва;  и вы можете использовать одно вместо другого, не принимая во
внимание, описан ли list как указатель, или как массив.
     Единственное различие между описанием list,как указателя или
как массива состоит в размещении самого массива.  Если вы описали
list  как  массив,  то программа автоматически выделяет требуемый
объем памяти,  а имя массива является константой-указателем. Если
же  вы  описали переменную list как указатель,  то вы сами обяза-
тельно должны выделить память под  массив,  используя  для  этого
функцию  calloc или сходную с ней функцию,  или же присвоить этой
переменной адрес некоторого сегмента памяти,  который уже был оп-
ределен ранее.
     Не забудьте, что индекс массива начинается с элемента [0], а

                             - 94 -

не  с  элемента [1].  Наиболее распространенная ошибка может быть
проиллюстрирована на примере следующей программы:
            main()
          {
              int list[100],i;
              for (i = 1; i <= 100; i++)
              list[i] = i + 1;
          }
     Данная программа  оставляет  первый элемент list - list[0] -
неинициализированным, и записывает значение в несуществующий эле-
мент list - list[100] - возможно испортив при этом другие данные.
     Правильная программа будет иметь следующий вид:
            main()
          {
              int list[100],i;
              for (i = 0; i < 100; i++)
              list[i] = i+1;
          }


     6.2.2. Инициализация массивов

     Начальные значения элементам массива можно присвоить в месте
описания массива следующим образом:
         тип имя_массива[] = {знач1, знач2, ..., значN};
     Начальные значения  элементов массива заключаются в фигурные
скобки.  Если пользователь не указал в квадратных скобках  размер
массива,  то компилятор сам задает размер массива по числу приве-
денных начальных значений в фигурных скобках.
     Рассмотрим программу:
     #include <stdio.h>
     int data[5] = {5, 4, 3, 2, 1};
     float scores[] = {3.4, 2.7, 1.8, 6.9, -24.3};
     char prompt[] = {'О', 'т', 'в', 'е', 'т', ':', '', '\О'};
     main();
     {
     printf("\nРазмер массива data = %d", sizeof(data));
     printf("\nРазмер массива scores = %d", sizeof(scores));
     printf("\nРазмер массива prompt = %d", sizeof(prompt));

                             - 95 -

     printf("\n\npromrt = %s\n", prompt)
     }
     Здесь описаны три массива: data, scores и prompt.
     При описании массива data явно указано, что он содержит пять
целых. Таким образом, его размер - 10 байтов.
     Размерности массивов scores[] и prompt[] заданы неявно путем
инициализации значений:  в первом случае - пяти вещественных чис-
ле, а во втором - восьми символов.
     Массив scores[] можно описать и как scores[5]. Соответствен-
но вместо описания prompt[] можно подставить и prompt[8].
     Если начальные значения не заданы, то все элементы указанных
массивов будут нулевыми,  поскольку  все  статические  переменные
инициализируются значением нуль.

     6.2.3. Строки и операции над ними

     Си не поддерживает отдельный строковый тип данных, но он все
же предусматривает два слегка отличающихся подхода к  определению
строк.  Один состоит в использовании символьного массива,  другой
заключается в использовании указателя на символ.
     Рассмотрим использование символьного массива для определения
строки:
     #include<string.h>
     main ()
     {
          char msg[30];
          strcpy(msg, "Hello, world");
          puts(msg);
     }
выражение [30],  после msg, предписывает компилятору выделить па-
мять  для 29 символов,  то есть для массива из 29 переменных типа
char (30-е знакоместо должно быть заполнено  нулевым  символом  -
\0.  Константа-указатель msg не содержит символьное значение; она
хранит адрес (некоторого места в памяти) первого из этих 29 пере-
менных типа char.
     Когда компилятор обнаруживает оператор  strcpy(msg,  "Hello,
world"), он делает следующее:
     - Создает строку "Hello, world", сопровождаемую нулевым (\0)
       символом (с кодом ASCII 0),в некотором месте файла объект-

                             - 96 -

       ного кода (резервирует 13 байт памяти).
     - Вызывает  подпрограмму  strcpy  из стандартной библиотеки,
       интерфейс с которой описан в файле string.h, которая копи-
       рует  символы  из  этой строки по одному в участок памяти,
       указываемый константой msg.  Он делает это до тех пор пока
       не  будет скопирован нулевой символ в конце строки "Hello,
       world".
     Когда вы вызываете функцию puts(msg),  то ей передается зна-
чение msg - адрес первой буквы,  на которую он  указывает.  Затем
puts  проверяет,  не  является ли символ по этому адресу нулевым.
Если да,  то puts заканчивает работу;  иначе puts  печатает  этот
символ, добавляет единицу (1) к адресу и делает проверку на нуле-
вой символ снова.
     Из-за этой  зависимости  от  нулевого символа известно,  что
строки в Си называются "завершающиеся нулем",  т.е. они представ-
ляют из себя последовательности символов, заканчивающиеся нулевым
символом.  Этот подход позволяет снять ограничения с длины строк;
строка может быть такой длины, какой позволяет память для ее хра-
нения.
     Второй метод,  который  можно  использовать  для определения
строк, - это указатель на символы. Рассмотрим программу:
     main()
     {
         char *msg;
         msg = "Hello, world";
         puts(msg);
     }
     Звездочка (*) впереди msg указывает компилятору, что msg яв-
ляется указателем на символ;  другими словами,  msg может хранить
адрес некоторого символа. Однако, при этом компилятор не выделяет
никакого пространства для размещения символов и не инициализирует
msg  каким-либо конкретным значением,  а лишь резервирует память,
необходимую для хранения указателя msg (два байта для малой моде-
ли памяти).
     Когда компилятор находит оператор msg = "Hello,  world "; он
делает следующее:
     - Как и раньше,  он создает строку "Hello, world", сопровож-
       даемую  нулевым  символом,  где-то внутри файла объектного
       кода.

                             - 97 -

     - Присваивает  начальный адрес этой строки - адрес символа H
       - переменной msg,  т.е. инициализирует указатель msg конк-
       ретным значением.
     Команда puts(msg) работает так же,  как  и  раньше,  печатая
символы до тех пор, пока она не встретит нулевой символ.
     В соответствии с K&R строковые константы состоят обязательно
из  одной строки,  имеющей конструкцию:  двойные кавычки,  текст,
двойные кавычки ("как эта").  Для продолжения символьной последо-
вательности на новой строке вы должны использовать обратный слеш.
     В Турбо Си разрешается использовать многостроковые  элементы
в строковых константах,  которые могут потребоваться для конкате-
нации (соединения) строк. Так, например, вы можете сделать следу-
ющее:
 main()
{
     char   *p;
     p = "Это пример того, как Турбо Си"
         " будет автоматически\nвыполнять конкатенацию"
         " ваших очень длинных строк,\nделая наглядным"
         " общий вид программ."
     puts(p);
}
     Вот результат работы программы:
          Это пример того, как Турбо Си будет автоматически
          выполнять конкатенацию ваших очень длинных строк,
          делая наглядным общий вид программ.
     Как мы уже говорили,  строки можно объявить как указатели на
тип данных char или как массивы данных типа char. Речь шла о том,
что между ними существует лишь одно важное различие:  если вы ис-
пользуете указатель на данные типа char, память для строки не ре-
зервируется;  если вы используете массив данных, то память резер-
вируется автоматически и константа-указатель - имя массива -  со-
держит адрес начала зарезервированной области памяти.
     Недостаточное понимание этой разницы может привести  к  двум
типам ошибок. Рассмотрим следующую программу:
              main()
              {
                  char *name;
                  char msg[10];

                             - 98 -

                  printf("Назовите свое имя.");
                  scanf("%s",name);
                  msg = "Здравствуйте, ";
                  printf("%s %s:",msg,name);
              }
     На первый  взгляд все законно,  немного неуклюже,  но вполне
допустимо. Однако здесь допущены две ошибки.
     Первая ошибка содержится в выражении:
                        scanf("%s",name).
     Выражение само  по себе законно и корректно.  Поскольку name
является указателем на char,  вам не нужно ставить перед ним  ад-
ресный  оператор (&).  Однако память для name не зарезервирована;
строка, которую вы введете, будет записана по какому-то случайно-
му адресу,  который окажется в name. Компилятор обнаружит это, но
поскольку эта ситуация не приведет к  сбою  выполнения  программы
(т.к. строка все же будет сохранена), компилятор выдаст лишь пре-
дупреждающее сообщение, но не ошибку.
           "Possible use of 'name' before definition"
       ("Возможно использование 'name' до ее определения")
     Вторая ошибка  содержится в операторе msg = "Здравствуйте,".
Компилятор считает, что вы пытаетесь заменить значение msg на ад-
рес строковой константы "Здравствуйте,".  Это сделать невозможно,
поскольку имена массивов являются константами,  и не  могут  быть
модифицированы (как, например, 7 является константой и нельзя за-
писать "7 = i"). Компилятор выдаст вам сообщение об ошибке:
                       "Lvalue required."
             ("Использование константы недопустимо")
     Каково решение  этой  проблемы?  Простейший выход - изменить
способ описания переменных name и msg:
              main()
              {
                   char name[10];
                   char *msg;
                   printf("Назовите свое имя");
                   scanf("%s",name);
                   msg = "Здравствуйте,";
                   printf("%s%s",msg,name);
              }


                             - 99 -

     Эта программа безупречна.  Переменной name выделяется память
независимо от памяти,  выделяемой для строки, которую вы вводите,
тогда  как в msg присваивается адрес строковой константы "Здравс-
твуйте,".  Если,  тем не менее,  вы оставите старое описание, вам
нужно изменить программу следующим образом:
              #include <string.h>
              #include <alloc.h>
              main()
              {
                   char *name;
                   char msg[10];
                   name = (char *) malloc (10);
                   printf("Назовите свое имя");
                   scanf("%s",name);
                   strcpy(msg,"Здравствуйте,");
                   printf("%s%s",msg,name);
              }
     Вызов функции malloc выделяет отдельно 10  байтов  памяти  и
присваивает  адрес  этого участка памяти name,  решив нашу первую
проблему.  Функция strcpy производит посимвольное копирование  из
строковой константы string "Здравствуйте," в массив msg.

     6.2.4. Многомерные массивы

     Описание многомерных массивов выглядит так:
               type name[size1][size2]...[sizeN];
            (тип имя [размер1][размер2]...[размерN])

     Рассмотрим следующую программу,  которая определяет два дву-
мерных массива, а затем выполняет их матричное умножение:
             main()
             {
                int a[3][4] = {{ 5,  3, -21, 42},
                               {44, 15,   0,  6},
                               {97 , 6,  81,  2}};
                int b[4][2] = {{22,   7},
                               {97, -53},
                               {45,   0},
                               {72,   1} };

                             - 100 -

                int c[3][2],i,j,k;
                for (i=0; i<3; i++) {
                    for (j=0; j<2; j++) {
                        c[i][j] = 0;
                        for (k=0; k<4; k++)
                            c[i][j] += a[i][k] * b[k][j];
                    }
                }
                for (i=0; i<3; i++) {
                    for (j=0; j<2; j++)
                        printf("c[%d][%d] = %d ",i,j,c[i][j]);
                    printf("\n");
                }
             }
     Отметим два момента в этой программе.  Синтаксис определения
двумерного  массива состоит из набора {...} списков,  разделенных
запятой.  Квадратные скобки ([ ]) используются для записи каждого
индекса.
     Некоторые языки для определения массивов используют  синтак-
сис [i,j]. Так можно написать и на Си, но это все равно, что ска-
зать просто [j],  т.к. запятая интерпретируется как оператор, оз-
начающий  ("  определить i,  затем определить j,  затем присвоить
всему выражению значение j").
     Для полной уверенности ставьте квадратные скобки вокруг каж-
дого индекса.
     Многомерные массивы  хранятся в памяти слева направо по пра-
вилу "строки - столбцы". Это означает, что последний индекс изме-
няется быстрее. Другими словами, в массиве arr[3][2] элементы arr
хранятся в памяти в следующем порядке:
     arr[0][0] arr[0][1] arr[1][0] arr[1][1] arr[2][0] arr[2][1]

     Тот же принцип сохраняется для массивов трех- и большей раз-
мерности.
     Выражение arr[i][j]  переводится компилятором Турбо Си в эк-
вивалентное выражение *(*(arr+i)+j).  Имя  массива  arr  является
константой-указателем на строку с индексом 0.  Выражение *(arr+i)
задает указатель на строку с индексом i.



                             - 101 -

     6.2.5. Массивы и функции

     Что произойдет,  если вы захотите передать массив в функцию?
Рассмотрим  следующую  функцию,  возвращающую индекс минимального
числа массива int:
             int imin(int list[], int size)
             {
                int i, minindx, min;
                minindx = 0;
                min = list[minindx];
                for (i = 1; i < size; i++)
                    if (list[i] < min) {
                        min = list[i];
                        minindx = i;
                    }
                return(minindx);
             }
     Здесь вы видите одну из важных особенностей Си: вам необяза-
тельно знать при трансляции величину list[].  Почему?  Потому что
компилятор  считает list[] начальным адресом массива,  и не забо-
тится о том, где его конец.
     Программа, обращающаяся к функции imin, может выглядеть так:
        #include <stdlib.h>
        #define VSIZE 22
        main()
        {  extern int imin(int list[], int size);
           int i,vector[VSIZE];
           for (i = 0; i < VSIZE; i++) {
               vector[i] = rand();
               printf("vector[%2d] = %6d\n",i,vector[i]);
           }
           i = imin(vector,VSIZE);
           printf("minimum: vector[%2d] = %6d\n",i,vector[i]);
        }
     Может возникнуть вопрос:  что именно передается  в  imin?  В
функцию imin передается начальный адрес массива vector. Это озна-
чает, что если вы производите какие-либо изменения массива list в
imin  то,  те  же изменения будут произведены и в массиве vector.
Например, вы можете написать следующую функцию :

                             - 102 -

        void setrand(int list[],int size);
        {
           int i;
           for (i = 0; i < size; i++) list[i] = rand();
        }
     Теперь для инициализации массива vector вы можете написать в
main setrand(vector,VSIZE).  Следует заметить, что массиву vector
будут присвоены некие случайные числа, являющиеся результатом ра-
боты  датчика  случайных  чисел,  эмулируемого  функцией Турбо Си
rand(), из диапазона: 0-32767.
     А как  передавать многомерный массив?  Имеется ли такая воз-
можность? Предположим, вы хотите модифицировать setrand для рабо-
ты с двумерным массивом. Вы должны написать приблизительно следу-
ющее:
        void setrand(int matrix[][CSIZE],int rsize)
        {
           int i,j;
           for (i = 0; i < rsize; i++) {
               for (j = 0; j < CSIZE; j++)
                   matrix[i][j] = rand();
           }
        }
     Где CSIZE  -  это глобальная константа,  определяющая второе
измерение массива.  Другими словами,  любой массив,  передаваемый
setrand получит второе измерение массива, равный CSIZE.
     В общем случае, если многомерный массив передается в качест-
ве параметра функции, то необходимо задавать все его размерности,
кроме первой.
     Однако, есть еще одно решение.  Предположим, у вас есть мас-
сив matrix[15][7],  который вы хотите передать в setrand. Если вы
используете следующее описание:
                  setrand(int list[],int size)
обращение к функции будет иметь вид:
                      setrand(matrix,15*7);
     Массив matrix будет рассматриваться функцией setrand как од-
номерный массив,  содержащий 105 элементов (15 строк *  7  столб-
цов), с которым будут произведены необходимые вам действия.



                             - 103 -

     6.2.6. Свободные массивы

     Свободными называются двумерные массивы или матрицы,  размер
каждой из строк которых может быть различным.
     Пример описания двумерного массива names,  который инициали-
зируется с использованием массива из  3  строк  (указателей  типа
char):
 char *names[]=
      {
       "Андрей",
       "Петр",
       "Николай"
      };
 Здесь names[0]="Андрей";
       names[1]="Петр";
       names[2]="Николай";
       имя массива names является адресом начала строки "Андрей".

     6.3. Структуры

     6.3.1. Описание структур

     Массивы и указатели позволяют вам создавать список элементов
одного типа. А что, если вы хотите создать нечто, содержащее эле-
менты различного типа? Для этого используются СТРУКТУРЫ.
     Структура - это конгломерат элементов различного  типа.  До-
пустим,  вы хотите сохранить информацию о звезде:  ее имя, спект-
ральный класс, координаты и прочее. Вы можете описать это следую-
щим образом:
             typedef struct {
                char   name[25];
                char   class;
                short  subclass;
                float  decl,RA,dist;
             } star ;
     Здесь определена структура (struct) типа star.  Сделав такое
описание в начале своей программы,  вы можете дальше использовать
этот определенный вами тип данных:


                             - 104 -

             main()
             {
                star mystar;
                strcpy(mystar.name,"Епсилон Лебедя");
                mystar.class    = 'N';
                mystar.subclass =  2;
                mystar.decl     =  3.5167;
                mystar.RA       = -9.633;
                mystar.dist     =  0.303;
                /* конец функции main() */
             }
     Вы обращаетесь к каждому элементу структуры,  используя  его
составное имя, состоящее из имени структурной переменной (на пер-
вом месте) и,  в порядке иерархической подчиненности, имен ее об-
разующих  элементов,  разделенных точками (.).  Конструкция вида:
varname.memname (имя переменной.имя элемента)  считается  эквива-
лентной имени переменной того же типа, что и memname, и вы можете
выполнять с ней те же операции.
     Вы можете описывать указатели на структуры точно так же, как
и указатели на другие типы данных.  Это необходимо  для  создания
связных  списков и других динамических структур данных элементами
которых, в свою очередь, являются структуры данных.
     Фактически указатели  на  структуры так часто используются в
Си,  что существует специальный  символ  для  ссылки  на  элемент
структуры,  адресованной указателем. Рассмотрим следующий вариант
предыдущей программы:
             #include <alloc.h>
             main()
             {
                star *mystar;
                mystar = (star *) malloc(sizeof(star));
                strcpy(mystar -> name,"Эпсилон Лебедя");
                mystar -> class    = 'N';
                mystar -> subclass =  2;
                mystar -> decl     =  3.5167;
                mystar -> RA       = -9.633;
                mystar -> dist     =  0.303;
                /* Конец функции main() */
             }

                             - 105 -

     В этом варианте mystar объявляется как указатель типа  star,
а  не  как переменная типа star.  Память для mystar резервируется
путем обращения к функции malloc.  ТЕПЕРЬ, КОГДА ВЫ ССЫЛАЕТЕСЬ НА
ЭЛЕМЕНТЫ mystar,  ИСПОЛЬЗУЙТЕ ptrname -> memnane. Символ -> озна-
чает,  что "элемент структуры направлен в ...";  это  сокращенный
вариант от обозначения (*ptrname).memnane принятый в Си.
     В общем случае структуры конструируются следующим образом:
     struct имя_структуры
     {
       тип_1 поле_1;
       тип_2 поле_2;
       ...
       тип_n поле_n;
     };

     Обратите внимание на точку с запятой после закрывающей скоб-
ки  в описании структуры.  Отсутствие такого разделителя является
частой синтаксической ошибкой.
     Описание переменных структурного типа выглядит следующим об-
разом:
                   struct struct_name x, y, z;

     Структурным переменным можно присваивать значение  агрегатно
(сразу  по всей структуре),  но их нельзя сравнивать на равенство
или неравенство.  Для сравнения структур программисту следует на-
писать специализированные функции, зависящие от приложения.
     В тех случаях, когда допускается использовать унарную опера-
цию & получения адреса для структуры в целом, можно эту же опера-
цию использовать и для получения адреса элемента структуры.
     Так как при описании переменной структурного типа требуется,
чтобы в описании присутствовал спецификатор struct, обычно полное
имя структурного типа оформляют в виде макро. Покажем такой прием
на следующем примере.
     Пусть нам  нужно выполнить действия над комплексными типами.
Поскольку комплексное число может быть представлено двумя вещест-
венными, то воспользуемся следующей структурой:
     #define COMPLEX struct complex_type
     COMPLEX
     {

                             - 106 -

     float real;
     float imag;
     };
     Приведенное макроопределение  COMPLEX  позволяет   описывать
комплексные переменные в естественной форме.
     Если переменные с1, с2 и с3 описаны как комплексные, то опе-
рация умножения с1 на с2 для вычисления с3 может быть реализована
следующим образом:
     COMPLEX c1, c2, c3;
     c3.real = c1.real * c2.real - c1.imag * c2.imag;
     c3.imag = c1.imag * c2.real + c1.real * c2.imag;
     Удобно ввести абстрактные арифметические операции над  комп-
лексными числами,  реализовав для каждой такой операции соответс-
твующую функцию.  Заметим,  что непосредственный доступ  к  полям
структур - это плохой стиль программирования.
     Структуры можно использовать при построении абстрактных  ти-
пов  данных.  Все  операции,  которые  разрешены  применительно к
структуре,  должны быть при этом  реализованы  в  виде  отдельных
функций.
     В старых версиях Си при передаче структуры в качестве  пара-
метра функции требовалось указывать адрес структуры,  а не ее са-
му.  В связи с этим формальным параметром функции должен был слу-
жить  указатель  на  структуру.  В Турбо Си и в стандарте Си ANSI
разрешается передавать, изменять и возвращать структуры по значе-
нию.  Тем не менее необходимо все-таки использовать указатели для
передачи структур,  с тем чтобы обеспечивать совместимость  прог-
рамм с другими системами программирования Си.
     Еще один пример описания структурной переменной:
     struct complex_type
     {
       double real;
       double imag;
     } my_complex;

     Имя переменной указывается вслед за описанием структуры.
     Структуры могут задаваться неполностью. Поле структуры может
быть описано как указатель на саму структуру.



                             - 107 -

     6.3.2. Битовые поля

     Целочисленные элементы могут быть помещены в маленький объем
памяти с использованием битовых полей. Битовые поля часто исполь-
зуются в машинозависимых приложениях,  когда требуется работать с
битовыми картами, описывающими конфигурацию аппаратуры.
     В некоторых реализациях Си для каждого битового поля  разре-
шено использовать только беззнаковый тип.  В Турбо Си для битовых
полей можно применять как тип int,  так и тип unsigned int.  Поля
целого типа представляются в виде двоичного дополнительного кода,
где самый левый (больший) бит соответствует знаку.
     Существенно, что  в  Турбо  Си битовые поля располагаются от
меньших номеров к большим.  В других компиляторах с Си может быть
принят иной порядок. Программируя на Турбо Си, следует вниматель-
но кодировать работу с битовыми полями,  чтобы не  столкнуться  с
проблемами мобильности!
     Рассмотрим пример работы с битовыми полями:
     #include <stdio.h>
     struct bit_type
     {
      unsigned i:2;
      unsigned j:6;
      int       :3;
      unsigned k:3;
      unsigned l:2;
     } bit;
   main ()
     {
      bit.i=2;
      bit.j=9;
      bit.k=7;
      bit.l=2;
      printf(bit=%u\n", bit);
     }

     Первое поле i имеет размер 2 бита.  Второе поле  j  занимает
шесть битов.  Следующее поле не имеет имени. Вы видите здесь при-
мер неполного описания структуры.  Следующее  поле  k  ограничено
тремя битами. Последнее поле l ограничено двумя битами.

                             - 108 -

     На рис.  6.2 показано распределение  памяти  под  переменную
bit.

     15 14 │ 13 12 11 │ 10 9 8 │ 7 6 5 4 3 2  │ 1 0 │
       l        k     безымянная      j          i

       Рис. 6.2. Распределение памяти под переменную bit.

     Битовое представление переменной bit показано на рис 6.3.

     1 0 │ 1 1 1 │ 0 0 0 │ 0 0 1 0 0 1  │ 1 0 │

         Рис. 6.3. Битовое представление переменной bit.

     Программа выведет 47142.

     6.3.3. Инициализация структур

     Структуры можно  инициализировать  непосредственно  в  месте
описания.  Рассмотрим пример инициализации структурной переменной
и передачи ее адреса в качестве параметра функции:

     #include <stdio.h>
     #include <string.h>
     #include <alloc.h>
     #define RECORD struct data_record
     RECORD
     {
       char *last_name;
       char *first_name;
       long id_number;
     };
       RECORD my_record = { "Ричард",
                            "Уинер",
                            12345678
                          };
   main()
     {
       extern void enter_data(RECORD *data);

                             - 109 -

       extern void print_record(RECORD *data);
       print_record(&my_record);
       enter_data(&my_record);
       print_record(&my_record);
       printf("\n");
     }
     void enter_data(RECORD *data)
     {
       char info[40];
       printf("\nВведите фамилию:");
       scanf("%s", info);
       data -> last_name = (char *)
                           malloc(strlen(info) + 1);
       strcpy(data -> last_name, info);
       printf("\nВведите имя:");
       scanf("%s", info);
       data -> first_name = (char *)
                           malloc(strlen(info) + 1);
       strcpy(data -> first_name, info);
       printf("\nВведите номер:");
       scanf("%1d", &data -> id_number);
     }
     void print_record(RECORD *data)
     {
       printf("\n\nФамилия: %s", data -> last_name);
       printf("\nИмя: %s", data -> first_name);
       printf("\nНомер: %ld", data -> id_number);
     }
     Здесь задается структура RECORD(struct data_record), которая
содержит  три  поля:  last_name  (строка),  first_name  (строка),
id_number (длинное целое), а также описывается и инициализируется
структурная переменная my_record.
     Начальные значения  структурной  переменной  задаются внутри
набора скобок. Соответствие между константами и полями устанавли-
вается  по  порядку записи.  Это означает,  что первая по порядку
константа связывается с первым по порядку полем, вторая - со вто-
рым и т.д.
     Параметром функции enter_data является адрес структурной пе-
ременной  типа  RECORD.  Память под строки first_name и last_name

                             - 110 -

отводится внутри функции enter_data.  Это  гарантирует,  что  для
размещения  элемента  указанной  структуры  будет  отведено ровно
столько памяти, сколько нужно.
     С помощью функции print_record осуществляется вывод содержи-
мого структурной переменной,  адрес которой передается в качестве
параметра.

     6.3.4. Массивы структур

     Комбинируя структуры и массивы,  можно строить универсальные
и гибкие структуры данных. Рассмотрим пример:
     #include <stdio.h>
     #define RECORD struct data_record
     RECORD
     {
       char *last_name;
       char *first_name;
       long id_number;
     };
     RECORD data_base[ 3 ] = { "Уинер", "Ирвин", 1,
                               "Уинер", "Марк", 2,
                               "Уинер", "Эрик", 3
                             };
     main()
     {
       extern void print_records( RECORD *data, int size);
       print_records( data_base, 3 );
       printf( "\n" );
     }
     void print_records( RECORD *data, int size)
     {
       int i;
       for ( i = 0; i < size; i++ )
     {
       printf( "\n\nФамилия : %s", ( data + i ) -> last_name );
       printf( "\nИмя : %s", ( data + i ) -> first_name );
       printf( "\nНомер : %ld", ( data + i ) -> id_number );
     }
     }

                             - 111 -

     Описывается массив структур data_base  типа  RECORD  (struct
data_record).  Массив  инициализируется значениями при его описа-
нии.
     Для снятия ссылки с полей last_name,  first_name и id_number
параметра  data_base,  передаваемого  подпрограмме,  используется
операция ->.
     Рассмотрим еще один  вариант  реализации  функции  print_re-
cords, результаты работы обеих программ совпадают:

     main()
     {
       extern void print_records(RECORD data [], int size );
       print_records( data_base, 3 );
       printf( "\n" );
     }
     void print_records( RECORD data[], int size )
     {
       int i;
       for ( i = 0; i < size; i++ )
       {
         printf( "\n\nФамилия : %s", data [ i ].last_name );
         printf( "\nИмя : %s", data [ i ].first_name );
         printf( "\nНомер : %ld", data [ i ]. id_number );
       }
     }

     6.4. Объединения

     Используя объединения (union), можно в одной и той же облас-
ти  памяти размещать данные различных типов.  Естественно,  что в
данный момент времени в  памяти  могут  быть  размещены  значения
только одного включенного в объединение типа.
     Рассмотрим пример:
     #include <stdio.h>
     #define ALTERNATIVE_DATA union data_record
     ALTERNATIVE_DATA
     {
       char s[ 4 ];
       float r;

                             - 112 -

       int i;
       char ch;
       unsigned j;
     };
     main()
     {
       ALTERNATIVE_DATA data;
       printf("\nsizeof( data ) = %d\n",
       sizeof( data ) );
     }
     Здесь определяется объединение ALTERNATIVE_DATA.
     Программа выводит следующую строку:
                       sizeof( data ) = 4
     Размер памяти, требуемой для размещения объединения, опреде-
ляется размером наибольшего поля, длина самого большого поля рав-
на четырем байтам.
     Для создания эквивалента записей с вариантами,  имеющимися в
Паскале  или  Модуле-2,  можно  использовать  объединения  внутри
структур. Такой прием использован в программе:
    #include <stdio.h>
    #define DATA struct data_type
    enum employee_type {salary,hourly};
    DATA
    {
     char last_name[10];
     char first_name[10];
     enum employee_type tag;
     union
     {
      float hourly_wage;
      float annual_salary;
     } wage;
    };
    main()
    {
     DATA person;
     /* ... */
    }
     Структура DATA  содержит поле с именем wage типа union_type.

                             - 113 -

Поскольку не имеет смысла хранить для одного  человека  и  размер
его почасовой ставки, и оклад (работник может быть либо почасови-
ком, либо штатным сотрудником), то в объединении поля hourly_wage
(почасовой тариф) и annual_salary (оклад) совмещены,  что обеспе-
чивает экономию памяти.
     В структуру включено поле tag,  позволяющее узнавать,  какое
из двух полей (hourly_wage или annual_salary) является активным в
каждом  конкретном случае.  Не существует другого способа узнать,
какое из полей активно.

     6.5. Файлы и их типизация

     6.5.1. Определение файла

     Термин файл происходит из представления  о  последовательной
структуре  информационных  записей.  Такой  файл располагается на
диске. Базовыми операциями над файлом являются следующие:
     - считывание блока данных из файла в оперативную память (од-
       на или несколько записей);
     - запись блока данных из оперативной памяти в файл;
     - обновление блока данных в файле;
     - считывание определенной записи данных из файла;
     - занесение определенной записи данных в файл.
     Состав файла задается структурой FILE,  описание которой со-
держится в файле stdio.h. Эта структура, скопированная непосредс-
твенно из файла stdio.h системы Турбо Си, имеет вид
 typedef struct
 {
  short level;            /*Уровень буфера*/
  unsigned flags;         /*Флаги статуса файла*/
  char fd;                /*Дескриптор файла*/
  char hold;              /*Предыдущий символ, если нет буфера*/
  short bsize;            /*Размер буфера*/
  unsigned char *buffer;  /*Буфер передачи данных*/
  unsigned char *curp;    /*Текущий активный указатель*/
  short token;            /*Для проверки корректности*/
 } FILE
     Глобальные файловые переменные stdin, stdout и stderr иници-
ируются системой перед началом работы любой прикладной программы.

                             - 114 -


     В начале работы файл stdin приписывается к клавиатуре,  но с
использованием стандартных команд переадресации ввода MS  DOS  он
может быть переназначен. Такие команды переадресации ввода проис-
ходят от появившихся ранее и более устоявшихся команд переадреса-
ции в системе UNIX.
     Файл stdout приписывается в выводному терминалу.
     Файл stderr приписывается к пользовательскому выводному тер-
миналу и не может быть переназначен на другой файл.  Таким  обра-
зом,  если  пользователь желает послать сообщение на терминал без
учета того, что интерпретация файла по умолчанию могла быть изме-
нена, он должен использовать выводной поток stderr.
     Функции, реализующие работу с файловым вводом  и  выводом  в
Турбо Си, собраны в библиотеке stdio.h. Все такие функции совмес-
тимы с аналогичными функциями в системе UNIX.


     6.5.2. Текстовые и двоичные типы файлов

     Текстовый файл состоит из последовательности символов,  раз-
битой  на строки.  Для деления на строки используется управляющий
символ '\n'.  Текстовые файлы оказываются переносимыми  с  одного
типа компьютера на другой,  если символы, содержащиеся в символь-
ном потоке, принадлежат стандартному набору символов.
     В Турбо  Си,  как  и в большинстве реализаций Си для машин с
процессором типа 80х86,  применяется отображение  целых  чисел  в
символы в соответствии со стандартом ANSI. При построении тексто-
вых файлов в Турбо Си разрешено использовать 256 символов,  вклю-
чающих и псевдографические символы фирмы IBM.
     Жесткий стандарт языка Си ANSI, поддерживаемый системой Тур-
бо Си,  предписывает, чтобы реализация обеспечивала работу не ме-
нее чем с 254 символами.
     Двоичный файл  -  это последовательность значений типа char.
Использование двоичных файлов делает программы  немобильными  при
их  переносе  из  одной среды в другую.  Любой набор данных может
быть представлен как набор символов, но такое представление может
изменяться при переходе из одной реализации Си к другой.



                             - 115 -

     6.5.3. Функции работы с файлами

                            Макро EOF
     Макро EOF определяется следующим образом:
                       #define EOF ( -1 )
     Этот макро в операциях ввода/вывода служит для обозначения и
проверки  конца файла.  Подразумевается,  что макро EOF имеет тип
значения символьный знаковый.  Если символьный тип - беззнаковый,
то использовать EOF нельзя.

                          Функция fopen
     Функция fopen используется для открытия файла.  Интерфейс  с
функцией fopen описывается следующим образом:
           FILE *fopen ( char *filename, char *type );
     В качестве  первого  параметра  функции  должно передаваться
правильное имя файла.
     Второй параметр определяет тип открываемого файла. Допустимы
следующие типы файлов:
      "r" Открыть уже существующий файл на ввод (чтение).
      "w" Создать новый файл или очистить уже существующий файл и
          открыть его на вывод (запись).
      "a" Создать новый файл для вывода или осуществить  вывод  в
          конец уже существующего файла (добавление).
     "r+" Открыть существующий файл для обновления, которое будет
          проводиться с начала файла (чтение с обновлением).
     "w+" Создать новый или очистить существующий файл для обнов-
          ления его содержимого (запись с обновлением).
     "a+" Создать новый файл или подстроиться в конец  существую-
          щего  файла для обновления его содержимого (добавление
          с обновлением).

     Дополнительно к каждой из приведенных строк  можно  добавить
символ 'b',  указывающий на то, что открывается двоичный файл или
't' - текстовый файл.
     Функция fopen возвращает указатель на структуру FILE, описы-
вающую файл.
     Открытие в  текстовом  режиме  заключается в том,  что вывод
символа новой строки влечет за собой внесение в файл пары  симво-
лов  cr-lf,  а  ввод  из файла пары символов cr-lf трактуется как

                             - 116 -

ввод символа новой строки.  По умолчанию принимается режим откры-
тия, определяемый глобальной переменной _fmode. если ей присвоено
значение вида O_TEXT,  то открытие произойдет в текстовом режиме,
а если значение вида O_BINARY,  то открытие произойдет в двоичном
режиме. Переменная _fmode описана в файле fcntl.h, а ее начальным
значением является O_TEXT.
     Пример
     Вывод в файл TARGET символов j, cr, lf, b.
     /*fopen*/
     #include <stdio.h>
     #include <fcntl.h>
     main ()
     {
      FILE *Out;
      extern_fmode;
      Out = fopen("TARGET","wt");
      fprintf(Out,"j\n");
      fclose(Out);
      _fmode = o_BINARY;
      Out = fopen("TARGET","a+");
      fprintf(Out,"b");
      fclose(Out);
     }
     Если при  открытии  файла произошли какие-либо ошибки,  то в
глобальную переменную errno будет записан код  (номер)  ошибки  и
будет возвращен нулевой (0) указатель.

                         Функция fflush

     Функция fflush  служит для вывода каждого внутреннего буфера
в файл (stream). Интерфейс с этой функцией выглядит следующим об-
разом:
                   int fflush (FILE *stream);
После вызова функции файл остается открытым.  Если при выполнении
функции появятся ошибки, то будет возвращено значение EOF; в про-
тивном случае будет возвращен 0.
     Пример
     Несмотря на аварийное завершение выполнения программы, вывод
в файл TEXT надписи Kaja.

                             - 117 -

     /*fflush*/
     #include <stdio.h>
     main ()
     {
      FILE *Out;
      Out = fopen("TEXT","w");
      fprintf(Out,"Kaja");
      fflush(Out);
      abort();
     }


                         Функция freopen

     Функция freopen служит для закрытия  существующих  файлов  и
открытия их заново. Чаще всего эта функция используется для пере-
назначения стандартных потоков (stdin,  stdout, stderr) на другие
файлы. Интерфейс с функцией freopen имеет вид
   FILE *freopen ( char *filename, char *type, FILE *stream);
     Закрытие файла,  идентифицируемого аргументом stream,  уста-
новка файла с именем filename и открытие его в режиме,  указанном
в аргументе type таким образом,  чтобы его можно было идентифици-
ровать аргументом stream.
     Результат функции:  переменная типа (FILE *), идентифицирую-
щая файл,  или пустое значение,  если открытие файла окажется не-
возможным.
     Пример
     Вывод буквы  j  в стандартный выходной файл и буквы b в файл
WORK.
     /*freopen*/
     #include <stdio.h>
     main ()
     {
      putchar('j');
      (void)freopen("WORK","w",stdout);
      putchar('b');
     }



                             - 118 -

                         Функция fclose

     Интерфейс с функцией fclose выглядит следующим образом:
                   int fclose (FILE *stream);
С помощью этой функции в файл выводятся соответствующие буферы  и
указанный файл закрывается.  Если закрытие выполняется правильно,
то вырабатывается значение нуль, в противном случае вырабатывает-
ся значение EOF.
     Пример
     В случае успешного выполнения программы вывод надписи Done.
     /*fclose*/
     #include <stdio.h>
     main ()
     {
     FILE *Out;
     Out = fopen("TARGET","w");
     putc('j', Out);
     putc('b', Out);
      printf(fclose(Out) ? "Fail": "Done");
     }

                      Функции fgetc и getc

     Интерфейс с функцией fgetc описывается следующим образом:
                    int fgetc (FILE *stream);
С помощью  этой функции из указанного файла считывается очередной
символ и его значение переводится в тип int.  Если при считывании
обнаруживается ошибка или достигается конец файла, то возвращает-
ся значение EOF.
     Макро getc действует точно также, как и функция fgetc.
     Пример
     Копирование символов  из стандартного входного файла в стан-
дартный выходной файл.

     /*fgetc*/
     #include <stdio.h>
     main ()
     {
      int Chr;

                             - 119 -

      while((Chr = fgetc(stdin)) ! = EOF)
      putc(Chr, stdout);
     }

                         Функция getchar

     Интерфейс с функцией getchar выглядит следующим образом:
                         int getchar ();
С помощью этой функции из стандартного входного потока stdin счи-
тывается очередной символ и его значение переводится в  тип  int.
Если  переназначения  стандартного  входного потока не производи-
лось,  то ввод осуществляется с клавиатуры.  В  противном  случае
ввод будет осуществляться из файла, назначенного для входного по-
тока и указанного в командной строке при вызове программы.
     Пример
Копирование содержимого стандартного входного файла в файл TEXT.
     /*getchar*/
     #include <stdio.h>
     main ()
     {
      FILE *Out;
      int Chr;
      Out = fopen("TEXT","w");
      while((Chr = getchar()) ! = EOF)
       putc(Chr,Out);
     }

                         Функция ungetc

     Интерфейс с функцией ungetc выглядит следующим образом:
               int ungetc (char ch, FILE *stream);
     С помощью этой функции  символ  ch  возвращается  обратно  в
файл.  Если сразу же будет вызвана функция fgetc,  getc или getc-
har, то такой символ будет считан первым. Если при возвращении не
произошло ошибок, то будет считано значение этого символа, в про-
тивном случае будет считано значение EOF.
     Функцию ungetc удобно использовать в том случае, если требу-
ется просмотреть файл на один символ вперед, не нарушая сам файл.
     Пример

                             - 120 -

     Вывод буквы j.
     /*ungetc*/
     #include <stdio.h>
     #include <conio.h>
     main ()
     {
      char Chr;
      ungetc('j',stdin);
      Chr = getc(stdin);
      putchar(Chr);
     }

                          Функция fseek

     Интерфейс с функцией fseek выглядит следующим образом:
      int fseek (FILE *stream, long offset, int wherefrom);
     Эта функция служит для произвольного доступа к байтам, обыч-
но внутри двоичных файлов.
     Первый аргумент задает файл, к которому должен осуществлять-
ся прямой доступ.
     Второй аргумент offset является длинным целым числом со зна-
ком  и  указывает  число  байтов смещения от точки,  определяемой
третьим параметром функции.
     Третий параметр wherefrom указывает точку, от которой следу-
ет начинать отсчет смещения, заданного вторым аргументом:
                Значение 0 - смещение от начала файла.
                Значение 1 - смещение от текущей позиции файла.
                Значение 2 - смещение от конца файла.
     Для облегчения работы с функцией fseek определены  следующие
константы:
                          #define SEEK_SET 0
                          #define SEEK_CUR 1
                          #define SEEK_END 2
     Например, для  установки  стрелки (указателя) файла на конец
файла нужно воспользоваться таким обращением:
               fseek (stream_name, OL, SEEK_END);
     Пример
     Вывод надписи Iza.
     /*fseek*/

                             - 121 -

     #include <stdio.h>
     main ()
     {
      FILE *Upd;
      char Name[3];
      Upd = fopen("Work", "w+t");
      fprintf(Upd, "Ewa-Iza-Jan");
      fseek(Upd,-7,SEK_CUR);
      fscanf(Upd, "%3s", Name);
      printf("%3s", Name);
     }

                         Функция rewind

     Интерфейс с функцией rewind выглядит следующим образом:
                   void rewind (FILE *stream);
     С помощью  этой функции стрелка файла перемещается на начало
файла,  при этом обнуляется указатель  конца  файла  и  указатель
ошибки. Аналогичное действие может быть выполнено и с помощью вы-
зова
               fseek (stream_name, OL, SEEK_SET);
     Пример
     Троекратный вывод  в  стандартный  выходной файл содержимого
файла AUTOEXEC.BAT.
     /*rewind*/
     #include <stdio.h>
     main ()
     {
      int Count = 3;
      int Chr;
      FILE *Inp = fopen("\\AUTOEXEC.BAT", "r");
      while(Count --){
       while((Chr = getc(Inp))! = EOF)
         putc(Chr, stdout);
       putc('\n', stdout);
       rewind(Inp);
      }
     }


                             - 122 -

                          Функция fgets

     Интерфейс с функцией fgets выглядит следующим образом:
          char *fgets ( char *s, int n, FILE *stream);
     С помощью этой функции в строку s считываются символы до тех
пор, пока ни будет выполнено одно из условий:
     1. Начнется новая строка.
     2. Достигнут конец файла.
     3. Условия 1 или 2 не выполнились,  но прочитано n-1  симво-
        лов.
     После того как из файла в строку s будут прочитаны  символы,
строка дополняется символом нуль. Если при чтении встретился сим-
вол конца строки (условие 2),  то он переносится в строку s и ну-
левой символ записывается за ним. Если операция считывания прошла
успешно, то возвращается адрес строки s, в противном случае возв-
ращается значение нуль.
     Пример
     В случае,  когда  первая  строка стандартного входного файла
содержит последовательность символов Jan, вывод в стандартный вы-
ходной файл символов 'J', 'a', 'n' и '\n'.
     /*fgets*/
     #include <stdio.h>
     main ()
     {
      char Buf[20];
      printf("%s", fgets (Buf, 20, stdin));
     }

                          Функция gets

     Интерфейс с функцией gets имеет вид:
                     char *gets ( char *s);
     С помощью функции gets выполняется  считывание  символов  из
стандартного входного файла stdin.  Если входной файл прерывается
символом перехода на новую строку '\n', то этот символ отбрасыва-
ется и не попадает в строку s.
     Поскольку в функции gets (в отличие от функции fgets) не за-
дается  числовой параметр,  ограничивающий длину вводимой строки,
то следует соблюдать осторожность. Ведь число символов, введенных

                             - 123 -

из  файла  stdin,  может превысить размер памяти,  отведенный под
строку s.
     Пример
     Ввод, а затем вывод одной строки текста.
     /*gets*/
     #include <stdio.h>
     main ()
     {
      char Line[81];
      printf("%s", gets (Line));
     }

                      Функции fputc и putc

     Интерфейс с функцией fputc выглядит следующим образом:
               int fputc( char ch, FILE *stream);
     С помощью  этой  функции  символ ch записывается в указанный
файл. Если запись прошла успешно, то возвращается значение ch це-
лого типа, в противном случае возвращается значение EOF.
     Действие функции putc аналогично действию функции fputc, од-
нако первая обычно оформляется в виде макро.
     Пример
     Вывод буквы  E в стандартный выходной файл и возможный вывод
знака вопроса в стандартный файл для сообщения об ошибках.
     /*fputc*/
     #include <stdio.h>
     main ()
     {
      if (fputc('E',stdout) == EOF){
         fputc('?', stderr);
         exit(1);
      }
     }

                         Функция putchar

     Интерфейс с функцией putchar описывается следующим образом:
                     int putchar( char ch);
     Функция putchar действует аналогично функции fputc, но запи-

                             - 124 -

сывает символ ch в стандартный выходной файл stdout.  Обращение к
функции putchar можно заменить на эквивалентное:
                        putc(ch, stdout);
     Пример
     Вывод в стандартный выходной файл надписи jb.
     /*putchar*/
     #include <stdio.h>
     main ()
     {
      putchar (putchar('j')-8);
     }

                          Функция fputs

     Интерфейс с функцией fputs выглядит следующим образом:
               int fputs( char *s, FILE *stream);
     Строка s,  ограниченная символом нуль,  переписывается в вы-
ходной файл, причем символ нуль отбрасывается. Если при перезапи-
си возникает ошибка,  то возвращается значение EOF,  в  противном
случае возвращается ненулевое значение кода последнего выводимого
символа.
     Пример
     Создание файла ONELINE, содержащего надпись Kaja.
     /*fputs*/
     #include <stdio.h>
     main ()
     {
      FILE *Out = fopen ("ONELINE","w");
      fputs("Kaja\n", Out);
      exit(1);
     }

                          Функция puts

     Интерфейс с функцией puts оформляется следующим образом:
                       int puts( char *s);
     Эта функция выполняется аналогично функции fputs,  за исклю-
чением  того,  что  символы переписываются в стандартный выходной
файл stdout и строка s независимо от того,  содержит она  символы

                             - 125 -

или нет, дополняется символом конца строки '\n'.
     Пример
     Вывод надписи Hello world.
     /*puts*/
     #include <stdio.h>
     main ()
     {
      puts("Hello world");
     }

                          Функция fread

     Интерфейс с функцией fread выглядит следующим образом:
 int fread(void *ptr,unsigned elem_size,int count,FILE *stream);
     С помощью  этой  функции  из входного файла считываются и по
адресу *ptr записываются не более чем количество count  элементов
размером elem_size байтов каждый. Функция возвращает число факти-
чески считанных элементов.
     Пример
     Вывод надписи Count = 3.
     /*fread*/
     #include <stdio.h>
     char Arr[30];
     main ()
     {
      FILE *Upd = fopen("ARRAYS", "w+");
      int Rep, Count;
      for(Count = 1; Count! = 4; Count ++){
          Arr[0] = Count;
          fwrite(Arr, sizeoff Arr, 1, Upd);
      }
       rewind(Upd);
       Count = 0;
       do{
         Rep = fread(Arr, sizeoff Arr, 1, Upd);
         if(Rep<1);
           break;
         Count++;
      } while(1);

                             - 126 -

      printf("Count = %d", Count);
     }

                         Функция fwrite

     Интерфейс с функцией fwrite описывается следующим образом:
 int fwrite(void *ptr,unsigned elem_size,int count,FILE *stream);
     С помощью этой функции,  начиная с адреса *ptr,  считываются
не более чем количество count элементов размером elem_size байтов
каждый,  и  эти  элементы  записываются в выходной файл.  Функция
возвращает число фактически записанных элементов.

                          Функция feof

     Интерфейс с функцией feof выглядит следующим образом:
                    int feof( FILE *stream );
     Если при чтении из указанного файла достигнут  конец  файла,
то  возвращается  значение нуль,  в противном случае возвращается
ненулевое значение.
     Если не  предпринималась  попытка прочитать из файла отсутс-
твующий символ,  следующий за последним, то функция feof не будет
сигнализировать о том, что достигнут конец файла.

                         Функция ferror

     Интерфейс с функцией ferror имеет вид
                   int ferror( FILE *stream );
     Функция ferror  позволяет опросить состояние признака ошибки
указанного файла после чтения или записи в него. Возвращаемое ну-
левое значение показывает, что ошибок не было, в то время как не-
нулевое значение сигнализирует об ошибке.
     Для чистки признака ошибки используется функция clearerr.

                        Функция clearerr

     Интерфейс с функцией clearerr описывается следующим образом:
                 void clearerr( FILE *stream );
     С помощью указанной функции устанавливается в нуль состояние
признака ошибки в указанном файле.  Признак ошибки файла устанав-

                             - 127 -

ливается в нуль и при закрытии файла.

                         Функция rename
     Интерфейс с функцией rename выглядит следующим образом:
           int rename( char *oldname, char *newname );
     С помощью  указанной  функции  имя файла oldname меняется на
новое имя newname. Если переименование прошло успешно, то возвра-
щается  значение нуль,  в противном случае возвращается ненулевое
значение.
     Пример. Перемещение и переименование файла.
     /*rename*/
     #include <stdio.h>
     main ()
     {
      printf("%d", rename("\\ISA\\JAN", "\\EVA\\KAJA"));
     }
           Функции fprintf, printf, sprintf и cprintf

     С помощью функций fprintf,  printf, sprintf и cprintf выпол-
няется  форматный  вывод соответственно в указанный выходной файл
(или в стандартный выходной файл stdout),  в указанную строку или
на терминал.
     Рассмотрим интерфейсы с указанными функциями:
int fprintf(FILE*stream,char *format,<дополнительные аргументы>);
int printf( char *format, <дополнительные аргументы>);
int sprintf( char *s, char *format, <дополнительные аргументы>);
int cprintf( char *format, <дополнительные аргументы>);
     Каждая из описываемых функций в случае возникновения  ошибки
возвращает значение EOF,  в противном случае она возвращает число
символов, переданных по назначению.
     Пример
     Вывод надписи (+123.457).  Элемент 9 определяет ширину внеш-
него поля,  элемент  .3 - число цифр после десятичной точки, эле-
менты - (минус) и + (плюс) указывают соответственно,  что число в
выходном поле выравнивается влево и что числу  предшествует  знак
плюс или минус.
     /*fprintf.1*/
     #include <stdio.h>
     main ()

                             - 128 -

     {
      fprintf(stdout, "(%-+9.3f)", 123.4567);
     }
                          Функция ftell

     Интерфейс с функцией ftell оформляется следующим образом:
                   long ftell( FILE *stream );
     Результат функции - текущий указатель на файл.
     Пример
     Вывод числа символов, содержащихся в файле STDIO.H.
     /*ftell*/
     #include <stdio.h>
     main ()
     {
      FILE *Inp;
      Inp = fopen("D:\\tc\\include\\stdio.h", "r");
      fseek(Inp, 0, SEEK_END);
      printf("%ld", ftell(Inp));
     }
             Функции scanf, fscanf, sscanf и cscanf

     Интерфейс с функциями scanf,  fscanf,  sscanf и cscanf имеет
вид
int scanf( char *format, <дополнительные аргументы>);
int fscanf(FILE *stream,char *format,<дополнительные аргументы>);
int sscanf(char *string,char *format,<дополнительные аргументы>);
int cscanf( char *format, <дополнительные аргументы>);
     С помощью  функции scanf осуществляется ввод из стандартного
файла stdin. Функция fscanf вводит из файла, указанного пользова-
телем.  Функция sscanf вводит из заданной строки.  Функция cscanf
вводит с консоли.
     Все функции  семейства scanf вводят поля символ за символом,
переводя их в соответствии с указанным форматом.
     Пример
     Ввод из стандартного входного файла последовательности  сим-
волов в виде числа и вывод информации о его значении. Числу долж-
на предшествовать надпись Val=. Перед словом Val, а также с обеих
сторон от знака равенства могут находиться интервалы.  Если вход-
ная последовательность имеет другой вид,  то результатом выполне-

                             - 129 -

ния программы будет вывод числа -13.
     /*fscanf.1*/
     #include <stdio.h>
     main ()
     {
      int Val = -13;
      fscanf(stdin, "Val = %d", &Val);
      printf("\n\n Val = %d",Val);
     }
                          Функция setbuf

     Интерфейс с функцией setbuf выглядит следующим образом:
           void setbuf( FILE *stream, char *buffer );
     С помощью  этой функции системе вода/вывода предлагается для
выполнения обменов использовать буфер, указанный в качестве пара-
метра функции,  вместо буфера,  подключаемого автоматически. Если
указан нулевой буфер,  то ввод/вывод будет небуферизированным,  в
противном случае он будет полностью буферизироваться.  Размер бу-
фера должен быть равен BUFSIZ байтам  (соответствующая  константа
описана в файле stdio.h).
     Если обмены не буферизуются,  то символы передаются потреби-
телю на прямую, без предварительного накопления.
     Обращаем внимание на то,  что следует обязательно  закрывать
файлы,  работа  с которыми ведется через динамически определяемые
буферы пользователя.  Закрытие рекомендуется осуществлять при вы-
ходе из функции, в которой такие буфера заводятся.
     Пример
     Вывод в файл WORK символа * (звездочка). Это действие выпол-
няется несмотря на аварийное завершение выполнения программы.
     /*setbuf*/
     #include <stdio.h>
     main ()
     {
      FILE *Out;
      Out = fopen("WORK","w");
      setbuf(Out, NULL);
      putc('*',Out);
      abort();
     }

                             - 130 -

     7. Сложные модели данных

     Теория структур данных предоставляет широкий спектр  моделей
для  построения таких повторно используемых компонентов программ-
ного обеспечения, как стеки, очереди, списки и деревья. Благодаря
тому что перечисленные структуры данных имеют множество возможных
применений,  они являются важнейшими фундаментальными понятиями в
программной инженерии.

     7.1. Линейные ссылочные структуры

     7.1.1. Стек

     Стек часто  называют структурой типа "первым вошел - послед-
ним вышел".
     Базовыми операциями со стеком являются
push - добавить в стек новый элемент;
pop - удалить из стека последний элемент;
peek - считать элемент с "верхушки" стека,  не изменяя  при  этом
       весь стек.
     Максимальное число элементов,  которые  можно  разместить  в
стеке,  не должно лимитироваться программным окружением.  По мере
добавления в стек новых элементов и удаления  старых  память  под
стек должна динамически дозапрашиваться и освобождаться.
     Рассмотрим интерфейс с пакетом программ  работы  со  стеком.
Предполагается,  что  базовый тип элементов такого стека - целый.
/*Интерфейс со стеком*/
/*stack.h*/
#define STACK struct stack
STACK {
 int info;
 STACK *next;
};
extern void push(STACK **s, int item);
extern int pop(STACK **s, int *error);
extern int peek(STACK **s, int *error);
     На примере описания структуры STACK видно,  что можно описы-
вать  не все ее поля.  Второе поле структуры STACK - указатель на
структуру STACK. Такой способ рекурсивного определения, при кото-

                             - 131 -

ром  структура содержит ссылку на саму себя,  является вполне до-
пустимым.  Компилятор отводит под указатель next требуемое  коли-
чество памяти независимо от того,  на какой объект этот указатель
ссылается.
     В функциях  push,  pop  и  peek используются двойные ссылки.
Благодаря этому каждая из таких функций может  возвращать  в  ка-
честве  результата  своей  работы указатель на новый элемент типа
STACK (используется передача параметров по ссылке). Входным пара-
метром указанных функций является адрес указателя на стек,  с ис-
пользованием которого вычисляется и возвращается новый адрес эле-
мента. После каждой операции добавления или удаления указатель на
связанный список меняется.
     Функции pop и peek имеют еще один параметр, целого типа, пе-
редаваемый по ссылке - error.  Если в стеке имеется хотя бы  один
элемент,  то функции выдают *error=0.  Если стек пуст, а следова-
тельно,  бессмысленно удалять или считывать что-либо из стека, то
*error принимает значение 1.
     Реализация функций работы со стеком приведена ниже.
/*Реализация стека*/
/*stack.h*/
#include <alloc.h>
#include "stack.h"
void push (STACK **s, int item)
{
 STACK *new_item=(STACK*)malloc(sizeof(STACK));
 new_item->info=item;
 new_item->next=*s;
 *s=new_item;
}
int pop(STACK **s, int *error)
{
 /* *error = 0, если операция POP выполнена успешно, иначе = 1 */
 STACK *old_item=*s;
 int old_info=0;
 if (*s)
 {
  old_info=old_item->info;
  *s=old_item->next;
   free(old_item);

                             - 132 -

   *error=0;
  }
else
 *error =1 ;
return (old_info);
}
int peek (STACK **s, int *error)
{
 /**error = 0 , если в стеке не меньше одного элемента,
   *error = 1 , если в стеке нет элементов
*/
if (*s)
{
 *error=0;
  return(*s)->info;
  }
else
{
*error =1;
 return 0;
 }}
     Внимательно изучим текст функции push.
     Память под новый элемент запрашивается  из  кучи  с  помощью
первого оператора
         STACK *new_item=(STACK*)malloc(sizeof(STACK));
     Преобразование типа (STACK *) нужно для того, чтобы привести
указатель, выдаваемый функцией malloc, к виду, при котором он мо-
жет  ссылаться на STACK.  Для вычисления числа байтов,  требуемых
для размещения структуры, служит встроенная функция size of.
     В следующей строке программы
                      new_item->info=item;
полю info структуры присваивается значение переменной item.  Опе-
рация снятия ссылки -> использована здесь потому,  что new_item -
это указатель на тип STACK.
     Далее при помощи оператора
                       new_item->next=*s;
полю next присваивается  значение  адреса  "верхушки"  связанного
списка *s.
     И наконец, с помощью оператора

                             - 133 -

                          *s=new_item;
указателю *s присваивается новое значение адреса "верхушки" спис-
ка new_item,  и этот указатель возвращается в качестве результата
функции.
     Функция pop,  перед  тем  как  сделать  попытку обратиться к
списку,  проверяет значение *s.  Если значение равно 0, то список
пуст, и в этом случае выражению *error присваивается значение 1.
     Тестовая программа, иллюстрирующая работу со стеком:
/*Тестовая программа, использующая переменные типа стек*/
#include <stdio.h>
#include "stack"
STACK *s1,*s2;
main()
{
int error;
push(&s1,12);
printf("\npeek(s1)=%d",peek(&s1,&error));
push(&s1,13);
printf("\npeek(s1)=%d",peek(&s1,&error));
push(&s1,14);
printf("\npeek(s1)=%d",peek(&s1,&error));
push(&s1,15);
printf("\npeek(s1)=%d",peek(&s1,&error));
  push(&s2,pop(&s1,&error));
  push(&s2,pop(&s1,&error));
  push(&s2,pop(&s1,&error));
  push(&s2,pop(&s1,&error));
printf("\npop(&s2)=%d",pop(&s2,&error));
printf("\npop(&s2)=%d",pop(&s2,&error));
printf("\npop(&s2)=%d",pop(&s2,&error));
printf("\npop(&s2)=%d\n",pop(&s2,&error));
}
     Существенно, что  стековые переменные s1 и s2 типа указатель
описаны как глобальные.  Это гарантирует,  что каждая  переменная
будет инициализирована нулем. Если бы переменные были описаны как
локальные,  то начальные значения их были бы неопределены,  что в
свою очередь могло привести к ошибке в функциях pop и peek.
     В тестовой программе не используется значение переменной er-
ror.

                             - 134 -

     Результат работы программы выглядит следующим образом:
peek( s1 )=12
peek( s1 )=13
peek( s1 )=14
peek( s1 )=15
pop( &s2 )=12
pop( &s2 )=13
pop( &s2 )=14
pop( &s2 )=15

     7.1.2. Очередь

     Очередью называют структуру данных,  организованную по прин-
ципу "первым вошел - первым вышел".
     Базовыми операциями над очередью являются
insert - добавить в очередь новый элемент;
take_out - удалить из очереди первый элемент.
     Как и  для стека,  максимальное число элементов в очереди не
должно лимитироваться используемым программным обеспечением.  Па-
мять для очереди должна запрашиваться и освобождаться динамически
по мере того,  как в очередь добавляются и из  очереди  удаляются
элементы.
     Предполагается, что базовым типом элементов очереди является
тип int.
     Интерфейс с функциями обслуживания очереди:
/*Интерфейс с пакетом программ работы с очередью*/
/*Файл queue.h*/
#define QUEUE struct queue
QUEUE
{
int info;
QUEUE *next;
};
extern void insert(QUEUE **q, int item);
extern int take_out(QUEUE **q, int *error);
     Определяется структура QUEUE. Здесь же описываются интерфей-
сы с функциями insert и take_out.
     Функция take_out  имеет  параметр  *error,  передаваемый  по
ссылке.  Значение параметра равно нулю, если в очереди содержится

                             - 135 -

один  или  более элементов (целых чисел),  и равно единице,  если
очередь пуста.
     Ниже приведены подпрограммы, реализующие работу с очередью.
/*Реализация очереди*/
/*Файл queue.с*/
#include <alloc.h>
#include "queue.h"
void insert (QUEUE **q, int item)
{
QUEUE *current=*q;
QUEUE *previous=0;
QUEUE *new_node;
while (current)
{
 privious=current;       /*privious=*q=new_node_1*/
 current=current->next;  /*current=(*q)->next=0*/
 }
new_node=(QUEUE*)malloc(sizeof(QUEUE));
new_node ->info=item;
if (previous)
{
 new_node->next=previous->next; /* = 0 */
 previous->next=new_node;
 }
else
 {
  *q=new_node;     /* *q=new_node_1*/
  (*q)->next=0;    /*new_node_1->next=0*/
 }
}
int take_out(QUEUE **q, int *error)
{
int value=0;
QUEUE *old_header=*q;
if (*q)
   {
    value=old_header->info;
    *q=old_header->next;
    free(old_header);

                             - 136 -

    *error=0;
   }
   else *error=1;
   return value;
}
     Рассмотрим подробно функцию insert.
     Описывается локальная переменная current типа  указатель,  и
она инициализируется значением *q. Описывается локальная перемен-
ная previous типа указатель, и она инициализируется значением 0.
     В цикле  типа WHILE связанный список просматривается до кон-
ца. Указатель previous содержит адрес последнего элемента QUEUE в
списке.  Затем отводится память под очередь QUEUE new_node,  полю
info новой структуры QUEUE присваивается значение item,  перемен-
ной  previous  присваивается  значение  указателя на new_node,  а
new_node устанавливается в 0,  если очередь не пуста, и принимает
значение  указателя на новый элемент в голове очереди,  если оче-
редь прежде была пустой.
     Код для функции take_out сходен с кодом для функции pop.
     Тестовая программа, использующая очередь:
/*Тестовая программа, использующая переменные типа очередь*/
/*Файл queue.с*/
#include <sdtio.h>
#include <alloc.h>
#include "queue.h"
QUEUE *q1,*q2;
main()
{
 int error;
 insert(&q1,12);
 insert(&q1,13);
 insert(&q1,14);
 insert(&q1,15);
 insert(&q2,take_out(&q1,&error));
 insert(&q2,take_out(&q1,&error));
 insert(&q2,take_out(&q1,&error));
 insert(&q2,take_out(&q1,&error));
 printf("\nremove(&q2)=%d",take_out(&q2,&error));
 printf("\nremove(&q2)=%d",take_out(&q2,&error));
 printf("\nremove(&q2)=%d",take_out(&q2,&error));

                             - 137 -

 printf("\nremove(&q2)=%d\n",take_out(&q2,&error));
}
     Результатом ее работы будет
remove(&q2) = 12
remove(&q2) = 13
remove(&q2) = 14
remove(&q2) = 15


     7.1.3. Связанные списки

     Списки являются весьма популярными структурами и применяются
для представления абстрактного аппарата поиска элемента. Элементы
в списках обычно располагаются в возрастающем или  убывающем  по-
рядке.
     Стеки и очереди являются специальными разновидностями  обоб-
щенных списков.
     Простой список может быть  определен  при  помощи  следующих
операций:
insert     - Добавить новый элемент в список,  сохраняя  установ-
             ленный порядок следования.
take_out   - Удалить  элемент  из  списка, сохранив установленный
             порядок следования.  Если  элемент  отсутствует,  то
             функция не выполняет никаких действий.
is_present - Определить, содержится ли в списке заданный элемент.
             Если содержится, то возвращается значение единица, в
             противном случае возвращается значение нуль.
display    - Вывести все по порядку элементы списка.
destory    - Освободить память, занимаемую списком.
     Как для стека и очереди,  так и  для  связанного  списка  не
должно  существовать  ограничения  на максимальное количество его
элементов,  налагаемого программным окружением. Память под список
должна  динамически  запрашиваться  и освобождаться по мере того,
как элементы добавляются и удаляются.
     Существует множество  способов реализовать связанный список.
Это однонаправленные списки, закольцованные списки, двунаправлен-
ные списки и т.д.
     Рассмотрим интерфейс  с  программами  работы  со  связанными
списками.

                             - 138 -

     Реализован простой однонаправленный список.
/*Интерфейс с программами работы со связанным  списком  персонала
университета*/
/*Файл list.h*/
#define STAFF struct stuff_type
STAFF
{
 int years_of_service;
 float hourly_wage;
 };
#define STUDENT struct student_type
STUDENT
{
 float grade_pt_average;
 int level;
};
#define PROFESSOR struct prof_type
PROFESSOR
{
 int dept_number;
 float annual_salary;
};
#define NODE_TYPE enum node_type
typedef NODE_TYPE {student,professor,staff};
#define LIST struct list
LIST
{
 char last_name[10];
 char first_name[10];
 int age;
 LIST *next;
 NODE_TYPE tag;
 union
 {
 STUDENT student;
 PROFESSOR professor;
 STAFF staff;
 } node_tag;
};

                             - 139 -

extern void insert(LIST **lst, LIST *item);
extern void display(LIST *lst);
extern int is_present(LIST *lst, LIST *item);
extern int take_out(LIST **lst, LIST *item);
extern void destroy_list(LIST **lst);
     Список содержит вложенные структуры и вложенные объединения.
Возможности здесь безграничны!
     Вначале определяются структуры STAFF,  STUDENT и  PROFESSOR,
содержащие каждая по два числа (поля). Далее описывается перечис-
ляемый тип NODE_TYPE. С помощью этого типа будет описываться поле
списочной структуры, указывающее на тип элемента поля.
     Списочная структура  (LIST)  включает  пять  обычных  полей:
last_name  (последнее  имя),  first_name (первое имя),  age (воз-
раст),  next (следующее) и tag (флаг),  а также  объединение  no-
de_tag.  Это  объединение  состоит из трех членов:  student (сту-
дент),  professor (профессор) и staff (персонал). Каждая перемен-
ная типа LIST может содержать элементы только одного типа из объ-
единения. Такая структура, похожая на запись с вариантами, позво-
ляет  экономно расходовать память,  поскольку она занимает прост-
ранство,  требуемое для размещения первых пяти обычных  элементов
структуры,  плюс пространство,  занимаемое элементом максимальной
длины из объединения.
     В файле  list.h  кроме  описания структуры данных для списка
задан еще и интерфейс с пятью функциями: insert, display, is_pre-
sent, take_out и destroy_list.
     Реализация программ работы со связанными списками:
/*Файл list.c*/
#include <stdio.h>
#include <string.h>
#include <alloc.h>
#include "list.h"
static LIST* create_node(LIST *item)
{
 LIST *node;
 node=(LIST*)malloc(sizeof(LIST));
 *node =*item;
 return node;
}
void destroy_list(LIST **lst)

                             - 140 -

{
 LIST *current_node=*lst;
 LIST *previous_node =0;
 while (current_node !=0)
 {
 previous_node =current_node;
 current_node=current_node->next;
 free(prefious_node);
 }
 *lst=0;
 }
int take_out(LIST **lst, LIST *item)
{
 LIST *current_node=*lst;
 LIST *previous_node=0;
 while (current_node !=0 &&
       strcmp(current_node->last_name,item->last_name)!=0)
 {
  previous_node=current_node;
  current_node=current_node->next;
  }
  if (current_node !=0 && previous_node ==0 )
   {
    *lst=current_node->next;
    free(current_node);
   }
   else if (current_node !=0 && previous_node!=0)
           {
           previous_node->next=current_node->next;
           free(current_node);
           }
}
void insert (LIST **lst, LIST *item)
{
 /* Фамилия используется как ключевое поле в списке */
 char key[10];
 LIST *current_node=*lst;
 LIST *previous_node=0;
 LIST *new_node;

                             - 141 -

 strcpy(key,item->last_name);
 while (current_node !=0 && strcmp(current_node->last_name,
        key)<0)
 {
 previous_node=current_node;
 current_node=current_node->next;
 }
new_node=create_node(item);
new_node->next=current_node;
if (previous_node==0)
   *lst=new_node;
else previous_node->next=new_node;
}
void display (LIST *lst)
{
 LIST *current=lst;
 while (current)
 {
 printf("\n%s, %s",current->last_name,current->first_name);
 printf("\n Возраст =%d"current->age);
 swith (current->tag)
 {
 case student: printf("\nСпециализация: %.2f",
                    current->node_tag.student.grage_pt_average);
               printf("\nКурс: %d\n",
                    current->node_tag.student.level);
 break;
 case professor: printf ("\nНомер кафедры: %d",
                       current->node_tag.professor.dept_number);
                 printf ("\nОклад: $%.2f\n",
                      current->node_tag.professor.annual_salary);
 break;
 case staff: printf ("\nСрок службы: %d",
                    current->node_tag.staff.years_of_service);
             printf ("\nПочасовой тариф: $%.2f\n",
                    current->node_tag.staff.hourly_wage);
 }
 current=current->next;
 }

                             - 142 -

}
int is_present(LIST *lst, LIST *item)
{
/* Фамилия используется как ключевое поле в списке */
LIST *current_node=lst;
while (current_node && strcmp(item->last_name,current_node->
       last_name)!=0)
      if (strcmp(item->last_name,current_node->last_name)!=0)
         current_node=current_node->next;
         return(current_node !=0);
}
     Функция create_node (создать элемент), описанная как
               static LIST* create_node(LIST *item)
спрятана от загрузчика и других программ системы, поскольку зада-
на статически.  Ее назначение - отводить память под новый элемент
списка и передавать данные,  помещенные по адресу item (указатель
на структуру), в новый элемент.
     В функции используется множественное присваивание:
                          *node =*item;
для пересылки  всей информации,  расположенной по адресу item,  в
область памяти по адресу *node.
     Цикл типа WHILE в функции destroy_list использован для осво-
бождения памяти,  занимаемой элементами списка.  После завершения
цикла  WHILE  значение  переменной *lst,  передаваемой по ссылке,
оказывается равным нулю.
     В функции  take_out в цикле типа WHILE перебираются элементы
списка до тех пор, пока либо не будет достигнут конец списка, ли-
бо  не  будет  установлено  соответствие  между  строкой  в  поле
last_name переменной item и полем last_name  в  текущем  элементе
current_node. Если цикл прекращается, а элемент previous_node ра-
вен нулю, то изменяется указатель на голову списка *lst и память,
занимаемая старым головным элементом списка,  освобождается (иск-
лючается всегда элемент,  находящийся в голове списка). В против-
ном случае операторы     previous_node->next=current_node->next;
                         free(current_node);
продвигают указатель по списку и освобождают память  из-под  уда-
ляемого элемента.
     В функции insert указатель LIST current_node инициализирует-
ся значением *lst и переменная previons_node инициализируется ну-

                             - 143 -

лем. В цикле типа WHILE просматривается список либо до конца, ли-
бо до тех пор,  пока  значение  поля  last_name  переменной  cur-
rent_node не перестанет быть меньше, чем поле last_name добавляе-
мого элемента, поскольку список упорядочен по возрастанию.
     Динамически запрашивается  память  под  указатель new_node и
данные из элемента item пересылаются по  адресу  new_node.  Новый
элемент new_node подключается к списку при помощи оператора
                  new_node->next=current_node;
     Если добавляемый  элемент  является  первым  в первоначально
пустом списке (previous_node равен нулю),  то указатель на голову
списка *lst устанавливается на new_node. Иначе, указатель продви-
гается по списку при помощи операторов
                  previous_node->next=new_node;
     Самая большая программа требуется для функции display,  пос-
кольку ее работа существенно зависит от типа выводимого элемента.
После того как будут выведены поля last_name,  first_name и  age,
при помощи переключателя определяется, как выводить остальные по-
ля.  Предположим,  что значение поля tag есть  student,  т.е.  мы
должны распечатать информацию о студенте.  Попробуйте разобраться
в том,  каким образом осуществляется доступ к  глубоко  вложенной
информации grade_pt_average.
     Тестовая программа,  использующая большинство функций из па-
кета программ работы со списками:
#include <string.h>
#include <stdio.h>
#include <alloc.h>
#include "list.h"
LIST *my_list;
main()
{
 LIST *item1=(LIST*)malloc(sizeof(LIST));
 LIST *item2=(LIST*)malloc(sizeof(LIST));
 LIST *item3=(LIST*)malloc(sizeof(LIST));
 strcpy(item1->last_name,"Smith");
 strcpy(item1->first_name,"Robert");
 item1->age=26;
 item1->tag=staff;
 item1->node_tag.staff.years_of_service=3;
 item1->node_tag.staff.hourly_wage=5.25;

                             - 144 -

 insert(&my_list,item1);
   strcpy(item2->last_name,"Jones");
   strcpy(item2->first_name,"Richard");
 item2->age=56;
 item2->tag=professor;
 item2->node_tag.professor.dept_number=7;
 item2->node_tag.professor.annual_salary=48321.0;
 insert(&my_list,item2);
   strcpy(item3->last_name,"Evans");
   strcpy(item3->first_name,"Henry");
 item3->age=19;
 item3->tag=student;
 item3->node_tag.student.level=1;
 item3->node_tag.student.grade_pt_average=3.1;
 insert(&my_list,item3);
   display(my_lst);
   if (is_present(my_list,item1))
     printf("\nЭлемент 1 присутствует в списке.\n");
 else
     printf("Элемент 1 отсутствует в списке.\n");
 take_out(&my_list,item3);
 display(my_list);
 take_out(&my_list,item2);
 display(my_list);
 take_out(&my_list,item1);
 display(my_list);
 printf("\n");
}
     Сначала инициализируются три  указателя  на  списки:  item1,
item2 и item3.
     В список добавляются три структуры,  значения полей  которых
задаются в программе. Программа выведет следующий текст:
     Evans, Henry
     Возраст=19
     Специализация: 3.10
     Курс: 1

     Jones, Richard
     Возраст=56

                             - 145 -

     Номер кафедры: 7
     Оклад: $48321.00

     Smith, Robert
     Возраст=26
     Стаж: 3
     Почасовой тариф: $5.25

     Элемент 1 присутствует в списке.

     Jones, Richard
     Возраст=56
     Номер кафедры: 7
     Оклад: $48321.00

     Smith, Robert
     Возраст=26
     Стаж: 3
     Почасовой тариф: $5.25

     Smith, Robert
     Возраст=26
     Стаж: 3
     Почасовой тариф: $5.25

     7.2. Обобщенные (родовые) структуры данных

     Базовые операции определения абстракций списка и дерева  по-
иска  не зависят от типа данных,  содержащихся в структуре списка
или дерева. Поэтому такие абстракции являются идеальными кандида-
турами для их обобщенной (родовой) реализации.
     Родовой пакет структур данных при  условии  его  эффективной
реализации  может  стать повторно используемым программным компо-
нентом. Программисту не придется для каждого нового используемого
типа данных создавать свою реализацию структуры.

     7.2.1. Родовой список

     Рассмотрим интерфейс  с  программами,  реализующими  родовой

                             - 146 -

список с однотипными элементами.
/*Файл genlist.h*/
#define LIST struct header
#define NODE struct node
typedef void (*display_function) (char *data);
LIST
{
 NODE *next;
 int elem_size;
 display_function display;
};
NODE
{
 char *info;
 NODE *next;
};
extern void define (LIST **lst,int size,
                    display_function disp_fun);
extern void insert_front (LIST **lst, char *data);
extern void insert_back (LIST **lst, char *data);
extern char *get_front(LIST **lst);
extern void display_list(LIST *lst);
     Определяются структуры LIST и NODE.
     Структура LIST является заголовком связного списка. Структу-
ра включает три поля: next, elem_size и display. Поле next содер-
жит  указатель  на первый элемент списка,  имеющий тип NODE.  При
инициализации поле получает значение нулевого указателя (0). Раз-
мер каждого элемента списка в байтах помещается в поле elem_size.
Поле display содержит  указатель  на  определяемую  пользователем
функцию,  с помощью которой можно вывести значение элемента.  Эта
функция вывода приписывается заголовку списка при вызове  функции
define.
     Пользователь должен сам позаботиться о разработке  программы
вывода значений элементов для каждого конкретного списка.  Невоз-
можно организовать вывод значений с помощью самого родового паке-
та, поскольку заранее не известен базовый тип элементов списка и,
следовательно, не определена форма представления значений.
     Структура NODE содержит поля info и next. Поле info описыва-
ется как указатель на минимальный предопределенный тип,  а именно

                             - 147 -

на тип char,  данные в поле info должны передаваться байт за бай-
том. Поле next указывает на следующий элемент списка типа NODE.
     На рис.  7.1  показана  структура  данных  родового связного
списка.

              LIST                          NODE
      ┌─────────────────────┐            ┌────────┐
      │       next    ──────┼─────────── 76 0│  info  │
      │       elem_size     │            │  next ─┼──────┐
      │       display       │            └────────┘      │
      └─────────────────────┘                            │
                                   ┌─────────────────────┘
                                   │     ┌────────┐
                                   └──── 76 0│  info  │
                                         │  next ─┼────── 76
                                         └────────┘

                7Р 0Рис. 7.1. Родовой связный список.

     Далее приведен интерфейс с функциями  define,  insert_front,
insert_back, get_front и display_list.
     В предлагаемом простом родовом пакете программ для работы со
списками допускаются только два способа включения новых элементов
в список: добавление в начало списка (функция insert_front) и до-
бавление в конец списка (insert_back).  Удалить элемент из списка
можно единственным способом,  а именно исключив элемент из начало
списка.
     Перед началом работы с пакетом следует обратиться к  функции
define.  С помощью этой функции в заголовок списка заносится раз-
мер элемента списка в байтах  (поле  elem_size)  и  указатель  на
программу вывода значений, определяемую пользователем (поле disp-
lay).
     Реализация программ работы с родовым списком:
/*Файл genlist.h*/
#include "genlist.h"
#include <alloc.h>
void define (LIST **lst,int size, display_function disp_fun)
{
 *lst=(LIST*)malloc(sizeof(LIST));

                             - 148 -

 (*lst)-> next = 0;
 (*lst)->elem_size = size;
 (*lst)->display = disp_fun;
}
void insert_front (LIST **lst,char *data)
{
 NODE *new_node;
 int index;
 /*Отводится память для структуры new_node и ее полей*/
 new_node = (NODE*)malloc(sizeof(NODE));
 new_node->info=(char*)malloc((*lst)->elem_size);
 /*Пересылка данных в элемент new_node*/
 for (index=0;index<(*lst)->else_size;index++)
 new_node ->info[index]=data[index];
 /*Присоединение элемента new_node к списку*/
 if ((*lst)->next) new_node->next=(*lst)->next;
 else
 new_node ->next=0;
 (*lst)->next=new_node;
}
void insert_back (LIST **lst,char *data)
{
 NODE *previous,*current,*new_node;
 int index;
 /*Отводится память для структуры new_node и ее полей*/
 new_node=(NODE*)malloc(sizeof(NODE);
 new_node->info =(char*)malloc((*lst)->elem_size);
 new_node->next=0;
 /*Пересылка данных в элемент new_node*/
 for (index=0;index<(*lst)->elem_size;index++)
 new_node->info[index]=data[index];
 if ((*lst)->next)
 {
  /*Поиск конца списка*/
  previous=(*lst)->next;
  current =previous->next;
  while (current!=0)
  {
   previous=current;

                             - 149 -

   current=current->next;
  }
 /*Присоединение элемента new_node к списку*/
  previous->next=new_node;
 }
else
 /*Элемент new_node является первым в списке*/
(*lst)->next=new_node;
}
char *get_front (LIST **lst)
{
 NODE *old_node=(*lst)->next;
 char *ret_info;
 int index;
 if ((*lst)->next==0)
 {
  printf("\nОшибка: список пуст");
  return 0;
 }
else
{
 ret_info=(char*)malloc((*lst)->elem_size);
 for (index=0;index<(*lst)->elem_size;index++)
     ret_info[index]=old_node->info[index];
 (*lst)->next=old_node->next;
 free(old_node);
 return ret_info;
 }
}
void display_list (LIST *lst)
{
 NODE *current=lst->next;
 while (current)
 {
  lst->display(current->info);
  current=current->next;
  }
}
     Как уже  отмечалось,  с  помощью функции define с заголовком

                             - 150 -

списка связывается соответствующая функция вывода  значений  эле-
мента и задается размер элемента списка. Используя передачу пара-
метра по ссылке, первый оператор функции define
                *lst=(LIST*)malloc(sizeof(LIST));
возвращает адрес нового списка.
     Следующие три  оператора инициируют список и заносят в соот-
ветствующие поля  заданные  пользователем  значения  elem_size  и
disp_fun.
     В программе,  реализующей функцию insert_back, сначала отво-
дится  память для указателя new_node.  Далее отводится память для
одного из полей этой структуры - поля new_node->info.  Число бай-
тов, отведенных по адресу new_node->info, равно значению elem_si-
ze.  В первом операторе адрес,  полученный от функции malloc  для
структуры  new_node,  преобразуется к виду указателя на тип NODE.
Во втором операторе адрес,  полученный от функции malloc для поля
new_node->info, преобразуется в указатель на тип char.
     Далее полю next структуры *new_node  присваивается  значение
нуль.
     Затем осуществляется побайтовая пересылка данных из  массива
data  в поле new_node->info.  Функции insert_back не известен тип
информации,  которая заносится в список, но, несмотря на это, пе-
ресылка информации все-таки осуществляется.
     Если создается уже не первый элемент в списке,  то для пере-
бора элементов используется цикл WHILE. По достижении конца спис-
ка элемент new_node присоединяется к списку.
     Если в  список  заносится  первый  элемент,  то  в поле next
структуры *lst заносится указатель на структуру new_node.
     Функция get_front  возвращает  указатель  на  значение  типа
char.  В функции отводится память для возвращаемой  информации  и
адрес такой информации передается в виде указателя на тип char.
     Если список не  пустой,  то  по  адресу  ret_info  отводится
elem_size  байтов.  Затем осуществляется побайтовая пересылка ин-
формации из поля old_node->info  в  массив  ret_info.  Изменяются
ссылки  между  элементами  списка и в качестве результата функции
возвращается адрес массива ret_info.
     В функции display_list осуществляется обход списка и вызыва-
ется функция display:
                  lst->display(current->info);
     Тестовая программа построения двух списков, использующая па-

                             - 151 -

кет программ работы с родовыми списками:
/*Программа работает с родовым списком*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genlist.h"
LIST *number_list;
LIST *record_list;
#define RECORD struct record
RECORD
{
 char name[30];
 float id;
};
main ()
{
 extern void display_number(char *info);
 extern void display_record(char *info);
 {
 int item;
 int *value;
 define (&number_list,sizeof(item),display_number);
 item=4;
 insert_front(&number_list,(char*)&item);
 item=5;
 insert_front(&number_list,(char*)&item);
 item=6;
 insert_front(&number_list,(char*)&item);
 item=-12;
 insert_back(&number_list,(char*)&item);
 value =(int*)get_front(&number_list);
 printf("\nэлемент=%d",*value);
 display_list(number_list);
}
{
 RECORD *item=(RECORD*)malloc(sizeof(RECORD));
 RECORD *value;
 define(&record_list,sizeof(RECORD),display_record);
 strcpy(item->name,"Aaaaa");

                             - 152 -

 item->id=1.2345;
 insert_front(&record_list,(char*)item);
 strcpy(item->name,"Bbbbb");
 item->id=2.2345;
 insert_front(&record_list,(char*)item);
 strcpy(item->name,"Ccccc");
 item->id=3.2345;
 insert_front(&record_list,(char*)item);
 strcpy(item->name,"Ddddd");
 item->id=4.2345;
 insert_back(&record_list,(char*)item);
 value=(RECORD*)get_front(&record_list);
 printf("\n\nИмя %s",value->name);
 display_list(record_list);
 }
printf("\n");
}
void display_number(char *info)
{
 printf("\n%d",*((int*)info));
}
void display_record(char *info)
{
 RECORD *temp=(RECORD*)info;
 printf("\nИмя -> %s",temp->name);
 printf("\nНомер ->%f",temp->id);
}

     Определяются два списка,  number_list и record_list.  Каждый
элемент списка record_list содержит поле name (строка  длиной  до
30 символов) и поле id (число с плавающей точкой).
     В тестовой программе определяются две функции выводы  значе-
ний display_number и display_record.
     В функции display_number  используется  преобразование  типа
(int  *),  с помощью которого вначале результат переводится в тип
указателя на тип int,  который, в свою очередь, служит для вывода
значения элемента списка как целого числа.
     В функции display_record определяется  локальная  переменная
temp,  которая инициализируется значением (RECORD*).  Результатом

                             - 153 -

работы функции будут значения полей элементов списка temp->info и
temp->id.
     Функция main состоит из двух блоков. В первом блоке в список
заносится  несколько  элементов:  в  начале с помощью функции in-
sert_front,  а затем с использованием функции insert_back.  Далее
из списка удаляется элемент с помощью следующего оператора:
              value =(int*)get_front(&number_list);
Функция get_front возвращает указатель на значение типа char. Та-
кой адрес преобразуется к виду указателя на  значение  типа  int.
Затем по адресу выбирается значение, и оно печатается.
     И наконец, осуществляется вывод списка number_list.
     Аналогичные действия  выполняются  и  для второго списка re-
cord_list.
     Программа выведет:
     Элемент = 6
     5
     4
     -12
     Имя Ccccc
     Имя -> Bbbbb
     Номер -> 2.2345000
     Имя -> Aaaaa
     Номер -> 1.2345000
     Имя -> Ddddd
     Номер -> 4.2345000


     7.2.2. Родовое дерево поиска

     Деревья относятся к наиболее важным структурам  данных,  ис-
пользуемым в информатике.  Деревья применяются при синтаксическом
анализе,  поиске, сортировке, управлении базами данных, в игровых
алгоритмах и других важных сферах приложений.
     Дерево представляет собой конечное множество элементов, каж-
дый  из  которых может быть либо пустым,  либо содержать корневой
узел и,  возможно,  другие узлы.  Эти узлы можно разделить на два
непересекающихся  подмножества,  каждое  из которых само является
двоичным деревом.  Такие подмножества называются левым  и  правым
поддеревьями. Каждый узел двоичного дерева может иметь 0, 1 или 2

                             - 154 -

поддерева.  Если у узла нет поддеревьев (потомков), то он называ-
ется листом.
     Будем предполагать, что каждый узел дерева имеет идентифици-
рующий его ключ.
     Дерево поиска  является  разновидностью  дерева,  обладающей
следующим свойством: все узлы дерева, лежащие левее и ниже данно-
го узла, имеют значение ключа, меньшее, чем значение ключа данно-
го узла,  а все узлы,  лежащие правее и ниже данного узла,  имеют
значение ключа,  большее, чем значение ключа данного узла. Приве-
денное свойство позволяет эффективно организовать поиск по двоич-
ному дереву.


     На рис. 7.2. показано дерево, являющееся деревом поиска.



                               ┌────────┐
                               │   50   │
                               └────────┘
                              /           \
                             /             \
                            /               \
                       ┌────────┐       ┌────────┐
                       │   30   │       │   70   │
                       └────────┘       └────────┘
                      /          \
                     /            \
                    /              \
               ┌────────┐      ┌────────┐
               │   15   │      │   45   │
               └────────┘      └────────┘

                       Рис. 7.2. Дерево поиска.


     На рис. 7.3. изображено дерево, для которого нарушено требо-
вание из определения дерева поиска, корневой узел имеет два левых
потомка, значения ключей у которых больше чем 30.

                             - 155 -

                               ┌────────┐
                               │   30   │
                               └────────┘
                              /           \
                             /             \
                            /               \
                       ┌────────┐       ┌────────┐
                       │   40   │       │   90   │
                       └────────┘       └────────┘
                      /          \
                     /            \
                    /              \
               ┌────────┐      ┌────────┐
               │   20   │      │   60   │
               └────────┘      └────────┘

         Рис. 7.3. Дерево, не являющееся деревом поиска.
     Деревья поиска являются весьма важными с практической  точки
зрения,  поскольку они относительно сбалансированы: число уровней
дерева примерно равно двоичному логарифму от числа узлов.  Напри-
мер,  относительно  сбалансированное дерево с 1000000 узлов имеет
лишь 20 уровней.
     Алгоритмы, используемые для добавления,  исключения и поиска
элементов в дереве,  зависят не от количества узлов,  а от  коли-
чества уровней дерева. Таким образом, нелинейная структура дерева
существенно влияет на достижение эффективности вычислений.
     Рассмотрим интерфейс  с программами работы с родовым деревом
поиска,  все элементы которого имеют одинаковый тип.
/*Файл gentree.h*/
#define TREE struct tree
#define NODE struct node
typedef void (*display_function)(char *data);
typedef int (*less_than_function)(char *data1, char *data2);
typedef int (*equal_function)(char *data1, char *data2);
TREE
{
 NODE *next;
 int elem_size;
 display_function display;

                             - 156 -

 less_than_function less_than;
 equal_function equal; };
NODE
{
 char *info;
 NODE *left,*right;
};
extern void define (TREE **tree,int size,display_function disp,
                   less_than_function lthan,equal_function eq);
extern void insert (TREE **tree ,char *item);
extern void take_out(TREE **tree,char *item);
extern void display_tree(TREE *root);
extern int is_present (TREE *root,char *item);
extern void destroy(TREE **root);
     Определяются структуры TREE и NODE. Структура данных родово-
го дерева изображена на рис. 7.4.
                   ┌───────────────────────┐
                   │       elem_size       │
                   │       display         │
             TREE  │       less_than       │
                   │       equal           │
                   │       next ──┐        │
                   └──────────────┼────────┘
                                   7^
                             ┌────────┐
                             │  info  │
                NODE┌────────┼─ left  │
                    │        │  right─┼─────────┐
                    │        └────────┘         │
                    │                           │
                    │                           │
                     7^                           ^
               ┌────────┐                   ┌────────┐
               │  info  │                   │  info  │
       NODE    │  left  │          NODE     │  left  │
               │  right │                   │  right │
               └────────┘                   └────────┘

                Рис. 7.4. Родовое дерево поиска.

                             - 157 -

     Определяются три типа, устанавливающие указатели на функции.
Тип  display_function  задает указатель на функцию,  имеющую один
параметр  data   и   возвращающую   значение   типа   void.   Тип
less_than_function  и equal_function задает указатель на функцию,
использующую два параметра,  data1 и data2,  которые указывают на
значения типа char и возвращают значение типа int.
     Три рассмотренных определения типа являются прототипами  для
описываемых пользователем функций, используемых в функции define.
Поскольку пакет программ для родового дерева не рассчитан на  ра-
боту  с  каким-то конкретным базовым типом данных,  то средствами
пакета невозможно ни определить способ сравнения  двух  элементов
базового типа, ни задать способ вывода значений элементов.
     Функции disp, lthan и eq, определяемые пользователем, связы-
ваются с корневым узлом дерева с помощью функции define.
     С применением этой же функции в корень  дерева  заносится  и
размер  элемента  в  байтах.  Для  обеспечения целостности работы
программ пакета вызовам функций должно предшествовать обращение к
функции define.
     Первым параметром каждой их трех функций  define,  insert  и
take_out  является  адрес  указателя на структуру TREE.  Любая из
приведенных функций может что-либо изменить в корневом узле дере-
ва.  Так,  функция define всегда изменяет корневой узел.  Функции
insert и take_out изменяют корневой узел,  если только  к  дереву
добавляется новый элемент или из дерева удаляется элемент.
     Реализация программ работы с родовым деревом:
/*Файл gentree.c*/
#include <string.h>
#include <alloc.h>
#include "gentree.h"
static NODE* create_node (char *item,int size)
{
 NODE *node;
 int i;
 node=(NODE*)malloc(sizeof(NODE));
 node->info = (char*)malloc(size);
/* выполняется побайтная пересылка */
for (i=0;i<size;i++)
    node ->info[i]=item[i];
    return node;

                             - 158 -

}
static void post_order(NODE *current)
{
 if (current)
 {
  post_order(current->left);
  post_order(current->right);
  free(current->info);
  free(current);
  }
}
void destroy (TREE **root)
{
 NODE *current=(*root)->next;
 post_order(current);
 (*root)->next=0;
}
void define (TREE **tree,int size,
            display_function disp,
            less_than_function lthan,
            equal_function eq)
{
 *tree=(TREE*)malloc(sizeof(TREE));
  (*tree)->next=0;
  (*tree)->display=disp;
  (*tree)->less_than=lthan;
  (*tree)->elem_size=size;
  (*tree)->equal=eq;
}
int take_out (TREE **root,char *item)
{
NODE *previous=0,*present=(*root)->next,*replace,*s,*parent;
int found=0;
while (present && !found)
{
 if ((*root)->equal(present->info,item)) found=1;
    else
    {
    previous=present;

                             - 159 -

    if ((*root)->less_than(item,present->info))
         present=present->left;
       else present=present->right;
    }
}
if (found)
{
 if (present->left==0) replace=present->right;
    else if (present->right==0) replace=present->left;
         else
            {
             parent=present;
             replace=s;
             s=replace->left;
             while (s!=0)
            {
              parent=replace;
              replace=s;
              s=replace->left;
            }
            if (parent!=present)
            {
            parent->left=replace->right;
            replace->right=present->right;
            }
            replase->left=present->left;
            }
  if (present==0) (*root)->next=replace;
     else if (present==previous->left) previous->left=replace;
             else
                 previous->right=replace;
  free(present->info);
  free(present);
  }
}
void insert (TREE **root,char *item)
{
 NODE *parent=0,*current=(*root)->next;
 NODE *new_node;

                             - 160 -

 int found=0;
while (current && !found)
{
 if ((*root)->equal(current->info,item)) found=1;
    else
    {
    parent=current;
    if ((*root)->less_than(item,current->info))
         current=current->left;
       else current = current->right;
    }
}
if (found==0)
{
 if (parent==0)
/* первый узел дерева */
{
 new_node=create_node(item,(*root)->elem_size);
 new_node->left=new_node->right=0;
 (*root)->next=new_node;
}
else
{
 new_node=create_node(item,(*root)->elem_size);
 new_node->left=new_node->right=0;
 if ((*root)->less_than(item,parent->info))
      parent->left=new_node;
    else parent->right=new_node;
    }
}
}
static void traverse(NODE* current,display_function display)
{
 if (current)
    {
    traverse(current->left,display);
    (*display)(current->info);
    traverse(current->right,display);
    }

                             - 161 -

}
void display_tree(TREE *root)
{
NODE *current=root->next;
traverse(current,root->display);
}
int is_present(TREE *root,char *item)
{
NODE *current=root->next;
int found=0;
while (current && !found)
{
 if (root->equal(item,current->info)) found=1;
  else
  {
  if (root->less_than(current->info,item)) current=current->left;
     else current=current->right;
  }
}
return found;
}
     Первая функция create_node невидима для загрузчика,  так как
снабжена спецификатором static. Обращение к этой функции выполня-
ется из функции  insert.  Очевиден  родовой  характер  реализации
функции create_node.
     Новый узел  дерева описывается как объект типа NODE.  Память
отводится как для структуры узла,  так и для информационного поля
info.  Пересылка данных из элемента в узел осуществляется побайт-
но. В качестве результата функции возвращается адрес нового узла.
     В функции  destroy  описывается локальный указатель current,
причем ему присваивается значение поля next структуры *root.  За-
тем вызывается рекурсивная функция post_order, параметром которой
является указатель current.  Обход дерева в  глубину  реализуется
фрагментом программы:
 if (current)
 {
  post_order(current->left);
  post_order(current->right);
  free(current->info);

                             - 162 -

  free(current);
  }
где для доступа к узлам применяется рекурсия,  при которой всегда
вначале обращаются к левому,  а затем к правому потомку узла. Под
доступом  подразумевается,  что  сначала освобождается память для
поля info структуры NODE,  а только потом - для  самой  структуры
NODE.  При  использовании  алгоритма обхода дерева в глубину узлы
удаляются от нижних к верхним,  причем связи между узлами никогда
раньше времени не разрываются.
     В функции define отводится память под новый  корневой  узел.
Затем  в этот узел заносятся размер элемента в байтах (elem_size)
и указатели на определяемые пользователем функции disp,  lthan  и
eq.
     В функциях take_out и insert для сравнения  полей  last_name
заданной  структуры используются определяемые пользователем функ-
ции equal и less_than.
     Положение нового  узла  в  дереве  определяется по следующим
правилам.
     Значение ключа элемента, добавляемого к дереву, сравнивается
со значение ключа корневого узла.  Если ключ элемента меньше  чем
ключ корневого узла,  то нужно переместиться к левому потомку уз-
ла;  в противном случае следует переместиться к  правому  потомку
узла.  Сравнения повторяются, причем каждый раз ключ элемента со-
поставляется либо с ключом левого потомка,  либо с ключом правого
потомка. Если обнаруживается совпадение, то сравнения прекращают-
ся; в противном случае сравнения продолжаются, пока не будет дос-
тигнут низ дерева.
     После завершения обхода дерева указатель parent всегда  ука-
зывает на узел,  лежащий на один уровень выше, чем узел, на кото-
рый указывает указатель curent, и задает положение предка текуще-
го узла.  Если указатель current принимает нулевое значение (т.е.
достигнут низ дерева),  то вновь создаваемый узел подключается  к
родительскому узлу либо как левый,  либо как правый потомок в за-
висимости от значения ключа узла.
     В функции  display_tree описывается локальный указатель cur-
rent, которому присваивается значение адреса корневого узла дере-
ва.  Затем вызывается функция traverse. Вторым параметром функции
traverse  передается  адрес  определяемой  пользователем  функции
display.

                             - 163 -

     В функции travense,  описанной как static, для обхода дерева
вглубь используются {операторы} в if (current).  При обходе с по-
мощью функции display, указатель на которую передается в качестве
параметра, выводятся значения, содержащиеся в каждом узле.
     В функции is_present в процессе обхода дерева вызывается оп-
ределяемая  пользователем функция equal.  Если сравнение значений
ключей с помощью функции equal показало их совпадение, то функция
is_present  возвращает 1,  в противном случае результат функции -
нуль.
     Тестовая программа, использующая пакет программ работы с ро-
довым деревом поиска:
#include <stdio.h>
#include <alloc.h>
#include <stdlib.h>
#include <string.h>
#include "gentree.h"
TREE *my_tree;
#define RECORD struct record
RECORD
 {
 char name[30];
 float id;
 };
main()
{
 extern void display_record(char *info);
 extern int less_than(char *item1,char *item2);
 extern int equal (char *item1,char *item2);
 RECORD *item=(RECORD)malloc(sizeof(RECORD));
 RECORD *value;
 define (&my_tree,sizeof(RECORD),display_record,less_than,equal);
 strcpy(item->name,"Ccccc");
 item->id=3.2345;
 insert(&my_tree,(char*)item);
 strcpy(item->name,"Eeeee");
 item->id=5.2345;
 insert(&my_tree,(char*)item);
 strcpy(item->name,"Aaaaa");
 item->id=1.2345;

                             - 164 -

 insert(&my_tree,(char*)item);
 strcpy(item->name,"Ddddd");
 item->id=4.2345;
 insert(&my_tree,(char*)item);
 strcpy(item->name,"Fffff");
 item->id=6.2345;
 insert(&my_tree,(char*)item);
 strcpy(item->name,"Bbbbb");
 item->id=2.2345;
 insert(&my_tree,(char*)item);
 take_out(&my_tree,(char*)item);
 display_tree(my_tree);
 destroy(&my_tree);
 printf("\n");
}
void display_record(char *info)
{
RECORD *temp=(RECORD*)info;
printf("\nИмя -> %s",temp->name);
printf("\n Номер -> %f",temp->id);
}
int less_than(char *item1,char *item2)
{
 RECORD *first=(RECORD*)item1;
 RECORD *second=(RECORD*)item2;
 return strcmp(first->name,second->name)<0;
}
int equal(char *item1,char *item2)
{
RECORD *first=(RECORD*)item1;
RECORD *second=(RECORD*)item2;
return strcmp(first->name,second->name)==0;
}
     В тестовой программе определяется структура RECORD, содержа-
щая два поля.  Первое поле name служит ключом, на основе которого
строится дерево.  Второе поле id содержит числовое значение  типа
float.
     Дерево my_tree описывается как глобальная структура.
     В качестве  параметров функции define передаются три опреде-

                             - 165 -

ляемые пользователем функции,  display_record, less_than и equal.
В  качестве  первого  параметра  функции  define передается адрес
структуры my_tree. Указатель item на структуру RECORD многократно
используется для занесения в дерево новых параметров.  Затем один
из элементов удаляется из дерева. Значения элементов дерева выво-
дятся на печать,  после чего дерево уничтожается. Программа выво-
дит следующие результаты:
     Имя -> Aaaaa
     Номер -> 1.234500
     Имя -> Ccccc
     Номер -> 3.234500
     Имя -> Ddddd
     Номер -> 4.234500
     Имя -> Eeeee
     Номер -> 5.234500
     Имя -> Fffff
     Номер -> 6.234500

  8. Организация программных средств

     8.1. Архитектура программных средств и библиотеки

     Турбо СИ имеет богатую поддержку в виде более 300 библиотеч-
ных подпрограмм - функции и макросов,  которые вы можете вызывать
из своих Си-программ для решения широкого спектра задач,  включая
ввод/вывод низкого и высокого уровня, работу со строками и файла-
ми,  распределение памяти,  управление процессами, преобразование
данных,  математические  вычисления,  сортировка и поиск и многое
другое.
     Подпрограммы Турбо   Си  содержатся  в  библиотечных  файлах
(Cx.lib и MATHx.lib).  Так как Турбо Си поддерживает шесть разных
моделей  памяти,  то каждая модель имеет свои собственные библио-
течные файлы,  содержащие версии подпрограмм, написанные с учетом
особенностей каждой модели памяти.
     Турбо Си поддерживает  предварительный  стандарт  языка  Си,
предложенный ANSI. Этот стандарт, помимо всего прочего, допускает
применение прототипов функции,  передаваемых подпрограммами в ва-
шей программе на Си.  Все библиотечные подпрограммы Турбо Си опи-
саны вместе со своими прототипами в  одном  или  нескольких  фай-

                             - 166 -

лах-заголовках. Такими файлами являются .h или "include" файлы.
     В процессе использования Турбо Си вам может понадобиться на-
писать функцию,  похожую на библиотечную, но не аналогичную ей по
выполняемым действиям. Обладая доступом к исходным текстам библи-
отеки поддержки Си,  вы легко сможете отыскать такую функцию и на
ее основе написать свою.

     8.1.1. Включаемые файлы Турбо Си

ALLOC.H    Описание  функции  управления  памятью   (allocation,
           deallocation и др.)
ASSERT.H   Определение assert - отладчика macro.
BIOS.H     Описание различных функций, используемых при обращении
           к  подпрограммам  BIOS  (базовой системе ввода-вывода)
           IBM PC.
CONIO.H    Описание различных функций, используемых в обращении к
           подпрограммам ввода-вывода DOS.
CTYPE.H    Содержит информацию, используемую макросами классифи-
           кации символов  и  макросами  преобразования  символов
           (такими как макросы isalpha или toascii)
DIR.H      Содержит структуры, макросы и  функции  для  работы  с
           каталогами и маршрутами доступа.
DOS.H      Содержит  определения  различных  констант и описания,
           необходимые для обращения к MS-DOS и процессору 8086.
ERRNO.H    Определяет константы кодов ошибок.
PCNTL.H    Определяет символьные константы, используемые для свя-
           зи с библиотечной подпрограммой open.
FLOAT.H    Содержит параметры подпрограмм работы с числами с пла-
           вающей точкой.
IO.H       Содержит структуры и описания подпрограмм ввода-вывода
           нижнего уровня.
LIMITS.H   Содержит параметры  среды, информацию  об ограничениях
           на время  компиляции и диапазоны различных целочислен-
           ных значений.
MATH.H     Содержит описание прототипов математических функций, а
           также определение макроса HUGE_VAL и описание уникаль-
           ных  структур,  используемых  подпрограммами matherr и
           _matherr.
MEM.H      Описывает функции работы с  памятью(многие из них так-

                             - 167 -

           же определены в string.h).
PROCESS.H  Содержит   структуры  и   описания   функции семейства
           spawn... и exec...
SETJMP.H   Определяет тип jmp_buf, используемый функциями longjmp
           и setjmp, и описывает эти функции.
SHARE.H    Определяет параметры  для  функций,  которые позволяют
           использовать деление файла (file_sharing).
SIGNAL.H   Определяет  константы  SIG_IGM  и  SIG_DEL и описывает
           функции ssignal и gsignal.
STDARG.H   Определяет макросы, используемые для чтения списка ар-
           гументов в функциях,  описанных как функции с перемен-
           ным  числом аргументов (таких,  как vprintf,  vscanf и
           т.д.).
STDDEF.H   Определяет несколько общих типов данных и макросов.
STDIO.H    Определяет типы и макросы, необходимые для стандартно-
           го пакета ввода-вывода, описанного Керниганом и Ричи и
           впервые введенного в UNIX System V. А также определяет
           стандартный ввод-вывод, переопределяющий потоки stdin,
           stdout и  stderr,  и  описывает  потокоориентированные
           подпрограммы ввода/вывода.
STDLIB.H   Описывает различные  подпрограммы  общего  назначения,
           подпрограммы преобразования, поиска, сортировки и дру-
           гие.
STRING.H   Описывает различные подпрограммы обработки строк и ра-
           боты с памятью.
SYS\       Определяет  символьные константы, используемые при от-
           крытии
STAT.H     и создании файла.
TIME.H     Определяет структуры, заполняемые подпрограммами  пре-
           образования  времени  asctime, gmtime,localtime; типы,
           используемые подпрограммами ctime,  difftime,  gmtime,
           localtime  и  stime,  а  также содержит прототипы этих
           функций.
VALUES.H   Определяет наиболее важные константы, включая машинно-
           зависимые; обеспечивает совместимость  с  операционной
           системой UNIX System V.




                             - 168 -

     8.1.2. Библиотека подпрограмм по категориям

     Библиотека подпрограмм  Турбо Си предназначена для различных
задач. В этом разделе будут перечислены подпрограммы и подключае-
мые файлы, содержащие их описания, в соответствии с основными ка-
тегориями решаемых задач.
     Подпрограммы классификации:   классифицируют   символы  кода
ASII,  такие как буквы,  управляющие символы, пунктуацию, символы
нижнего регистра и т.д.
     Подпрограммы каталога: предназначены для работы с каталогами
или именами путей доступа.
     Подпрограммы процессов: запускают и завершают новые процессы
внутри других.
     Подпрограммы преобразования  символов  и  срок:  преобразуют
символы и строки; из символьного в различные числовые представле-
ния (с плавающей точкой, целое, длинное) и наоборот; из прописных
в строчные (и наоборот).
     Подпрограммы диагностики:  обеспечивают встроенный  контроль
ошибочных ситуаций.
     Подпрограммы ввода/ввода:  обеспечивают ввод/вывод низкого и
высокого уровней.
     Интерфейсные подпрограммы (DOS,  8086,  BIOS): позволяют ис-
пользовать средства DOS, BIOS и возможности процессора.
     Подпрограммы манипулирования (строками,  памятью): позволяют
работать  со строками и блоками памяти:  копировать,  сравнивать,
производить различные преобразования и осуществлять поиск.
     Математические подпрограммы:  позволяют осуществлять матема-
тические преобразования и вычисления.
     Подпрограммы распределения  памяти:  позволяют  осуществлять
динамическое выделение памяти в малой и большой моделях данных.
     Прочие подпрограммы:  позволяют осуществлять нелокальные пе-
реходы в программах.
     Стандартные подпрограммы.
     Подпрограммы работы со временем и датой: позволяют проводить
преобразование времени,  даты, а также осуществлять различные ма-
нипуляции с ними.




                             - 169 -

     8.2. Управление процессами компиляции, директивы компиляции

     Турбо Си поддерживает все управляющие команды, описанные в K
&R. Этими командами являются директивы препроцессора - строки ис-
ходной программы,  начинающиеся со знака #,  за которым или перед
которым может следовать символ пробела или табуляции.

     8.2.1. Замена лексем

     Турбо Си  поддерживает  определения K&R для #define и #undef
со следующими дополнениями:
     1. Ниже  приведенные  идентификаторы не должны встречаться в
директивах #define и #undef:
     _STDC_
     _FILE_
     _LINE_
     _DATE_
     _TIME_
     2. Две лексемы могут быть помещены вместе в макроопределение
с разделением их знаками ## (плюс необязательные пробелы с каждой
стороны).  Препроцессор удаляет пробелы и ##, а также комбинирует
разделенные  лексемы.  Это  может  быть использовано для создания
идентификаторов, например, задав:
               #define VAR(i,j)          (i ## j)
при VAR(x,6) обращение вызовет подстановку x6. Это заменяет иног-
да употребляемую, но не переносимую запись (i/**/j).
     3. Вложенные макросы  в  строке  макроопределения  сработают
лишь  тогда,  когда сработает сам макрос,  а не при его описании.
Это больше касается вложенных макросов #undef.
     4. Символ #,  помещаемый перед макроаргументом,  указанном в
последовательности, преобразует аргумент в строку. При макроподс-
тановке  производится замена #<формальный аргумент> на "<действи-
тельный аргумент>". Так, при задании макроопределения
        #define TRACE(flag) printf(#flag "= %d\n", flag)
следующий фрагмент текста программы
     highval = 1024;
     TRACE(highval);
преобразуется в:
     highval = 1024;

                             - 170 -

     printf("highval" "= %d\n", highval);
     5. В отличие от других реализаций,  Турбо Си не  подставляет
макроаргументы внутри строк и символьных констант.

     8.2.2. Включение файла

     В Турбо Си директива #include реализована согласно K&R, но с
некоторыми дополнительными особенностями.  Если  препроцессор  не
нашел include файл в каталоге, установленном по умолчанию, (пред-
полагается,  что вы используете запись include "filename"), тогда
он ищет каталоги, заданные опцией компилятора -I. Если вы исполь-
зуете форму #include <ИмяФайла>,  тогда ищутся  только  каталоги,
заданные  опцией  -I.  (Каталоги,  перечисленные  в меню по опции
O/Environment/Include,  эквивалентны маршруту,  указанному с  по-
мощью опции -I pathname в командной строке.
     Вы можете задать маршрут к #include,  через граничные разде-
лители, используя макрорасширение. Если следующая после ключевого
слова строка начинается с идентификатора, препроцессор просматри-
вает текст для макроса.  Однако,  если строка заключена в кавычки
или в острые скобки, Турбо Си не будет проверять ее для распозна-
вания макроса. Например,
     #define myinclude     "c:\tc\include\mystuff.h"
     #include myinclude
     #include "myinclude.h"
1-ый #include   оператор   заставит   препроцессор  просматривать
C:\TC\INCLUDE\MYSTUFF.H, тогда как 2-ой вызовет просмотр MYINCLU-
DE.H в каталоге по умолчанию.
     Кроме того,  вам нельзя  использовать  объединение  литерных
строк и вставку лексем в макросе, который используется в операто-
ре include. Макрорасширение должно создавать текст, который чита-
ется как нормальная #include директива.

     8.2.3. Условная компиляция

     Турбо Си  поддерживает определение условной компиляции K&R с
помощью замены  соответствующих  строк  на  пустые.  Игнорируемые
строки начинаются с директив #if,  #ifdef, #ifndef, #else, #elif,
и #endif,  также как и все некомпилируемые строки, являющиеся ре-
зультатом этих директив. Все директивы условной компиляции должны

                             - 171 -

заканчиваться в исходной программе или include файле,  в  которых
они начались.
     Турбо Си поддерживает также оператор  ANSI  defined(символ).
Значение  1 (true) присваивается,  если символ был предварительно
определен (с использованием #define) и затем не  был  отменен  (с
использованием  undef);  в противном случае присваивается 0 (fal-
se). Так, директива
                       #if defined(mysym)
адекватна директиве
                          #ifdef mysym
     Преимущество в том,  что вы можете повторно использовать de-
fined в сложном выражении, стоящем за директивой #if:
             #if defined(mysym) || defined(yoursym)
     Наконец, Турбо  Си (в отличие от ANSI) позволяет вам исполь-
зовать оператор sizeof в выражениях препроцессора.  Так вы можете
написать следующее:
     #if (sizeof(void *) == 2)
     #define SDATA
     #else
     #define LDATA
     #endif
     Турбо Си поддерживает определение #line,  данное в K&R. Рас-
ширения макросов в #line такие же, как и в #include.

     8.2.4. Директива error

     Турбо Си поддерживает директиву #error,  которая упоминается
(но не определена в полной мере) в ANSI-стандарте. Ее формат:
                          #error errmsg
     Если вы включили эту директиву в условную компиляцию в своем
исходном файле, и условие ложно, то препроцессор, считав директи-
ву #error, немедленно прерывает процесс, выдав при этом следующее
сообщение:
          Fatal: filename line# Error directive: errmsg
(Фатальная ошибка: Имяфайла строка# Ошибка в директиве: errmsg)
     Препроцессор просматривает текст,  уничтожая комментарии,  а
на экран выводит оставшийся текст  без  просмотра  для  выявления
макросов.


                             - 172 -

     8.2.5. Директива pragma

     Турбо Си поддерживает директиву #pragma,  которая (как и er-
ror),  неясно определяется в стандарте ANSI.  Ее  целью  является
разрешить специализированные директивы по форме:
                     #pragma <имя директивы>
     С помощью #pragma Турбо Си может определить любые директивы,
которые ему требуются,  без  вмешательства  других  компиляторов,
поддерживающих #pragma.  Почему? Потому что, по определению, если
компилятор не опознал  имя  директивы,  он  игнорирует  директиву
#pragma.
     Турбо Си распознает две директивы #pragma. Первая:
                         #pragma inline
     Эта директива эквивалентна опции компилятора -B. Она сообща-
ет компилятору о том,  что в вашей программе присутствуют команды
ассемблера. Наилучшее ее расположение - начало файла, т.к. компи-
лятор самоперезапускается с опцией -B сразу, как только встретит-
ся #pragma inline.  На самом деле, вы можете опустить и опцию -B,
и директиву #pragma inline, т.к. компилятор все равно самопереза-
пускается,  как только встретит asm операторы; целью этой опции и
директивы является экономия времени компиляции.
     Другая #pragma директива - это
                           #pragma warn
     Данная директива позволяет вам не принимать во внимание спе-
циальную  опцию  командной строки -wxxx (или спецификацию Display
warnings...On ).
     Например, если  исходный  текст вашей программы содержит ди-
рективы:
     #pragma warn +xxx
     #pragma warn -yyy
     #pragma warn .zzz
то xxx включит вывод пользователю  предупреждений  (если  даже  в
подменю O/C/Errors/ она была выключена); yyy выключит вывод сооб-
щений;  а zzz восстановит первоначальное значение, которое было в
начале компиляции файла.

     8.2.6. Директива null

     Ради завершенности, ANSI-стандарт и Турбо Си опознают пустую

                             - 173 -

директиву,  состоящую из строки со знаком #. Эта директива всегда
игнорируется.

     8.2.7. Встроенные макроимена

     ANSI стандарт  требует  чтобы в реализации было 5 встроенных
макросов.  Турбо Си применяет все 5.  Отметим,  что каждый из них
начинается и оканчивается символами подчеркивания (__).

_LINE_ Номер  обрабатываемой строки исходной программы - десятич-
       ная константа.  Первая строка исходного  файла  определена
       как 1.
_FILE_ Имя обрабатываемого исходного  файла  -  строка  символов.
       Данное  макроопределение изменяется всякий раз,  при обра-
       ботке компилятором директивы #include или директивы #line,
       или по окончании включаемого файла.
_DATE_ Дата начала обработки текущего исходного  файла  -  строка
       символов.  Каждое вхождение _DATE_ в заданном файле гаран-
       тирует одно значение,  независимо от продолжительности об-
       работки.  Дата  имеет формат mmm dd yyyy,  где mmm - месяц
       (Jan,  Feb и т.д.),  dd - число текущего месяца (1...31; в
       первой позиции dd ставится пробел,  если число меньше 10),
       yyyy - год (1987, 1988 и т.д.).
_TIME_ Время начала обработки текущего исходного файла препроцес-
       сором - строка символов.  Каждое вхождение _TIME_ в задан-
       ном файле гарантирует одно значение, независимо от продол-
       жительности обработки. Время имеет формат hh:mm:ss, где hh
       -  час  (00...23),  mm  -  минуты (00...59),  ss - секунды
       (00...59).
_STDC_ Константа,  равная  1,  если вы компилируете с (-A) флагом
       (ANSI keywords only...ON), устанавливающим совместимость с
       ANSI стандартом; иначе макроопределение не определено.

     8.2.8. Встроенные макросы Турбо Си

     Для вашего  использования  препроцессор  Турбо Си определяет
несколько дополнительных макросов. Также, как для макросов, пред-
писанных стандартом ANSI, каждый из них начинается и оканчивается
двумя символами подчеркивания.

                             - 174 -

_TURBOC_ Выдает  номер текущей версии Турбо Си - шеснадцатиричная
         константа.  Версия 1.0 представляется как 0x0100; версия
         1.2 - как 0x0102 и т.д.
_PASCAL_ Определяет наличие флага  -p;  устанавливается  в  целую
         константу, равную 1, если используется флаг -p; иначе не
         определяется.
_MSDOS_ Целая константа, равная 1, для всех компиляторов
_CDECL_ Сигнализирует  о том,  что флаг -p не использовался (Cal-
        ling convention...C); устанавливает целую константу, рав-
        ную 1,  если флаг -p не использовался; иначе не определя-
        ется.
     Следующие 6 макросов зависят от выбранной для компиляции мо-
дели памяти.  Для заданной компиляции определяется только одна из
них;  остальные (по-определению) не определяются.  Например, если
вы компилируете с малой моделью,  определяется _SMALL_, а осталь-
ные - нет;  поэтому директива #if  defined(_SMALL_)  будет  иметь
значение  true (истина),  в то время как #if defined(_HUGE_) (или
любая другая) будет иметь значение false  (ложь).  Действительное
значение  для любого определенного макроса равно 1.
_TINY_    Опция выбора крохотной модели памяти
_SMALL_   Опция выбора малой модели памяти
_MEDIUM_  Опция выбора средней модели памяти
_COMPACT_ Опция выбора компактной модели памяти
_LARGE_   Опция выбора  большой модели памяти
_HUGE_    Опция выбора огромной модели памяти

   9. Объектно-ориентированное программирование

     9.1. Основные концепции ООП

     Объектно-ориентированное программирование (ООП) есть резуль-
тат естественной эволюции более ранних методологий программирова-
ния:  оно  более структурировано и более модульное и абстрактное,
чем традиционное программирование.  Три основных концепции харак-
теризуют язык ООП:
- инкапсуляция - это комбинирование данных с процедурами и  функ-
                 циями,  которые манипулируют этими данными,  для
                 получения нового типа данных - объекта;
- наследование - это  определение  объекта и затем  использование

                             - 175 -

                 его для построения иерархии  производных  объек-
                 тов,  причем  каждый  производный объект ("пото-
                 мок") наследует доступ к коду и данным всех сво-
                 их "прародителей";
- полиморфизм -  это придавание  действию  одного  имени, которое
                 совместно  используется объектами всей иерархии,
                 причем  каждый  объект  иерархии  реализует  это
                 действие своим собственным, подходящем для него,
                 образом.

     9.2. Классы

     С++ и С имеют структуры;  они представляют собой формы гете-
рогенных составных типов. С++ переопределяет структуры так, чтобы
разрешить сокрытие данных,  наследование и функции-члены как  ос-
новные новые расширения.  В С++ ключевые слова class и struct ис-
пользуются для объявления типов, определяемых пользователем. При-
мер:
     class vect {
     private:
        int* p;    //базовый указатель
        int size;  //число элементов
     public:
        //конструкторы и деструктор
        vect() {size = 10; p = new int[10]} //создают массив
                                            //размерности 10
        vect(int n);            //создают массив размерности n
        vect(vect& v);          //vect
        vect(int a[], int n);   //инициализируется от массива
        ~vect()  {delete [] p}  //деструктор
        //прочие функции-члены
        int ub() { return (size - 1); }  //верхняя граница
        int& operator[] (int i);         //элемент проверенный на
                                         //невыход за границу
     };
     Ключевые слова  public,  private и protected указывают види-
мость членов,  которые следуют за ними.  По умолчанию для  класса
устанавливается  private,  а для struct - по умолчанию public.  В
вышеупомянутом примере данные-члены p и size - private. Это дела-

                             - 176 -

ет  их  видимыми  исключительно для функций-членов того же самого
класса.

     9.3. Конструкторы и деструкторы

     Конструктор - функция-член,  имя которой совпадает с  именем
класса.  Он создает объекты типа класса. Это включает инициализа-
цию членов-данных,  и, часто, распределение свободной памяти, ис-
пользующее new.  Классы, имеющие конструктор с пустым списком па-
раметров,  как конструктор, все параметры которого имеют значение
по умолчанию, могут быть базовыми типами для объявления массивов,
если инициализация неявная.  Такой конструктор  называется  конс-
труктором по умолчанию.
       foo::foo()  {...}             //конструктор по умолчанию
       hoo::hoo(int i=0)  {...}      //конструктор по умолчанию
     Деструктор - функция-член с именем,  таким  же,  как  и  имя
класса, которому предшествует символ ~ (тильда). Обычная его цель
состоит в том, чтобы удалять значения типа класса. Это обычно вы-
полняется путем применения delete.
     Конструктор в форме
                    тип::тип (const тип & x)
используется для выполнения копирования значения  одного  типа  в
другой, когда
     - Переменная типа инициализируется значением типа.
     - Значение типа передано как аргумент в функцию.
     - Значение типа возвращается из функции.
     Это называется конструктором копии и,  если он не указан яв-
но, то генерируется компилятором. По умолчанию происходит почлен-
ная инициализация значений.
     Классы с конструкторами по умолчанию могут иметь порожденный
тип массива. Например,
                           vect a[5];
является объявлением,  которое  использует  конструктор  с пустым
списком параметров для того,  чтобы создать массив a из пяти объ-
ектов, каждый из которых - типа vect размером 10.
     Класс, имеющий члены,  тип которых требует конструктора, мо-
жет  определять  их  после списка параметров для его собственного
конструктора. Конструктор имеет список обращений к конструкторам,
указываемых через запятую, следующих после двоеточия. Конструктор

                             - 177 -

вызывается с использованием имени члена, сопровождаемого парамет-
ризованным списком параметров.  Конструкторы не могут быть вирту-
альными,  а деструкторы - могут.  Конструкторы и  деструкторы  не
наследуются.

     9.4. Функции-члены

     Функции-члены - функции,  объявленные внутри класса, и имею-
щие доступ к private, protected и public членам этого класса. Бу-
дучи  определенными внутри класса,  они обрабатываются как inline
функции.  При необходимости они также обрабатываются как перегру-
женные функции. В классе vect определяется
     int ub()   { return (size - 1); }    //верхняя граница
как функция-член.  В  этом  примере  функция  члена  ub  - inline
(встроена) и имеет доступ к private члену size.
     Функции-члены обычно  вызываются с использованием операторов
"." или ->, как в
     vect a(20), b;        //вызывает соответствующий конструктор
     vect* ptr_v = &b;
     int uba = a.ub(), ubb;//вызывает член ub
     ubb = ptr_v -> ub();  //вызывают член ub

     9.4.1. Указатель this

     Ключевое слово this обозначает неявно  объявленный  самоссы-
лочный указатель.  this может использоваться только в нестатичес-
кой функции-члене.  Простая иллюстрация его использования следую-
щая:
     //Использование указателя this
     class c_pair  {
     private:
        char c1, c2;
     public:
        c_pair(char b)  { c1 = 1 + (c2 = b); }
        c_pair increment() { c1++, c2++, return (*this); }
        unsigned where_am_I() { return ((unsigned)this); }
        void print() { cout << c1 << c2 << "\t"; }
     };
     Функция-член increment() использует неявно объявленный  ука-

                             - 178 -

затель this для того, чтобы возвратить вновь увеличенные значения
c1 и c2.  Функция-член where_am_I() возвращает адрес данного объ-
екта.  Ключевое  слово  this  обозначает встроенный самоссылочный
указатель.  Как будто c_pair неявно объявил частный член  c_pair*
const this.
     Ранние системы C++ позволяли управление памятью  для  объек-
тов, которые разрешали манипулировать присвоением указателя this.
Такой код устарел, потому что указатель this является немодифици-
руемым.

     9.4.2. Функции-члены static и const

     Обычная функция-член вызывается как
                      object.mem(i, j, k);
     Она имеет явный список аргументов i,  j,  k и неявный список
параметров, который состоит из членов object i. Неявные параметры
можно считать списком параметров, доступных через указатель this.
В отличии от этого static функция-член не может обращаться к  лю-
бому члену,  использующему указатель this.  Const функция-член не
может изменять свои неявные параметры. Следующий пример иллюстри-
рует эти различия:
  //Расчет зарплаты с использованием
  //static и const функций-членов.
  #include <iostream.h>
  class salary {
  private:
     int b_sal;
     int your_bonus;
     static int all_bonus;   //объявление
  public:
     salary(int b) : b_sal(b) { }
     void calc_bonus(double perc)  {your_bonus = b_sal * perc;}
     static void reset_all(int p)  {all_bonus = p; }
     int comp_tot() const
        { return (b_sal + your_bonus + all_bonus); }
  };
  int salary::all_bonus = 100;  //объявление и определение
  main()
  {

                             - 179 -

    salary w1(1000), w2(2000);
    w1.calc_bonus(0.2);
    w2.calc_bonus(0.15);
    salary::reset_all(400);  //эквивалентно w1.reset_all(400);
    cout << " w1 " << w1.comp_tot() << " w2 " << w2.comp_tot()
         << "\n";
  }
     Статический член  all_bonus  требует  объявления в контексте
файла.  Он существует независимо от любых объявляемых специфичес-
ких переменных типа salary.  На статический член также можно ссы-
латься так:
                        salary::all_bonus
     Модификатор const появляется между концом списка  параметров
и началом тела кода.  Он указывает, что все члены-данные не будут
изменять свои значения.  Это также делает код более  надежным.  В
результате  самоссылочный  указатель передается как const salary*
const this.  Функция-член static может  вызываться  с  оператором
разрешения контекста или с использованием специфического объекта.
Следовательно,
     salary::reset_all(400);
     w1.reset_all(400);
     (&w2) -> reset_all(400);
эквивалентны.

     9.5. Наследование

     Наследование - механизм порождения нового класса от старого.
Для  создания  порожденного класса можно что-либо добавлять к су-
ществующему классу или изменять его. Класс может быть порожден от
существующего класса таким образом:
     class имя класса : (public│protected│private)
     имя базового класса
     {
       объявления члена
     };
     Как обычно,  ключевое  слово class может заменяться ключевым
словом struct с тем отличием,  что все члены по умолчанию -  pub-
lic.  Ключевые слова public, private и protected используются как
модификаторы видимости для членов класса.  Член  public  видим  в

                             - 180 -

контексте.  Член  private  видим для других функций-членов внутри
собственного класса.  Член  protected  видим  для  функций-членов
внутри  класса  и любого класса,  непосредственно порожденного от
этого.  Модификаторы видимости могут использоваться внутри объяв-
ления класса в любом порядке и с любой частотой.
     Базовый класс,  имеющий конструктор с параметрами,  требует,
чтобы класс,  порожденный от него, имел конструктор. Форма такого
конструктора:
     имя класса (список параметров) : имя базового класса (список
параметров базового класса)
     {
      ...
     };
     Список параметров базового класса  используется  при  вызове
соответствующего конструктора базового класса и выполняется преж-
де, чем выполняется тело конструктора порожденного класса.
     Класс, порожденный как public, представляет собой подтип ос-
новного класса. Переменная порожденного класса в большинстве слу-
чаев может обрабатываться так,  как будто это  был  тип  базового
класса. Указатель, тип которого - указатель на базовый класс, мо-
жет указывать на объекты, имеющие тип public порожденного класса.
Ссылка на порожденный класс, если это имеет значение, может неяв-
но преобразовываться в ссылку на public базовый  класс.  Возможно
объявлять  ссылку на базовый класс и инициализировать ее объектом
public порожденного класса.
     Ниже следует пример порожденного класса:
     class vect_bnd : public vect {
     private:
        int l_bnd, u_bnd;
     public:
        vect_bnd();
        vect_bnd(int, int);
        int& operator[] (int);
        int ub() { return (u_bnd); }
        int lb() { return (l_bnd); }
     };
     vect_bnd::vect_bnd() : vect(10)
     {
        l_bnd = 0;

                             - 181 -

        u_bnd = 9;
     }
     vect_bnd::vect_bnd(int lb, int ub) : vect(ub - lb + 1)
     {
        l_bnd = lb;
        u_bnd = ub:
     }
     В этом  примере  конструкторы  порожденного  класса вызывают
конструкторы базового класса со списком параметров после  двоето-
чия.

     9.6. Множественное наследование

     Множественное наследование   позволяет  порожденному  классу
создаваться из более чем одного базового класса.  Синтаксис заго-
ловков класса расширяется для того,  чтобы включить список основ-
ных классов и уровни доступа к ним. Пример:
     class tools {
     ...
     };
     class parts {
     ...
     };
     class labor {
     ...
     };
     class plans: public tools, public parts, public labor {
     ...
     };
     В этом примере порожденный класс plans наследует public чле-
ны всех трех базовых классов.  Эта связь наследования описывается
направленным графом наследования без петель (DAG). DAG - структу-
ра типа графа, узлы которого представляют собой классы, а направ-
ленные дуги указывают направления от базового к порожденным клас-
сам.
     Если при порождении возникают члены различных классов с оди-
наковыми именами,  это может  вызвать  неоднозначности.  Подобное
наследование допускается, если пользователь не делает неоднознач-
ных ссылок на такие члены.

                             - 182 -

     В случае  множественного наследования два базовых класса мо-
гут быть порождены от общего предка.  Если оба базовых класса ис-
пользуются  классом,  порожденным  от них обычным способом,  этот
класс будет иметь два подобъекта общего предка.  Если это нежела-
тельно,  дублирование  может  удаляться  с использованием virtual
наследования.

     9.7. Вызов конструкторов

     Ранние версии C++ оставили неопределенным порядок выполнения
для  инициализации  конструкторов базового класса и конструкторов
класса-члена.  Большую часть времени эти конструкции не  зависели
друг от друга, и результаты не могли зависеть от порядка выполне-
ния. Однако, с добавлением множественного наследования, стало не-
желательно  и  опасно продолжать эту небрежность.  Поэтому принят
следующий порядок:
     1. Явная ссылка на конструкторы базового класса в том поряд-
ке, в котором они перечислены после двоеточия.
     2. Неупомянутые базовые классы в порядке, в котором они объ-
явлены.
     3. Явная  ссылка  на конструкторы класса-члена в порядке,  в
котором они перечислены после двоеточия.
     Виртуальные базовые  классы  имеют  специальный  приоритет и
создаются перед любым из своих порожденных классов. Они создаются
перед  любыми невиртуальными базовыми классами.  Порядок создания
зависит от их DAG. Этот порядок такой - снизу вверх, справа нале-
во.  Деструкторы  вызываются  в порядке,  обратном конструкторам.
Проиллюстрируем это разработкой предыдущего примера.
     class tools {
     ...
     public:
        tools(char*);
        ~tools();
        ...
     };
     class parts {
     ...
     public:
        parts(char*);

                             - 183 -

        ~parts();
        ...
     }
     class labor {
     ...
     public:
        labor(int);
        ~labor();
        ...
     }
     class plans : public tools, public parts, public labor {
     ...
        special a;   //класс-член с конструктором
     public:
        plans(int m) : labor(m), tools("lathe"),
                       a(m), parts("widget")
           {...}
        ~plans();
        ...
     };
     В этом случае конструктор члена a(m) появляется прежде,  чем
конструктор  основного класса parts("widget"),  но,  по правилам,
вызывается последним.  Так как его конструктор был последним, его
деструктор вызывается первым,  а затем ~parts,  ~tools,  ~labor и
~plans.


     9.8. Абстрактный базовый класс

     Чистая виртуальная функция - виртуальная функция-член,  тело
которой не определено.  Форма объявления ее внутри класса следую-
щая:
                  virtual прототип функции = 0;
     Порожденный класс должен  определять  или  объявлять  каждую
чистую  виртуальную  функцию  своего  непосредственного  базового
класса. Класс, который имеет, по крайней мере, одну чистую вирту-
альную функцию является абстрактным классом.



                             - 184 -

     9.9. Указатель на член класса

     C использует  указатели для структур и простую схему вызова,
чтобы выбирать значения членов.  В C++ указатель на  член  класса
отличен от указателя на класс. Указатель на член класса имеет тип
T::*,  где T - имя класса. С++ имеет два оператора, которые дейс-
твуют в качестве разыменования указателя на член класса. Операто-
ры указателя на член:
                            .* и .>*
     Считая obj.* ptr_mem первым разыменованием указателя для по-
лучения переменной-члена, можно обеспечить доступ к ее значению.
     class object { public: int a, b, c; } x, y, *q = &y;
     int object::*p = &object::b;

     x.*p       //получает x.b
     y .> *p    //получает y.b

   10. Процесс проектирования алгоритмов

     10.1. Этапы построения алгоритма

     Алгоритм представляет собой строгую систему правил,  опреде-
ляющую последовательность действий над некоторыми объектами. Сле-
дуя такой системе правил как  инструкции,  различные  исполнители
будут  действовать  одинаково и получат одинаковые результаты.  В
частности,  алгоритмом является всякая  последовательность  дейс-
твий,  выполнение  которой  можно поручить вычислительной машине.
Таким образом, подготовка и решение задачи на ЭВМ сводятся к раз-
работке, описанию и выполнению алгоритма.
     Основными этапами построения алгоритма являются:
     1. Постановка задачи.
     2. Построение модели.
     3. Разработка алгоритма.
     4. Проверка правильности алгоритма.
     5. Реализация алгоритма.
     6. Анализ алгоритма и его сложности.
     7. Проверка программы.
     8. Составление документации.


                             - 185 -

     10.1.1. Постановка задачи

     Обычно процесс такой формулировки задачи сводится  к  поста-
новке правильных вопросов.  Перечислим некоторые полезные вопросы
для плохо сформулированных задач:
     Понятна ли терминология, используемая в предварительной фор-
мулировке?
     Что дано?
     Что нужно найти?
     Как определить решение?
     Каких данных не хватает и все ли они нужны?
     Являются ли какие-то имеющиеся данные бесполезными?
     Какие сделаны допущения?
     Пример. Джек  -  агент по продаже компьютеров (коммивояжер);
на его территории 20 городов,  разбросанных по всему Техасу. Ком-
пания  возмещает  ему только 50%  стоимости деловых автомобильных
поездок. Джек вычислил, сколько ему будет стоить переезд на маши-
не между каждыми двумя городами на его территории.  Ему,  естест-
венно, хотелось бы снизить свои дорожные расходы.
     Что дано?  Исходная информация задана в виде перечня городов
на территории Джека и соответствующей  матрицы  стоимостей,  т.е.
двумерного  массива с элементами Cij,  равными стоимости переезда
из города i в город j.  В данном случае матрица стоимостей  имеет
20 строк и 20 столбцов.
     Что мы хотим найти? Мы хотим помочь Джеку снизить его дорож-
ные расходы.  Обдумав ситуацию, мы придем к выводу, что ничего не
можем сделать без дополнительной информации от  Джека.  Имеет  ли
Джек  в одних городах больше покупателей,  чем в других?  Если да
или если есть какие-то особые покупатели,  то Джек, возможно, за-
хочет посещать какие-то города чаще. Могут быть и такие города, в
которые Джек специально не поедет,  а заедет туда, когда окажется
в соседнем городе. Другими словами, надо знать больше о приорите-
тах Джека и учитывать предпочтения при составлении графика  поез-
док.
     Поэтому мы возвращаемся к Джеку и требуем  у  него  дополни-
тельную информацию.  Он сообщает, что хотел бы иметь маршрут, на-
чинающийся и оканчивающийся в его базовом городе и проходящий  по
одному разу через все остальные города на его территории.  Следо-
вательно,  нам требуется список городов,  содержащий каждый город

                             - 186 -

только один раз,  за исключением базового города, который стоит в
списке первым и последним.  Порядок городов в этом списке  предс-
тавляет  собой маршрут,  по которому Джек должен объезжать города
на своей территории. Сумма стоимостей проезда между каждыми двумя
последовательными городами списка - это общая стоимость маршрута,
представленного списком.  Мы решим задачу Джека,  если представим
ему список с наименьшей возможной общей стоимостью.

     10.1.2. Построение модели

     Приступая к  разработке модели,  следует задать два основных
вопроса:
     1. Какие  математические структуры больше всего подходят для
задачи?
     2. Существуют ли решенные аналогичные задачи?
     На выбор соответствующей структуры будут  оказывать  влияние
такие факторы,  как:  1) ограниченность наших знаний относительно
небольшим количеством структур,  2)  удобство  представления,  3)
простота вычислений,  4) полезность различных операций, связанных
с рассматриваемой структурой или структурами.
     Сделав пробный выбор математической структуры, задачу следу-
ет переформулировать и  терминах  соответствующих  математических
объектов.  Это будет одна из возможных моделей, если мы можем ут-
вердительно ответить на такие вопросы, как:
     Вся ли  важная информация задачи хорошо описана математичес-
кими объектами?
     Существует ли математическая величина, ассоциируемая с иско-
мым результатом?
     Выявили мы  какие-нибудь  полезные отношения между объектами
     модели?
     Можем мы работать с моделью?
     Удобно ли с ней работать?
     Пример. Возвращаемся к задаче агента по продаже компьютеров,
рассмотренной ранее.
     Очевидно, нужно  взять лист бумаги и нанести на нем по одной
точке,  соответствующей каждому городу.  Расположим  точки  любым
удобным способом, соединим точки i и j линиями и проставим на них
"веса" Cij.
     Такая схема  -  это  частный  случай известного в математике

                             - 187 -

графа,  или сети.  В общем случае сеть - это множество точек  (на
плоскости) вместе с линиями,  соединяющими некоторые или все пары
точек; над линиями могут быть проставлены веса.
     Для простоты  предположим,  что у Джека только пять городов,
для которых матрица стоимостей показана на рис. 10.1, а.

                                             1
                                            //\\
         ┌ 1 2 3 4 5 ┐                  5 / /  \ \1
        1│ - 1 2 7 5 │                  / 7/ 3  \2 \
        2│ 1 - 4 4 3 │              5 /___/______\___\2
 Город  3│ 2 4 - 1 2 │                \  /        \  /
        4│ 7 4 1 - 3 │                3\/          \/4
        5│ 5 3 2 3 - │                  4───────────3
         └           ┘                        1
              а                               б

        Рис. 10.1. Задача коммивояжера с пятью городами.

Тогда сетевая модель может быть изображена,  как на рис.  10.1,б.
Предположим  также,  что  стоимость проезда из города i в город j
такая же, как из j в i, хотя это и необязательно.
     Что мы ищем в задаче? В терминах теории сетей список городов
(который мы ранее описали) определяет замкнутый цикл, начинающий-
ся  с  базового города и возвращающийся туда же после прохождения
каждого города по одному разу.  Такой цикл соответствует неотрыв-
ному движению карандаша вдоль линии сети,  которое проходит через
каждую  точку только один раз и начинается и оканчивается в одной
и той же точке.  Обход такого рода назовем туром.  Стоимость тура
определяется как сумма весов всех пройденных ребер.  Задача реше-
на, если мы можем найти тур с наименьшей стоимостью.
     Обход 1-5-3-4-2-1 есть тур со стоимостью 5+2+1+4+1=13. Явля-
ется ли он туром с минимальной стоимостью?
     Рассмотренная задача известна в литературе как задача комми-
вояжера; она стала в какой-то мере классической. Это один из наи-
более известных примеров таких задач,  которые очень легко поста-
вить и промоделировать, но очень трудно решить.



                             - 188 -

     10.1.3. Разработка алгоритма

     Как только  задача  четко поставлена и для нее построена мо-
дель, мы должны приступить к разработке алгоритма ее решения. Вы-
бор метода разработки,  зачастую сильно зависящий от выбора моде-
ли, может значительной степени повлиять на эффективность алгорит-
ма решения. Два разных алгоритма могут быть правильными, но очень
сильно отличаться по эффективности.
     Пример. Вернемся к коммивояжеру.
     Сначала произвольно перенумеруем n городов целыми числами от
1  до  n,  присваивая каждому городу свой номер.  Базовому городу
приписываем номер n. Заметим, что каждый тур однозначно соответс-
твует перестановке целых числе 1,  2,  ...,  n-1.  Действительно,
каждый тур соответствует единственной перестановке,  и каждая пе-
рестановка  соответствует единственному туру.  Такое соответствие
называется взаимно-однозначным.  Таким образом,  для любой данной
перестановки мы можем легко проследить соответствующий тур на се-
тевой модели и в то же время вычислить стоимость этого тура.
     Можно решить задачу, образуя все перестановки первых n-1 це-
лых положительных чисел. Для каждой перестановки строим соответс-
твующий тур и вычисляем его стоимость.  Обрабатывая таким образом
все перестановки, запоминаем тур, который к текущему моменту име-
ет наименьшую стоимость. Если мы находим тур с более низкой стои-
мостью, то производим дальнейшие сравнения с этим туром.
     Algorithm ETS  (Исчерпывающий  коммивояжер).  Решить  задачу
коммивояжера  с N городами,  последовательно рассматривая все пе-
рестановки из N-1 положительных целых  чисел.  Таким  образом  мы
рассмотрим каждый возможный тур и выберем вариант TOUR с наимень-
шей стоимостью MIN.  Алгоритм ETS требует в качестве входных дан-
ных число городов N и матрицу стоимостей C.
Шаг 0. [Инициализация, т.е. установка в начальное состояние] Set
       TOUR<- 7' 0; and MIN<- 7$ 0.
Шаг 1. [Образование   всех  перестановок]  For I<-1 to (N-1)!  do
       through шаг 4 od; and STOP.
Шаг 2. [Получение новой перестановки] Set P<-I-я перестановка це-
       лых чисел 1, 2, ..., N-1. (Заметим, что здесь нужен подал-
       горитм.)
Шаг 3. [Построение  нового тура] Строим тур T(P), соответствующий
       перестановке P; and вычисляем стоимость COST(T(P)). (Заме-

                             - 189 -

       тим, что здесь нужны два других подалгоритма.)
Шаг 4. [Сравнение] If COST(T(P)) < MIN then set TOUR<-T(P);  and
       MIN<-COST(T(P)) fi.
     Алгоритм ETS  -  неплохое первое приближение к точному алго-
ритму.  Ему недостает некоторых важных подалгоритмов, и он недос-
таточно близок к окончательной программе.
     Существует тенденция:  программисты затрачивают относительно
небольшое время на стадию разработки алгоритма при создании прог-
раммы.  Проявляется сильное желание как можно быстрее начать  пи-
сать  самое программу.  Этому побуждению не надо поддаваться.  На
стадии разработки требуется тщательное обдумывание, следует также
уделить  внимание  двум предшествующим и первым трем следующим за
стадией разработки этапам.

     10.1.4. Правильность алгоритма

     Доказательство правильности алгоритма - это один из наиболее
трудных,  а  иногда и особенно утомительных этапов создания алго-
ритма.
     Вероятно, наиболее распространенная процедура доказательства
правильности программы - это прогон ее на разных тестах. Если вы-
данные программой ответы могут быть подвержены известными или вы-
численными вручную данными,  возникает искушение  сделать  вывод,
что  программа "работает". Однако  этот метод редко исключает все
сомнения;  может существовать случай, в котором программа не сра-
ботает.
     Мы предложим следующую общую  методику  доказательства  пра-
вильности алгоритма. Предположим, что алгоритм описан в виде пос-
ледовательности шагов,  скажем,  от шага 0 до шага m. Постараемся
предложить  некое  обоснование правомерности для каждого шага.  В
частности,  может потребоваться лемма об условиях, действующих до
и  после  пройденного шага.  Затем постараемся предложить доказа-
тельство конечности алгоритма,  при этом будут проверены все под-
ходящие входные данные и получены все подходящие выходные данные.
     Пример. Алгоритм ETS настолько прост,  что его  правильность
легко  доказать.  Поскольку  проверяется каждый тур,  должен быть
проверен и тур и минимальной стоимостью;  как только до него дой-
дет очередь,  он будет запомнен. Он не будет отброшен - это может
случиться только в том случае, если существует тур с меньшей сто-

                             - 190 -

имостью.  Алгоритм должен закончить работу,  так как число туров,
которые нужно проверить,  конечно.  Подобный метод доказательства
известен  как "доказательство исчерпыванием"; это самый грубый из
всех методов доказательства.
     Подчеркнем тот  факт,  что правильность алгоритма еще ничего
не говорит о его эффективности. Исчерпывающие алгоритмы редко бы-
вают хорошими во всех отношениях.

     10.1.5. Реализация алгоритма

     Этот этап может быть довольно трудным.  Во-первых, трудность
заключается в том,  что очень часто отдельно взятый шаг алгоритма
может  быть выражен в форме,  которую трудно перевести непосредс-
твенно в конструкции языка программирования.  Например,  один  из
шагов алгоритма может быть записан в виде,  требующем целой подп-
рограммы для его реализации. Во-вторых, реализация может оказать-
ся трудным процессом потому,  что перед тем, как мы сможем начать
писать программу, мы должны построить целую систему структур дан-
ных для представления важных аспектов используемой модели.  Чтобы
сделать это, необходимо ответить, например, на такие вопросы:
     Каковы основные переменные?
     Каких они типов?
     Сколько нужно массивов и какой размерности?
     Имеет ли смысл пользоваться связными списками?
     Какие нужны подпрограммы (возможно, уже записанные в памяти)?
     Каким языком программирования пользоваться?
     Конкретная реализация может существенно влиять на требования
к памяти и на скорость алгоритма.
     Другой аспект  построения программной реализации - это прог-
раммирование сверху-вниз. Программирование сверху-вниз - это под-
ход  к разработке и реализации,  который состоит в преобразовании
алгоритма в такую последовательность все более конкретизированных
алгоритмов, что окончательный вариант представляет собой програм-
му для ЭВМ.
     Сделаем очень  важное  замечание.  Одно дело - доказать пра-
вильность конкретного алгоритма,  описанного с  словесной  форме.
Другое дело - доказать,  что данная машинная программа, предполо-
жительно являющаяся реализацией этого алгоритма, также правильна.


                             - 191 -

     10.1.6. Анализ алгоритма и его сложности

     Существует ряд важных практических причин для анализа  алго-
ритмов.  Одной из них является необходимость получения оценок или
границ для объема памяти или времени работы,  которое потребуется
алгоритму для успешной обработки конкретных данных. Машинное вре-
мя и память - относительно дефицитные (и дорогие) ресурсы, на ко-
торые часто одновременно претендуют многие пользователи.
     Существуют также важные теоретические  причины  для  анализа
алгоритмов.  Хотелось  бы иметь некий количественный критерий для
сравнения двух алгоритмов, претендующих на решение одной и той же
задачи.  Более  слабый алгоритм должен быть улучшен или отброшен.
Желательно также иметь механизм для выявления наиболее  эффектив-
ных алгоритмов  и замены устаревших.  Иногда невозможно составить
четкое мнение об относительной эффективности  двух  алго  ритмов.
Один  может  в  среднем лучше работать,  к примеру,  на случайных
входных данных,  в то время как другой лучше работает на каких-то
специальных входных данных.
     Пусть А - алгоритм для решения некоторого класса задач,  а n
- размерность отдельной задачи из этого класса. Во многих задачах
n - просто скаляр,  равный числу вершин графа.  В общем случае  n
может быть массивом или длиной вводимой последовательности. Опре-
делим f 4A 0(n) как рабочую функцию,  дающую верхнюю границу для мак-
симального числа основных операций (сложения,  сравнения и т.д.),
которые должен выполнить алгоритм А для решения любой задачи раз-
мерности n. Будем пользоваться следующим критерием для оценки ка-
чества алгоритма А.  Говорят, что алгоритм А полиномиальный, если
f 4A 0(n) растет не быстрее, чем полином от n, в противном случае ал-
горитма А экспоненциальный.
     Следующее обозначение  стандартно  во  многих математических
дисциплинах, в том числе и в анализе алгоритмов. Функцию f(n) оп-
ределяют как O[g(n)] и говорят,  что она порядка g(n) для больших
n, если
                        f(n)
                   lim ------ = constant 7 - 0 0.
                  n-> 74 0  g(n)
Это обозначается, как f(n)=O[g(n)]. Функция h(n) является o[z(n)]
для больших n, если


                             - 192 -

                           h(n)
                      lim ------ = 0.
                     n-> 74 0  z(n)
Эти символы произносятся соответственно, как "О большое" и как "о
малое".  Интуитивно,  если f(n) есть O[g(n)], то эти две функции,
по  существу,  возрастают  с одинаковой скоростью при n-> 74 0.  Если
f(n) есть o[g(n)], то g(n) возрастает гораздо быстрее, чем f(n).
     Важно также знать, насколько плохо работает экспоненциальный
алгоритм.  Существует много важных задач, для которых в настоящее
время  известны только экспоненциальные алгоритмы.  Одна из них -
задача коммивояжера.  Эти задачи необходимо решать ввиду их прак-
тической значимости.  Раз уж известны только экспоненциальные ал-
горитмы,  то хотелось бы пользоваться  наиболее  эффективными  из
них. Очевидно, что алгоритм, решающий задачу размерности n за O(2
в степени n) шагов,  предпочтительнее алгоритма,  решающего ее за
O(n!) или O(n в степени n) шагов.
     Пример. Рассмотрим ранее описанный алгоритм ETS. Сразу можно
сделать  вывод,  что  это  экспоненциальный алгоритм с оценкой по
крайней мере O(n!). В задаче с n городами алгоритм ETS требует от
нас  исчерпывающе перечислить перестановки первых n-1 положитель-
ных целых чисел.  Число таких перестановок (n-1)!. Даже если тре-
буется  только один шаг для каждой такой перестановки,  эта часть
алгоритма все же потребует O[(n-1)!] шагов.  Как только представ-
лена перестановка,  как в шаге 1 алгоритма ETS, можно найти соот-
ветствующий тур и его стоимость  за  O(n)  шагов.  Поэтому  любая
верхняя  граница для общего времени работы должна быть по крайней
мере O(n!).
     Предположим, что  у коммивояжера 20 городов и что есть фено-
менальный подалгоритм алгоритма ETS для шага 1, который генериру-
ет новую перестановку только за один шаг.  Предположим также, что
машина выполняет каждый элементарный  шаг  (например,  сравнение,
сложение,  поиск  элемента матрицы) за 10 в степени -7 с.  Тогда,
так так 20!  =приблизительно 2*10 в степени 18,  решение задачи с
использованием алгоритма ETS займет немногим меньше 70 веков.

     10.1.7. Проверка программы

     После того как исправлено множество ошибок, программу, нако-
нец, можно прогнать на простом примере (таком, который может быть

                             - 193 -

проверен вручную). Что же дальше?
     Программа должна быть проверена для широкого спектра  допус-
тимых  входных  данных.  Этот процесс может быть продолжительным,
утомительным и сложным.
     Как выбрать входные данные для тестирования?  На этот вопрос
невозможно дать общего ответа. Для любого алгоритма ответ зависит
от  сложности программы,  имеющегося ресурса времени,  а также от
персонала,  занимающегося проверкой, числа вводов (т.е. вариантов
входных данных),  для которых можно установить правильность выво-
дов,  и т.д.  Обычно множество всех вводов огромно, и полная про-
верка практически невозможна.
     Дальнейшая проверка также необходима для того, чтобы устано-
вить качество алгоритма.
     Сделанные в ходе анализа упрощающие  допущения  должны  быть
экспериментально  проверены.  Многие  большие,  сложные алгоритмы
трудно или невозможно математически исследовать.  В таких случаях
особенно важно проверить алгоритм в действии,  трудоемкости,  так
как это единственная возможность оценить его качество.
     Опыт показывает,  что анализ среднего функционирования алго-
ритма более ценен и трудоемок, чем анализ наилучшего и наихудшего
случаев. Если возможен анализ худшего случая, то очень важно экс-
периментально установить,  работает ли алгоритм значительно лучше
в среднем, чем в худшем случае.
     Аналитический и экспериментальный анализ дополняют друг дру-
га.  Аналитический анализ может быть неточным, если сделаны слиш-
ком сильные упрощающие допущения.  В этом случае могут быть полу-
чены только грубые оценки. С другой стороны, получить достаточное
экспериментальное подтверждение для гарантий какой-либо статисти-
ческой  достоверности  может оказаться невозможным или непрактич-
ным.  Экспериментальные  результаты,особенно  когда  используются
случайно сгенерированные данные, могут оказаться слишком односто-
ронними.  Чтобы получить достоверные результаты,  нужно там,  где
это возможно, провести как аналитическое, так и экспериментальное
исследование.
     Программы следует тестировать также для того,  чтобы опреде-
лить их вычислительные ограничения.  Алгоритм ETS хорошо работает
для  n<=6 и очень плохо для n>=15.  К сожалению,  в данном случае
переход не плавный,  и алгоритм имеет тенденцию плохо работать  в
промежуточных случаях.  Желательно пользоваться как аналитически-

                             - 194 -

ми,  так и экспериментальными методами, чтобы охарактеризовать те
входные данные,  которые считаются или "хорошими", или "плохими".
Например, предположим, что есть алгоритм, который в худшем случае
имеет трудоемкость O(n!), а его средняя трудоемкость O(n в степе-
ни 3).  Было бы очень удобно,  если бы мы могли  охарактеризовать
входные данные для алгоритма другим параметром a, а затем устано-
вить,  какие комбинации (n,a) требуют  экспоненциального  времени
работы,  а для каких комбинаций задача может быть решена за поли-
номиальное время. Ясно, что если средняя характеристика - порядка
O(n в степени 3),  то должно быть меньше вводов, требующих экспо-
ненциального времени.

     10.1.8. Документация

     Наиболее очевидный мотив для документации - дать возможность
людям понять программы, которые написаны другими. Конечно, лучший
способ - это составить программу настолько понятно, чтобы она са-
ма  себя  поясняла.  Но  это  невозможно осуществить ни для каких
программ, кроме простейших; и программа в коде должна быть допол-
нена  другими  формами  пояснений.  Обычно для этого используются
карты с комментариями.
     Но в  действительности  это только надводная часть айсберга.
Документация включает в себя всю информацию и помогает объяснить,
что делается в программе, т.е., в частности, блок-схемы, описания
ступеней в построении сверху-вниз, вспомогательные доказательства
правильности, результаты тестирования, детальные описания формата
и требований к вводу/выводу и т.д.  Золотое  правило:  оформляйте
ваши программы в таком виде, в каком вам хотелось бы видеть прог-
раммы, написанные другими.

     10.2. Методы разработки алгоритмов

     10.2.1. Методы частных целей, подъема и отрабатывания назад

     Первый метод связан со сведением трудной задачи к последова-
тельности более простых задач. Такая процедура называется методом
частных целей.
     Осмысленный выбор  более простых задач - скорее дело искусс-
тва или интуиции, чем науки. Более того, не существует общего на-

                             - 195 -

бора правил для определения класса задач,  которые можно решить с
помощью такого подхода.
     Частные цели могут быть установлены, когда получим ответы на
следующие вопросы:
     1. Можем ли мы решить часть задачи?  Можно ли, игнорируя не-
которые условия, решить оставшуюся часть задачи?
     2. Можем  ли мы решить задачу для частных случаев?  Можно ли
разработать алгоритм,  который дает решение, удовлетворяющее всем
условиям задачи,  но входные данные которого ограничены некоторым
подмножеством всех входных данных?
     3. Есть ли что-то, относящееся к задаче, что мы не достаточ-
но хорошо поняли?  Если попытаться глубже  вникнуть  в  некоторые
особенности задачи,  сможем ли мы что-то узнать,  что поможет нам
подойти к решению?
     4. Встречались ли мы с похожей задачей,  решение которой из-
вестно?  Можно ли видоизменить ее решение для решения нашей зада-
чи? Возможно ли, что эта задача эквивалентна известной нерешенной
задаче?
     Второй метод  разработки алгоритмов известен как метод подъ-
ема.  Алгоритм подъема начинается с принятия начального предполо-
жения или вычисления начального решения задачи.  Затем начинается
насколько возможно быстрое движение "вверх" от начального решения
по направлению к лучшим решениям.  Когда алгоритм достигает такую
точку,  из которой больше невозможно двигаться  наверх,  алгоритм
останавливается.  К  сожалению,  не всегда окончательное решение,
полученной с помощью алгоритма подъема,  будет оптимальным.  Этот
"дефект" часто ограничивает применение метода подъема.
     Название "подъем" отчасти происходит от алгоритмов  нахожде-
ния  максимумов функций нескольких переменных.  Предположим,  что
f(x,y) - функция переменных x и y и задача состоит  в  нахождении
максимального  значения f.  Функция f может быть представлена по-
верхностью (имеющей холмы и впадины) над плоскостью xy.  Алгоритм
подъема  может  начать работу в любой точке Z0 этой поверхности и
проделать путь вверх к вершине в точке Z1.  Это значение является
"локальным"  максимумом  в отличие от "глобального" максимума,  и
метод подъема не дает оптимального решения.
     Вообще методы подъема являются "грубыми". Они запоминают не-
которую цель и стараются сделать все, что могут и где могут, что-
бы подойти ближе к цели. Это делает их несколько недальновидными.

                             - 196 -

     Как показывает наш пример,  алгоритмы подъема могут быть по-
лезны, если нужно быстро получить приближенное решение.
     Третий метод известен как отрабатывание назад, т.е. начинаем
с  цели или решения и движемся обратно по направлению к начальной
постановке задачи.  Затем,  если эти действия обратимы,  движемся
обратно от постановки задачи к решению.
     Задача о джипе.
     Мы хотели бы пересечь на джипе 1000-мильную пустыню,  израс-
ходовав при этом минимум горючего.  Объем топливного  бака  джипа
500 галлонов, горючее расходуется равномерно, по 1 галлону на ми-
лю.  В точке старта имеется неограниченный резервуар с  топливом.
Так как в пустыне нет складов горючего, мы должны установить свои
собственные хранилища и наполнить их топливом из бака машины. Где
расположить эти хранилища? Сколько горючего нужно залить в каждое
из них?
     Подойдем к этой задаче с помощью метода отрабатывания назад.
С какого расстояния от конца мы сможем пересечь пустыню, имея за-
пас горючего в точности на k баков? Мы будем задавать этот вопрос
для k=1,  2,  3,  ..., пока не найдем такое целое n, что n полных
баков позволяет пересечь всю 1000-мильную пустыню.
     Для k=1 ответ равен 500 милям, как и показано на рис. 10.2.

      0 миль                   500 миль               1000 миль
      I----------------I---I---I----------------------I
      A                 \ / \ /B                      C
                         X2  X1


    Рис. 10.2. Задача о джипе: пересечение пустыни из A в C.
Можно заправить  машину  в точке B и пересечь оставшиеся 500 миль
пустыни.  Ясно, что это наиболее отдаленная точка, стартуя из ко-
торой можно преодолеть пустыню,  имея в точности 500 галлонов го-
рючего.
     Мы поставили перед собой частную цель,  потому что не смогли
решить сразу исходную задачу. Мы не задаем вопрос: сколько топли-
ва нужно машине, чтобы преодолеть заданную дистанцию? Вместо это-
го задаем более простой,  но родственный вопрос: какое расстояние
можно проехать на заданном количестве топлива? Ответить на первый
вопрос становится возможным, когда ответом на второй является: не

                             - 197 -

меньше 1000 миль.
     Предположим, что k=2,  т.е.  имеется два полных  бака  (1000
галлонов). Будем рассматривать этот случай, опираясь на результат
для k=1.  Каково максимальное значение X1, такое, что отправляясь
с 1000 галлонами горючего из точки 500-X1, можно перевезти доста-
точно горючего в точку B,  чтобы завершить поездку,  как в случае
k=1.
     Один из способов определения приемлемого значения X1 состоит
в следующем. Заправляемся в точке 500-X1, едем X1 миль до B и пе-
реливаем в хранилище все горючее, кроме X1 галлонов, которые пот-
ребуются для возвращения в точку 500-X1.  В этой точке бак стано-
вится пустым.  Теперь наполняем второй полный бак,  проезжаем  X1
миль до B, забираем в B горючее, оставленное там, и из B едем в C
с полным баком.  Общее пройденное расстояние состоит из трех  от-
резков по X1 миль и одного отрезка BC длиной 500 миль.  Мы должны
израсходовать каждую каплю топлива, чтобы сделать значение X1 как
можно большим. Поэтому X1 находим из уравнения
                    3*X1+500=1000 (галлонов);
его решение:  X1=500/3.  Таким образом,  два бака (1000 галлонов)
позволяют нам проехать
                   D2=500+X1=500*(1+1/3) миль
     Рассмотрим k=3.  Из какой точки мы можем выехать с 1500 гал-
лонами  топлива так,  что машина сможет доставить 1000 галлонов в
точку 500-X1?  Возвращаясь к рис. 10.2, мы ищем наибольшее значе-
ние  X2,  такое,  что,  выезжая с 1500 галлонами топлива из точки
500-X1-X2,  мы можем доставить 1000 галлонов в точку  500-X1.  Мы
выезжаем из точки 500-X1-X2,  доезжаем до 500-X1,  переливаем все
горючее,  кроме X2 галлонов,  и возвращаемся в точку 500-X1-X2  с
пустым баком.  Повторив эту процедуру,  мы затратим 4*X2 галлонов
на проезд и оставим 1000-4*X2 галлонов в точке 500-X1.  Теперь  в
точке 500-X1-X2 осталось ровно 500 галлонов. Заправляемся послед-
ними 500 галлонами и едем в точку 500-X1,  израсходовав на это X2
галлонов.
     Теперь мы находимся в точке 500-X1,  затратив на проезд 5*X2
галлонов  топлива.  Здесь  оставлено  в общей сложности 1500-5*X2
галлонов.  Это количество должно быть равно 1000  галлонам,  т.е.
X2=500/5.  Из  этого  заключаем,  что 1500 галлонов позволяют нам
проехать
               D3=500+X1+X2=500*(1+1/3+1/5) миль.

                             - 198 -

     Продолжая индуктивно процесс отрабатывания назад,  получаем,
что n баков горючего позволяют нам проехать Dn миль, где
                Dn=500*(1+1/3+1/5+...+1/(2n-1)).
     Нужно найти  наименьшее  значение  n,  при котором Dn>=1000.
Простые вычисления показывают,  что для n=7 имеем D7=977,5  мили,
т.е. семь баков, или 3500 галлонов, топлива дадут нам возможность
проехать 977,5 мили. Полный восьмой бак - это было бы уже больше,
чем нам надо,  чтобы перевезти 3500 галлонов из точки A, в точку,
отстоящую на 22,5 мили (1000-977,5) от A,  для доставки 3500 гал-
лонов топлива к отметке 22,5 мили достаточно 337,5 галлона. Таким
образом,  для того,  чтобы пересечь на машине пустыню из A  в  C,
нужно 3837,5 галлона горючего.
     Теперь алгоритм транспортировки горючего может  быть  предс-
тавлен  следующим  образом.  Стартуем из A,  имея 3837,5 галлона.
Здесь как раз достаточно топлива, чтобы постепенно перевезти 3500
галлонов  к  отметке 22,5 мили,  где мы в конце концов окажемся с
пустым баком и запасом горючего на семь  полных  заправок.  Этого
топлива достаточно, чтобы перевезти 3000 галлонов к точке, отсто-
ящей на 22,5+500/13 миль от A,  где бак машины будет опять  пуст.
Последующие   перевозки   приведут  нас  к  точке,  отстоящей  на
22,5+500/13+500/11 миль от A, с пустым баком и 2500 галлонами.
     Продолжая таким  образом,  мы  продвигаемся вперед благодаря
анализу, проведенному методом отрабатывания назад. Вскоре мы ока-
жемся у отметки 500*(1-1/3)=1000/3 миль с 1000 галлонами топлива.
Затем мы перевезем 500 галлонов в B, зальем их в бак машины и до-
едем  без остановки до C.  Рис.  10.3 иллюстрирует весь этот про-
цесс.

  7 баков        4 бака    3 бака     2 бака      1 бак
3837,5 гал.     2000 гал. 1500 гал.  1000 гал.   500 гал.

A                   7          5          3     B
*  15   *      *---------*----------*-----------*------------->*C
 поездок ------                                      500
                X3=500/7   X2=500/5    X1=500/3

            Рис. 10.3. Схема решения задачи о джипе.
Dn есть n-я частная сумма нечетного гармонического ряда. Посколь-
ку этот ряд расходится,  алгоритм дает возможность пересечь любую

                             - 199 -

пустыню.
     Возникает вопрос,  можно ли  проехать  1000  миль,  затратив
меньше чем 33837,5 галлона горючего. Оказывается, что нельзя. До-
казательство этого факта довольно сложно.  Однако можно высказать
следующий,  довольно правдоподобный довод. Очевидно, мы действуем
наилучшим образом для k=1. При k=2 мы используем наш план для k=1
и затем водим в действие второй бак горючего для того, чтобы ока-
заться как можно дальше от B.  Исходная предпосылка для  k  баков
заключается в том,  что мы знаем, как действовать наилучшим обра-
зом в случае с k-1 баками,  и отодвигаемся как можно дальше назад
с помощью k-го бака.

     10.2.2. Эвристики

     Эвристический алгоритм,  или эвристика, определяется как ал-
горитм со следующими свойствами:
     1. Он обычно находит хорошие,  хотя не обязательно оптималь-
ные решения.
     2. Его можно быстрее и проще реализовать,  чем любой извест-
ный точный алгоритм (т.е.  тот,  который гарантирует  оптимальное
решение).
     Хотя не существует универсальной  структуры,  которой  можно
описать  эвристические алгоритмы,  многие из них основываются или
на методе частных целей, или на методе подъема. Один общий подход
к  построению эвристических алгоритмов заключается в перечислении
всех требований к точному решению и разделении требований на  два
класса, например:
     1. Те, которые легко удовлетворить.
     2. Те, которые не так легко удовлетворить.
Или
     1. Те, которые должны быть удовлетворены.
     2. Те,  по отношению к которым мы могли бы пойти на  компро-
        мисс.
     Тогда цель построения алгоритма - создать алгоритм, гаранти-
рующий выполнение требований 1-го класса, но не обязательно 2-го.
Это не означает, что для удовлетворения требований 2-го класса не
делается никаких попыток,  это просто означает, что не может быть
дано никаких гарантий, что они будут удовлетворены.
     В качестве  примера  рассмотрим  следующий "грубый" алгоритм

                             - 200 -

решения задачи коммивояжера.
     Algorithm GTS (коммивояжер).  Построить приближенное решение
TOUR со стоимостью COST для задачи коммивояжера с  N  городами  и
матрицей стоимостей C,  начиная с вершины U.
Шаг 0. [Инициализация] Set TOUR<- 7' 0;  COST<-0;  V<-; помечаем U -
       "использована",  а все другие вершины - "не использована".
       (Вершина V - положение на сети в данный момент).
Шаг 1. [Посещение всех городов] For K<-1 to N-1 do шаг 2 od.
Шаг 2. [Выбор  следующего ребра] Пусть (V,W) - ребро с наименьшей
       стоимостью,  ведущее из V в любую неиспользованную вершину
       W;  set TOUR<-TOUR+(V,W);  COST<-COST+C(V,W); помечаем W -
       "использована"; and set V<-W.
Шаг 3. [Завершение тура] Set TOUR<-TOUR+(V,U); COST<-COST+C(V,U);
       and STOP.
     На рис.  10.4, а изображена сеть c рис. 10.1; рис.10.4, б-е
               1                      1                 1
              //\\                     \                 \
          5 / /  \ \1               3  1\             3  1\
          / 7/ 3  \2 \          5________\2       5________\2
      5 /___/______\___\2               //         \\
        \  /        \  /              4//4         3\\2
        3\/    1     \/4              //             \\
         4────────────3             4 3              4 3

            Стоим=0               Стоим=1            Стоим=4
              а                      б                  в

               1                      1                 1
                \                      \                 \
             3  1\                  3  1\             3/ 1\
         5________\2            5________\2       5________\2
          \                      \                 \7/
            \2                     \2                \2
              \                      \             /   \
         4______\3              4______\3         4______\3

            Стоим=6               Стоим=7            Стоим=14
               г                     д                  е
                Рис. 10.4. Иллюстрация алгоритма GTS.

                             - 201 -

иллюстрирует построение тура коммивояжера алгоритмом GTS, начина-
ющегося в вершины 1.
     Алгоритм GTS дает тур со стоимостью 14, но есть тур со стои-
мостью 13.  Ясно,  что алгоритм GTS не всегда находит тур с мини-
мальной стоимостью.
     Алгоритм GTS основан на идее подъема. Цель - найти тур с ми-
нимальной стоимостью.  Задача сведена к набору  частных  целей  -
найти  на  каждом шаге "самый дешевый" город,  чтобы посетить его
следующим. Алгоритм не строит плана вперед; текущий выбор делает-
ся безотносительно к последующим выборам.
     Оптимальное решение задачи коммивояжера имеет  два  основных
свойства:
     1. Оно состоит из множества ребер, вместе представляющих тур.
     2. Стоимость никакого другого тура не будет меньше данного.
Алгоритм GTS рассматривает свойство  1  как  "обязательное",  или
"легкое", требование,  а свойство 2 - как "Трудное", относительно
которого можно пойти на компромисс.
     Пример с пятью городами показывает,  что алгоритм GTS не га-
рантирует свойство 2. Однако на шаге 2 делается некоторая попытка
снизить стоимость тура T.
     Конечно, для алгоритма GTS легко написать программу,  но яв-
ляется  ли  он быстрым?  Для произвольной задачи коммивояжера с n
городами требуется O(n в степени 2) операций чтобы прочесть  или
построить матрицу стоимостей C.  Поэтому нижняя граница сложности
любого алгоритма, способного дать нетривиальное возможное решение
этой  задачи,  равна O(n в степени 2).  Поэтому алгоритм GTS нас-
только быстрый, насколько возможно.
     Качество алгоритма GTS может быть значительно улучшено прос-
той модификацией.  Самым плохим свойством алгоритма является  то,
что  выбор  ребер очень низкой стоимости при выполнении шага 1 на
ранних или средних стадиях работы алгоритма может привести к  вы-
бору очень дорогих ребер в заключительной стадии.  Один из спосо-
бов предостеречься от этого - применять алгоритм для  каждого  из
p<=n разных,  случайно выбранных, начальных городов. Другая моди-
фикация может состоять в повторении алгоритма для того же  самого
начального города, но надо начинать со второго до дешевизне ребра
и затем,  быть может, вернуться в прохождению самых дешевых ребер
для  последующих вершин.  Затем можно выбрать наименьший из расс-
мотренных туров. Или лучше: сохранять только самый дешевый тур из

                             - 202 -

до  сих  пор  найденных  и отбрасывать частично построенные туры,
стоимости которых уже превышают стоимость текущего самого дешево-
го тура.  Конечно, сложность модифицированного алгоритма, который
назовем GTS2, может достигать порядка O(p*n в степени 2).
     Algorithm GTS2  (грубый коммивояжер,  версия 2).  Образовать
туры из 1<=P<=N разных начальных городов для задач коммивояжера с
N городами.  Последовательно строятся P туров и запоминается луч-
ший из до сих пор найденных туров. В качестве ввода для алгоритма
требуются значения N, P, матрица стоимостей C и P начальных горо-
дов {V1, V2, ... Vp}.
Шаг 0. [Инициализация]  Set K<-0; COST<- 74 0; and BEST<- 7' 0. (Перемен-
       ная K отсчитывает число до сих пор использованных  началь-
       ных городов; BEST служит для запоминания лучшего из до сих
       пор найденных туров, стоимость которого равна COST.)
Шаг 1. [Начало  нового  тура] Do through шаг 3 while K<P od;  and
       STOP.
Шаг 2. [Образование  нового тура] Set K<-K+1;  and CALL GTS (Vk).
       (Оператор CALL GTS(Vk) заставляет алгоритм  GTS  построить
       тур с городом Vk в качестве начального.  Тур T(K) со стои-
       мостью C(K) построен.)
Шаг 3. [Обновление   лучшего   тура]   If  C(K)<COST   then   set
       BEST<-T(K); and COST<-C(K) fi.
     Реализация алгоритма GTS2 с подалгоритмом GTS не представля-
ет труда.  Алгоритм GTS2 должен передавать текущее значение  COST
алгоритму GTS.  Если в процессе выполнения подпрограммы стоимость
частично построенного тура больше или равна COST, то возвращается
значение C(K)= 74 0.

     10.2.3. Программирование с отходом назад

     Метод разработки алгоритма, известный как программирование с
отходом назад, можно описать как организованный исчерпывающий по-
иск,  который  часто позволяет избежать исследования всех возмож-
ностей.  Этот метод особенно удобен для решения задач,  требующих
проверки потенциально большого, но конечного числа решений.
     Задача о замке
     В качестве примера рассмотрим комбинационный замок,  состоя-
щий из набора N переключателей,  каждый из которых может  быть  в
положении "вкл" и "выкл".  Замок открывается только при одном на-

                             - 203 -

боре положений переключателей,  из которых не менее [N/2]  (целая
часть  от N/2) находятся в положении "вкл".  Предположим,  что мы
забыли эту комбинацию,  а нам надо  отпереть  замок.  Предположим
также, что мы готовы перепробовать (если необходимо) все комбина-
ции. Нам нужен алгоритм для систематического  генерирования  этих
комбинаций.  Если проигнорировать условие [N/2], то для замка су-
ществует 2 в степени N возможных комбинаций. Неплохие шансы найти
правильную комбинацию могут быть при N<=10.  Однако условие [N/2]
позволит отбросить (или лучше не генерировать) многие комбинации.
     Промоделируем каждую возможную комбинацию вектором из N  ну-
лей и единиц.  На i-м месте будет 1, если i-й переключатель нахо-
дится в положении "вкл",  и 0, если i-й переключатель - в положе-
нии "выкл".  Множество всех возможных N-векторов хорошо моделиру-
ется с помощью двоичного дерева. Каждая вершина k-го уровня этого
дерева будет соответствовать определенному набору первых k компо-
нент N-вектора.  Две ветви,  идущие вниз из вершины этого уровня,
соответствуют  двум  возможным  значениям  (k+1)-й  компоненты  в
N-векторе. У дерева будет N уровней. Рис. 10.5 на примере N=4 по-
ясняет основную конструкцию.
                         Корень                         Уровень 0
                          /  \
                       /        \
                    /              \
                  /                  \
               1/                      \0               Уровень 1
              /\                        /\
             /  \                      /  \
           /      \                  /      \
          /        \                /        \
       11/           \10         01/           \00      Уровень 2
        /\           /\           /\           /\
       /  \         /  \         /  \         /  \
   111/    \110 101/    \100 011/    \010 001/    \000  Уровень 3
     /\    /\     /\    /\     /\    /\     /\    /\
    /  \  /  \   /  \  /  \   /  \  /  \   /  \  /  \
 1111    1101  1011   1001  0111   0101  0011  0001     Уровень 4
      1110  1100   1010   1000  0110   0100   0010  0000
     Рис. 10.5. Двоичное дерево, представляющее N-векторы из
                         нулей и единиц.

                             - 204 -

     Условие, заключающееся в том, что число переключателей в по-
ложении "вкл" должно быть не меньше [N/2], позволяет нам не обра-
зовывать  части  дерева,  которые  не могут привести к правильной
комбинации. Например, рассмотрим вершину 00. Так как правая ветвь
(к  000) не может привести к допустимой комбинации,  нет нужды ее
формировать.  Если какие-то вершины, следующие за рассматриваемой
вершиной,  не удовлетворяют ограничению задачи, то эти вершины не
надо рассматривать. В данном случае никакие из вершин, находящих-
ся внутри пунктирных линий,  не нужно исследовать и даже формиро-
вать.
     Теперь, воспользовавшись этой моделью двоичного дерева, мож-
но  изложить  процедуру  отхода  назад для образования только тех
комбинаций,  в которых по крайней мере [N/2] переключателей нахо-
дятся в положении "вкл".  Алгоритм сводится к пересечению дерева.
Двигаемся вниз по дереву,  придерживаясь левой ветви, до тех пор,
пока это возможно. Достигнув конечной вершины, опробуем соответс-
твующую комбинацию.  Если она не подходит,  поднимаемся  на  один
уровень и проверяем,  можем ли мы спуститься опять по другой вет-
ви.  Если это возможно, берем самую левую из неисследованных вет-
вей. Если нет, отходим вверх еще на один уровень и пытаемся спус-
титься из этой вершины.  Перед спуском проверяем,  можно ли удов-
летворить  условие об [N/2] включенных переключателях в последую-
щих вершинах.  Этот алгоритм просмотрит следующую  последователь-
ность вершин:
     1
    11
   111
  1111   Проверка этой комбинации.
   111   Отход, так как 1111 - конечная вершина.
  1110   Спуск по единственной непросмотренной ветви вниз, про-
         верка этой комбинации.э
   111   Снова отход.
    11   Отход дальше, так как из 111 все ветви просмотрены.
   110   Спуск по единственной непросмотренной ветви.
  1101   Проверка комбинации.
   110   Отход из 1101.
  1100   Проверка комбинации.
   110   Отход из 1100.
    11   Отход, так как все ветви просмотрены.

                             - 205 -

     1   Отход, так как все ветви просмотрены.
    10   Спуск по единственной непросмотренной ветви.
   101   Спуск по самой левой непросмотренной ветви.
  1011   Проверка комбинации.
   101   Отход.
  1010   Проверка комбинации.
   101   Отход.
    10   Отход.
   100   Спуск по единственной непросмотренной ветви.
  1001   Проверка комбинации.
   100   Отход.
    10   Отход:  заметим,  что мы не опускаемся  к 1000, так  как
         эта вершина  нарушает условие о том,  что должно быть по
         крайней мере две единицы.
     1   Отход.
Корень   Отход.
     0   Спуск по единственной непросмотренной ветви.
     .
     .
     .  и т.д.
     Алгоритм останавливается, когда мы возвращаемся к корню и не
остается непросмотренных ветвей.
     Этот простой пример иллюстрирует  основные  свойства,  общие
для  всех  алгоритмов с отходом назад.  Если можно сформулировать
задачу так, что все возможные решения могут быть образованы пост-
роением N-векторов,  тогда ее можно решить при помощи процедуры с
отходом.

     10.2.4. Метод ветвей и границ
     Метод ветвей и границ похож на методы с отходами назад  тем,
что он исследует древовидную модель пространства решений и приме-
ним для широкого круга дискретных комбинаторных задач.  Алгоритмы
с отходами нацелены на то, чтобы найти одну или все конфигурации,
моделируемые  N-векторами,  которые  удовлетворяют   определенным
свойствам. Алгоритмы ветвей и границ ориентированы в большей сте-
пени на оптимизацию.  В решаемой задача определена числовая функ-
ция стоимости для каждой из вершин, появляющихся в дереве поиска.
Цель - найти конфигурацию, на которой функция стоимости достигает
максимального или минимального значения.

                             - 206 -

     Алгоритм ветвей и границ хорошо работает в задаче  коммивоя-
жера.  Задача называется симметричной,  если Cij=Cji для всех i и
j,  т.е.  если стоимость проезда между каждыми двумя городами  не
зависит от направления. Предположим, что Cii= 74 0 для всех i.
     Авторы излагаемого алгоритма - Литл, Мерти, Суини и Карел.
Во-первых, рассмотрим ветвление. На рис. 10.6, а показана матрица
 ш1
       1   2   3   4   5                      1
      ┌──┬───┬───┬───┬──┐                  -------
     1│ 74 0 │25 │40 │31 │27│                / /// \\\ \
      ├──┼───┼───┼───┼──┤            27/  / ││ ││ \  \25
     2│5 │  74 0 │17 │30 │25│             /22/31││9││19\5 \
      ├──┼───┼───┼───┼──┤            / /    ││ ││  8 \ \
     3│19│15 │  74 0 │ 6 │ 1│           5/______││_││______\2
      ├──┼───┼───┼───┼──┤            \------││-││------/
     4│9 │50 │24 │  74 0 │ 6│            \ \ 25 ││ ││    / /
      ├──┼───┼───┼───┼──┤             \6\   ││ ││  /17/
     5│22│ 8 │ 7 │10 7  0│ 7 4 0│            10\ \ // 40\\ / /15
      └──┴───┴───┴───┴──┘                \/__24___\/
                                          4-------3
                                              6
              а                               б
 ш0
     Рис. 10.6. Задача коммивояжера: (а) матрица стоимостей;
                    (б) сеть из пяти городов.

стоимостей для  асимметричной задачи коммивояжера с пятью города-
ми, представленной на рис. 10.6, б.
     Корень поискового  дерева  будет  соответствовать  множеству
"всех возможных туров",  т.е.  эта вершина представляет множество
всех 4!  возможных туров.  В общем случае для любой асимметричной
задачи с N городами корень будет представлять полное множество  R
всех (N-1)! возможных туров. Ветви, выходящие из корня, определя-
ются выбором одного ребра, скажем (i,j). Наша цель состоит в том,
чтобы разделить множество всех туров на два множества:  одно, ко-
торое, весьма вероятно, содержит оптимальный тур, и другое, кото-
рое,  вероятно, не содержит. Для этого выбираем ребро (i,j); оно,
как мы надеемся,  входит в оптимальный тур,  и разделяем R на два
множества {i,j} и {i,j}". В множество {i,j} входят туры из R, со-
держащие ребро (i,j), а в {i,j}" - не содержащие (i,j).
     Предположим, производим ветвление на ребре (i,j)=(3,5), име-
ющем наименьшую стоимость во всей матрице.  Корень и первый  уро-
вень дерева пространства решений будут тогда такими, как показано
на рис. 10.7.



                             - 207 -


                         ┌────┐47
                         │ R  │
                         │Все │                       Уровень 0
                         │туры│
                         └────┘
                        /      \
                       /        \
                      /          \
                     /            \
                 ┌──────┐49     ┌─────┐62
                 │{3,5}"│       │{3,5}│               Уровень 1
                 └──────┘       └─────┘
                               /       \
                              /         \
                          ┌──────┐    ┌─────┐
                          │{2,1}"│    │{2,1}│         Уровень 2
                          └──────┘    └─────┘

      Рис. 10.7. Построение дерева поиска по методу ветвей
                            и границ.

Заметим, что каждый тур из R содержится только в одном  множестве
уровня  1.  Если бы мы как-то могли сделать вывод,  что множество
{3,5}" не содержит оптимального тура, то нам нужно было бы иссле-
довать  только  множество {3,5}.  Затем разделяем множество {3,5}
таким же образом, как и множество R. Следующее по дешевизне ребро
в  матрице  - это ребро (2,1) со стоимостью C21=5.  Поэтому можно
разделить множество {3,5} на туры, включающие ребро (2,1) и туры,
не включающие этого ребра; это показано на уровне 2. Путь от кор-
ня к любой вершине дерева выделяет  определенные  ребра,  которые
должны  или  не должны быть включены в множество,  представленное
вершиной дерева.  Например,  левая вершина уровня 2  представляет
множество всех туров, содержащих ребро (3,5) и не содержащих реб-
ра (2,1).  Вообще, если X - вершина дерева, а (i,j) - ребро ветв-
ления,  то обозначим вершины, непосредственно следующие за X, че-
рез Y и Y". Множество Y обозначает подмножество туров из X с реб-
ром (i,j), а множество Y" - подмножество X без (i,j).
     Поясним, что подразумевается под вычислением границ.

                             - 208 -

     С каждой  вершиной  дерева мы связываем нижнюю границу стои-
мости любого тура из множества,  представленного вершиной. Вычис-
ление этих нижних границ - основной фактор,  дающий экономию уси-
лий в любом алгоритме типа ветвей и границ. Поэтому особое внима-
ние следует уделить получению как можно более точных границ. При-
чина этого следующая.  Предположим,  что мы построили  конкретный
полный тур со стоимостью m. Если нижняя граница, связанная с мно-
жеством туров, представленных вершиной Vk, равна M>=m, то до кон-
ца  процесса поиска оптимального тура не нужно рассматривать вер-
шину Vk и все следующие за ней.
     Основной шаг  при вычислении нижних границ известен как при-
ведение. Оно основано на следующих двух соображениях:
     1. В  терминах матрицы стоимостей C каждый полный тур содер-
жит только один элемент (ребро и  соответствующую  стоимость)  из
каждого столбца и каждой строки.  Заметим, что обратное утвержде-
ние не всегда верно.  Множество,  содержащее один и  только  один
элемент  из каждой строки и из каждого столбца C,  не обязательно
представляет          тур.          Например,           множество
{(1,5),(5,1),(2,3),(3,4),(4,2)}  удовлетворяет этому условию,  но
не образует тура.
     2. Если  вычесть  константу  h  из каждого элемента какой-то
строки или столбца матрицы стоимостей C, то стоимость любого тура
при новой матрице C' ровно на h меньше стоимости того же тура при
матрице C.  Поскольку любой тур должен содержать ребро из  данной
строки  или данного столбца,  стоимость всех туров уменьшается на
h. Это вычитание называется приведением строки (или столбца).
     Пусть t  -  оптимальный тур при матрице стоимостей C.  Тогда
стоимостью тура t будет
                        z(t)= 7  0сумма Cij.
                             (i,j)Ct
Если C'  получается  из C приведением строки (или столбца),  то t
должен остаться оптимальным туром при C' и
                          z(t)=h+z'(t),
где z'(t) - стоимость тура t при C'.
     Под приведением всей матрицы стоимостей C понимается следую-
щее.  Последовательно проходим строки C и вычитаем значение  наи-
меньшего элемента hi каждой строки из каждого элемента этой стро-
ки.  Потом то же самое делаем для каждого столбца. Если для неко-
торого  столбца  или строки hi=0,  то рассматриваемый столбец или

                             - 209 -

строка уже приведены,  и тогда переходим к следующему столбцу или
строке.
     Положим
                        h=   сумма    hi.
                           все строки
                            и столбцы
Полученную в результате матрицу стоимостей назовем приведенной из
C.  На рис.  10.8 показано приведение матрицы стоимостей, изобра-
женной на
 ш1
                        1    2    3    4    5
                     ┌────┬────┬────┬────┬─────┐
                    1│   74 0 │  0 │ 15 │  3 │  2  │ h1=25
                     ├────┼────┼────┼────┼─────┤
                    2│  0 │   74 0 │ 12 │ 22 │  20 │ h2=5
                     ├────┼────┼────┼────┼─────┤
                    3│ 18 │ 14 │   74 0 │  2 │  0  │ h3=1
                     ├────┼────┼────┼────┼─────┤
                    4│  3 │ 44 │ 18 │   74 0 │  0  │ h4=6
                     ├────┼────┼────┼────┼─────┤
                    5│ 15 │  1 │  0 │  0 │   74 0  │ h5=7
                     └────┴────┴────┴────┴─────┘
                      h6=0 h7=0 h8=0 h9=0 h10=0
 ш0
      Рис. 10.8. Приведение матрицы стоимостей, показанной
                        на рис. 10.6, а.
рис. 10.6,  а.  Значения hi даны в конце каждой строки и  столбца
(строки и столбцы последовательно перенумерованы).
     Общее приведение составляет h=47 единиц. Следовательно, ниж-
няя граница стоимости любого тура из R также равна 47, т.е.
                       z(t)=h+z'(t)>=h=47,
так как  z'(t)>=0  для  любого тура t при приведенной матрице C'.
Эта граница показана около корня дерева на рис. 10.7.
     Рассмотрим нижние границы для вершин уровня 1, т.е. для мно-
жеств {3,5} и {3,5}". Будем работать с приведенной матрицей, имея
в виду,  что значение 47 должно быть прибавлено к стоимости опти-
мального тура t при C' для того,  чтобы получить  истинную  стои-
мость t при C.
     По определению ребро (3,5) содержится в каждом туре множест-
ва {3,5}. Этот факт препятствует выбору ребра (5,3), так как реб-
ра (3,5) и (5,3) образуют цикл, а это не допускается ни для како-
го тура.  Ребро (5,3) исключаем из рассмотрения, положив c53=бес-
конечности.  Строку 3 и столбец 5 также можно исключить из  даль-
нейшего  рассмотрения по отношению к множеству {3,5},  потому что
уже есть ребро из 3 в 5.  Часть приведенной  матрицы  стоимостей,

                             - 210 -

показанной на рис. 10.8, которая будет хоть сколько-нибудь полез-
на для дальнейшего поиска на множестве туров {3,5},  показана  на
рис. 10.9, а. Она может быть приведена к матрице
 ш1
        1   2   3   4                      1   2   3   4
      ┌───┬───┬───┬───┐                   ┌───┬───┬───┬───┐
     1│  74 0 │ 0 │ 15│ 3 │                  1│  74 0 │ 0 │ 3 │ 3 │0
      ├───┼───┼───┼───┤                   ├───┼───┼───┼───┤
     2│ 0 │  74 0 │ 12│ 22│                  2│ 0 │  74 0 │ 0 │ 22│0
      ├───┼───┼───┼───┤                   ├───┼───┼───┼───┤
     4│ 3 │ 44│ 18│  74 0 │                  3│ 0 │ 41│ 3 │  74 0 │3
      ├───┼───┼───┼───┤                   ├───┼───┼───┼───┤
     5│ 15│ 1 │  74 0 │ 0 │                  4│ 15│ 1 │  74 0 │ 0 │0
      └───┴───┴───┴───┘                   └───┴───┴───┴───┘
                                           0   0   12  0
                                              h=12+3=15
             а                                    б
 ш0
     Рис. 10.9. (а) Приведенная матрица стоимостей после вычерки-
                вания  строки  3  и  столбца  5  и   установления
                c53=бесконечность;  (б)  приведение матрицы стои-
                мостей, изображенной в части (а).

стоимостей, показанной на рис. 10.9, б с h=15. Теперь нижняя гра-
ница для любого тура из множества {3,5} равна 47+15=62;  она ука-
зана около вершины {3,5} на рис. 10.7.
     Нижняя граница для  множества  {3,5}"  получается  несколько
иным  способом.  Ребро(3,5) не может находиться в этом множестве,
поэтому полагаем c35=бесконечность  в  матрице,  изображенной  на
рис.  10.8. В любой тур из {3,5}" будет входить какое-то ребро из
города 3 и какое-то ребро к городу 5.  Самое дешевое ребро из го-
рода 3,  исключая старое значение (3,5), имеет стоимость 2, а са-
мое дешевое ребро к городу 5 имеет  стоимость  0.  Следовательно,
нижняя  граница  любого  тура в множестве {3,5}" равна 47+2+0=49;
это указано около вершины {3,5}" на рис. 10.7.
     На данной  стадии нам удалось сократить размер матрицы стои-
мостей, рассматриваемой в вершине {3,5}. Кроме того, если мы смо-
жем найти тур из множества {3,5}" со стоимостью, меньшей или рав-
ной 62,  тогда не нужно проводить дальше ветвления  и  вычисления
границ в вершине {3,5}. В этом случае будем говорить, что вершина
{3,5} в дереве отработана. Тогда следующей целью может быть ветв-
ление  из вершины {3,5}" в надежде найти тур со стоимостью в пре-
делах 49<=c<=62.
     В основных чертах блок-схема этого алгоритма ветвей и границ
показана на рис. 10.10. Здесь используются следующие обозначения.

                             - 211 -


 ш1
                    ┌────────────────────────┐
                   1│Инициализация переменных│
                    │Считывание данных       │
                    └──────────┬─────────────┘
                               │
                    ┌──────────┴─────────┐
                   2│Приведение C        │
                    │Установка корня, X=R│
                    └──────────┬─────────┘
                               │
                    ┌──────────┴──────────┐
                   3│Выбор ребра (k,l) для│
          ┌─────────┤следующего ветвления │
          │         └──────────┬──────────┘
          │                    │
          │         ┌──────────┴─────────┐
          │        4│Процесс ветвления   │
          │         │Установка вершины Y"│
          │         │Вычисление w(Y")    │
          │         └──────────┬─────────┘
          │                    │
          │         ┌──────────┴────────┐
          │        5│Процесс ветвления  │
          │         │Установка вершины Y│
          │         │Вычисление w(Y)    │
          │         └─────────┬─────────┘
  ┌───────┴───────┐           │
11│Корректировка C│           │
  │для текущей X  │         6
  └───────┬───────┘
          │
          │              Достаточна      Да  7┌─────────────┐
          │            ли мала матрица  ─────>│Проведение   │
          │              стоимостей C         │исчерпывающей│
          │Нет                ?               │оценки для Y │
          │                                   └──────┬──────┘
          │                                          │
          │                                          │
          │                   │                      │
          │                   │Нет                   │
                       ┌──────┴──────┐       ┌───────┴─────────┐
                      9│  Выбор      │      8│ Если w(Y)<z0,   │
       z0<=w(X)  <─────┤  следующей  │<──────┤ полагаем z0=w(Y)│
          ?            │  вершины X  │       │ Тур запоминаем  │
                       └─────────────┘       └─────────────────┘

          │
          │Да
          │
          ?
 ш0
        Рис. 10.10 Блок-схема алгоритма ветвей и границ.

Буква X обозначает текущую вершину на дереве поиска, а w(X) - со-
ответствующую нижнюю границу.  Вершины, следующие непосредственно
за X назовем Y и Y"; они выбираются ветвлением по некоторому реб-

                             - 212 -

ру  (k,l).  Символ  z0 обозначает стоимость самого дешевого тура,
известного на данный момент. В начальный момент z0=бесконечность.


     10.2.5. Рекурсия и итерация

     В математике и программировании рекурсия - это метод опреде-
ления или выражения функции,  процедуры, языковой конструкции или
решения задачи посредством той же функции, процедуры и т.д.
     Факториалы и числа Фибоначчи
     Факториальная функция определяется рекурсивно следующим  об-
разом:
                  0!=1, N!=Nx(N-1)!, если N>0,
или в виде фрагмента программы:
             FAC(0)=1,                           (1)
             FAC(N)=N*FAC(N-1), если N>0.        (2)
Областью определения функции FAC является множество неотрицатель-
ных целых чисел.
     Уравнение (2) - это пример рекуррентного соотношения. Рекур-
рентные  соотношения  выражают значения функции при помощи других
значений, вычисленных для меньших аргументов. Уравнение (1) - не-
рекурсивно  определенное  начальное значение функции.  Для каждой
рекурсивной функции нужно хотя бы одно такое начальное  значение,
в противном случае ее нельзя вычислить в явном виде.
     Аналогично числа Фибоначчи определяются следующей  бесконеч-
ной последовательностью целых чисел:  1,  1,  2, 3, 5, 8, 13, 21,
34, 55, 89, .... Проверка показывает, что N-й элемент этой после-
довательности  равен  сумме  двух  непосредственно предшествующих
элементов.  Таким образом, если FIB(N) обозначает N-е число Фибо-
наччи, что значение FIB(N) может быть определено из рекуррентного
соотношения:
                    FIB(N)=FIB(N-1)+FIB(N-2).
     Так как FIB(N) определено  через  два  разных  значения  для
меньших аргументов, необходимы два начальных значения. Ими служат
                            FIB(1)=1,
                            FIB(2)=1.
     Посмотрим, какую  работу  надо  проделать,  чтобы  вычислить
FAC(N)  для  произвольного  натурального числа N.  Для вычисления
FAC(N) мы должны произвести  рекурсивное  обращение  и  вычислить

                             - 213 -

FAC(N-1). Это в свою очередь требует другого рекурсивного обраще-
ния для вычисления FAC(N-2) и т.д.  Таким образом, для того чтобы
вычислить FAC(N),  нужно произвести N рекурсивных обращений, пос-
леднее из которых выполняется для FAC(0)=1. Принято говорить, что
глубина рекурсии, требуемой для вычисления FAC(N), равна N. В ма-
шинных программах глубина рекурсии  соответствует  самой  длинной
последовательности обращений к процедуре,  требуемой для вычисле-
ния функции.  Поэтому глубина рекурсии - это мера  вычислительной
сложности рекурсивно определенной функции.
     Для вычисления значения FIB(N) функции Фибоначчи  нужно  вы-
числить  два  значения  функции [FIB(N-1) и FIB(N-2)].  Каждое из
этих вычислений в свою очередь требует двух вычислений - два  для
FIB(N-1) и еще два для FIB(N-2) и т.д. Это подсказывает, что глу-
бина рекурсии,  требуемая для вычисления FIB(N),  равна приблизи-
тельно  2  в  степени (N-2).  Такой подход дает сильно завышенную
оценку.  Ясно,  что если известны N-1 значений,  FIB(1),  FIB(2),
...,  FIB(N-1),  то можно вычислить FIB(N). Более того, поскольку
сразу были заданы FIB(1) и FIB(2),  потребуется только N-3 вычис-
лений для FIB(3),  ...,  FIB(N-1).  Таким образом, N-2 вычислений
функции будет достаточно для вычисления FIB(N).
     Функция Аккермана
     Две рекурсивные функции, рассмотренные до сих пор, были дос-
таточно простыми.  Поэтому,  чтобы не сложилось неправильное впе-
чатление о том,  насколько сложны рекурсивные функции, представим
следующую,  довольно простую на первый взгляд, дважды рекурсивную
функцию,  известную как функция Аккермана.  Функция дважды рекур-
сивна, если сама функция и один из ее аргументов определены через
самих себя.


                         N+1,             если M=0;
              A(M,N) =   A(M-1,1)         если N=0;
                         A[M-1, A(M,N-1)] в остальных случаях.



   Беглый просмотр рис.10.11 показывает, как трудно вычислить эту



                             - 214 -

   A(4,2)                  A(1,3)              = 5
     /\                      /\
    /  \                    /  \
 A(3,  A(4,1))           A(0,  A(1,2))         = 4
         /\                      /\
        /  \                    /  \
     A(3,  A(4,0))    = 13   A(0,  A(1,1))     = 3
              │
              │              A(2,5)            = 13
            A(3,1)      = 13   /\
              /\              /  \
             /  \          A(1,  A(2,4))       = 11
          A(2,  A(3,0)) = 5        /\
                   │              /  \
                   │           A(1,  A(2,3))   = 9
                 A(2,1) = 5             /\
                   /\                  /  \
                  /  \              A(1,  A(2,2))  = 7
               A(1,  A(2,0)) = 3             /\
                        │                   /  \
                        │                A(1,  A(2,1))  = 5
                      A(1,1) = 3                  /\
                        /\                       /  \
                       /  \                   A(1,  A(1,1))  = 3
                    A(0,  A(1,0)) = 2
                             │
                             │
                           A(0,1) = 2
  A │ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 ...
────┼──────────────────────────────────────────────
  0 │ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 ...
    │   /
  1 │ 2  3  4  5  6  7  8  9 10 11 12 13 14 15 ...
    │   /
  2 │ 3  5  7  9 11 13 15 17 19 21 23 25 27 29 ...
    │   /
  3 │ 5 13                                   O
    │  /
  4 │13  O      Рис. 10.11. Вычисление функции Аккермана A(4,2).

                             - 215 -

функцию даже для таких малых аргументов, как M=4 и N=2. Заметьте,
например, что A(4,1)=A(3,13).
     Как только алгоритм рекурсивно сформулирован, возникает нес-
колько вариантов реализации. Первый и наиболее очевидный - реали-
зовать его на языке программирования,  допускающем рекурсию. Вто-
рой вариант - реализовать его на нерекурсивном  языке,  моделируя
стек.  Третья возможность - обратиться за помощью к литературе по
разным "автоматическим"  процедурам  преобразования  рекурсивного
алгоритма  в  итеративный.  Наконец,  можно пересмотреть задачу с
тем,  чтобы выяснить,  действительно ли рекурсия необходима, т.е.
можно построить новый алгоритм.

     10.2.6. Моделирование

     Машинное моделирование  - это процесс экспериментирования на
ЭВМ над моделью динамической системы.  Непосредственная цель этих
экспериментов  -  наблюдение  за  поведением системы при заданных
предположениях,  условиях и значениях параметров.  Конечной целью
может быть:  (1) формулирование стратегии управления, (2) опреде-
ление оптимальных или возможных конфигураций системы,  (3)  уста-
новление  реальных  производственных планов и (4) решение вопроса
об оптимальных экономических стратегиях.
     Преимущества машинного моделирования многочисленны. Они поз-
воляют изучить с желаемой степенью детальности все части системы,
объединенные  в  единое целое,  в то время как аналитически можно
изучить только отдельные части системы.  Всеми переменными  можно
управлять, и все можно измерять. Машинное моделирование позволяет
получить информацию о реальной системе,  когда непрактично прово-
дить на ней прямой эксперимент.  Имитация позволяет испытать сис-
тему до того,  как на соответствующую реальную систему  затрачены
время и деньги.
     Имитационные эксперименты можно проводить в разных масштабах
времени.  Время может быть замедленно, чтобы проверить на микрос-
копическом уровне свойства, которые трудно проанализировать в ре-
альной системе.  Время может быть ускорено, чтобы охватить все на
макроскопическим уровне,  например,  при изучении отдаленных пос-
ледствий  тех  или иных допущений.  Время также можно остановить,
повернуть вспять и проиграть заново, чтобы изучить случаи необыч-
ного поведения более детально.  В реальных системах часто бывает,

                             - 216 -

что, начав некоторый эксперимент, остановить его нельзя.
     Почему мы не прибегаем к моделированию во всех случаях?  Су-
ществует несколько частичных ответов на этот  вопрос.  Во-первых,
моделирование - это экспериментальный метод.  Поэтому всегда воз-
никает серьезный вопрос,  как истолковать результаты.  Важно  по-
нять,  что достоверность выходных данных зависит от того, в какой
степени модель и основные допущения отражают характеристики  сис-
темы.  Машинная  имитация может стать дорогостоящей,  если модель
становится чрезмерно детализированной.
     Возможно, самые  простые и наиболее распространенные из всех
имитационных алгоритмов - это  алгоритмы,  моделирующие  очереди.
Задачи об очередях допускают также большое число разных предполо-
жений и обобщений,  что делает их хорошими примерами для дальней-
шего изучения.
     Основными объектами в простой очереди  (линии  обслуживания)
являются клиенты,  прибывающие через случайные интервалы времени,
и обслуживающее устройство, которое обслуживает каждого клиента в
течение случайного интервала времени. Когда клиенты прибывают, их
или сразу обслуживают,  или они выстраиваются, образуя очередь, и
их обслуживают по принципу: первым пришел - первым обслужен. Рис.
10.12 иллюстрирует систему одна очередь/одно  обслуживающее  уст-
ройство.
 ш1

                              Обслуженные
                         <─────────────────────┐
                                               │    ┌┐
                     ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐      ┌─┐   ││  ┌─┐
──────────────────>  └─┘ └─┘ └─┘ └─┘ └─┘      └─┘   ││  └─┘
   Прибывающие      └──────────────┬──────────────┘ └┘ └─┬─┘
                                   │                     │
                                Очередь            Обслуживающее
                                                     устройство

 ш0


 Рис. 10.12. Система "одна очередь/одно обслуживающее устройство".


     Функционирование такой  очереди  определяется следующими ха-
рактерными особенностями и предположениями:
     1. Имеется случайная переменная X,  которая определяет время
прибытия следующего клиента.  Существует  несколько  возможностей
для решения вопроса о времени прибытия клиента.  Мы будем предпо-

                             - 217 -

лагать, что если клиент K прибывает в момент времени t, то клиент
K+1 прибывает в момент t+T,  где T - случайная переменная, значе-
ние которой лежит между 1 и некоторым фиксированным целым  числом
MAXA, с заданным распределением вероятностей.
     2. Имеется случайная  переменная  S,  определяющая,  сколько
времени длится обслуживание клиента K. Предполагается, что значе-
ние величины S лежит между 1 и некоторым другим фиксированным це-
лым числом MAXC с заданным распределением вероятностей. Если обс-
луживание начато, оно продолжается до полного завершения, т.е. не
допускается прерывание или обслуживание с приоритетом.
     3. Существует очередь клиентов,  обслуживаемая по  принципу:
первым пришел - первым обслужен.  Как только клиент встает в оче-
редь, он остается в ней, пока не будет обслужен. Сразу после обс-
луживания он покидает систему.
     4. Все действия в системе описываются дискретными  "события-
ми"; отсюда название "моделирование дискретных событий". Событие,
грубо говоря,  может быть описано как что-то меняющее "состояние"
или конфигурацию системы. Говорят, что событие является первичным
или независимым, если оно не вызвано другим событием; в противном
случае оно называется вторичным или условным событием.  Независи-
мыми событиями в системе обслуживания являются:
     (а) Прибытие клиента.
     (б) Завершение обслуживания клиента.
     5. В начальном состоянии система пуста. В момент времени t=0
обслуживающее устройство не занято и в очереди никого нет.
     6. Потоком действий управляют часы с дискретным,  постоянным
приращением времени. Эти часы отсчитывают постоянные единицы вре-
мени;  это могут быть секунды, наносекунды (при рассмотрении ими-
тационных моделей операционных систем ЭВМ) или месяцы,  годы (при
рассмотрении имитационных моделей народонаселения).
     7. Для определения промежутков времени между прибытиями кли-
ентов  и  продолжительностей  их  обслуживания применяется датчик
случайных чисел.
     Чтобы разработать алгоритм для моделирования конкретной сис-
темы одна очередь/одно обслуживающее устройство,  нужно  выяснить
ряд вопросов:
     1. Каковы  распределения  вероятностей  промежутков  времени
между прибытиями клиентов и продолжительности обслуживания?
     2. Каким датчиком случайных чисел и как пользоваться для по-

                             - 218 -

лучения случайных промежутков времени?
     3. Каковы правила в очереди  (свойства  очереди)?  Например,
пойдут ли первыми клиенты, имеющие самый высокий приоритет? Будут
ли нетерпеливые клиенты покидать  очередь  из-за  того,  что  она
слишком большая или слишком медленно движется? Ограничено ли чис-
ло клиентов, которые одновременно могут находиться в очереди?
     4. Сколько  времени  следует  продолжать  процесс  имитации?
Должны ли часы отсчитывать по единице времени, или они должны пе-
реходить к моменту следующего определенного события?
     5. Как будут "составлены расписания"  для  событий,  относи-
тельно  которых  установлено (случайно или не случайно),  что они
должны произойти в определенной время? Иными словами, как мы убе-
димся,  что  эти события и все другие,  являющиеся их следствием,
действительно происходят и происходят вовремя?  Что делать в слу-
чае "совпадения",  т.е. когда два или более событий случаются од-
новременно?
     6. Какие  данные  нужно  собрать во время процесса имитации?
Типичные данные,  в получении которых могла бы возникнуть заинте-
ресованность, следующие:
     (а) Число прибытий в процессе имитации.
     (б) Средняя длина очереди.
     (в) Среднее время ожидания в очереди.
     (г) Максимальная длина очереди.
     (д) Эффективность использования  обслуживающего  устройства,
т.е. процент времени, в течение которого обслуживающее устройство
было занято.
     (е) Среднее, максимальное и минимальное время обслуживания.
     (ж) Функция распределения длины очереди, т.е. процентные до-
ли времени, в течение которого длина очереди была t.
     (з) Число клиентов, которым не пришлось ждать.
     Ответы на вопросы 1-6 зависят от специфики моделируемой сис-
темы обслуживания. Но как на них отвечать?
     Можно начать  с наблюдения за реальной системой обслуживания
в течение некоторого времени и собрать данные  такого  рода,  как
указано в пункте 6, регистрируя промежутки времени между прибыти-
ями и продолжительность обслуживания. В большинстве систем обслу-
живания моменты прибытия подвержены большим колебаниям, зависящим
от времени дня (явление времени пика). Возникает несколько допол-
нительных вопросов по поводу этих данных.  Например, что можно из

                             - 219 -

них вывести? Достаточно ли велика выборка? Можно ли эти временные
интервалы аппроксимировать некоторыми стандартными распределения-
ми?  Разумные ответы на эти вопросы требуют понимания теории про-
верки гипотез, теории выборок и т.п.
     Фактически во всех вычислительных устройствах  имеется  сис-
темный  датчик  случайных чисел для равномерного распределения на
интервале [0,1).  Это распределение может быть  использовано  для
того, чтобы смоделировать другие распределения случайной перемен-
ной.
     Большинство систем  обслуживания имеют заранее установленный
неизменный порядок (правила) очереди.  Поэтому для  таких  систем
этот  вопрос не входит в задачу разработки имитационного алгорит-
ма. Но в других случаях, таких, как операционные системы ЭВМ, оп-
ределение  оптимальных порядков очереди - важная цель моделирова-
ния.
     Основное предположение  в  системах  с дискретными событиями
заключается в том, что состояние системы изменяется, только когда
происходит  событие;  в противном случае состояние остается неиз-
менным. Таким образом, нет нужды в беспрерывном ходе часов, когда
ничего не случается. Наиболее общий подход - произвести все изме-
нения,  необходимые вследствие совершившегося  события,  а  затем
продвинуть имитируемое время ко времени следующего события. Такой
подход к моделированию дискретных событий называется методом пла-
нирования событий.

     Для иллюстрации этого подхода  на  рис.  10.13  представлена
 ш1
                             4┌────────┐
                             4│ 0 Начало 4 │
                             4└─ 0──┬─── 4─┘
                                │
                        1┌──────┴──────┐
                         │Инициализация│
                         └──────┬──────┘
                                │
┌──────────────────────────────>о
│                               │
│                     2┌────────┴─────────┐
│                      │   Определение    │
│                      │следующего события│
│                      └────────┬─────────┘
│                               │
│                    3┌─────────┴──────────┐
│                     │   Перевод часов    │
│                     │к следующему событию│
│                     └─────────┬──────────┘
│                               │

                             - 220 -

│
│              Прибытие     4             Завершение
│              клиента        Какое 4    0   обслуживания
│           ┌───────────    следующее 4    0 ─────────────┐
│           │                событие? 4   0               │
│           │                                         │
│           │                     4  0                    │
│ ┌─────────┴──────────┐                 ┌────────────┴─────────┐
│ │    Планирование    │                 │     Планирование     │
│ │ следующего события;│                 │следующего завершения;│
│ │постановка в очередь│                 │исключение из очереди │
│ └─────────┬──────────┘                 └────────────┬─────────┘
│           │                                         │
│           └──────────────────>о<────────────────────┘
│                               │
└───────────────────────────────┘
 ш0
   Рис. 10.13. Блок-схема моделирования системы "одна очередь/
                 одно обслуживающее устройство".
принципиальная блок-схема  алгоритма  моделирования  системы одна
очередь/одно обслуживающее устройство.  Чтобы получить моделирую-
щую программу,  необходима некоторая переработка этой блок-схемы.
В частности,  нет условия для остановки (или возвращения). С этой
целью мы вводим три различные целочисленные переменные ARR,  COMP
и TERM,  обозначающие соответственно время  следующего  прибытия,
время завершения обслуживания и время окончания моделирования. Мы
также вводим переменную CLOCK для записи  текущего  времени.  Так
как мы используем метод планирования событий, полагаем переменную
CLOCK равной времени следующего запланированного события: это или
время следующего прибытия, или время завершения обслуживания, или
время окончания моделирования.  Тогда блоки 2,  3 и 4  становятся
такими, как показано на рис. 10.14.
 ш1
                                  │
                  ───────────────>о
                                  │
                         ┌────────┴─────────┐
                         │ CLOCK=минимум из │
                         │ ARR, COMP, TERM  │
                         └────────┬─────────┘
                                  │

                         ARR            COMP
                   ┌──────────  CLOCK ──────────┐
                   │              ?             │


                                  │
                                  │TERM
                                ┌─┴─┐
                                │ T │
                                └───┘
 ш0
      Рис. 10.14. Блок-схема определения следующего события.

                             - 221 -

     Далее рассмотрим,  что должно быть сделано в блоке 5 на рис.
10.13,  когда имеет место новое прибытие. Во-первых, мы можем оп-
ределить время следующего прибытия в соответствии с правилом вида
                   ARR = CLOCK + RANARR(1,MAXA)
где RANARR(1,MAXA) - функция,  которая дает случайное целое число
между 1 и некоторой фиксированной константой MAXA с  определенным
распределением вероятностей.
     Следующая работа,  которую нужно выполнить,  когда прибывает
новый  клиент,  -  это или поставить клиента в очередь,  или если
обслуживающее устройство свободно, то обслужить его. Если очереди
нет (длина очереди определяется переменной QUEUE), то можно опре-
делить время ухода данного клиента (т.е. время полного обслужива-
ния) из уравнения
                  COMP = CLOCK + RANCOM(1, MAXC)
Тогда блок 5 становится таким, как на рис. 10.15.
 ш1

   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
  │              ┌────────────┴─────────────┐                   │
                 │ARR = CLOCK+RANARR(1,MAXA)│
  │              └────────────┬─────────────┘                   │
                              │
  │                                                             │
                  Да                   Нет
  │            ┌───────── QUEUE=0  ──────────────┐              │
               │             ?                   │
  │    ┌───────┴──────┐               ┌──────────┴─────────┐    │
       │COMP = CLOCK+ │               │  QUEUE=QUEUE + 1   │
  │    │RANCOM(1,MAXC)│               │QMAX=MAX(QMAX,QUEUE)│    │
       └───────┬──────┘               └──────────┬─────────┘
  │            │                                 │              │
               └─────────────>o<─────────────────┘
  │                           │                                 │
   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─

 ш0
             Рис. 10.15. Блок-схема для нового прибытия.

     Для завершения блока 6 также  потребуется  определить  время
завершения следующего обслуживания:
                  COMP = CLOCK + RANCOM(1,MAXC)
     Следует, однако,  рассмотреть и особую ситуацию,  когда оче-
редь становится пустой.  Конечно,  в этом случае время завершения
следующего  обслуживания не имеет смысла.  Поэтому мы произвольно
полагаем COMP=TERM+1,  чтобы гарантировать, что завершение не яв-
ляется следующим запланированным событием. Тогда блок 6 становит-
ся таким, как показано на рис. 10.16.

                             - 222 -

 ш1
  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
 │                                                             │
                 Да                   Нет
 │            ┌───────── QUEUE=0  ──────────────┐              │
              │             ?                   │
 │    ┌───────┴──────┐             ┌────────────┴────────────┐ │
      │COMP = TERM+1 │             │COMP=CLOCK+RANCOM(1,MAXC)│
 │    └───────┬──────┘             │QUEUE=QUEUE - 1          │ │
              │                    └────────────┬────────────┘
 │            │                                 │              │
              └─────────────>o<─────────────────┘
 │                           │                                 │
  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─

 ш0
       Рис. 10.16. Блок-схема для завершения обслуживания.

     Что еще осталось сделать?  Во-первых, нужно задать начальные
значения (инициализовать) всем переменным,  таким, как ARR, TERM,
QUEUE,  QMAX,  MAXA, MAXC и COMP. Затем нужно определить подпрог-
раммы для вычисления RANARR и RANCOM.  Наконец, нужно представить
какой-то вывод - в окружности, обозначенной T на рис. 10.14.
     Заметим, что эта блок-схема еще не совсем  полна.  Например,
не организован сбор данных - по существу мы регистрировали только
QMAX.





















                             - 223 -

                              ЛИТЕРАТУРА

     1. Керниган Б., Ритчи Д. Язык программирования Си. - М.: Фи-
нансы и статистика, 1992.
     2. Инструментальные средства персональных ЭВМ.  В 10 кн. Кн.
7.  Программирование  в  среде  Турбо  Си:  Практическое пособие.
/Л.Е.Агабеков,  Е.А.  Просуков,  А.В.  Кононенков и др. - М.: ВШ,
1993.
     3. Б.  Страуструп.  Язык программирования С++. Часть первая.
Пер. с англ. - Киев: "ДиаСофт", 1993.
     4. Б.  Страуструп.  Язык программирования С++. Часть вторая.
Пер. с англ. - Киев: "ДиаСофт", 1993.
     5. П.  Ирэ.  Объектно-ориентированное программирование с ис-
пользованием C++. Перв. с англ. - К.: НИПФ "ДиаСофт", 1995.
     6. Бруно Бабэ.  Просто и ясно о Borland C++:  Пер. с англ. -
М.: БИНОМ, 1995.
     7. Уинер Р.  Язык Турбо Си: Пер. с англ. - М.: Мир, 1991.
     8. Белецкий Я.  Энциклопедия языка Си:  Пер. с польск. - М.:
Мир, 1992.
     9. Гудман С.,  Хидетниеми С.  Введение в разработку и анализ
алгоритмов. - М.: Мир, 1981.
     10. Кнут.  Д.  Искусство программирования для ЭВМ. В 3 т. Т.
1-3. - М.: Мир, 1976.
     11. Вирт Н.  Алгоритмы и структуры данных.  - М.: Мир, 1989.
     12. Лэнгсам И.  и др.  Структуры данных персональных ЭВМ.  -
М.: Мир, 1989.



