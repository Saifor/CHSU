using System; using System.Collections.Generic; using System.IO; using System.Linq; class Program { static void Main() { try { // Чтение входного файла string[] inputLines; try { inputLines = File.ReadAllLines("INPUT.TXT"); if (inputLines.Length == 0) { Console.WriteLine("Файл INPUT.TXT пуст"); return; } } catch (FileNotFoundException) { Console.WriteLine("Файл INPUT.TXT не найден"); return; } // Парсинг количества квартир if (!int.TryParse(inputLines[0], out int N) || N <= 0 || N > 30) { Console.WriteLine("Некорректное количество квартир в первой строке"); return; } // Обработка списка труб var pipes = new List<(int, int)>(); for (int i = 1; i < inputLines.Length; i++) { string[] parts = inputLines[i].Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries); if (parts.Length != 2) { Console.WriteLine($"Ошибка в строке {i + 1}: требуется ровно два числа"); continue; } if (!int.TryParse(parts[0], out int a) || !int.TryParse(parts[1], out int b) || a <= 0 || b <= 0 || a > N || b > N) { Console.WriteLine($"Ошибка в строке {i + 1}: номера квартир должны быть от 1 до {N}"); continue; } // Добавляем трубу в нормализованном виде (меньший номер сначала) pipes.Add((Math.Min(a, b), Math.Max(a, b))); } // Удаляем дубликаты труб var uniquePipes = pipes.Distinct().ToList(); // Находим трубы, которые можно заменить var replaceablePipes = new List<(int, int)>(); foreach (var pipe in uniquePipes) { // Создаем временный граф без текущей трубы var tempGraph = uniquePipes.Where(p => p != pipe).ToList(); // Проверяем, остаются ли квартиры связанными if (!AreConnected(tempGraph, pipe.Item1, pipe.Item2, N)) { replaceablePipes.Add(pipe); } } // Вывод результата Console.WriteLine("Трубы, которые можно заменять:"); if (replaceablePipes.Count == 0) { Console.WriteLine("Нет труб для замены"); } else { foreach (var pipe in replaceablePipes.OrderBy(p => p.Item1).ThenBy(p => p.Item2)) { Console.WriteLine($"{pipe.Item1} {pipe.Item2}"); } } } catch (Exception ex) { Console.WriteLine($"Произошла непредвиденная ошибка: {ex.Message}"); } } static bool AreConnected(List<(int, int)> graph, int start, int end, int N) { if (start == end) return true; var visited = new bool[N + 1]; var queue = new Queue<int>(); queue.Enqueue(start); visited[start] = true; while (queue.Count > 0) { int current = queue.Dequeue(); foreach (var pipe in graph) { if (pipe.Item1 == current && !visited[pipe.Item2]) { if (pipe.Item2 == end) return true; visited[pipe.Item2] = true; queue.Enqueue(pipe.Item2); } else if (pipe.Item2 == current && !visited[pipe.Item1]) { if (pipe.Item1 == end) return true; visited[pipe.Item1] = true; queue.Enqueue(pipe.Item1); } } } return false; } }