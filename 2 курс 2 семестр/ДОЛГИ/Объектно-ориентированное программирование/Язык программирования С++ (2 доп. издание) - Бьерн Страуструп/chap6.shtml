<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 6<br>
Производные классы</h3>

<p align="right"><i>Не плоди объекты без нужды.<br>
-В. Оккам</i></p>
<p>Эта глава посвящена понятию производного класса. Производные
   классы - это простое, гибкое и эффективное средство определения
   класса. Новые возможности добавляются к уже существующему
   классу, не требуя его перепрограммирования или перетрансляции.
   С помощью производных классов можно организовать общий
   интерфейс с несколькими различными классами так, что в других
   частях программы можно будет единообразно работать с объектами
   этих классов. Вводится понятие виртуальной функции, которое
   позволяет использовать объекты надлежащим образом даже
   в тех случаях, когда их тип на стадии трансляции неизвестен.
   Основное назначение производных классов - упростить
   программисту задачу выражения общности классов.</p>

<a name="#introduct"></a><h4>6.1 Введение и краткий обзор</h4>
<p>Любое понятие не существует изолированно, оно существует во
   взаимосвязи с другими понятиями, и мощность данного понятия во
   многом определяется наличием таких связей. Раз класс служит для
   представления понятий, встает вопрос, как представить взаимосвязь
   понятий. Понятие производного класса и поддерживающие его
   языковые средства служат для представления иерархических связей,
   иными словами, для выражения общности между классами. Например,
   понятия окружности и треугольника связаны между собой, так как
   оба они представляют еще понятие фигуры, т.е. содержат более общее
   понятие. Чтобы представлять в программе окружности и треугольники
   и при этом не упускать из вида, что они являются фигурами, надо
   явно определять классы окружность и треугольник так, чтобы было видно,
   что у них есть общий класс - фигура. В главе исследуется, что
   вытекает из этой простой идеи, которая по сути является основой того,
   что обычно называется объектно-ориентированным программированием.</p>
<p>Глава состоит из шести разделов:</p>
<p>п.<a href="#derivat">6.2</a> с помощью серии небольших примеров вводится понятие производного
         класса, иерархии классов и виртуальных функций.</p>
<p>п.<a href="#abstr">6.3</a> вводится понятие чисто виртуальных функций и абстрактных
         классов, даны небольшие примеры их использования.</p>
<p>п.<a href="#example">6.4</a> производные классы показаны на законченном примере</p>
<p>п.<a href="#multinher">6.5</a> вводится понятие множественного наследования как возможность
         иметь для класса более одного прямого базового класса,
         описываются способы разрешения коллизий имен, возникающих
         при множественном наследовании.</p>
<p>п.<a href="#contrl">6.6</a> обсуждается механизм контроля доступа.</p>
<p>п.<a href="#freemem">6.7</a> приводятся некоторые приемы управления свободной памятью для
         производных классов.<p>
<p>В последующих главах также будут приводиться примеры, использующие
   эти возможности языка.</p>

<a name="#derivat"></a><h4>6.2 Производные классы</h4>
<p>Обсудим, как написать программу учета служащих некоторой
   фирмы. В ней может использоваться, например, такая структура данных:</p>
<pre>
              struct employee {            // служащие
                   char*     name;         // имя
                   short     age;          // возраст
                   short     department;   // отдел
                   int       salary;       // оклад
                   employee* next;
                   // ...
               };
</pre>
<p>Поле next нужно для связывания в список записей о служащих
   одного отдела (employee). Теперь попробуем определить структуру данных
   для управляющего (manager):</p>
<pre>
              struct manager {
                 employee emp;    // запись employee для управляющего
                 employee* group; // подчиненный коллектив
                 short   level;
                 // ...
              };
</pre>
<p>Управляющий также является служащим, поэтому запись employee
   хранится в члене emp объекта manager. Для человека эта общность
   очевидна, но для транслятора член emp ничем не отличается от
   других членов класса. Указатель на структуру manager (manager*)
   не является указателем на employee (employee*), поэтому
   нельзя свободно использовать один вместо другого. В частности,
   без специальных действий нельзя объект manager включить в список
   объектов типа employee. Придется либо использовать явное приведение
   типа manager*, либо в список записей employee включить адрес
   члена emp. Оба решения некрасивы и могут быть достаточно запутанными.
   Правильное решение состоит в том, чтобы тип manager был типом
   employee с некоторой дополнительной информацией:</p>
<pre>

            struct manager : employee {
              employee* group;
              short level;
              // ...
            };
</pre>
<p>Класс manager является производным от employee, и, наоборот, employee
   является базовым классом для manager. Помимо члена group в классе
   manager есть члены класса employee (name, age и т.д.).</p>
<p>Графически отношение наследования обычно изображается в виде
   стрелки от производных классов к базовому:</p>
<pre>
                employee
                   ^
                   |
                 manager
</pre>
<p>Обычно говорят, что производный класс наследует базовый класс, поэтому
   и отношение между ними называется наследованием. Иногда базовый класс
   называют суперклассом, а производный - подчиненным классом. Но
   эти термины могут вызывать недоумение, поскольку объект производного
   класса содержит объект своего базового класса. Вообще производный
   класс больше своего базового в том смысле, что в нем содержится
   больше данных и определено больше функций.</p>
<p>Имея определения employee и manager, можно создать список
   служащих, часть из которых является и управляющими:</p>
<pre>
            void f()
            {
              manager m1, m2;
              employee e1, e2;
              employee* elist;
              elist = &m1;           // поместить m1 в elist
              m1.next = &e1;         // поместить e1 в elist
              e1.next = &m2;         // поместить m2 в elist
              m2.next = &e2;         // поместить m2 в elist
              e2.next = 0;           // конец списка
            }
</pre>
<p>Поскольку управляющий является и служащим, указатель manager*
   можно использовать как employee*. В то же время служащий не
   обязательно является управляющим, и поэтому employee* нельзя
   использовать как manager*.</p>
<p>В общем случае, если класс derived имеет общий базовый класс
   base, то указатель на derived можно без явных преобразований типа
   присваивать переменной, имеющей тип указателя на base. Обратное
   преобразование от указателя на base к указателю на derived может быть
   только явным:</p>
<pre>
       void g()
       {
         manager mm;
         employee* pe = &mm; // нормально

         employee ee;
         manager* pm = &ee;  // ошибка:
                             // не всякий служащий является управляющим

         pm->level = 2;      // катастрофа: при размещении ee
                             // память для члена `level' не выделялась

         pm = (manager*) pe; // нормально: на самом деле pe
                             // не настроено на объект mm типа manager

         pm->level = 2;      // отлично: pm указывает на объект mm
                             // типа manager, а в нем при размещении
                             // выделена память для члена `level'
       }
</pre>
<p>Иными словами, если работа с объектом производного класса идет через
   указатель, то его можно рассматривать как объект базового класса.
   Обратное неверно. Отметим, что в обычной реализации С++ не
   предполагается динамического контроля над тем, чтобы после преобразования
   типа, подобного тому, которое использовалось в присваивании pe в pm,
   получившийся в результате указатель действительно был настроен на объект
   требуемого типа (см. п.<a href="chap13.shtml#dinamic">13.5</a>).</p>

<a name="#func"></a><h5>6.2.1 Функции-члены</h5>
<p>Простые структуры данных вроде employee и manager сами по себе
   не слишком интересны, а часто и не особенно полезны. Поэтому добавим
   к ним функции:</p>
<pre>
         class employee {
           char* name;
           // ...
         public:
           employee* next;  // находится в общей части, чтобы
                            // можно было работать со списком
           void print() const;
           // ...
        };

        class manager : public employee {
           // ...
        public:
           void print() const;
           // ...
        };
</pre>
<p>Надо ответить на некоторые вопросы. Каким образом функция-член
   производного класса manager может использовать члены базового класса
   employee? Какие члены базового класса employee могут использовать
   функции-члены производного класса manager? Какие члены базового
   класса employee может использовать функция, не являющаяся членом объекта
   типа manager? Какие ответы на эти вопросы должна давать реализация
   языка, чтобы они максимально соответствовали задаче программиста?</p>
<p>Рассмотрим пример:</p>
<pre>
        void manager::print() const
        {
           cout << " имя "    << name << '\n';
        }
</pre>
<p>Член производного класса может использовать имя из общей части своего
   базового класса наравне со всеми другими членами, т.е. без указания
   имени объекта. Предполагается, что есть объект, на который настроен
   this, поэтому корректным обращением к name будет this->name. Однако,
   при трансляции функции manager::print() будет зафиксирована ошибка:
   члену производного класса не предоставлено право доступа к частным
   членам его базового класса, значит name недоступно в этой функции.</p>
<p>Возможно многим это покажется странным, но давайте рассмотрим
   альтернативное решение: функция-член производного класса имеет
   доступ к частным членам своего базового класса. Тогда само понятие
   частного (закрытого) члена теряет всякий смысл, поскольку для доступа
   к нему достаточно просто определить производный класс. Теперь уже
   будет недостаточно для выяснения, кто использует частные члены класса,
   просмотреть все функции-члены и друзей этого класса. Придется
   просмотреть все исходные файлы программы, найти производные
   классы, затем исследовать каждую функцию этих классов. Далее надо
   снова искать производные классы от уже найденных и т.д. Это, по крайней
   мере, утомительно, а скорее всего нереально. Нужно всюду, где это
   возможно, использовать вместо частных членов защищенные (см. 
   п.<a href="#protmemb">6.6.1</a>).</p>
<p>Как правило, самое надежное решение для производного класса -
   использовать только общие члены своего базового класса:</p>
<pre>
           void manager::print() const
           {
             employee::print();   // печать данных о служащих

             // печать данных об управляющих
           }
</pre>
<p>Отметим, что операция :: необходима, поскольку функция print()
   переопределена в классе manager. Такое повторное использование имен
   типично для С++. Неосторожный программист написал бы:</p>
<pre>
          void manager::print() const
          {
             print();   // печать данных о служащих

             // печать данных об управляющих
          }
</pre>
<p>В результате он получил бы рекурсивную последовательность вызовов
   manager::print().</p>

<a name="#constr"></a><h5>6.2.2 Конструкторы и деструкторы</h5>
<p>Для некоторых производных классов нужны конструкторы. Если конструктор
   есть в базовом классе, то именно он и должен вызываться с указанием
   параметров, если таковые у него есть:</p>
<pre>
          class employee {
            // ...
          public:
            // ...
            employee(char* n, int d);
         };

         class manager : public employee {
            // ...
         public:
            // ...
           manager(char* n, int i, int d);
         };
</pre>
<p>Параметры для конструктора базового класса задаются в определении
   конструктора производного класса. В этом смысле базовый класс
   выступает как класс, являющийся членом производного класса:</p>
<pre>
         manager::manager(char* n, int l, int d)
            : employee(n,d), level(l), group(0)
         {
         }
</pre>
<p>Конструктор базового класса employee::employee() может иметь такое
   определение:</p>
<pre>
         employee::employee(char* n, int d)
             : name(n), department(d)
         {
           next = list;
           list = this;
         }
</pre>
<p>Здесь list должен быть описан как статический член employee.</p>
<p>Объекты классов создаются снизу вверх: вначале базовые, затем
   члены и, наконец, сами производные классы. Уничтожаются они в
   обратном порядке: сначала сами производные классы, затем члены,
   а затем базовые. Члены и базовые создаются в порядке описания их
   в классе, а уничтожаются они в обратном порядке.</p>

<a name="#hierar"></a><h5>6.2.3 Иерархия классов</h5>
<p>Производный класс сам в свою очередь может быть базовым классом:</p>
<pre>
          class employee { /* ... */ };
          class manager : public employee { /* ... */ };
          class director : public manager { /* ... */ };
</pre>
<p>Такое множество связанных между собой классов обычно называют
   иерархией классов. Обычно она представляется деревом, но бывают
   иерархии с более общей структурой в виде графа:</p>
<pre>
          class temporary { /* ... */ };
          class secretary : public employee { /* ... */ };

         class tsec
           : public temporary, public secretary { /* ... */ };

         class consultant
           : public temporary, public manager { /* ... */ };

</pre>
<p>Видим, что классы в С++ могут образовывать направленный ацикличный
   граф (подробнее об этом говорится в п.<a href="#baseclass">6.5.3</a>). Этот граф для
   приведенных классов имеет вид:</p>

<a name="#field"></a><h5>6.2.4 Поля типа</h5>
<p>Чтобы производные классы были не просто удобной формой краткого
   описания, в реализации языка должен быть решен вопрос: к какому из
   производных классов относится объект, на который смотрит указатель base*?
   Существует три основных способа ответа:</p>
<ol>
<li>Обеспечить, чтобы указатель мог ссылаться на объекты только
         одного типа (п.<a href="#figlib">6.4.2</a>);
<li>Поместить в базовый класс поле типа, которое смогут проверять
         функции;
<li>использовать виртуальные функции (п.<a href="#virt">6.2.5</a>).
</ol>
<p>Указатели на базовые классы обыкновенно используются при проектировании
   контейнерных классов (множество, вектор, список и т.д.). Тогда в
   случае [1] мы получим однородные списки, т.е. списки объектов одного
   типа. Способы [2] и [3] позволяют создавать разнородные списки, т.е.
   списки объектов нескольких различных типов (на самом деле, списки
   указателей на эти объекты). Способ [3] - это специальный надежный в
   смысле типа вариант способа [2]. Особенно интересные и мощные варианты
   дают комбинации способов [1] и [3]; они обсуждаются в главе 
   <a href="chap8.shtml">8</a>.</p>
<p>Вначале обсудим простой способ с полем типа, т.е. способ [2].<br>
   Пример с классами manager/employee можно переопределить так:</p>
<pre>
            struct employee {
               enum empl_type { M, E };
               empl_type type;
               employee* next;
               char*     name;
               short     department;
               // ...
           };

           struct manager : employee {
              employee* group;
              short     level;
              // ...
          };
</pre>
<p>Имея эти определения, можно написать функцию, печатающую данные
   о произвольном служащем:</p>
<pre>
         void print_employee(const employee* e)
         {
            switch (e->type) {
            case E:
              cout << e->name << '\t' << e->department << '\n';
              // ...
              break;
           case M:
             cout << e->name << '\t' << e->department << '\n';
             // ...
             manager* p = (manager*) e;
             cout << "level" << p->level << '\n';
             // ...
             break;
           }
         }
</pre>
<p>Напечатать список служащих можно так:</p>
<pre>
         void f(const employee* elist)
         {
           for (; elist; elist=elist->next) print_employee(elist);
         }
</pre>
<p>Это вполне хорошее решение, особенно для небольших программ,
   написанных одним человеком, но оно имеет существенный недостаток:
   транслятор не может проверить, насколько правильно программист
   обращается с типами. В больших программах это приводит к ошибкам
   двух видов. Первый - когда программист забывает проверить поле
   типа. Второй - когда в переключателе указываются не все возможные
   значения поля типа. Этих ошибок достаточно легко избежать в
   процессе написания программы, но совсем нелегко избежать их при
   внесении изменений в нетривиальную программу, а особенно,
   если это большая программа, написанная кем-то другим. Еще
   труднее избежать таких ошибок потому, что функции типа print() часто
   пишутся так, чтобы можно было воспользоваться общностью классов:</p>
<pre>
               void print(const employee* e)
               {
                 cout << e->name << '\t' << e->department << '\n';
                 // ...
                 if (e->type == M) {
                    manager* p = (manager*) e;
                    cout << "level" << p->level << '\n';
                    // ...
                 }
               }
</pre>
<p>Операторы if, подобные приведенным в примере, сложно найти в большой
   функции, работающей со многими производными классами. Но даже когда они
   найдены, нелегко понять, что происходит на самом деле. Кроме того, при
   всяком добавлении нового вида служащих требуются изменения во всех
   важных функциях программы, т.е. функциях, проверяющих поле типа. В
   результате приходится править важные части программы, увеличивая тем
   самым время на отладку этих частей.</p>
<p>Иными словами,  использование  поля типа чревато ошибками и
   трудностями при сопровождении программы. Трудности резко возрастают
   по мере роста программы, ведь использование поля типа противоречит
   принципам модульности и упрятывания данных. Каждая функция,
   работающая с полем типа, должна знать представление и специфику
   реализации всякого класса, являющегося производным для класса,
   содержащего поле типа.</p>

<a name="#virt"></a><h5>6.2.5 Виртуальные функции</h5>
<p>С помощью виртуальных функций можно преодолеть трудности, возникающие
   при использовании поля типа. В базовом классе описываются функции,
   которые могут переопределяться в любом производном классе. Транслятор
   и загрузчик обеспечат правильное соответствие между объектами и
   применяемыми к ним функциями:</p>
<pre>
           class employee {
             char* name;
             short department;
             // ...
             employee* next;
             static employee* list;
           public:
             employee(char* n, int d);
             // ...
             static void print_list();
             virtual void print() const;

          };
</pre>
<p>Служебное слово virtual (виртуальная) показывает, что функция print()
   может иметь разные версии в разных производных классах, а выбор нужной
   версии при вызове print() - это задача транслятора.
   Тип функции указывается в базовом классе и не может быть
   переопределен в производном классе. Определение виртуальной функции
   должно даваться для того класса, в котором она была впервые
   описана (если только она не является чисто виртуальной функцией,
   см. п.<a href="chap6.shtml#abstr">6.3</a>). Например:</p>
<pre>
            void employee::print() const
            {
               cout << name << '\t' << department << '\n';
               // ...
            }
</pre>
<p>Мы видим, что виртуальную функцию можно использовать, даже если
   нет производных классов от ее класса. В производном же классе
   не обязательно переопределять виртуальную функцию, если она там
   не нужна. При построении производного класса надо определять
   только те функции, которые в нем действительно нужны:</p>
<pre>
             class manager : public employee {
                employee* group;
                short     level;
                // ...
             public:
                manager(char* n, int d);
                // ...
                void print() const;
             };
</pre>
<p>Место функции print_employee() заняли функции-члены print(), и она
   стала не нужна. Список служащих строит конструктор employee 
   (п.<a href="#constr">6.2.2</a>).
   Напечатать его можно так:</p>
<pre>
             void employee::print_list()
             {
               for ( employee* p = list; p; p=p->next) p->print();
             }
</pre>
<p>Данные о каждом служащем будут печататься в соответствии с типом
   записи о нем. Поэтому программа</p>
<pre>
            int main()
            {
               employee e("J.Brown",1234);
               manager m("J.Smith",2,1234);
               employee::print_list();
            }
</pre>
<p>напечатает</p>
<pre>
            J.Smith 1234
                    level 2
            J.Brown 1234
</pre>
<p>Обратите внимание, что функция печати будет работать даже в том случае,
   если функция employee_list() была написана и оттранслирована еще до того,
   как был задуман конкретный производный класс manager! Очевидно, что для
   правильной работы виртуальной функции нужно в каждом объекте класса
   employee хранить некоторую служебную информацию о типе. Как правило,
   реализации в качестве такой информации используют просто указатель.
   Этот указатель хранится только для объектов класса с виртуальными
   функциями, но не для объектов всех классов, и даже для не для всех
   объектов производных классов. Дополнительная память отводится только
   для классов, в которых описаны виртуальные функции. Заметим, что
   при использовании поля типа, для него все равно нужна дополнительная
   память.</p>
<p>Если в вызове функции явно указана операция разрешения
   области видимости ::, например, в вызове manager::print(),
   то механизм вызова виртуальной функции не действует. Иначе подобный
   вызов привел бы к бесконечной рекурсии. Уточнение имени функции
   дает еще один положительный эффект: если виртуальная функция
   является подстановкой (в этом нет ничего необычного), то в вызове
   с операцией :: происходит подстановка тела функции. Это
   эффективный способ вызова, который можно применять
   в важных случаях, когда одна виртуальная функция
   обращается к другой с одним и тем же объектом. Пример такого
   случая - вызов функции manager::print(). Поскольку тип объекта
   явно задается в самом вызове manager::print(), нет нужды определять
   его в динамике для функции employee::print(), которая и будет
   вызываться.</p>

<a name="#abstr"></a><h4>6.3 Абстрактные классы</h4>
<p>Многие классы сходны с классом employee тем, что в них можно дать
   разумное определение виртуальным функциям. Однако, есть и другие
   классы. Некоторые, например, класс shape, представляют
   абстрактное понятие (фигура), для которого нельзя создать объекты.
   Класс shape приобретает смысл только как базовый класс в некотором
   производном классе. Причиной является то, что невозможно дать
   осмысленное определение виртуальных функций класса shape:</p>
<pre>
              class shape {
                 // ...
              public:
                 virtual void rotate(int) { error("shape::rotate"); }
                 virtual void draw()  { error("shape::draw"): }
                 // нельзя ни вращать, ни рисовать абстрактную фигуру
                 // ...
              };
</pre>
<p>Создание объекта типа shape (абстрактной фигуры) законная, хотя
   совершенно бессмысленная операция:</p>
<pre>
             shape s;  // бессмыслица: ``фигура вообще''
</pre>
<p>Она бессмысленна потому, что любая операция с объектом s приведет
   к ошибке.</p>
<p>Лучше виртуальные функции класса shape описать как чисто
   виртуальные. Сделать виртуальную функцию чисто виртуальной можно,
   добавив инициализатор = 0:</p>
<pre>
        class shape {
          // ...
        public:
          virtual void rotate(int) = 0; // чисто виртуальная функция
          virtual void draw() = 0;      // чисто виртуальная функция
        };
</pre>
<p>Класс, в котором есть виртуальные функции, называется абстрактным.
   Объекты такого класса создать нельзя:</p>
<pre>
             shape s;   // ошибка: переменная абстрактного класса shape
</pre>
<p>Абстрактный класс можно использовать только в качестве базового
   для другого класса:</p>
<pre>
             class circle : public shape {
               int radius;
             public:
               void rotate(int) { } // нормально:
                                    // переопределение shape::rotate
               void draw();         // нормально:
                                    // переопределение shape::draw

               circle(point p, int r);
             };
</pre>
<p>Если чисто виртуальная функция не определяется в производном
   классе, то она и остается таковой, а значит производный класс тоже
   является абстрактным. При таком подходе можно реализовывать
   классы поэтапно:</p>
<pre>
             class X {
             public:
               virtual void f() = 0;
               virtual void g() = 0;
             };

             X b;   // ошибка: описание объекта абстрактного класса X

             class Y : public X {
               void f();  // переопределение X::f
             };

             Y b;   // ошибка: описание объекта абстрактного класса Y

             class Z : public Y {
               void g();  // переопределение X::g
             };

             Z c;   // нормально
</pre>
<p>Абстрактные классы нужны для задания интерфейса без уточнения
   каких-либо конкретных деталей реализации. Например, в операционной
   системе детали реализации драйвера устройства можно скрыть
   таким абстрактным классом:</p>
<pre>
             class character_device {
             public:
                virtual int open() = 0;
                virtual int close(const char*) = 0;
                virtual int read(const char*, int) =0;
                virtual int write(const char*, int) = 0;
                virtual int ioctl(int ...) = 0;
                // ...
             };
</pre>
<p>Настоящие драйверы будут определяться как производные от класса
   character_device.</p>
<p>После введения абстрактного класса у нас есть все основные
   средства для того, чтобы написать законченную программу.</p>

<a name="#example"></a><h4>6.4 Пример законченной программы</h4>
<p>Рассмотрим программу рисования геометрических фигур на экране. Она
   естественным образом распадается на три части:</p>
<ol>
<li>монитор экрана: набор функций и структур данных низкого уровня
         для работы с экраном; оперирует только такими понятиями, как
         точки, линии;
<li>библиотека фигур: множество определений фигур общего вида
         (например, прямоугольник, окружность) и стандартные
         функции для работы с ними;
<li>прикладная программа: конкретные определения фигур, относящихся
         к задаче, и работающие с ними функции.
</ol>
<p>Как правило, эти три части программируются разными людьми в разных
   организациях и в разное время, причем они обычно создаются
   в перечисленном порядке. При этом естественно возникают затруднения,
   поскольку, например, у разработчика монитора нет точного представления
   о том, для каких задач в конечном счете он будет использоваться. Наш
   пример будет отражать этот факт. Чтобы пример имел допустимый
   размер, библиотека фигур весьма ограничена, а прикладная
   программа тривиальна. Используется совершенно примитивное
   представление экрана, чтобы даже читатель, на машине
   которого нет графических средств, сумел поработать с этой программой.
   Можно легко заменить монитор экрана на более развитую программу,
   не изменяя при этом библиотеку фигур или прикладную программу.</p>

<a name="#monitor"></a><h5>6.4.1 Монитор экрана</h5>
<p>Вначале было желание написать монитор экрана на С, чтобы еще больше
   подчеркнуть разделение между уровнями реализации. Но это оказалось
   утомительным, и поэтому выбрано компромиссное решение: стиль
   программирования, принятый в С (нет функций-членов, виртуальных
   функций, пользовательских операций и т.д.), но используются
   конструкторы, параметры функций полностью описываются и проверяются
   и т.д. Этот монитор очень напоминает программу на С, которую
   модифицировали, чтобы воспользоваться возможностями С++, но
   полностью переделывать не стали.</p>
<p>Экран представлен как двумерный массив символов и управляется
   функциями put_point() и put_line(). В них для связи с экраном
   используется структура point:</p>
<pre>
           // файл screen.h

           const int XMAX=40;
           const int YMAX=24;

           struct point {
               int x, y;
               point() { }
               point(int a,int b) { x=; y=b; }
           };

           extern void put_point(int a, int b);
           inline void put_point(point p) { put_point(p.x,p.y); }

           extern void put_line(int, int, int, int);
           extern void put_line(point a, point b)
              { put_line(a.x,a.y,b.x,b.y); }

           extern void screen_init();
           extern void screen_destroy();
           extern void screen_refresh();
           extern void screen_clear();

           #include <iostream.h>
</pre>
<p>До вызова функций, выдающих изображение на экран (put_...), необходимо
   обратиться к функции инициализации экрана screen_init(). Изменения
   в структуре данных, описывающей экран, станут видимы на нем
   только после вызова функции обновления экрана screen_refresh().
   Читатель может убедиться, что обновление экрана происходит
   просто с помощью копирования новых значений в массив, представляющий
   экран. Приведем функции и определения данных для управления
   экраном:</p>
<pre>
           #include "screen.h"
           #include <stream.h>

           enum color { black='*', white=' ' };

           char screen[XMAX] [YMAX];

           void screen_init()
           {
             for (int y=0; y&lt;YMAX; y++)
                 for (int x=0; x&lt;XMAX; x++)
                     screen[x] [y] = white;
           }
</pre>
<p>Функция</p>
<pre>
           void screen_destroy() { }
</pre>
<p>приведена просто для полноты картины. В реальных системах обычно
   нужны подобные функции уничтожения объекта.</p>
<p>Точки записываются, только если они попадают на экран:</p>
<pre>
          inline int on_screen(int a, int b)  // проверка попадания
          {
             return 0&lt;=a && a &lt;XMAX && 0&lt;=b && b&lt;YMAX;
          }

          void put_point(int a, int b)
          {
             if (on_screen(a,b)) screen[a] [b] = black;
          }
</pre>
<p>Для рисования прямых линий используется функция put_line():</p>
<pre>
          void put_line(int x0, int y0, int x1, int y1)
          /*
             Нарисовать отрезок прямой (x0,y0) - (x1,y1).
             Уравнение прямой: b(x-x0) + a(y-y0) = 0.
             Минимизируется величина abs(eps),
             где eps = 2*(b(x-x0)) + a(y-y0).
             См. Newman, Sproull
             ``Principles of interactive Computer Graphics''
             McGraw-Hill, New York, 1979. pp. 33-34.
           */
           {
             register int dx = 1;
             int a = x1 - x0;
             if (a &lt; 0) dx = -1, a = -a;

             register int dy = 1;
             int b = y1 - y0;
             if (b &lt; 0) dy = -1, b = -b;

             int two_a = 2*a;
             int two_b = 2*b;
             int xcrit = -b + two_a;
             register int eps = 0;

             for (;;) {
               put_point(x0,y0);
               if (x0==x1 && y0==y1) break;
               if (eps &lt;= xcrit) x0 +=dx, eps +=two_b;
               if (eps>=a || a&lt;b) y0 +=dy, eps -=two_a;
             }
           }
</pre>
<p>Имеются функции для очистки и обновления экрана:</p>
<pre>
      void screen_clear() { screen_init(); }

      void screen_refresh()
      {
       for (int y=YMAX-1; 0&lt;=y; y--) { // с верхней строки до нижней
          for (int x=0; x&lt;XMAX; x++)   // от левого столбца до правого
              cout << screen[x] [y];
          cout << '\n';
       }
     }
</pre>
<p>Но нужно понимать, что все эти определения хранятся в некоторой
   библиотеке как результат работы транслятора, и изменить их нельзя.</p>

<a name="#figlib"></a><h5>6.4.2 Библиотека фигур</h5>
<p>Начнем с определения общего понятия фигуры. Определение должно
   быть таким, чтобы им можно было воспользоваться (как базовым классом
   shape) в разных классах, представляющих все конкретные фигуры
   (окружности, квадраты и т.д.). Оно также должно позволять работать
   со всякой фигурой исключительно с помощью интерфейса, определяемого
   классом shape:</p>
<pre>
          struct shape {
             static shape* list;
             shape* next;

             shape() { next = list; list = this; }

             virtual point north() const = 0;
             virtual point south() const = 0;
             virtual point east() const = 0;
             virtual point west() const = 0;
             virtual point neast() const = 0;
             virtual point seast() const = 0;
             virtual point nwest() const = 0;
             virtual point swest() const = 0;

             virtual void draw() = 0;
             virtual void move(int, int) = 0;
           };
</pre>
<p>Фигуры помещаются на экран функцией draw(), а движутся по нему
   с помощью move(). Фигуры можно помещать относительно друг друга,
   используя понятие точек контакта. Для обозначения точек контакта
   используются названия сторон света в компасе: north - север, ... ,
   neast - северо-восток, ... , swest - юго-запад. Класс каждой
   конкретной фигуры сам определяет смысл этих точек и определяет,
   как рисовать фигуру. Конструктор shape::shape() добавляет
   фигуру к списку фигур shape::list. Для построения этого списка
   используется член next, входящий в каждый объект shape. Поскольку
   нет смысла в объектах типа общей фигуры, класс shape определен как
   абстрактный класс.</p>
<p>Для задания отрезка прямой нужно указать две точки или точку
   и целое. В последнем случае отрезок будет горизонтальным, а целое
   задает его длину. Знак целого показывает, где должна находиться заданная
   точка относительно конечной точки, т.е. слева или справа от нее:</p>
<pre>
            class line : public shape {
            /*
              отрезок прямой ["w", "e" ]
              north() определяет точку - `` выше центра отрезка и
              так далеко на север, как самая его северная точка''
            */
              point w, e;
           public:
              point north() const
                { return point((w.x+e.x)/2,e.y&lt;w.y?w.y:e:y); }
              point south() const
                { return point((w.x+e.x)/2,e.y&lt;w.y?e.y:w.y); }
              point east() const;
              point west() const;
              point neast() const;
              point seast() const;
              point nwest() const;
              point swest() const;

              void move(int a, int b)
                 { w.x +=a; w.y +=b; e.x +=a; e.y +=b; }
              void draw() { put_line(w,e); }

              line(point a, point b) { w = a; e = b; }
              line(point a, int l) { w = point(a.x+l-1,a.y); e = a; }
           };
</pre>
<p>Аналогично определяется прямоугольник:</p>
<pre>
           class rectangle : public shape {
           /*   nw ------ n ----- ne
                |                  |
                |                  |
                w         c        e
                |                  |
                |                  |
                sw ------ s ----- se
           */
              point sw, ne;
           public:
              point north() const { return point((sw.x+ne.x)/2,ne.y); }
              point south() const { return point((sw.x+ne.x)/2,sw.y); }
              point east() const;
              point west() const;
              point neast() const { return ne; }
              point seast() const;
              point nwest() const;
              point swest() const { return sw; }

              void move(int a, int b)
              { sw.x+=a; sw.y+=b; ne.x+=a; ne.y+=b; }
              void draw();

              rectangle(point,point);
            };
</pre>
<p>Прямоугольник строится по двум точкам. Конструктор усложняется, так
   как необходимо выяснять относительное положение этих точек:</p>
<pre>
            rectangle::rectangle(point a, point b)
            {
              if (a.x <= b.x) {
                 if (a.y <= b.y) {
                    sw = a;
                    ne = b;
                 }
                 else {
                    sw = point(a.x,b.y);
                    ne = point(b.x,a.y);
                 }
               }
               else {
                 if (a.y <= b.y) {
                    sw = point(b.x,a.y);
                    ne = point(a.x,b.y);
                 }
                 else {
                    sw = b;
                    ne = a;
                 }
               }
             }
</pre>
<p>Чтобы нарисовать прямоугольник, надо нарисовать четыре отрезка:</p>
<pre>
             void rectangle::draw()
             {
               point nw(sw.x,ne.y);
               point se(ne.x,sw.y);
               put_line(nw,ne);
               put_line(ne,se);
               put_line(se,sw);
               put_line(sw,nw);
             }
</pre>
<p>В библиотеке фигур есть определения фигур и функции для работы
   с ними:</p>
<pre>
            void shape_refresh();      // нарисовать все фигуры
            void stack(shape* p, const shape* q); // поместить p над q
</pre>
<p>Функция обновления фигур нужна, чтобы работать с нашим примитивным
   представлением экрана; она просто заново рисует все фигуры. Отметим,
   что эта функция не имеет понятия, какие фигуры она рисует:</p>
<pre>
            void shape_refresh()
            {
              screen_clear();
              for (shape* p = shape::list; p; p=p->next) p->draw();
              screen_refresh();
            }
</pre>
<p>Наконец, есть одна действительно сервисная функция, которая рисует
   одну фигуру над другой. Для этого она определяет юг (south()) одной
   фигуры как раз над севером (north()) другой:</p>
<pre>
            void stack(shape* p, const shape* q) // поместить p над q
            {
              point n = q->north();
              point s = p->south();
              p->move(n.x-s.x,n.y-s.y+1);
            }
</pre>
<p>Представим теперь, что эта библиотека является собственностью
   некоторой фирмы, продающей программы, и, что она продает только
   заголовочный файл с определениями фигур и оттранслированные
   определения функций. Все равно вы сможете определить новые фигуры,
   воспользовавшись для этого купленными вами функциями.</p>

<a name="#applic"></a><h5>6.4.3 Прикладная программа</h5>
<p>Прикладная программа предельно проста. Определяется новая фигура
   myshape (если ее нарисовать, то она напоминает лицо), а затем
   приводится функция main(), в которой она рисуется со шляпой. Вначале
   дадим описание фигуры myshape:</p>
<pre>
             #include "shape.h"

             class myshape : public rectangle {
               line* l_eye;   // левый глаз
               line* r_eye;   // правый глаз
               line* mouth;   // рот
             public:
               myshape(point, point);
               void draw();
               void move(int, int);
             };
</pre>
<p>Глаза и рот являются отдельными независимыми объектами которые
   создает конструктор класса myshape:</p>
<pre>
             myshape::myshape(point a, point b) : rectangle(a,b)
             {
               int ll = neast().x-swest().x+1;
               int hh = neast().y-swest().y+1;
               l_eye = new line(
                   point(swest().x+2,swest().y+hh*3/4),2);
               r_eye = new line(
                   point(swest().x+ll-4,swest().y+hh*3/4),2);
               mouth = new line(
                   point(swest().x+2,swest().y+hh/4),ll-4);
             }
</pre>
<p>Объекты, представляющие глаза и рот, выдаются функцией shape_refresh()
   по отдельности. В принципе с ними можно работать независимо от
   объекта my_shape, к которому они принадлежат. Это один из способов
   задания черт лица для строящегося иерархически объекта myshape.
   Как это можно сделать иначе, видно из задания носа. Никакой тип "нос"
   не определяется, он просто дорисовывается в функции draw():</p>
<pre>
             void myshape::draw()
             {
               rectangle::draw();
               int a = (swest().x+neast().x)/2;
               int b = (swest().y+neast().y)/2;
               put_point(point(a,b));
             }
</pre>
<p>Движение фигуры myshape сводится к движению объекта базового класса
   rectangle и к движению вторичных объектов (l_eye, r_eye и mouth):</p>
<pre>
             void myshape::move(int a, int b)
             {
               rectangle::move(a,b);
               l_eye->move(a,b);
               r_eye->move(a,b);
               mouth->move(a,b);
             }
</pre>
<p>Наконец, определим несколько фигур и будем их двигать:</p>
<pre>
             int main()
             {
               screen_init();
               shape* p1 = new rectangle(point(0,0),point(10,10));
               shape* p2 = new line(point(0,15),17);
               shape* p3 = new myshape(point(15,10),point(27,18));
               shape_refresh();
               p3->move(-10,-10);
               stack(p2,p3);
               stack(p1,p2);
               shape_refresh();
               screen_destroy();
               return 0;
             }
</pre>
<p>Вновь обратим внимание на то, что функции, подобные shape_refresh()
   и stack(), работают с объектами, типы которых были определены
   заведомо после определения этих функций (и, вероятно, после
   их трансляции).</p>
<p>Вот получившееся лицо со шляпой:</p>
<pre>
             ***********
             *         *
             *         *
             *         *
             *         *
             *         *
             *         *
             *         *
             ***********
          *****************
             ***********
             *         *
             * **   ** *
             *         *
             *    *    *
             *         *
             * ******* *
             *         *
             ***********
</pre>
<p>Для упрощения примера копирование и удаление фигур не обсуждалось.</p>

<a name="#multinher"></a><h4>6.5 Множественное наследование</h4>
<p>В п.<a href="chap1.shtml#multinher">1.5.3</a> и п.<a href="#hierar">6.2.3</a> уже говорилось, что у класса может быть несколько
   прямых базовых классов. Это значит, что в описании класса после :
   может быть указано более одного класса. Рассмотрим задачу моделирования,
   в которой параллельные действия представлены стандартной библиотекой
   классов task, а сбор и выдачу информации обеспечивает библиотечный
   класс displayed. Тогда класс моделируемых объектов (назовем его
   satellite) можно определить так:</p>
<pre>
            class satellite : public task, public displayed {
               // ...
            };
</pre>
<p>Такое определение обычно называется множественным наследованием.
   Обратно, существование только одного прямого базового класса называется
   единственным наследованием.</p>
<p>Ко всем определенным в классе satellite операциям добавляется
   объединение операций классов task и displayed:</p>
<pre>
           void f(satellite& s)
           {
             s.draw();    // displayed::draw()
             s.delay(10); // task::delay()
             s.xmit();    // satellite::xmit()
           }
</pre>
<p>С другой стороны, объект типа satellite можно передавать функциям с
   параметром типа task или displayed:</p>
<pre>
           void highlight(displayed*);
           void suspend(task*);

           void g(satellite* p)
           {
             highlight(p);   // highlight((displayed*)p)
             suspend(p);     // suspend((task*)p);
           }
</pre>
<p>Очевидно, реализация этой возможности требует некоторого (простого)
   трюка от транслятора: нужно функциям с параметрами task и
   displayed передать разные части объекта типа satellite.</p>
<p>Для виртуальных функций, естественно, вызов и так выполнится
   правильно:</p>
<pre>
           class task {
              // ...
              virtual pending() = 0;
           };

           class displayed {
              // ...
              virtual void draw() = 0;
           };

           class satellite : public task, public displayed {
              // ...
              void pending();
              void draw();
           };
</pre>
<p>Здесь функции satellite::draw() и satellite::pending() для объекта
   типа satellite будут вызываться так же, как если бы он был объектом типа
   displayed или task, соответственно.</p>
<p>Отметим, что ориентация только на единственное наследование
   ограничивает возможности реализации классов displayed, task и
   satellite. В таком случае класс satellite мог бы быть task или
   displayed, но не то и другое вместе (если, конечно, task не является
   производным от displayed или наоборот). В любом случае теряется
   гибкость.</p>

<a name="#multentry"></a><h5>6.5.1 Множественное вхождение базового класса</h5>
<p>Возможность иметь более одного базового класса влечет за собой
   возможность неоднократного вхождения класса как базового. Допустим,
   классы task и displayed являются производными класса link, тогда
   в satellite он будет входить дважды:</p>
<pre>
            class task : public link {
               // link используется для связывания всех
               // задач в список (список диспетчера)

               // ...
            };

            class displayed : public link {
               // link используется для связывания всех
               // изображаемых объектов (список изображений)

               // ...
            };
</pre>
<p>Но проблем не возникает. Два различных объекта link используются
   для различных списков, и эти списки не конфликтуют друг с другом.
   Конечно, без риска неоднозначности нельзя обращаться к членам класса
   link, но как это сделать корректно, показано в следующем разделе.
   Графически объект satellite можно представить так:</p>
<p>Но можно привести примеры, когда общий базовый класс не должен
   представляться двумя различными объектами (см. п.<a href="#baseclass">6.5.3</a>).</p>

<a name="#sanct"></a><h5>6.5.2 Разрешение неоднозначности</h5>
<p>Естественно, у двух базовых классов могут быть функции-члены
   с одинаковыми именами:</p>
<pre>
            class task {
               // ...
               virtual debug_info* get_debug();
            };

            class displayed {
               // ...
               virtual debug_info* get_debug();
            };
</pre>
<p>При использовании класса satellite подобная неоднозначность функций
   должна быть разрешена:</p>
<pre>
       void f(satellite* sp)
       {
        debug_info* dip = sp->get_debug(); //ошибка: неоднозначность
        dip = sp->task::get_debug();       // нормально
        dip = sp->displayed::get_debug();  // нормально
       }
</pre>
<p>Однако, явное разрешение неоднозначности хлопотно, поэтому
   для ее устранения лучше всего определить новую функцию в
   производном классе:</p>

<pre>            class satellite : public task, public derived {
               // ...
               debug_info* get_debug()
               {
                 debug_info* dip1 = task:get_debug();
                 debug_info* dip2 = displayed::get_debug();
                 return dip1->merge(dip2);
               }
            };
</pre>
<p>Тем самым локализуется информация из базовых для satellite классов.
   Поскольку satellite::get_debug() является переопределением функций
   get_debug() из обоих базовых классов, гарантируется, что именно она
   будет вызываться при всяком обращении к get_debug() для объекта
   типа satellite.</p>
<p>Транслятор выявляет коллизии имен, возникающие при определении
   одного и того же имени в более, чем одном базовом классе. Поэтому
   программисту не надо указывать какое именно имя используется, кроме
   случая, когда его использование действительно неоднозначно. Как правило
   использование базовых классов не приводит к коллизии имен. В большинстве
   случаев, даже если имена совпадают, коллизия не возникает, поскольку
   имена не используются непосредственно для объектов производного класса.</p>
<p>Аналогичная проблема, когда в двух классах есть функции с одним
   именем, но разным назначением, обсуждается в п.<a href="chap13.shtml#infclass">13.8</a> на примере
   функции draw() для классов Window и Cowboy.</p>
<p>Если неоднозначности не возникает, излишне указывать имя
   базового класса при явном обращении к его члену. В частности, если
   множественное наследование не используется, вполне достаточно
   использовать обозначение типа "где-то в базовом классе". Это
   позволяет программисту не запоминать имя прямого базового класса и
   спасает его от ошибок (впрочем, редких), возникающих при перестройке
   иерархии классов. Например, в функции из п.<a href="#virt">6.2.5</a></p>
<pre>
           void manager::print()
           {
             employee::print();
             // ...
           }
</pre>
<p>предполагается, что employee - прямой базовый класс для manager.
   Результат этой функции не изменится, если employee окажется косвенным
   базовым классом для manager, а в прямом базовом классе функции
   print() нет. Однако, кто-то мог бы следующим образом перестроить
   классы:</p>
<pre>
           class employee {
             // ...
             virtual void print();
           };

           class foreman : public employee {
             // ...
             void print();
           };

           class manager : public foreman {
             // ...
             void print();
           };
</pre>
<p>Теперь функция foreman::print() не будет вызываться, хотя почти
   наверняка предполагался вызов именно этой функции. С помощью
   небольшой хитрости можно преодолеть эту трудность:</p>
<pre>
           class foreman : public employee {
             typedef employee inherited;
             // ...
             void print();
           };

           class manager : public foreman {
             typedef foreman inherited;
             // ...
             void print();
           };

           void manager::print()
           {
             inherited::print();
             // ...
           }
</pre>
<p>Правила областей видимости, в частности те, которые относятся к
   вложенным типам, гарантируют, что возникшие несколько типов
   inherited не будут конфликтовать друг с другом. В общем-то дело
   вкуса, считать решение с типом inherited наглядным или нет.</p>

<a name="#baseclass"></a><h5>6.5.3 Виртуальные базовые классы</h5>
<p>В предыдущих разделах множественное наследование рассматривалось
   как существенный фактор, позволяющий за счет слияния классов
   безболезненно интегрировать независимо создававшиеся программы.
   Это самое основное применение множественного наследования, и,
   к счастью (но не случайно), это самый простой и надежный способ
   его применения.</p>
<p>Иногда применение множественного наследования предполагает
   достаточно тесную связь между классами, которые рассматриваются
   как "братские" базовые классы. Такие классы-братья обычно должны
   проектироваться совместно. В большинстве случаев для этого не
   требуется особый стиль программирования, существенно отличающийся
   от того, который мы только что рассматривали. Просто на производный
   класс возлагается некоторая дополнительная работа. Обычно она
   сводится к переопределению одной или нескольких виртуальных
   функций (см. п.<a href="chap13.shtml#concret">13.2</a> и 
   п.<a href="chap8.shtml#templat">8.7</a>). В некоторых случаях классы-братья
   должны иметь общую информацию. Поскольку С++ - язык со строгим контролем
   типов, общность информации возможна только при явном указании того,
   что является общим в этих классах. Способом такого указания может
   служить виртуальный базовый класс.</p>
<p>Виртуальный базовый класс можно использовать для представления
   "головного" класса, который может конкретизироваться разными
   способами:</p>
<pre>
           class window {
             // головная информация
             virtual void draw();
           };
</pre>
<p>Для простоты рассмотрим только один вид общей информации из класса
   window - функцию draw(). Можно определять разные более развитые
   классы, представляющие окна (window). В каждом определяется своя
   (более развитая) функция рисования (draw):</p>
<pre>
            class window_w_border : public virtual window {
               // класс "окно с рамкой"
               // определения, связанные с рамкой
               void draw();
            };

            class window_w_menu : public virtual window {
               // класс "окно с меню"
               // определения, связанные с меню
               void draw();
            };
</pre>
<p>Теперь хотелось бы определить окно с рамкой и меню:</p>
<pre>
            class window_w_border_and_menu
                  : public virtual window,
                  public window_w_border,
                  public window_w_menu {
                  // класс "окно с рамкой и меню"
                  void draw();
            };
</pre>
<p>Каждый производный класс добавляет новые свойства окна. Чтобы
   воспользоваться комбинацией всех этих свойств, мы должны
   гарантировать, что один и тот же объект класса window используется
   для представления вхождений базового класса window в эти
   производные классы. Именно это обеспечивает описание window во
   всех производных классах как виртуального базового класса.</p>
<p>Можно следующим образом изобразить состав объекта класса
   window_w_border_and_menu:</p>
<p>Чтобы увидеть разницу между обычным и виртуальным наследованием,
   сравните этот рисунок с рисунком из п.<a href="#multinher">6.5</a>, показывающим состав объекта
   класса satellite. В графе наследования каждый базовый класс с данным
   именем, который был указан как виртуальный, будет представлен
   единственным объектом этого класса. Напротив, каждый базовый
   класс, который при описании наследования не был указан как
   виртуальный, будет представлен своим собственным объектом.</p>
<p>Теперь надо написать все эти функции draw(). Это не слишком
   трудно, но для неосторожного программиста здесь есть ловушка.</p>
<p>Сначала пойдем самым простым путем, который как раз к ней и ведет:</p>
<pre>
              void window_w_border::draw()
              {
                 window::draw();
                 // рисуем рамку
              }

              void window_w_menu::draw()
              {
                window::draw();
                // рисуем меню
              }
</pre>
<p>Пока все хорошо. Все это очевидно, и мы следуем образцу определения
   таких функций при условии единственного наследования (п.<a href="#func">6.2.1</a>), который
   работал прекрасно. Однако, в производном классе следующего уровня
   появляется ловушка:</p>
<pre>
             void window_w_border_and_menu::draw() // ловушка!
             {
                window_w_border::draw();
                window_w_menu::draw();

                // теперь операции, относящиеся только
                // к окну с рамкой и меню
              }
</pre>
<p>На первый взгляд все вполне нормально. Как обычно, сначала выполняются
   все операции, необходимые для базовых классов, а затем те, которые
   относятся собственно к производным классам. Но в результате
   функция window::draw() будет вызываться дважды! Для большинства
   графических программ это не просто излишний вызов, а порча
   картинки на экране. Обычно вторая выдача на экран затирает первую.</p>
<p>Чтобы избежать ловушки, надо действовать не так поспешно. Мы
   отделим действия, выполняемые базовым классом, от действий,
   выполняемых из базового класса. Для этого в каждом классе введем
   функцию _draw(), которая выполняет нужные только для него
   действия, а функция draw() будет выполнять те же действия плюс
   действия, нужные для каждого базового класса. Для класса window
   изменения сводятся к введению излишней функции:</p>
<pre>
            class window {
             // головная информация
             void _draw();
             void draw();
            };
</pre>
<p>Для производных классов эффект тот же:</p>
<pre>
             class window_w_border : public virtual window {
                // класс "окно с рамкой"
                // определения, связанные с рамкой
                void _draw();
                void draw();
             };

             void window_w_border::draw()
             {
                window::_draw();
                _draw();   // рисует рамку
             };
</pre>
<p>Только для производного класса следующего уровня проявляется
   отличие функции, которое и позволяет обойти ловушку с повторным
   вызовом window::draw(), поскольку теперь вызывается window::_draw()
   и только один раз:</p>
<pre>
             class window_w_border_and_menu
                 : public virtual window,
                 public window_w_border,
                 public window_w_menu {

                 void _draw();
                 void draw();
             };

             void window_w_border_and_menu::draw()
             {
               window::_draw();
               window_w_border::_draw();
               window_w_menu::_draw();

               _draw();  // теперь операции, относящиеся только
                         // к окну с рамкой и меню
             }
</pre>
<p>Не обязательно иметь обе функции window::draw() и window::_draw(),
   но наличие их позволяет избежать различных простых описок.</p>
<p>В этом примере класс window служит хранилищем общей для
   window_w_border и window_w_menu информации и определяет интерфейс
   для общения этих двух классов. Если используется единственное
   наследование, то общность информации в дереве классов достигается
   тем, что эта информация передвигается к корню дерева до тех
   пор, пока она не станет доступна всем заинтересованным в ней
   узловым классам. В результате легко возникает неприятный эффект:
   корень дерева или близкие к нему классы используются как пространство
   глобальных имен для всех классов дерева, а иерархия классов вырождается
   в множество несвязанных объектов.</p>
<p>Существенно, чтобы в каждом из классов-братьев переопределялись
   функции, определенные в общем виртуальном базовом классе. Таким
   образом каждый из братьев может получить свой вариант операций,
   отличный от других. Пусть в классе window есть общая функция
   ввода get_input():</p>
<pre>
             class window {
              // головная информация
              virtual void draw();
              virtual void get_input();
            };
</pre>
<p>В одном из производных классов можно использовать эту функцию,
   не задумываясь о том, где она определена:</p>
<pre>
            class window_w_banner : public virtual window {
               // класс "окно с заголовком"
               void draw();
               void update_banner_text();
            };

            void window_w_banner::update_banner_text()
            {
              // ...
              get_input();
              // изменить текст заголовка
            }
</pre>
<p>В другом производном классе функцию get_input() можно определять,
   не задумываясь о том, кто ее будет использовать:</p>
<pre>
            class window_w_menu : public virtual window {
               // класс "окно с меню"
               // определения, связанные с меню
               void draw();
               void get_input(); // переопределяет window::get_input()
            };
</pre>
<p>Все эти определения собираются вместе в производном классе следующего
   уровня:</p>
<pre>
            class window_w_banner_and_menu
               : public virtual window,
               public window_w_banner,
               public window_w_menu
            {
               void draw();
            };
</pre>
<p>Контроль неоднозначности позволяет убедиться, что в классах-братьях
   определены разные функции:</p>
<pre>
            class window_w_input : public virtual window {
               // ...
               void draw();
               void get_input();  // переопределяет window::get_input
            };

            class window_w_input_and_menu
               : public virtual window,
               public window_w_input,
               public window_w_menu
           {             // ошибка: оба класса window_w_input и
                         // window_w_menu переопределяют функцию
                         // window::get_input
              void draw();
           };
</pre>
<p>Транслятор обнаруживает подобную ошибку, а устранить неоднозначность
   можно обычным способом: ввести в классы window_w_input и
   window_w_menu функцию, переопределяющую "функцию-нарушителя", и
   каким-то образом устранить неоднозначность:</p>
<pre>
           class window_w_input_and_menu
             : public virtual window,
             public window_w_input,
             public window_w_menu
          {
             void draw();
             void get_input();
          };
</pre>
<p>В этом классе window_w_input_and_menu::get_input() будет
   переопределять все функции get_input(). Подробно механизм разрешения
   неоднозначности описан в п.<a href="referenc.shtml#R.10.1.1">R.10.1.1</a>.</p>

<a name="#contrl"></a><h4>6.6 Контроль доступа</h4>
<p>Член класса может быть частным (private), защищенным (protected)
   или общим (public):</p>
<ul>
<li>       Частный член класса X могут использовать только функции-члены и
       друзья класса X.
<li>       Защищенный член класса X могут использовать только функции-члены
       и друзья класса X, а так же функции-члены и друзья всех
       производных от X классов (см. п.<a href="chap5.shtml#friend">5.4.1</a>).
<li>       Общий член можно использовать в любой функции.
</ul>
<p>Эти правила соответствуют делению обращающихся к классу функций на три
   вида: функции, реализующие класс (его друзья и члены), функции,
   реализующие производный класс (друзья и члены производного класса) и
   все остальные функции.</p>
<p>Контроль доступа применяется единообразно ко всем именам. На
   контроль доступа не влияет, какую именно сущность обозначает имя.
   Это означает, что частными могут быть функции-члены, константы и т.д.
   наравне с частными членами, представляющими данные:</p>
<pre>
               class X {
               private:
                 enum { A, B };
                 void f(int);
                 int a;
               };

               void X::f(int i)
               {
                 if (i&lt;A) f(i+B);
                 a++;
               }

               void g(X& x)
               {
                 int i = X::A;     // ошибка: X::A частный член
                 x.f(2);           // ошибка: X::f частный член
                 x.a++;            // ошибка: X::a частный член
               }
</pre>
<a name="#protmemb"></a><h5>6.6.1 Защищенные члены</h5>
<p>Дадим пример защищенных членов, вернувшись к классу window из
   предыдущего раздела. Здесь функции _draw() предназначались только для
   использования в производных классах, поскольку предоставляли неполный
   набор возможностей, а поэтому не были достаточны удобны и
   надежны для общего применения. Они были как бы строительным
   материалом для более развитых функций. С другой стороны, функции draw()
   предназначались для общего применения. Это различие можно выразить,
   разбив интерфейсы классов window на две части - защищенный интерфейс
   и общий интерфейс:</p>
<pre>
              class window {
              public:
                virtual void draw();
                // ...
              protected:
                void _draw();
                // другие функции, служащие строительным материалом
              private:
                // представление класса
              };
</pre>
<p>Такое разбиение можно проводить и в производных классах, таких, как
   window_w_border или window_w_menu.</p>
<p>Префикс _ используется в именах защищенных функций, являющихся
   частью реализации класса, по общему правилу: имена, начинающиеся с _ ,
   не должны присутствовать в частях программы, открытых для общего
   использования. Имен, начинающихся с двойного символа подчеркивания,
   лучше вообще избегать (даже для членов).</p>
<p>Вот менее практичный, но более подробный пример:</p>
<pre>
              class X {
              // по умолчанию частная часть класса
                 int priv;
              protected:
                 int prot;
              public:
                 int publ;
                 void m();
              };
</pre>
<p>Для члена X::m доступ к членам класса неограничен:</p>
<pre>
              void X::m()
              {
                priv = 1;   // нормально
                prot = 2;   // нормально
                publ = 3;   // нормально
              }
</pre>
<p>Член производного класса имеет доступ только к общим и защищенным
   членам:</p>
<pre>
              class Y : public X {
                 void mderived();
              };

              Y::mderived()
              {
                priv = 1;    // ошибка: priv частный член
                prot = 2;    // нормально: prot защищенный член, а
                             // mderived() член производного класса Y
                publ = 3;    // нормально: publ общий член
              }
</pre>
<p>В глобальной функции доступны только общие члены:</p>
<pre>
              void f(Y* p)
              {
                p->priv = 1;  // ошибка: priv частный член
                p->prot = 2;  // ошибка: prot защищенный член, а f()
                              // не друг или член классов X и Y
                p->publ = 3;  // нормально: publ общий член
              }
</pre>

<a name="#accsess"></a><h5>6.6.2 Доступ к базовым классам</h5>
<p>Подобно члену базовый класс можно описать как частный, защищенный
   или общий:</p>
<pre>
              class X {
              public:
                int a;
                // ...
              };

              class Y1 : public X {  };
              class Y2 : protected X { };
              class Y3 : private X { };
</pre>
<p>Поскольку X - общий базовый класс для Y1, в любой функции, если есть
   необходимость, можно (неявно) преобразовать Y1* в X*, и притом
   в ней будут доступны общие члены класса X:</p>
<pre>
          void f(Y1* py1, Y2* py2, Y3* py3)
          {
            X* px = py1;  // нормально: X - общий базовый класс Y1
            py1->a = 7;   // нормально
            px = py2;     // ошибка: X - защищенный базовый класс Y2
            py2->a = 7;   // ошибка
            px = py3;     // ошибка: X - частный базовый класс Y3
            py3->a = 7;   // ошибка
          }
</pre>
<p>Теперь пусть описаны</p>
<pre>
          class Y2 : protected X { };
          class Z2 : public Y2 { void f(); };
</pre>
<p>Поскольку X - защищенный базовый класс Y2, только друзья и члены Y2,
   а также друзья и члены любых производных от Y2 классов (в частности
   Z2) могут при необходимости преобразовывать (неявно) Y2* в X*.<br>
   Кроме того они могут обращаться к общим и защищенным членам класса X:</p>
<pre>
          void Z2::f(Y1* py1, Y2* py2, Y3* py3)
          {
            X* px = py1; // нормально: X - общий базовый класс Y1
            py1->a = 7; // нормально
            px = py2;   // нормально: X - защищенный базовый класс Y2,
                        // а Z2 - производный класс Y2
            py2->a = 7; // нормально
            px = py3;   // ошибка: X - частный базовый класс Y3
            py3->a = 7; // ошибка
          }
</pre>
<p>Наконец, рассмотрим:</p>
<pre>
          class Y3 : private X { void f(); };
</pre>
<p>Поскольку X - частный базовый класс Y3, только друзья и члены Y3
   могут при необходимости преобразовывать (неявно) Y3* в X*.
   Кроме того они могут обращаться к общим и защищенным членам
   класса X:</p>
<pre>
          void Y3::f(Y1* py1, Y2* py2, Y3* py3)
          {
            X* px = py1;  // нормально: X - общий базовый класс Y1
            py1->a = 7;   // нормально
            px = py2;     // ошибка: X - защищенный базовый класс Y2
            py2->a = 7;   // ошибка
            px = py3;     // нормально: X - частный базовый класс Y3,
                          // а Y3::f член Y3
            py3->a = 7;   // нормально
          }
</pre>

<a name="#freemem"></a><h4>6.7 Свободная память</h4>
<p>Если определить функции operator new() и operator delete(),
   управление памятью для класса можно взять в свои руки. Это также можно,
   (а часто и более полезно), сделать для класса, служащего базовым
   для многих производных классов. Допустим, нам потребовались свои
   функции размещения и освобождения памяти для класса employee 
   (п.<a href="#virt">6.2.5</a>)
   и всех его производных классов:</p>
<pre>
              class employee {
                // ...
              public:
                void* operator new(size_t);
                void operator delete(void*, size_t);
              };

              void* employee::operator new(size_t s)
              {
                // отвести память в `s' байтов
                // и возвратить указатель на нее
              }

              void employee::operator delete(void* p, size_t s)
              {
                // `p' должно указывать на память в `s' байтов,
                // отведенную функцией employee::operator new();
                // освободить эту память для повторного использования
              }
</pre>
<p>Назначение до сей поры загадочного параметра типа size_t становится
   очевидным. Это - размер освобождаемого объекта. При удалении простого
   служащего этот параметр получает значение sizeof(employee), а при
   удалении управляющего - sizeof(manager). Поэтому собственные
   функции классы для размещения могут не хранить размер каждого
   размещаемого объекта. Конечно, они могут хранить эти размеры (подобно
   функциям размещения общего назначения) и игнорировать параметр
   size_t в вызове operator delete(), но тогда вряд ли они будут лучше,
   чем функции размещения и освобождения общего назначения.</p>
<p>Как транслятор определяет нужный размер, который надо передать
   функции operator delete()? Пока тип, указанный в operator delete(),
   соответствует истинному типу объекта, все просто; но рассмотрим
   такой пример:</p>
<pre>
              class manager : public employee {
                int level;
                // ...
              };

              void f()
              {
                employee* p = new manager; // проблема
                delete p;
              }
</pre>
<p>В этом случае транслятор не сможет правильно определить размер. Как
   и в случае удаления массива, нужна помощь программиста. Он должен
   определить виртуальный деструктор в базовом классе employee:</p>
<pre>
              class employee {
                // ...
              public:
                // ...
                void* operator new(size_t);
                void operator delete(void*, size_t);
                virtual ~employee();
              };
</pre>
<p>Даже пустой деструктор решит нашу проблему:</p>
<pre>
             employee::~employee() { }
</pre>
<p>Теперь освобождение памяти будет происходить в деструкторе (а в нем
   размер известен), а любой производный от employee класс также будет
   вынужден определять свой деструктор (тем самым будет установлен
   нужный размер), если только пользователь сам не определит его.
   Теперь следующий пример пройдет правильно:</p>
<pre>
             void f()
             {
               employee* p = new manager; // теперь без проблем
               delete p;
             }
</pre>
<p>Размещение происходит с помощью (созданного транслятором) вызова</p>
<pre>
            employee::operator new(sizeof(manager))
</pre>
<p>а освобождение с помощью вызова</p>
<pre>
            employee::operator delete(p,sizeof(manager))
</pre>
<p>Иными словами, если нужно иметь корректные функции размещения и
   освобождения для производных классов, надо либо определить
   виртуальный деструктор в базовом классе, либо не использовать
   в функции освобождения параметр size_t. Конечно, можно было
   при проектировании языка предусмотреть средства, освобождающие
   пользователя от этой проблемы. Но тогда пользователь "освободился" бы
   и от определенных преимуществ более оптимальной, хотя и менее надежной
   системы.</p>
<p>В общем случае, всегда есть смысл определять виртуальный
   деструктор для всех классов, которые действительно используются как
   базовые, т.е. с объектами производных классов работают и, возможно,
   удаляют их, через указатель на базовый класс:</p>
<pre>
        class X {
           // ...
        public:
           // ...
           virtual void f(); // в X есть виртуальная функция, поэтому
                             // определяем виртуальный деструктор
           virtual ~X();
        };
</pre>

<a name="#virtconstr"></a><h5>6.7.1 Виртуальные конструкторы</h5>
<p>Узнав о виртуальных деструкторах, естественно спросить: "Могут ли
   конструкторы то же быть виртуальными?" Если ответить коротко - нет.
   Можно дать более длинный ответ: "Нет, но можно легко получить
   требуемый эффект".</p>
<p>Конструктор не может быть виртуальным, поскольку для правильного
   построения объекта он должен знать его истинный тип. Более того,
   конструктор - не совсем обычная функция. Он может взаимодействовать
   с функциями управления памятью, что невозможно для обычных
   функций. От обычных функций-членов он отличается еще тем, что
   не вызывается для существующих объектов. Следовательно нельзя получить
   указатель на конструктор.</p>
<p>Но эти ограничения можно обойти, если определить функцию,
   содержащую вызов конструктора и возвращающую построенный объект.
   Это удачно, поскольку нередко бывает нужно создать новый объект,
   не зная его истинного типа. Например, при трансляции иногда
   возникает необходимость сделать копию дерева, представляющего
   разбираемое выражение. В дереве могут быть узлы выражений разных
   видов. Допустим, что узлы, которые содержат повторяющиеся в выражении
   операции, нужно копировать только один раз. Тогда нам потребуется
   виртуальная функция размножения для узла выражения.</p>
<p>Как правило "виртуальные конструкторы" являются стандартными
   конструкторами без параметров или конструкторами копирования,
   параметром которых служит тип результата:</p>
<pre>
            class expr {
               // ...
            public:
               expr();  // стандартный конструктор
               virtual expr* new_expr() { return new expr(); }
            };
</pre>
<p>Виртуальная функция new_expr() просто возвращает стандартно
   инициализированный объект типа expr, размещенный в свободной памяти.
   В производном классе можно переопределить функцию new_expr() так,
   чтобы она возвращала объект этого класса:</p>
<pre>
            class conditional : public expr {
               // ...
            public:
              conditional();  // стандартный конструктор
              expr* new_expr() { return new conditional(); }
            };
</pre>
<p>Это означает, что, имея объект класса expr, пользователь может
   создать объект в "точности такого же типа":</p>
<pre>
            void user(expr* p1, expr* p2)
            {
               expr* p3 = p1->new_expr();
               expr* p4 = p2->new_expr();
               // ...
             }
</pre>
<p>Переменным p3 и p4 присваиваются указатели неизвестного, но подходящего
   типа.</p>
<p>Тем же способом можно определить виртуальный конструктор
   копирования, называемый операцией размножения, но надо подойти
   более тщательно к специфике операции копирования:</p>
<pre>
             class expr {
                // ...
                expr* left;
                expr* right;
             public:
                // ...
                   // копировать `s' в `this'
                inline void copy(expr* s);
                   // создать копию объекта, на который смотрит this
                virtual expr* clone(int deep = 0);
             };
</pre>
<p>Параметр deep показывает различие между копированием собственно
   объекта (поверхностное копирование) и копированием всего поддерева,
   корнем которого служит объект (глубокое копирование). Стандартное
   значение 0 означает поверхностное копирование.</p>
<p>Функцию clone() можно использовать, например, так:</p>
<pre>
           void fct(expr* root)
           {
             expr* c1 = root->clone(1);  // глубокое копирование
             expr* c2 = root->clone();   // поверхностное копирование
             // ...
           }
</pre>
<p>Являясь виртуальной, функция clone() способна размножать объекты
   любого производного от expr класса.</p>
<p>Настоящее копирование можно определить так:</p>
<pre>
              void expr::copy(expression* s, int deep)
              {
                if (deep == 0) { // копируем только члены
                   *this = *s;
                }
                else { // пройдемся по указателям:
                   left = s->clone(1);
                   right = s->clone(1);
                   // ...
                }
              }
</pre>
<p>Функция expr::clone() будет вызываться только для объектов типа
   expr (но не для производных от expr классов), поэтому можно просто
   разместить в ней и возвратить из нее объект типа expr, являющийся
   собственной копией:</p>
<pre>
              expr* expr::clone(int deep)
              {
                expr* r = new expr();  // строим стандартное выражение
                r->copy(this,deep);    // копируем `*this' в `r'
                return r;
              }
</pre>
<p>Такую функцию clone() можно использовать для производных от expr
   классов, если в них не появляются члены-данные (а это как раз
   типичный случай):</p>
<pre>
              class arithmetic : public expr {
                // ...
                // новых членов-данных нет =>
                // можно использовать уже определенную функцию clone
              };
</pre>
<p>С другой стороны, если добавлены члены-данные, то нужно определять
   собственную функцию clone():</p>
<pre>
             class conditional : public expression {
                expr* cond;
             public:
                inline void copy(cond* s, int deep = 0);
                expr* clone(int deep = 0);
                // ...
             };
</pre>
<p>Функции copy() и clone() определяются подобно своим двойникам из
   expression:</p>
<pre>
             expr* conditional::clone(int deep)
             {
               conditional* r = new conditional();
               r->copy(this,deep);
               return r;
             }

             void conditional::copy(expr* s, int deep)
             {
               if (deep == 0) {
                  *this = *s;
               }
               else {
                  expr::copy(s,1);  // копируем часть expr
                  cond = s->cond->clone(1);
               }
             }
</pre>
<p>Определение последней функции показывает отличие настоящего
   копирования в expr::copy() от полного размножения в expr::clone()
   (т.е. создания нового объекта и копирования в него). Простое
   копирование оказывается полезным для определения более сложных
   операций копирования и размножения. Различие между copy() и clone()
   эквивалентно различию между операцией присваивания и конструктором
   копирования (п.<a href="chap1.shtml#pattern">1.4.2</a>) и эквивалентно различию между функциями
   _draw() и draw() (п.<a href="#baseclass">6.5.3</a>). Отметим, что функция copy() не является
   виртуальной. Ей и не надо быть таковой, поскольку виртуальна
   вызывающая ее функция clone(). Очевидно, что простые операции
   копирования можно также определять как функции-подстановки.</p>

<a name="#intruct"></a><h5>6.7.2 Указание размещения</h5>
<p>По умолчанию операция new создает указанный ей объект в свободной
   памяти. Как быть, если надо разместить объект в определенном месте?
   Этого можно добиться переопределением операции размещения. Рассмотрим
   простой класс:</p>
<pre>
          class X {
             // ...
          public:
            X(int);
            // ...
          };
</pre>
<p>Объект можно разместить в любом месте, если ввести в функцию
   размещения дополнительные параметры:</p>
<pre>
          // операция размещения в указанном месте:
          void* operator new(size_t, void* p) { return p; }
</pre>
<p>и задав эти параметры для операции new следующим образом:</p>
<pre>
          char buffer[sizeof(X)];

          void f(int i)
          {
            X* p = new(buffer) X(i); // разместить X в buffer
            // ...
          }
</pre>
<p>Функция operator new(), используемая операцией new, выбирается
   согласно правилам сопоставления параметров (п.<a href="referenc.shtml#R.13.2">R.13.2</a>). Все
   функции operator new() должны иметь первым параметром size_t.
   Задаваемый этим параметром размер неявно передается операцией
   new.</p>
<p>Определенная нами функция operator new() с задаваемым размещением
   является самой простой из функций подобного рода. Можно привести
   другой пример функции размещения, выделяющей память из некоторой
   заданной области:</p>
<pre>
          class Arena {
             // ...
             virtual void* alloc(size_t) = 0;
             virtual void free(void*) = 0;
          };

          void operator new(size_t sz, Arena* a)
          {
            return a.alloc(sz);
          }
</pre>
<p>Теперь можно отводить память для объектов произвольных типов из
   различных областей (Arena):</p>
<pre>
          extern Arena* Persistent; // постоянная память
          extern Arena* Shared;     // разделяемая память

          void g(int i)
          {
            X* p = new(Persistent) X(i); // X в постоянной памяти
            X* q = new(Shared) X(i);     // X в разделяемой памяти
            // ...
          }
</pre>
<p>Если мы помещаем объект в область памяти, которая непосредственно
   не управляется стандартными функциями распределения свободной
   памяти, то надо позаботиться о правильном уничтожении объекта.
   Основным средством здесь является явный вызов деструктора:</p>
<pre>
          void h(X* p)
          {
            p->~X();             // вызов деструктора
            Persistent->free(p); // освобождение памяти
          }
</pre>
<p>Заметим, что явных вызовов деструкторов, как и глобальных функций
   размещения специального назначения, следует, по возможности,
   избегать. Бывают случаи, когда обойтись без них трудно, но
   новичок должен трижды подумать, прежде чем использовать явный
   вызов деструктора, и должен сначала посоветоваться с более опытным
   коллегой.</p>

<a name="#exercise"></a><h4>6.8 Упражнения</h4>
<ol>
<li>(*1) Пусть есть класс
<pre>
           class base {
           public:
              virtual void iam() { cout << "base\n"; }
           };
</pre>
      Определите два производных от base класса и в каждом определите
      функцию iam(), выдающую имя своего класса. Создайте объекты
      этих классов и вызовите iam() для них. Присвойте адреса объектов
      производных классов указателю типа base* и вызовите iam() с
      помощью этих указателей.
<li>(*2) Реализуйте примитивы управления экраном (п.<a href="#monitor">6.4.1</a>) разумным
      для вашей системы образом.
<li>(*2) Определите классы triangle (треугольник) и circle
      (окружность).
<li>(*2) Определите функцию, рисующую отрезок прямой, соединяющий
      две фигуры. Вначале надо найти самые ближайшие точки фигур, а
      затем соединить их.
<li>(*2) Измените пример с классом shape так, чтобы line было
      производным классом от rectangle, или наоборот.
<li>(*2) Пусть есть класс
<pre>
           class char_vec {
              int sz;
              char element [1];
           public:
              static new_char_vec(int s);
              char& operator[] (int i) { return element[i]; }
              // ...
           };
</pre>
       Определите функцию new_char_vec() для отведения непрерывного
       участка памяти для объектов char_vec так, чтобы элементы можно
       было индексировать как массив element[]. В каком случае эта
       функция вызовет серьезные трудности?
<li>(*1)  Опишите структуры данных, которые нужны для
       примера с классом shape из п.<a href="#example">6.4</a>, и объясните, как может
       выполняться виртуальный вызов.
<li>(*1.5) Опишите структуры данных, которые нужны для примера
       с классом satellite из п.<a href="#multinher">6.5</a>, и объясните, как может выполняться
       виртуальный вызов.
<li>(*2) Опишите структуры данных, которые нужны для примера с
       классом window из п.<a href="#baseclass">6.5.3</a>, и объясните, как может выполняться
       виртуальный вызов.
<li>(*2) Опишите класс графических объектов с набором возможных
       операций, который будет общим базовым в библиотеке графических
       объектов. Исследуйте какие-нибудь графические библиотеки,
       чтобы понять, какие операции нужны. Определите класс объектов
       базы данных с набором возможных операций, который будет
       общим базовым классом объектов, хранящихся как последовательность
       полей базы данных. Исследуйте какие-нибудь базы данных, чтобы
       понять, какие операции нужны. Определите объект графической
       базы данных, используя или не используя множественное
       наследование. Обсудите относительные плюсы и минусы обоих
       решений.
<li>(*2) Напишите вариант функции clone() из п.<a href="#virtconstr">6.7.1</a>, в котором
       размножаемый объект может помещаться в область Arena
       (п.<a href="#intruct">6.7.2</a>), передаваемую как параметр. Реализуйте простой
       класс Arena как производный от Arena.
<li>(*2) Пусть есть классы Circle (окружность), Square (квадрат) и
       Triangle (треугольник), производные от класса shape. Определите
       функцию intersect() с двумя параметрами типа Shape*, которая
       вызывает подходящую функцию, чтобы выяснить, пересекаются ли
       заданные две фигуры. Для этого в указанных классах нужно
       определить соответствующие виртуальные функции. Не тратьте
       силы на функцию, которая действительно устанавливает, что
       фигуры пересекаются, добейтесь только правильной
       последовательности вызовов функций.
<li>(*5) Разработайте и реализуйте библиотеку для моделирования,
       управляемого событиями. Подсказка: используйте <task.h>.
       Там уже устаревшие функции и можно написать лучше. Должен
       быть класс task (задача). Объект task должен уметь сохранять
       свое состояние и восстанавливать его (для этого можно
       определить функции task::save() и task::restore()) и тогда
       он может действовать как сопрограмма. Специальные задачи
       можно определять как объекты классов, производных от task.
       Программу, которую выполняет задача, определите как
       виртуальную функцию. Должна быть возможность передавать
       параметры новой задаче как параметры ее конструктору или
       конструкторам. Должен быть диспетчер, который реализует
       понятие виртуального времени. Определите функцию
       task::delay(long), которая будет "съедать" виртуальное
       время. Важный вопрос разработки: является ли
       диспетчер частью класса task, или он должен быть независимым?
       Задачи должны иметь возможность общения друг с другом.
       Для этой цели разработайте класс queue (очередь). Придумайте
       способ, чтобы задача могла ожидать входной поток из нескольких
       очередей. Все динамические ошибки должны обрабатываться
       единообразно. Как организовать отладку программ, написанных
       с помощью такой библиотеки?
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap7.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>