<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 3<br>
Выражения и операторы</h3>

<p align="right"><i>"Но с другой стороны не следует<br>
забывать про эффективность"</i><br>
(Джон Бентли)</p>
<p>С++ имеет сравнительно небольшой набор операторов, который позволяет
  создавать гибкие структуры управления, и богатый набор операций для
  работы с данными. Основные их возможности показаны в этой главе на одном
  завершенном примере. Затем приводится сводка выражений, и подробно
  обсуждаются операции преобразования типа и размещение в свободной памяти.
  Далее дана сводка операторов, а в конце главы обсуждается выделение
  текста пробелами и использование комментариев.</p>

<a name="#calc"></a><h4>3.1 Калькулятор</h4>
<p>Мы познакомимся с выражениями и операторами на примере программы
  калькулятора. Калькулятор реализует четыре основных арифметических
  действия в виде инфиксных операций над числами с плавающей точкой.
  В качестве упражнения предлагается добавить к калькулятору
  переменные. Допустим, входной поток имеет вид:</p>
<pre>
             r=2.5
             area=pi*r*r
</pre>
<p>(здесь pi имеет предопределенное значение). Тогда программа калькулятора
  выдаст:</p>
<pre>
             2.5
             19.635
</pre>
<p>Результат вычислений для первой входной строки равен 2.5, а результат
   для второй строки - это 19.635.</p>
<p>Программа калькулятора состоит из четырех основных частей:
  анализатора, функции ввода, таблицы имен и драйвера. По сути - это
  транслятор в миниатюре, в котором анализатор проводит синтаксический
  анализ, функция ввода обрабатывает входные данные и проводит
  лексический анализ, таблица имен хранит постоянную информацию, нужную
  для работы, а драйвер выполняет инициализацию,
  вывод результатов и обработку ошибок. К такому калькулятору можно
  добавить много других полезных возможностей, но программа его и так
  достаточно велика (200 строк), а введение новых возможностей
  только увеличит ее объем, не давая дополнительной
  информации для изучения С++.</p>

<a name="#analyz"></a><h5>3.1.1 Анализатор</h5>
<p>Грамматика языка калькулятора определяется следующими правилами:</p>
<pre>
       программа:
           END                    // END - это конец ввода
           список-выражений END

       список-выражений:
           выражение PRINT      // PRINT - это '\n' или ';'
           выражение PRINT список-выражений

       выражение:
           выражение + терм
           выражение - терм
           терм

       терм:
           терм / первичное
           терм * первичное
           первичное

       первичное:
           NUMBER      // число с плавающей запятой в С++
           NAME        // имя в языке С++ за исключением '_'
           NAME = выражение
           - первичное
           ( выражение )
</pre>
<p>Иными словами, программа есть последовательность строк, а каждая
   строка содержит одно или несколько выражений, разделенных точкой
   с запятой. Основные элементы выражения - это числа, имена и
   операции  *,  /,  +, - (унарный и бинарный минус) и =. Имена
   необязательно описывать до использования.</p>
<p>Для синтаксического анализа используется метод, обычно называемый
  рекурсивным спуском. Это распространенный и достаточно очевидный
  метод. В таких языках как С++, то есть в которых операция вызова
  не сопряжена с большими накладными расходами, это метод эффективен.
  Для каждого правила грамматики имеется своя функция, которая вызывает
  другие функции.  Терминальные символы (например, END, NUMBER, + и -)
  распознаются лексическим анализатором get_token(). Нетерминальные
  символы распознаются функциями синтаксического анализатора expr(),
  term() и prim(). Как только оба операнда выражения или подвыражения
  стали известны, оно вычисляется. В настоящем трансляторе  в этот
  момент создаются команды, вычисляющие выражение.</p>
<p>Анализатор использует для ввода функцию get_token().
  Значение последнего вызова get_token() хранится в глобальной переменной
  curr_tok. Переменная  curr_tok принимает значения элементов перечисления
  token_value:</p>
<pre>
           enum token_value {
                NAME,      NUMBER,     END,
                PLUS='+',  MINUS='-',  MUL='*',    DIV='/',
                PRINT=';', ASSIGN='=', LP='(',     RP=')'
           };
           token_value curr_tok;
</pre>
<p>Для всех функций анализатора предполагается, что get_token() уже
   была вызвана, и поэтому в curr_tok хранится следующая лексема,
   подлежащая анализу. Это позволяет анализатору заглядывать на одну
   лексему вперед. Каждая функция анализатора всегда читает
   на одну лексему больше, чем нужно для распознавания того правила,
   для которого она вызывалась. Каждая функция анализатора вычисляет
   "свое" выражение и возвращает его результат. Функция expr() обрабатывает
   сложение и вычитание. Она состоит из одного цикла, в котором
   распознанные термы складываются или вычитаются:</p>
<pre>
          double expr()                   // складывает  и вычитает
          {
            double left = term();

            for(;;)                     // ``вечно''
               switch(curr_tok) {
               case PLUS:
                    get_token();        // случай '+'
                    left += term();
                    break;
               case MINUS:
                    get_token();        // случай '-'
                    left -= term();
                    break;
              default:
                    return left;
              }
           }
</pre>
<p>Сама по себе эта функция делает немного. Как принято в
  высокоуровневых функциях больших программ, она выполняет задание,
  вызывая другие функции. Отметим, что выражения вида 2-3+4
  вычисляются как (2-3)+4, что предопределяется правилами грамматики.
  Непривычная запись for(;;) - это стандартный способ задания бесконечного
  цикла, и его можно обозначить словом "вечно". Это вырожденная форма
  оператора for, и альтернативой ей может служить оператор while(1).
  Оператор switch выполняется повторно до тех пор, пока не
  перестанут появляться операции + или - , а тогда по умолчанию выполняется
  оператор return (default).</p>
<p>Операции += и -= используются для выполнения операций сложения и
  вычитания. Можно написать эквивалентные присваивания: left=left+term() и
  left=left-term(). Однако вариант left+=term() и left-=term() не
  только короче, но и более четко определяет требуемое действие. Для бинарной
  операции @ выражение x@=y означает x=x@y, за исключением того, что x
  вычисляется только один раз. Это применимо к бинарным операциям:</p>
<pre>
        +     -     *     /     %     &     |     ^     <<     >>
</pre>
<p>поэтому возможны следующие операции присваивания:</p>
<pre>
       +=     -=    *=    /=    %=    &=    |=    ^=    <<=    >>=
</pre>
<p>Каждая операция является отдельной лексемой, поэтому a + =1
  содержит синтаксическую ошибку (из-за пробела между + и =). Расшифровка
  операций следующая: % - взятие остатка, &, | и  ^ - разрядные логические
  операции И, ИЛИ и Исключающее ИЛИ;  << и >> сдвиг влево и сдвиг вправо.
  Функции term() и get_token() должны быть описаны до определения expr().
  В главе 4 рассматривается построение программы в виде совокупности
  файлов. За одним исключением, все программы калькулятора можно составить
  так, чтобы в них все объекты описывались только один раз и до их
  использования. Исключением является функция expr(), которая вызывает
  функцию term(), а она, в свою очередь, вызывает prim(), и уже та, наконец,
  вызывает expr(). Этот цикл необходимо как-то разорвать, для чего вполне
  подходит заданное до определения prim() описание:</p>
<pre>
        double expr();    // это описание необходимо
</pre>
<p>Функция term() справляется с умножением и делением аналогично
  тому, как функция expr() со сложением и вычитанием:</p>
<pre>
       double term()                    // умножает и складывает
       {
         double left = prim();

         for(;;)
            switch(curr_tok)    {
            case MUL:
                get_token();         // случай '*'
                left *= prim();
                break;
            case DIV:
                get_token();         // случай '/'
                double d = prim();
                if (d == 0) return error("деление на 0");
                left /= d;
                break;
            default:
                return left;
            }
        }
</pre>
<p>Проверка отсутствия деления на нуль необходима, поскольку
  результат деления на нуль неопределен и, как правило, приводит к
  катастрофе.</p>
<p>Функция error() будет рассмотрена позже. Переменная d появляется в
  программе там, где она действительно нужна, и сразу же инициализируется.
  Во многих языках описание может находиться только в начале блока.
  Но такое ограничение может искажать естественную структуру программы и
  способствовать появлению ошибок.<br>
  Чаще всего не инициализированные локальные переменные
  свидетельствуют о плохом стиле программирования. Исключение составляют
  те переменные, которые инициализируются операторами ввода, и переменные
  типа массива или структуры, для которых нет традиционной
  инициализации с помощью одиночных присваиваний. Следует напомнить, что =
  является операцией присваивания,  тогда как == есть операция сравнения.</p>
<p>Функция prim, обрабатывающая первичное, во многом похожа на
  функции expr и term(). Но раз мы дошли до низа в иерархии вызовов,
  то в ней кое-что придется сделать. Цикл для нее не нужен:</p>
<pre>
          double number_value;
          char name_string[256];

          double prim()               // обрабатывает первичное
          {
            switch (curr_tok) {
            case NUMBER:          // константа с плавающей точкой
              get_token();
              return number_value;
            case NAME:
              if (get_token() == ASSIGN) {
                 name* n = insert(name_string);
                 get_token();
                 n->value = expr();
                 return n->value;
              }
              return look(name_string)->value;
           case MINUS:               // унарный минус
              get_token();
              return -prim();
           case LP:
              get_token();
              double e = expr();
              if (curr_tok != RP) return error("требуется )");
              get_token();
              return e;
          case END:
              return 1;
         default:
              return error("требуется первичное");
         }
      }
</pre>
<p>Когда появляется NUMBER (то есть константа с плавающей точкой),
  возвращается ее значение. Функция ввода get_token() помещает значение
  константы в глобальную переменную number_value. Если в программе
  используются глобальные переменные, то часто это указывает на то, что
  структура не до конца проработана, и поэтому требуется некоторая
  оптимизация. Именно так обстоит дело в данном случае. В идеале лексема
  должна состоять из двух частей: значения, определяющего вид лексемы
  (в данной программе это token_value), и (если необходимо) собственно
  значения лексемы. Здесь же имеется только одна простая переменная
  curr_tok, поэтому для хранения последнего прочитанного значения NUMBER
  требуется глобальная переменная number_value. Такое решение проходит
  потому, что калькулятор во всех вычислениях вначале выбирает одно число,
  а затем считывает другое из входного потока. В качестве упражнения
  предлагается избавиться от этой излишней глобальной переменной
  (п.<a href="#exercise">3.5</a> <a href="#3.5.15">[15]</a>).</p>
<p>Если последнее значение NUMBER  хранится в глобальной переменной
  number_value, то строковое представление последнего значения NAME
  хранится в name_string. Перед тем, как что-либо делать с именем,
  калькулятор должен заглянуть вперед, чтобы выяснить, будет ли ему
  присваиваться значение, или же будет только использоваться существующее
  его значение. В обоих случаях надо обратиться к таблице имен. Эта таблица
  рассматривается  в п.<a href="#nametabl">3.1.3</a>; а здесь достаточно только знать, что она
  состоит из записей, имеющих вид:</p>
<pre>
       struct name {
          char* string;
          name* next;
          double value;
       };
</pre>
<p>Член next используется  только служебными функциями, работающими
  с таблицей:</p>
<pre>
      name* look(const char*);
      name* insert(const char*);
</pre>
<p>Обе функции возвращают указатель на ту запись name, которая соответствует
  их параметру-строке. Функция look() "ругается", если имя не было
  занесено в таблицу. Это означает, что в калькуляторе можно использовать
  имя без предварительного описания, но в первый раз оно может
  появиться только в левой части присваивания.</p>

<a name="#funcin"></a><h5>3.1.2 Функция ввода</h5>
<p>Получение входных данных - часто самая запутанная часть программы.
  Причина кроется в том, что программа должна взаимодействовать
  с пользователем, то есть "мириться" с его прихотями, учитывать принятые
  соглашения и предусматривать кажущиеся редкими ошибки.
  Попытки заставить человека вести себя более удобным для машины образом,
  как правило, рассматриваются как неприемлемые, что справедливо.
  Задача ввода для функции низкого уровня состоит в последовательном
  считывании символов и составлении из них лексемы, с которой работают
  уже функции более высокого уровня. В этом примере низкоуровневый ввод
  делает функция get_token(). К счастью, написание низкоуровневой
  функции ввода достаточно редкая задача. В хороших системах есть
  стандартные функции для таких операций.</p>
<p>Правила  ввода для калькулятора были специально выбраны несколько
  громоздкими для потоковых функций ввода. Незначительные изменения
  в определениях лексем превратили бы get_token() в обманчиво простую
  функцию.</p>
<p>Первая сложность состоит в том, что символ конца строки '\n'
  важен для калькулятора, но потоковые функции ввода воспринимают его
  как символ обобщенного пробела. Иначе говоря, для этих функций '\n'
  имеет значение только как символ, завершающий лексему.
  Поэтому приходится анализировать все обобщенные пробелы (пробел,
  табуляция и т.п.). Это делается в операторе do, который эквивалентен
  оператору while, за исключением того, что тело оператора do
  всегда выполняется хотя бы один раз:</p>
<pre>
      char ch;

      do {    // пропускает пробелы за исключением '\n'
          if(!cin.get(ch)) return curr_tok = END;
      } while (ch!='\n' && isspace(ch));

</pre>
<p>Функция cin.get(ch) читает один символ из стандартного входного потока
  в ch. Значение условия if(!cin.get(ch)) - ложь,  если из потока cin
  нельзя получить ни одного символа.  Тогда возвращается лексема END, чтобы
  закончить работу калькулятора.  Операция ! (NOT) нужна потому, что
  в случае успешного считывания get() возвращает ненулевое значение.</p>
<p>Функция-подстановка isspace() из <ctype.h> проверяет, не является
  ли ее параметр обобщенным пробелом (п.<a href="chap10.shtml#inbuild">10.3.1</a>). Она возвращает ненулевое
  значение, если является, и нуль в противном случае. Проверка реализуется
  как обращение к таблице, поэтому для скорости лучше вызывать isspace(),
  чем проверять самому. То же можно сказать о функциях isalpha(), isdigit()
  и isalnum(), которые используются в get_token().</p>
<p>После пропуска обобщенных пробелов следующий считанный символ
  определяет, какой будет начинающаяся с него лексема. Прежде, чем
  привести всю функцию, рассмотрим некоторые случаи отдельно. Лексемы
  '\n' и ';', завершающие выражение, обрабатываются следующим образом:</p>
<pre>
           switch (ch) {
           case ';':
           case '\n':
                cin >> ws;    // пропуск обобщенного пробела
                return curr_tok=PRINT;
</pre>
<p>Необязательно снова пропускать пробел, но, сделав это, мы
  избежим повторных вызовов функции get_token(). Переменная ws, описанная
  в файле &lt;stream.h>, используется только как приемник ненужных пробелов.
  Ошибка во входных данных, а также конец ввода не будут обнаружены до
  следующего вызова функции get_token(). Обратите внимание, как несколько
  меток выбора помечают одну последовательность операторов, заданную
  для этих вариантов. Для обоих символов ('\n' и ';') возвращается лексема
  PRINT, и она же помещается в curr_tok.</p>
<p>Числа обрабатываются следующим образом:</p>
<pre>
         case '0': case '1': case '2': case '3': case '4':
         case '5': case '6': case '7': case '8': case '9':
         case '.':
              cin.putback(ch);
              cin >> number_value;
              return curr_tok=NUMBER;
</pre>
<p>Размещать метки вариантов горизонтально, а не вертикально,- не самый
  лучший способ, поскольку такой текст труднее читать; но писать строку
  для каждой цифры утомительно. Поскольку оператор >> может читать
  константу с плавающей точкой типа double, программа тривиальна:
  прежде всего начальный символ (цифра или точка) возвращается назад
  в cin, а затем константу можно считать в number_value.
  Имя, т.е. лексема NAME, определяется как буква, за которой может
  идти несколько букв или цифр:</p>
<pre>
           if (isalpha(ch)) {
              char* p = name_string;
              *p++ = ch;
              while (cin.get(ch) && isalnum(ch)) *p++ = ch;
              cin.putback(ch);
              *p = 0;
              return curr_tok=NAME;
           }
</pre>
<p>Этот фрагмент программы заносит в name_string строку, оканчивающуюся
   нулевым символом. Функции isalpha() и isalnum() определены в <ctype.h>.
   Результат isalnum(c) ненулевой, если c - буква или цифра, и нулевой
   в противном случае.<br>
   Приведем, наконец, функцию ввода полностью:</p>
<pre>
       token_value get_token()
       {
         char ch;

         do {    // пропускает обобщенные пробелы за исключением '\n'
             if(!cin.get(ch)) return curr_tok = END;
         } while (ch!='\n' && isspace(ch));

         switch (ch) {
         case ';':
         case '\n':
              cin >> ws;    // пропуск обобщенного пробела
              return curr_tok=PRINT;
         case '*':
         case '/':
         case '+':
         case '-':
         case '(':
         case ')':
         case '=':
              return curr_tok=token_value(ch);
         case '0': case '1': case '2': case '3': case '4':
         case '5': case '6': case '7': case '8': case '9':
         case '.':
              cin.putback(ch);
              cin >> number_value;
              return curr_tok=NUMBER;
        default:            // NAME, NAME= или ошибка
              if (isalpha(ch)) {
                 char* p = name_string;
                 *p++ = ch;
                 while (cin.get(ch) && isalnum(ch)) *p++ = ch;
                 cin.putback(ch);
                 *p = 0;
                 return curr_tok=NAME;
              }
              error("недопустимая лексема");
              return curr_tok=PRINT;
         }
      }
</pre>
<p>Преобразование операции в значение лексемы для нее тривиально,
   поскольку в перечислении token_value лексема операции была определена
   как целое (код символа операции).</p>

<a name="#nametabl"></a><h5>3.1.3 Таблица имен</h5>
<p>Есть функция поиска в таблице имен:</p>
<pre>
         name* look(char* p, int ins =0);
</pre>
<p>Второй ее параметр показывает, была ли символьная строка, обозначающая
  имя, ранее занесена в таблицу. Инициализатор =0 задает стандартное
  значение параметра, которое используется, если функция look()
  вызывается только с одним параметром. Это удобно, так как
  можно писать look("sqrt2"), что означает look("sqrt2",0),
  т.е. поиск, а не занесение в таблицу. Чтобы было так же удобно задавать
  операцию занесения в таблицу, определяется вторая функция:</p>
<pre>
        inline name* insert(const char* s) { return look(s,1); }
</pre>
<p>Как ранее упоминалось, записи в этой таблице имеют такой тип:</p>
<pre>
        struct name {
             char* string;
             name* next;
             double value;
        };
</pre>
<p>Член next используется для связи записей в таблице.<br>
  Собственно таблица  - это просто массив указателей на объекты типа name:
<pre>
        const TBLSZ = 23;
        name* table[TBLSZ];
</pre>
<p>Поскольку по умолчанию все статические объекты инициализируются нулем,
   такое тривиальное описание таблицы table обеспечивает также и нужную
   инициализацию.</p>
<p>Для поиска имени в таблице функция look() использует простой
   хэш-код (записи, в которых имена имеют одинаковый хэш-код,
   связываются):
   вместе):</p>
<pre>

             int ii = 0;        // хэш-код
             const char* pp = p;
             while (*pp) ii = ii<<1 ^ *pp++;
             if (ii < 0) ii = -ii;
             ii %= TBLSZ;
</pre>
<p>Иными словами, с помощью операции ^ ("исключающее ИЛИ") все символы
  входной строки p поочередно добавляются к ii. Разряд в результате x^y
  равен 1 тогда и только тогда, когда эти разряды в операндах x и y различны.
  До выполнения операции ^ значение ii сдвигается на один разряд влево,
  чтобы использовался не только один байт ii. Эти действия можно
  записать таким образом:</p>
<pre>
             ii <<= 1;
             ii ^= *pp++;
</pre>
<p>Для хорошего хэш-кода лучше использовать операцию ^, чем +. Операция
  сдвига важна для получения приемлемого хэш-кода в обоих случаях.
  Операторы</p>
<pre>
             if (ii < 0) ii = -ii;
             ii %= TBLSZ;
</pre>
<p>гарантируют, что значение ii будет из диапазона 0...TBLSZ-1. Напомним,
  что % - это операция взятия остатка. Ниже полностью приведена
  функция look:</p>
<pre>
            #include &lt;string.h>

            name* look(const char* p, int ins =0)
            {
              int ii = 0;        // хэш-код
              const char* pp = p;
              while (*pp) ii = ii&lt;&lt;1 ^ *pp++;
              if (ii &lt; 0) ii = -ii;
              ii %= TBLSZ;

              for (name* n=table[ii]; n; n=n->next)    // поиск
                  if (strcmp(p,n->string) == 0) return n;

              if (ins == 0) error("имя не найдено");

              name* nn = new name;                     // занесение
              nn->string = new char[strlen(p)+1];
              strcpy(nn->string,p);
              nn->value = 1;
              nn->next = table[ii];
              table[ii] = nn;
              return nn;
            }
</pre>
<p>После вычисления хэш-кода ii идет простой поиск имени по членам
   next. Имена сравниваются с помощью стандартной функции
   сравнения строк strcmp(). Если имя найдено, то возвращается указатель
   на содержащую его запись, а в противном случае заводится новая запись
   с этим именем.</p>
<p>Добавление нового имени означает создание нового объекта name
   в свободной памяти с помощью операции new (см. п.<a href="#freemem">3.2.6</a>), его
   инициализацию и включение в список имен. Последнее выполняется как
   занесение нового имени в начало списка, поскольку это можно сделать даже
   без проверки того, есть ли список вообще. Символьная строка имени
   также размещается в свободной памяти. Функция strlen() указывает,
   сколько памяти нужно для строки, операция new отводит нужную память,
   а функция strcpy() копирует в нее строку. Все строковые функции
   описаны в &lt;string.h>:</p>
<pre>
           extern int strlen(const char*);
           extern int strcmp(const char*, const char*);
           extern char* strcpy(char*, const char*);
</pre>

<a name="#errorhand"></a><h5>3.1.4 Обработка ошибок</h5>
<p>Поскольку программа достаточно проста, не надо особо беспокоиться
  об обработке ошибок. Функция error просто подсчитывает число ошибок,
  выдает сообщение о них и возвращает управление обратно:</p>
<pre>
            int no_of_errors;

            double error(const char* s)
            {
              cerr << "error: " << s << "\n";
              no_of_errors++;
              return 1;
            }
</pre>
<p>Небуферизованный выходной поток cerr обычно используется именно для
  выдачи сообщений об ошибках.<br>
  Управление возвращается из error() потому, что ошибки, как правило,
  встречаются посреди вычисления выражения. Значит надо либо полностью
  прекращать вычисления, либо возвращать значение, которое не должно
  вызвать последующих ошибок. Для простого калькулятора больше подходит
  последнее. Если бы функция get_token() отслеживала номера строк, то
  функция error() могла бы указывать пользователю приблизительное место
  ошибки. Это было бы полезно при неинтерактивной работе с калькулятором.
  Часто после появления ошибки программа должна завершиться, поскольку
  не удалось предложить разумный вариант ее дальнейшего выполнения.
  Завершить ее можно с помощью вызова функции exit(), которая заканчивает
  работу с выходными потоками (п.<a href="chap10.shtml#close">10.5.1</a>) и завершает программу,
  возвращая свой параметр в качестве ее результата.
  Более радикальный способ завершения программы - это вызов функции abort(),
  которая прерывает выполнение программы немедленно или сразу же после
  сохранения информации для отладчика (сброс оперативной памяти).
  Подробности вы можете найти в своем справочном руководстве.</p>
<p>Более тонкие приемы обработки ошибок можно предложить, если
  ориентироваться на особые ситуации (см.п.<a href="chap9.shtml">9</a>), но предложенное решение
  вполне приемлемо для игрушечного калькулятора в 200 строк.</p>

<a name="#driver"></a><h5>3.1.5 Драйвер</h5>
<p>Когда все части программы определены, нужен только драйвер, чтобы
  инициализировать и запустить процесс. В нашем примере с этим
  справится функция main():</p>
<pre>
         int main()
         {
           // вставить предопределенные имена:
           insert("pi")->value = 3.1415926535897932385;
           insert("e")->value = 2.7182818284590452354;

           while (cin) {
               get_token();
               if (curr_tok == END) break;
               if (curr_tok == PRINT) continue;
               cout << expr() << '\n';
           }
           return no_of_errors;
         }
</pre>
<p>Принято, что функция main() возвращает нуль, если программа завершается
   нормально, и  ненулевое  значение,  если происходит иначе.  Ненулевое
   значение возвращается как число ошибок. Оказывается, вся инициализация
   сводится к занесению предопределенных имен в таблицу.</p>
<p>В цикле main читаются выражения и выдаются результаты. Это делает
   одна строка:</p>
<pre>
          cout << expr() << '\n';
</pre>
<p>Проверка cin при каждом проходе цикла гарантирует завершение программы,
  даже если что-то случится с входным потоком, а проверка на лексему
  END нужна для нормального завершения цикла, когда функция get_token()
  обнаружит конец файла. Оператор break служит для выхода из
  ближайшего объемлющего оператора switch или цикла (т.е. оператора for,
  while или do). Проверка на лексему PRINT (т.е. на '\n' и ';') снимает
  с функции expr() обязанность обрабатывать пустые выражения. Оператор
  continue эквивалентен переходу на конец цикла, поэтому в нашем
  случае фрагмент:</p>
<pre>
           while (cin) {
           // ...
           if (curr_tok == PRINT) continue;
           cout << expr() << "\n";
         }
</pre>
<p>эквивалентен фрагменту:</p>
<pre>
          while (cin) {
          // ...
          if (curr_tok == PRINT) goto end_of_loop;
          cout << expr() << "\n";
          end_of_loop: ;
        }
</pre>
<p>Более подробно циклы описываются в п.<a href="referenc.shtml#R.6">R.6</a></p>

<a name="#comstrpar"></a><h5>3.1.6 Параметры командной строки</h5>
<p>Когда программа калькулятора уже была написана и отлажена, выяснилось,
  что неудобно вначале запускать ее, вводить выражение, а затем выходить
  из калькулятора. Тем более, что обычно нужно просто вычислить одно
  выражение. Если это выражение задать как параметр командной строки
  запуска калькулятора, то можно сэкономить несколько нажатий клавиши.</p>
<p>Как уже было сказано, выполнение программы начинается вызовом main().
  При этом вызове main() получает два параметра: число параметров (обычно
  называемый argc) и массив строк параметров (обычно называемый argv).
  Параметры - это символьные строки, поэтому argv имеет тип char*[argc+1].
  Имя программы (в том виде, как оно было задано в командной строке)
  передается в argv[0], поэтому argc всегда не меньше единицы. Например,
  для командной строки</p>
<pre>
            dc 150/1.1934
</pre>
<p>параметры имеют значения:</p>
<pre>
            argc        2
            argv[0]     "dc"
            argv[1]     "150/1.1934"
            argv[2]     0
</pre>
<p>Добраться до параметров командной строки просто; проблема в том, как
  использовать их так, чтобы не менять саму программу. В данном случае это
  оказывается совсем просто, поскольку входной поток может быть настроен
  на символьную строку вместо файла (п.<a href="chap10.shtml#strinf">10.5.2</a>).  Например, можно определить
  cin так, чтобы символы читались из строки, а не из стандартного
  входного потока:</p>
<pre>
           int main(int argc, char* argv[])
           {
             switch(argc) {
               case 1:    // считывать из стандартного входного потока
                  break;
               case 2:    // считывать из строки параметров
                 cin = *new istream(argv[1],strlen(argv[1]));
                 break;
               default:
                 error("слишком много параметров");
                 return 1;
            }

             // дальше прежний вариант main
         }
</pre>
<p>При этом istrstream - это функция istream, которая считывает
  символы из строки, являющейся ее первым параметром. Чтобы использовать
  istrstream нужно включить в программу файл <strstream.h>, а не
  обычный &lt;iostream.h>. В остальном же программа осталась без изменений,
  кроме добавления параметров в функцию main() и использования их
  в операторе switch. Можно легко изменить функцию main() так, чтобы она
  могла принимать несколько параметров из командной строки. Однако
  это не слишком нужно, тем более, что можно нескольких выражений
  передать как один параметр:</p>
<pre>
           dc "rate=1.1934;150/rate;19.75/rate;217/rate"
</pre>
<p>Кавычки необходимы потому, что символ ';' служит в системе UNIX
  разделителем команд. В других системах могут быть свои соглашения о
  параметрах командной строки.</p>

<a name="#operrep"></a><h4>3.2 Сводка операций</h4>
<p>Полное и подробное описание операций языка С++ дано в п.<a href="referenc.shtml#R.7">R.7</a>. Советуем
  прочитать этот раздел. Здесь же приводится краткая сводка операций и
  несколько примеров. Каждая операция сопровождается одним или
  несколькими характерными для нее именами и примером ее использования.
  В этих примерах class_name обозначает имя класса, member - имя члена,
  object - выражение, задающее объект класса, pointer - выражение, задающее
  указатель, expr - просто выражение, а lvalue (адрес) - выражение,
  обозначающее не являющийся константой объект. Обозначение (type) задает
  имя типа в общем виде (с возможным добавлением *, () и т.д.).
  Если оно указано без скобок, существуют ограничения.</p>
<p>Порядок применения унарных операций и операций присваивания
  "справа налево", а всех остальных операций - "слева направо".
  То есть, a=b=c означает a=(b=c), a+b+c означает (a+b)+c, и *p++ означает
  *(p++), а не (*p)++.</p>

<table width="90%" border="0" cellspacing="0" cellpadding="0">
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <th colspan="3">Операции С++</th>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <th>::<br>::</th>
  <th>Разрешение области видимости<br>Глобальное</th>
  <th>class_name :: member<br>:: name</th>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>.</td>
  <td>Выбор члена </td>
  <td>object . member</td>
</tr>
<tr>
  <td>-></td>
  <td> Выбор члена </td>
  <td>pointer -> member</td>
</tr>
<tr>
  <td>[]</td>
  <td>Индексирование</td>
  <td>pointer [ expr ]</td>
</tr>
<tr>
  <td>()</td>
  <td>Вызов функции </td>
  <td>expr ( expr_list )</td>
</tr>
<tr>
  <td>()</td>
  <td>Структурное значение </td>
  <td>type ( expr_list )</td>
</tr>
<tr>
  <td>sizeof</td>
  <td>Размер объекта</td>
  <td>sizeof expr</td>
</tr>
<tr>
  <td>sizeof</td>
  <td>Размер типа</td>
  <td>sizeof ( type )</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>++</td>
  <td>Постфиксный инкремент</td>
  <td>lvalue ++</td>
</tr>
<tr>
  <td>++</td>
  <td>Префиксный инкремент</td>
  <td>++ lvalue</td>
</tr>
<tr>
  <td>--</td>
  <td>Постфиксный декремент</td>
  <td>lvalue --</td>
</tr>
<tr>
  <td>--</td>
  <td>Постфиксный декремент</td>
  <td>-- lvalue</td>
</tr>
<tr>
  <td>~</td>
  <td>Дополнение</td>
  <td>~ expr</td>
</tr>
<tr>
  <td>!</td>
  <td>Логическое НЕ</td>
  <td>! expr</td>
</tr>
<tr>
  <td>-</td>
  <td>Унарный минус</td>
  <td>- expr</td>
</tr>
<tr>
  <td>+</td>
  <td>Унарный плюс</td>
  <td>+ expr</td>
</tr>
<tr>
  <td>&</td>
  <td>Взятие адреса</td>
  <td>& lvalue</td>
</tr>
<tr>
  <td>*</td>
  <td>Косвенность</td>
  <td>* expr</td>
</tr>
<tr>
  <td>new</td>
  <td>Создание (размещение)</td>
  <td>new type</td>
</tr>
<tr>
  <td>delete</td>
  <td>Уничтожение (освобождение)</td>
  <td>delete pointer</td>
</tr>
<tr>
  <td>delete[]</td>
  <td>Уничтожение массива</td>
  <td>delete[] pointer</td>
</tr>
<tr>
  <td>()</td>
  <td>Приведение(преобразование)типа</td>
  <td>( type ) expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>. * </td>
  <td>Выбор члена косвенный </td>
  <td> object . pointer-to-member</td>
</tr>
<tr>
  <td>->*</td>
  <td>Выбор члена косвенный</td>
  <td>pointer -> pointer-to-member</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>* </td>
  <td>Умножение</td>
  <td>expr * expr</td>
</tr>
<tr>
  <td>/</td>
  <td>Деление</td>
  <td>expr / expr</td>
</tr>
<tr>
  <td>%</td>
  <td>Остаток  от деления</td>
  <td>expr % expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>+</td>
  <td>Сложение (плюс)</td>
  <td>expr + expr</td>
</tr>
<tr>
  <td>-</td>
  <td>Вычитание (минус)</td>
  <td>expr - expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
</table>

<p>Все операции таблицы, находящиеся между двумя ближайшими друг
  к другу горизонтальными чертами,
  имеют одинаковый приоритет. Приоритет операций уменьшается при
  движении "сверху вниз". Например, a+b*c означает a+(b*c), так как *
  имеет приоритет выше, чем +; а выражение a+b-c означает (a+b)-c,
  поскольку + и - имеют одинаковый приоритет, и операции + и -
  применяются "слева направо".</p>

<table width="90%" border="0" cellspacing="0" cellpadding="0">
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <th colspan="3">Операции С++ (продолжение)</th>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>&lt;&lt;</td>
  <td>Сдвиг влево</td>
  <td>expr << expr</td>
</tr>
<tr>
  <td>>></td>
  <td>Сдвиг вправо</td>
  <td>expr >> expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>&lt;</td>
  <td>Меньше</td>
  <td>expr < expr</td>
</tr>
<tr>
  <td>&lt;=</td>
  <td>Меньше или равно </td>
  <td>expr <= expr</td>
</tr>
<tr>
  <td>></td>
  <td>Больше</td>
  <td>expr > expr</td>
</tr>
<tr>
  <td>></td>
  <td>Больше или равно</td>
  <td>expr >= expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>==</td>
  <td>Равно</td>
  <td>expr == expr</td>
</tr>
<tr>
  <td>!=</td>
  <td>Не равно</td>
  <td>expr != expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>&</td>
  <td>Поразрядное И </td>
  <td>expr & expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>^</td>
  <td>Поразрядное исключающее ИЛИ </td>
  <td>expr ^ expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>|</td>
  <td>Поразрядное включающее ИЛИ  </td>
  <td> expr | expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>&&</td>
  <td>Логическое И </td>
  <td>expr && expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>||</td>
  <td> Логическое ИЛИ </td>
  <td>expr || expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>? : </td>
  <td>Операция условия</td>
  <td>expr? expr : expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td>=</td>
  <td>Простое присваивание</td>
  <td>lvalue = expr</td>
</tr>
<tr>
  <td>*=</td>
  <td>Присваивание с умножением</td>
  <td>lvalue *= expr</td>
</tr>
<tr>
  <td>/=</td>
  <td>Присваивание с делением</td>
  <td>lvalue /= expr</td>
</tr>
<tr>
  <td>%=</td>
  <td>Присваивание с взятием остатка от деления</td>
  <td>lvalue %= expr</td>
</tr>
<tr>
  <td>+=</td>
  <td>Присваивание со сложением</td>
  <td>lvalue += expr</td>
</tr>
<tr>
  <td>-=</td>
  <td>Присваивание с вычитанием</td>
  <td>lvalue -= expr</td>
</tr>
<tr>
  <td><<=</td>
  <td>Присваивание со сдвигом влево</td>
  <td>lvalue <<= expr</td>
</tr>
<tr>
  <td>>>=</td>
  <td>Присваивание со сдвигом вправо</td>
  <td>lvalue >>= expr</td>
</tr>
<tr>
  <td>&=</td>
  <td>Присваивание с поразрядным И </td>
  <td>lvalue &= expr</td>
</tr>
<tr>
  <td>|=</td>
  <td>Присваивание с поразрядным  включающим ИЛИ</td>
  <td>lvalue |= expr</td>
</tr>
<tr>
  <td>^=</td>
  <td>Присваивание с поразрядным исключающим ИЛИ</td>
  <td>lvalue ^= expr</td>        
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
<tr>
  <td></td>
  <td>Запятая (последовательность)</td>
  <td>expr , expr</td>
</tr>
<tr>
  <td colspan="3"><hr></td>
</tr>
</table>

<a name="#bracket"></a><h5>3.2.1 Скобки</h5>
<p> Синтаксис языка С++ перегружен скобками, и разнообразие их применений
  способно сбить с толку. Они выделяют фактические параметры при
  вызове функций, имена типов, задающих функции, а также служат для
  разрешения конфликтов между операциями с одинаковым приоритетом.
  К счастью, последнее встречается не слишком часто, поскольку приоритеты
  и порядок применения операций определены так, чтобы выражения вычислялись
  "естественным образом" (т.е. наиболее распространенным образом).<br>
  Например, выражение</p>
<pre>
              if (i&lt;=0 || max&lt;i)   // ...
</pre>
<p>означает следующее: "Если i меньше или равно нулю, или если max меньше i".<br>
  То есть, оно эквивалентно</p>
<pre>
              if ( (i&lt;=0) || (max&lt;i) )    // ...
</pre>
<p>но не эквивалентно допустимому, хотя и бессмысленному выражению</p>
<pre>
              if (i &lt;= (0||max) < i)    // ...
</pre>
<p>Тем не менее, если программист не уверен в указанных правилах,
  следует использовать скобки, причем некоторые предпочитают для
  надежности писать более длинные и менее элегантные выражения, как:</p>
<pre>
             if ( (i&lt;=0) || (max&lt;i) )   // ...
</pre>
<p>При усложнении подвыражений скобки используются чаще.  Не надо, однако,
  забывать, что сложные выражения являются источником ошибок. Поэтому,
  если у вас появится ощущение, что в этом выражении нужны скобки,
  лучше разбейте его на части и введите дополнительную переменную.
  Бывают случаи, когда приоритеты операций не приводят к "естественному"
  порядку вычислений. Например, в выражении</p>
<pre>
             if (i&mask == 0)    // ловушка! & применяется после ==
</pre>
<p>не происходит маскирование i (i&mask), а затем проверка результата
   на 0. Поскольку у == приоритет выше, чем у &, это выражение эквивалентно
   i&(mask==0). В этом случае скобки играют важную роль:</p>
<pre>
             if ((i&mask) == 0) // ...
</pre>
<p>Имеет смысл привести еще одно выражение, которое вычисляется
   совсем не так, как мог бы ожидать неискушенный пользователь:</p>
<pre>
             if (0 <= a <= 99) // ...
</pre>
<p>Оно допустимо, но интерпретируется  как (0<=a)<=99, и результат первого
  сравнения равен или 0, или 1, но не значению a (если, конечно,
  a не есть 1). Проверить, попадает ли a в диапазон 0...99, можно так:</p>
<pre>
             if (0<=a && a<=99) // ...
</pre>
<p>Среди новичков распространена ошибка, когда в условии вместо ==
  (равно) используют = (присвоить):</p>
<pre>
             if (a = 7)   // ошибка: присваивание константы в условии
                    // ...
</pre>
<p>Она вполне объяснима, поскольку в большинстве языков "=" означает "равно".
  Для транслятора не составит труда сообщать об ошибках подобного рода.</p>

<a name="#ordcalc"></a><h5>3.2.2 Порядок вычислений</h5>
<p>Порядок вычисления подвыражений, входящих в выражение, не всегда
  определен. Например:</p>
<pre>
             int i = 1;
             v[i] = i++;
</pre>
<p>Здесь выражение может вычисляться или как v[1]=1, или как v[2]=1.
  Если нет ограничений на порядок вычисления подвыражений, то транслятор
  получает возможность создавать более оптимальный код. Транслятору
  следовало бы предупреждать о двусмысленных выражениях, но к сожалению
  большинство из них не делает этого.<br>
       Для операций</p>
<pre>
               &&    ||   ,
</pre>
<p>гарантируется, что их левый операнд вычисляется раньше правого операнда.
  Например, в выражении b=(a=2,a+1) b присвоится значение 3. Пример
  операции || был дан в п.<a href="#bracket">3.2.1</a>, а пример 
  операции && есть в п.<a href="#shoosoper">3.3.1</a>.
  Отметим, что операция запятая отличается по смыслу от той запятой, которая
  используется для разделения параметров при вызове функций. Пусть есть
  выражения:</p>
<pre>
              f1(v[i],i++);       // два параметра
              f2( (v[i],i++) )    // один параметр
</pre>
<p>Вызов функции f1 происходит с двумя параметрами: v[i] и i++, но
  порядок вычисления выражений параметров неопределен. Зависимость
  вычисления значений фактических параметров от порядка вычислений
  - далеко не лучший стиль программирования. К тому же программа
  становится непереносимой.</p>
<p>Вызов f2 происходит с одним параметром, являющимся выражением,
  содержащим операцию запятая:  (v[i], i++). Оно эквивалентно i++.</p>
<p>Скобки могут принудительно задать порядок вычисления. Например,
  a*(b/c) может вычисляться как (a*b)/c (если только пользователь
  видит в этом какое-то различие). Заметим, что для значений с плавающей
  точкой результаты вычисления выражений a*(b/c) и (a*b)/ могут
  различаться весьма значительно.</p>

<a name="#incdecr"></a><h5>3.2.3 Инкремент и декремент</h5>
<p>Операция ++ явно задает инкремент в отличие от неявного его задания
  с помощью сложения и присваивания. По определению ++lvalue означает
  lvalue+=1, что, в свою очередь  означает lvalue=lvalue+1 при условии,
  что содержимое lvalue не вызывает побочных эффектов. Выражение,
  обозначающее операнд инкремента, вычисляется только один раз. Аналогично
  обозначается операция декремента (--). Операции ++ и -- могут
  использоваться как префиксные и постфиксные операции.  Значением ++x
  является новое (т. е. увеличенное на 1) значение x. Например, y=++x
  эквивалентно y=(x+=1). Напротив, значение x++ равно прежнему значению x.
  Например, y=x++ эквивалентно y=(t=x,x+=1,t), где t - переменная того
  же типа, что и x.</p>
<p>Напомним, что операции инкремента и декремента указателя
  эквивалентны сложению 1 с указателем или вычитанию 1 из указателя, причем
  вычисление происходит в элементах массива, на который настроен
  указатель. Так, результатом  p++ будет указатель на следующий элемент.<br>
  Для указателя p типа T* следующее соотношение верно по определению:</p>
<pre>
            long(p+1) == long(p) + sizeof(T);
</pre>
<p>Чаще всего операции инкремента и декремента используются для
  изменения переменных в цикле. Например, копирование строки,
  оканчивающейся нулевым символом, задается следующим образом:</p>
<pre>
           inline void cpy(char* p, const char* q)
           {
             while (*p++ = *q++) ;
           }
</pre>
<p>Язык С++ (подобно С) имеет как сторонников, так и противников именно
  из-за такого сжатого, использующего сложные выражения стиля
  программирования. Оператор</p>
<pre>
           while (*p++ = *q++) ;
</pre>
<p>вероятнее всего, покажется невразумительным для незнакомых с С.<br>
  Имеет смысл повнимательнее посмотреть на такие конструкции, поскольку
  для C и C++ они не является редкостью.</p>
<p>Сначала рассмотрим более традиционный способ копирования массива
  символов:</p>
<pre>
           int length = strlen(q)
           for (int i = 0; i<=length; i++) p[i] = q[i];
</pre>
<p>Это неэффективное решение: строка оканчивается нулем; единственный
  способ найти ее длину - это прочитать ее всю до нулевого символа;
  в результате строка читается и для установления ее длины, и для
  копирования, то есть дважды. Поэтому попробуем такой вариант:</p>
<pre>
           for (int i = 0; q[i] !=0 ; i++) p[i] = q[i];
           p[i] = 0;   // запись нулевого символа
</pre>
<p>Поскольку p и q - указатели, можно обойтись без переменной i,
  используемой для индексации:</p>
<pre>
           while (*q !=0) {
                 *p = *q;
                 p++;      // указатель на следующий символ
                 q++;      // указатель на следующий символ
           }
           *p = 0;         // запись нулевого символа
</pre>
<p>Поскольку операция постфиксного инкремента позволяет сначала использовать
  значение, а затем уже увеличить его, можно переписать цикл так:</p>
<pre>
            while (*q != 0) {
                  *p++ = *q++;
             }
             *p = 0;   // запись нулевого символа
</pre>
<p>Отметим, что результат выражения  *p++ = *q++ равен *q. Следовательно,
  можно переписать наш пример и так:</p>
<pre>
             while ((*p++ = *q++) != 0)  { }
</pre>
<p>В этом варианте учитывается, что *q равно нулю только тогда, когда
  *q  уже скопировано в *p, поэтому можно исключить завершающее
  присваивание нулевого символа. Наконец, можно еще более сократить
  запись этого примера, если учесть, что пустой блок не нужен, а
  операция "!= 0" избыточна, т.к. результат условного выражения и так
  всегда сравнивается с нулем.  В результате мы приходим к
  первоначальному варианту, который вызывал недоумение:</p>
<pre>
             while (*p++ = *q++) ;
</pre>
<p>Неужели этот вариант труднее понять, чем приведенные выше? Только
  неопытным программистам на С++ или С! Будет ли последний вариант
  наиболее эффективным по затратам времени и  памяти?  Если  не  считать
  первого варианта с функцией strlen(), то это неочевидно. Какой из
  вариантов окажется эффективнее, определяется как спецификой системы
  команд, так и возможностями транслятора. Наиболее эффективный алгоритм
  копирования для вашей машины можно найти в стандартной функции копирования
  строк из файла <string.h>:</p>
<pre>
          int strcpy(char*, const char*);
</pre>

<a name="#logoper"></a><h5>3.2.4 Поразрядные логические операции</h5>
<p>Поразрядные логические операции</p>
<pre>
        &    |    ^    ~    >>    <<
</pre>
<p>применяются к целым, то есть к объектам типа char, short, int, long и
  к их беззнаковым аналогам. Результат операции также будет целым.</p>
<p>Чаще всего поразрядные логические операции используются для
  работы с небольшим по величине множеством данных (массивом разрядов).
  В этом случае каждый разряд беззнакового целого представляет один
  элемент множества, и число элементов определяется количеством разрядов.
  Бинарная операция & интерпретируется как пересечение множеств,
  операция | как объединение, а операция ^ как разность множеств.
  С помощью перечисления можно задать имена элементам множества.
  Ниже приведен пример, заимствованный из <iostream.h>:</p>
<pre>
           class ios {
           public:
              enum io_state {
                   goodbit=0, eofbit=1, failbit=2, badbit=4
              };
              // ...
           };
</pre>
<p>Состояние потока можно установить следующим присваиванием:</p>
<pre>
           cout.state = ios::goodbit;
</pre>
<p>Уточнение именем ios необходимо, потому что определение io_state находится
  в классе ios, а также чтобы не возникло коллизий, если пользователь заведет свои
  имена наподобие goodbit.</p>
<p>Проверку на корректность потока и успешное окончание операции можно
  задать так:</p>
<pre>
          if (cout.state&(ios::badbit|ios::failbit))  // ошибка в потоке
</pre>
<p>Еще одни скобки необходимы потому, что операция & имеет более высокий
  приоритет, чем операция "|".</p>
<p>Функция, обнаружившая конец входного потока, может сообщать об этом так:</p>
<pre>
          cin.state |= ios::eofbit;
</pre>
<p>Операция |= используется потому, что в потоке уже могла быть ошибка
  (т.е. state==ios::badbit), и присваивание</p>
<pre>
          cin.state =ios::eofbit;
</pre>
<p>могло бы затереть ее признак. Установить отличия в состоянии двух
  потоков можно следующим способом:</p>
<pre>
         ios::io_state diff = cin.state^cout.state;
</pre>
<p>Для таких типов, как io_state, нахождение различий не слишком полезная
  операция, но для других сходных типов она может оказаться весьма
  полезной. Например, полезно сравнение двух  разрядных массива, один из
  которых представляет набор всех возможных обрабатываемых прерываний,
  а другой - набор прерываний, ожидающих обработки.</p>
<p>Отметим, что использование полей (п.<a href="referenc.shtml#R.9.6">R.9.6</a>) может служить удобным
  и более лаконичным способом работы с частями слова, чем сдвиги и
  маскирование. С частями слова можно работать и с помощью поразрядных
  логических  операций. Например, можно выделить средние 16 разрядов
  из средины 32-разрядного целого:</p>
<pre>
        unsigned short middle(int a) { return (a>>8)&0xffff; }
</pre>
<p>Только не путайте поразрядные логические операции с просто логическими
  операциями:</p>
<pre>
                &&    ||    !
</pre>
<p>Результатом последних может быть 0 или 1, и они в основном
  используются в условных выражениях операторов if, while или for
  (п.<a href="#shoosoper">3.3.1</a>).  Например,  !0 (не нуль) имеет значение 1, тогда как ~0
  (дополнение нуля) представляет собой набор разрядов "все единицы",
  который обычно является значением -1 в дополнительном коде.</p>

<a name="#typetrans"></a><h5>3.2.5 Преобразование типа</h5>
<p>Иногда бывает необходимо явно преобразовать значение одного типа в
  значение другого. Результатом явного преобразования будет
  значение указанного типа, полученное из значения другого типа.<br>
  Например:</p>
<pre>
          float r = float(1);
</pre>
<p>Здесь перед присваиванием целое значение 1 преобразуется в значение
  с плавающей точкой 1.0f. Результат преобразования типа не является
  адресом, поэтому ему присваивать нельзя (если только тип не является
  ссылкой).</p>
<p>Существуют два вида записи явного преобразования типа:
  традиционная запись, как операция приведения в С, например, (double)a
  и функциональная запись, например, double(a). Функциональную запись
  нельзя использовать для типов, которые не имеют простого имени.
  Например, чтобы преобразовать значение в тип указателя, надо или
  использовать приведение</p>
<pre>
         char* p = (char*)0777;
</pre>
<p>или определить новое имя типа:</p>
<pre>
        typedef char* Pchar;
        char* p = Pchar(0777);
</pre>
<p>По мнению автора, функциональная запись в нетривиальных случаях
  предпочтительнее. Рассмотрим два эквивалентных примера:</p>
<pre>
         Pname n2 = Pbase(n1->tp)->b_name; // функциональная запись
         Pname n3 = ((Pbase)n2->tp)->b_name;   // запись с приведением
</pre>
<p>Поскольку операция -> имеет больший приоритет, чем операция приведения,
  последнее выражение выполняется так:</p>
<pre>
        ((Pbase)(n2->tp))->b_name
</pre>
<p>Используя явное преобразование в тип указателя можно выдать данный объект
  за объект произвольного типа. Например, присваивание</p>
<pre>
        any_type* p = (any_type*)&some_object;
</pre>
<p>позволит обращаться к некоторому объекту (some_object) через указатель
  p как к объекту произвольного типа (any_type). Тем не менее, если
  some_object в действительности имеет тип не any_type, могут получиться
  странные и нежелательные результаты.</p>
<p>Если преобразование типа не является необходимым, его вообще следует
  избегать. Программы, в которых есть такие преобразования, обычно
  труднее понимать, чем программы, их не имеющие. В то же время
  программы с явно заданными преобразованиями типа понятнее,
  чем программы, которые обходятся без таких преобразований, потому что
  не вводят типов для представления понятий более высокого уровня.
  Так, например, поступают программы, управляющие регистром устройства с
  помощью сдвига и маскирования целых, вместо того, чтобы определить
  подходящую структуру (struct) и работать непосредственно с ней
  (см. п.<a href="chap2.shtml#field">2.6.1</a>). Корректность явного преобразования типа часто
  существенно зависит от того, насколько программист понимает, как язык
  работает с объектами различных типов, и какова специфика данной реализации
  языка. Приведем пример:</p>
<pre>
            int i = 1;
            char* pc = "asdf";
            int* pi = &i;
            i = (int)pc;
            pc = (char*)i; // осторожно: значение pc может измениться.
                           // На некоторых машинах sizeof(int)
                           // меньше, чем sizeof(char*)
           pi = (int*)pc;
           pc = (char*)pi; // осторожно: pc может измениться
                           // На некоторых машинах char* имеет не такое
                           // представление, как int*
</pre>
<p>Для многих машин эти присваивания ничем не грозят, но для некоторых
  результат может быть плачевным. В лучшем случае подобная программа
  будет переносимой. Обычно без особого риска можно предположить,
  что указатели на различные структуры имеют одинаковое представление.
  Далее, произвольный указатель можно присвоить (без явного преобразования
  типа) указателю типа void*, а void* может быть явно преобразован
  обратно в указатель произвольного типа.</p>
<p>В языке С++ явные преобразования типа оказывается излишними во многих
  случаях, когда в С (и других языках) они требуются. Во многих
  программах можно вообще обойтись без явных преобразований типа, а во
  многих других они могут быть локализованы в нескольких подпрограммах.</p>

<a name="#freemem"></a><h5>3.2.6 Свободная память</h5>
<p>Именованный объект является либо статическим, либо автоматическим
  (см.п.<a href="chap2.shtml#timeobj">2.1.3</a>). Статический объект размещается в памяти в момент запуска
  программы и существует там до ее завершения. Автоматический объект
  размещается в памяти всякий раз, когда управление попадает в блок,
  содержащий определение объекта, и существует только до тех пор, пока
  управление остается в этом блоке. Тем не менее, часто бывает удобно
  создать новый объект, который существует до тех пор, пока он
  не станет ненужным. В частности, бывает удобно создать объект, который
  можно использовать после возврата из функции, где он был создан.
  Подобные объекты создает операция new, а операция delete используется
  для их уничтожения в дальнейшем. Про объекты, созданные операцией new,
  говорят, что они размещаются в свободной памяти. Примерами таких
  объектов являются узлы деревьев или элементы списка, которые входят
  в структуры данных, размер которых на этапе трансляции неизвестен.
  Давайте рассмотрим в качестве примера набросок транслятора, который
  строится аналогично программе калькулятора. Функции синтаксического
  анализа создают из представлений выражений дерево, которое будет
  в дальнейшем использоваться для генерации кода. Например:</p>
<pre>
         struct enode {
            token_value oper;
            enode* left;
            enode* right;
         };

        enode* expr()
        {
          enode* left = term();

          for(;;)
             switch(curr_tok) {
               case PLUS:
               case MINUS:
                    get_token();
                    enode* n = new enode;
                    n->oper = curr_tok;
                    n->left = left;
                    n->right = term();
                    left = n;
                    break;
              default:
                   return left;
             }
          }
</pre>
<p>Генератор кода может использовать дерево выражений, например так:</p>
<pre>
         void generate(enode* n)
         {
           switch (n->oper) {
           case PLUS:
                // соответствующая генерация
                delete n;
           }
         }
</pre>
<p>Объект, созданный с помощью операции new, существует, до тех пор,
  пока он не будет явно уничтожен операцией delete. После этого
  память, которую он занимал, вновь может использоваться new. Обычно нет
  никакого "сборщика мусора", ищущего объекты, на которые никто
  не ссылается, и предоставляющего занимаемую ими память операции new для
  повторного использования. Операндом  delete может быть
  только указатель, который возвращает операция new, или нуль.
  Применение delete к нулю не приводит ни к каким действиям.</p>
<p>Операция new может также создавать массивы объектов, например:</p>
<pre>
          char* save_string(const char* p)
          {
            char* s = new char[strlen(p)+1];
            strcpy(s,p);
            return s;
          }
</pre>
<p>Отметим, что для перераспределения памяти, отведенной операцией new,
  операция delete должна уметь определять размер размещенного объекта.<br>
  Например:</p>
<pre>
          int main(int argc, char* argv[])
          {
            if (argc < 2) exit(1);
            char* p = save_string(arg[1]);
            delete[] p;
          }
</pre>
<p>Чтобы добиться этого, приходится под объект, размещаемый стандартной
  операцией new, отводить немного больше памяти, чем под статический
  (обычно, больше на одно слово). Простой оператор delete уничтожает
  отдельные объекты, а операция delete[] используется для уничтожения
  массивов.</p>
<p>Операции со свободной памятью реализуются функциями (п.<a href="referenc.shtml#R.5.3.3">R.5.3.3</a>-<a href="referenc.shtml#R.5.3.4">4</a>):</p>
<pre>
          void* operator new(size_t);
          void operator delete(void*);
</pre>
<p>Здесь size_t - беззнаковый целочисленный тип, определенный в &lt;stddef.h>.</p>
<p>Стандартная реализация функции operator new() не инициализирует
  предоставляемую память.</p>
<p>Что случится, когда операция new не сможет больше найти свободной
  памяти для размещения? Поскольку даже виртуальная память небесконечна,
  такое время от времени происходит. Так, запрос вида:</p>
<pre>
         char* p = new char [100000000];
</pre>
<p>обычно не проходит нормально. Когда операция new не может выполнить
  запрос, она вызывает функцию, которая была задана как параметр
  при обращении к функции set_new_handler() из <new.h>. Например,
  в следующей программе:</p>
<pre>
        #include &lt;iostream.h>
        #include &lt;new.h>
        #include &lt;stdlib.h>

        void out_of_store()
        {
           cerr << "operator new failed: out of store\n";
           exit(1);
        }

        int main()
        {
          set_new_handler(&out_of_store);
          char* p = new char[100000000];
          cout << "done, p = " << long(p) << '\n';
        }
</pre>
<p>скорее всего, будет напечатано не "done", а  сообщение:</p>
<pre>
        operator new failed: out of store
        // операция new не прошла: нет памяти
</pre>
<p>С помощью функции new_handler можно сделать нечто более сложное,
  чем просто завершить программу. Если известен алгоритм операций new и
  delete (например, потому, что пользователь определил свои функции
  operator new и operator delete), то обработчик new_handler может
  попытаться найти свободную память для new. Другими словами,
  пользователь может написать свой "сборщик мусора", тем самым сделав
  вызов операции delete необязательным. Однако такая задача,
  безусловно, не под силу новичку.</p>
<p>По традиции операция new просто возвращает указатель 0, если не
  удалось найти достаточно свободной памяти. Реакция же на это
  new_handler не была установлена. Например, следующая программа:</p>
<pre>
       #include <stream.h>

       main()
       {
         char* p = new char[100000000];
         cout << "done, p = " << long(p) << '\n';
       }

   выдаст

       done, p = 0
</pre>
<p>Память не выделена, и вам сделано предупреждение! Отметим, что, задав
   реакцию на такую ситуацию в функции new_handler, пользователь берет
   на себя проверку: исчерпана ли свободная память. Она должна выполняться
   при каждом обращении в программе к new (если только пользователь
   не определил собственные функции для размещения объектов
   пользовательских типов; см. п.<a href="referenc.shtml#R.5.5.6">R.5.5.6</a>).</p>

<a name="#repoper"></a><h4>3.3 Сводка операторов</h4>
<p>Полное и последовательное описание операторов С++ содержится в
   п.<a href="referenc.shtml#R.6">R.6</a>. Советуем ознакомиться с этим разделом. Здесь же дается
   сводка операторов и несколько примеров.</p>
<b>Синтаксис операторов</b>
<pre>
   оператор:
      описание
      { список-операторов opt }
      выражение opt ;

      if ( выражение )  оператор
      if ( выражение )  оператор else оператор
      switch ( выражение ) оператор

      while ( выражение ) оператор
      do  оператор  while ( выражение )
      for (начальный-оператор-for выражение opt; выражение opt) оператор

      case  выражение-константа : оператор
      default : оператор
      break ;
      continue ;

      return  выражение opt ;

      goto  идентификатор ;
      идентификатор : оператор

      список-операторов:
         оператор
         список-операторов  оператор

      начальный-оператор-for:
         описание
         выражение opt ;
</pre>
<p>Обратите внимание, что описание является оператором, но нет операторов
  присваивания или вызова функции (они относятся к выражениям).</p>

<a name="#shoosoper"></a><h5>3.3.1 Выбирающие операторы</h5>
<p>Значение можно проверить с помощью операторов if или switch:</p>
<pre>
            if ( выражение )  оператор

            if ( выражение )  оператор  else  оператор

            switch  ( выражение )  оператор
</pre>
<p>В языке С++ среди основных типов нет отдельного булевского (тип
   со значениями истина, ложь). Все операции отношений:</p>
<pre>
            ==   !=   <   >   <=   >=
</pre>
<p>дают в результате целое 1, если отношение выполняется, и 0 в противном
   случае. Обычно определяют константы TRUE как 1 и FALSE как 0.</p>
<p>В операторе if, если выражение имеет ненулевое значение,
   выполняется первый оператор, а иначе выполняется второй (если
   он указан). Таким образом, в качестве условия допускается любое выражение
   типа целое или указатель. Пусть a целое, тогда</p>
<pre>
             if (a)  // ...

   эквивалентно

             if (a != 0) ...

        Логические операции

             &&    ||   !
</pre>
<p>обычно используются в условиях. В операциях && и || второй операнд
   не вычисляется, если результат определяется значением первого
   операнда. Например, в выражении</p>
<pre>
             if (p && l<p->count)  // ...
</pre>
<p>сначала проверяется значение p, и только если оно не равно нулю, то
   проверяется отношение l<p->count.</p>
<p>Некоторые простые операторы if удобно заменять выражениями
   условия. Например, вместо оператора</p>
<pre>
             if (a <= b)
                max = b;
             else
                max = a;
</pre>
<p>лучше использовать выражение</p>
<pre>
             max = (a<=b) ? b : a;
</pre>
<p>Условие в выражении условия не обязательно окружать скобками, но
   если их использовать, то выражение становится понятнее.</p>
<p>Простой переключатель (switch) можно записать с помощью
   серии операторов if. Например,</p>
<pre>
              switch (val) {
              case 1:
                  f();
                  break;
              case 2:
                  g();
                  break;
              default:
                  h();
                  break;
              }
</pre>
<p>можно эквивалентно задать так:</p>
<pre>
              if (val == 1)
                 f();
              else if (val == 2)
                 g();
              else
                 h();
</pre>
<p>Смысл обеих конструкций совпадает, но все же первая предпочтительнее,
  поскольку в ней нагляднее показана суть операции: проверка на
  совпадение значения val со значением из множества констант. Поэтому в
  нетривиальных случаях запись, использующая переключатель, понятнее.</p>
<p>Нужно позаботиться о каком-то завершении оператора, указанного
  в варианте переключателя, если только вы не хотите, чтобы стали
  выполняться операторы из следующего варианта. Например,
  переключатель</p>
<pre>
             switch (val) {       // возможна ошибка
             case 1:
                 cout << "case 1\n";
             case 2:
                 cout << "case 2\n";
             default:
                 cout << "default: case not found\n";
             }
</pre>
<p>при val==1 напечатает к большому удивлению непосвященных:</p>
<pre>
             case 1
             case 2
             default: case not found
</pre>
<p>Имеет смысл отметить в комментариях те редкие случаи, когда стандартный
   переход на следующий вариант оставлен намеренно. Тогда этот переход
   во всех остальных случаях можно смело считать ошибкой. Для
   завершения оператора в варианте чаще всего используется break, но
   иногда используются return и даже goto. Приведем пример:</p>
<pre>
             switch (val)  {       // возможна ошибка
             case 0:
                 cout << "case 0\n";
             case1:
             case 1:
                 cout << "case 1\n";
                 return;
             case 2:
                 cout << "case 2\n";
                 goto case1;
             default:
                 cout << "default: case not found\n";
                 return;
             }
</pre>
<p>Здесь при значении val равном 2 мы получим:</p>
<pre>
             case 2
             case 1
</pre>
<p>Отметим, что метку варианта нельзя использовать в операторе goto:</p>
<pre>
             goto case 2;  // синтаксическая ошибка
</pre>

<a name="#goto"></a><h5>3.3.2 Оператор goto</h5>
<p>Презираемый оператор goto все-таки есть в С++:</p>
<pre>
             goto идентификатор;

             идентификатор: оператор
</pre>
<p>Вообще говоря, он мало используется в языках высокого уровня, но
   может быть очень полезен, если текст на С++ создается не человеком,
   а автоматически, т.е. с помощью программы. Например,
   операторы goto используются при создании анализатора по заданной
   грамматике языка с помощью программных средств.
   Кроме того, операторы goto могут пригодиться в тех случаях,
   когда на первый план выходит скорость работы программы. Один из
   них - когда в реальном времени происходят какие-то вычисления во
   внутреннем цикле программы.</p>
<p>Есть немногие ситуации и в обычных программах, когда применение
   goto оправдано. Одна из них - выход из вложенного цикла или
   переключателя. Дело в том, что оператор break во вложенных циклах
   или переключателях позволяет перейти только на один уровень выше.<br>
   Приведем пример:</p>
<pre>
             void f()
             {
               int i;
               int j;

               for ( i = 0; i &lt; n; i++)
                   for (j = 0; j&lt;m; j++)
                       if (nm[i][j] == a) goto found;
                   // здесь a не найдено
                   // ...
               found:
                   //  nm[i][j] == a
             }
</pre>
<p>Есть еще оператор continue, который позволяет перейти на конец
   цикла. Что это значит, объяснено в п.<a href="#driver">3.1.5</a>.</p>

<a name="#comment"></a><h4>3.4 Комментарии и расположение текста</h4>
<p>Программу гораздо легче читать, и она становится намного понятнее, если
   разумно использовать комментарии и систематически выделять текст
   программы пробелами. Есть несколько способов расположения текста
   программы, но нет причин считать, что один из них - наилучший. Хотя
   у каждого свой вкус. То же можно сказать и о комментариях.</p>
<p>Однако можно заполнить программу такими комментариями, что читать
   и понимать ее будет только труднее. Транслятор не в силах понять
   комментарий, поэтому он не может убедиться в том, что комментарий:</p>
<ol>
<li>осмысленный
<li>действительно описывает программу
<li>не устарел
</ol>
<p>Во многих программах попадаются непостижимые, двусмысленные и просто
   неверные комментарии. Лучше вообще обходиться без них, чем давать
   такие комментарии.</p>
<p>Если некий факт можно прямо выразить в языке, то так и следует
   делать, и не надо считать, что достаточно упомянуть его в комментарии.
   Последнее замечание относится к комментариям, подобным приведенным
   ниже:</p>
<pre>
        // переменную "v" необходимо инициализировать.

        // переменная "v" может использоваться только в функции "f()".

        // до вызова любой функции из этого файла
        // необходимо вызвать функцию "init()".

        // в конце своей программы вызовите функцию "cleanup()".

        // не используйте функцию "weird()".

        // функция "f()" имеет два параметра.
</pre>
<p>При правильном программировании на С++ такие комментарии обычно
   оказываются излишними. Чтобы именно эти комментарии стали ненужными,
   можно воспользоваться правилами связывания (п.<a href="chap4.shtml#binding">4.2</a>) и областей
   видимости, а также правилами инициализации и уничтожения объектов
   класса (п.<a href="chap5.shtml#constr">5.5</a>).</p>
<p>Если некоторое утверждение выражается самой программой, не нужно
   повторять его в комментарии. Например:</p>
<pre>
           a = b + c;      // a  принимает значение b+c
           count++;        // увеличим счетчик count
</pre>
<p>Такие комментарии хуже, чем избыточные. Они раздувают объем текста,
   затуманивают программу и могут быть даже ложными. В то же время
   комментарии именно такого рода используют для примеров в учебниках
   по языкам программирования, подобных этой книге. Это одна из
   многих причин, по которой учебная программа отличается от настоящей.</p>
<p>Можно рекомендовать такой стиль введения комментариев в
   программу:</p>
<ol>
<li>начинать с комментария каждый файл программы: указать в
           общих чертах, что в ней определяется, дать ссылки на
           справочные руководства, общие идеи по сопровождению
           программы и т.д.;
<li>снабжать комментарием каждое определение класса или шаблона
           типа;
<li>комментировать каждую нетривиальную функцию, указав: ее
           назначение, используемый алгоритм (если только он неочевиден)
           и, возможно, предположения об окружении, в котором работает
           функция;
<li>комментировать определение каждой глобальной переменной;
<li>давать некоторое число комментариев в тех местах, где
           алгоритм неочевиден или непереносим;
<li>больше практически ничего.
</ol>
<p>Приведем пример:</p>
<pre>
         //  tbl.c: Реализация таблицы имен.

         /*
                 Использован метод Гаусса
             см. Ральстон "Начальный курс по ..." стр. 411.
         */

          // в swap() предполагается, что стек AT&T начинается с 3B20.

          /************************************

             Авторские права (c) 1991 AT&T, Inc
             Все права сохранены

          **************************************/
</pre>
<p>Правильно подобранные и хорошо составленные комментарии играют в
   программе важную роль. Написать хорошие комментарии не менее
   трудно, чем саму программу, и это - искусство, в котором стоит
   совершенствоваться.</p>
<p>Заметим, что если в функции используются только комментарии
   вида //, то любую ее часть можно сделать комментарием с помощью
   /* */, и наоборот.</p>

<a name="#exercise"></a><h4>3.5 Упражнения</h4>
<ol>
<li>(*1) Следующий цикл for перепишите с помощью оператора while:

             for (i=0; i<max_length; i++)
                 if (input_line[i] == '?') quest_count++;

      Запишите цикл, используя в качестве его управляющей переменной
   указатель так, чтобы условие имело вид *p=='?'.
<li>(*1) Укажите порядок вычисления следующих выражений, задав полную
      скобочную структуру:

              a = b + c * d << 2 & 8
              a & 077 != 3
              a == b || a == c && c < 5
              c = x != 0
              0 <= i < 7
              f(1,2) + 3
              a = - 1 + + b -- - 5
              a = b == c ++
              a = b = c = 0
              a[4][2] *= * b ? c : * d * 2
              a-b, c=d

<li>(*2) Укажите 5 различных конструкций на С++, значение которых
      неопределено.
<li>(*2) Приведите 10 разных примеров непереносимых конструкций
      на С++.
<li>(*1) Что произойдет при делении на нуль в вашей программе на С++?
      Что будет в случае переполнения или потери значимости?
<li>(*1) Укажите порядок вычисления следующих выражений, задав их
      полную скобочную структуру:

              *p++
              *--p
              ++a--
              (int*)p->m
              *p.m
              *a[i]

<li>(*2) Напишите такие функции: strlen() - подсчет длины строки,
      strcpy() - копирование строк и strcmp() - сравнение строк. Какими
      должны быть типы параметров и результатов функций? Сравните их
      со стандартными версиями, имеющимися в <string.h> и в вашем
      руководстве.
<li>(*1) Выясните, как ваш транслятор отреагирует на такие ошибки:
<pre>
              void f(int a, int b)
              {
                if (a = 3)  // ...
                if (a&077 == 0)  // ...
                a := b+1;
              }
</pre>
       Посмотрите, какова будет реакция на более простые ошибки.
<li>(*2) Напишите функцию cat(), которая получает два параметра-строки
      и возвращает строку, являющуюся их конкатенацией. Для
      результирующей строки используйте память, отведенную с помощью
      new. Напишите функцию rev() для перевертывания строки, переданной
      ей в качестве параметра. Это означает, что после вызова rev(p)
      последний символ p станет первым и т.д.
<li>(*2) Что делает следующая функция?

            void send(register* to, register* from, register count)
            // Псевдоустройство. Все комментарии сознательно удалены
            {
               register n=(count+7)/8;
               switch (count%8) {
                  case 0:  do {  *to++ = *from++;
                  case 7:        *to++ = *from++;
                  case 6:        *to++ = *from++;
                  case 5:        *to++ = *from++;
                  case 4:        *to++ = *from++;
                  case 3:        *to++ = *from++;
                  case 2:        *to++ = *from++;
                  case 1:        *to++ = *from++;
                               } while (--n>0);
              }
            }

       Каков может быть смысл этой функции?
<li>(*2) Напишите функцию atoi(), которая имеет параметр - строку цифр
       и возвращает соответствующее ей целое. Например, atoi("123")
       равно 123. Измените функцию atoi() так, чтобы она могла
       переводить в число последовательность цифр не только в десятичной,
       но и в восьмеричной и шестнадцатеричной записи, принятой в С++.
       Добавьте возможность перевода символьных констант С++. Напишите
       функцию itoa() для перевода целого значения в строковое
       представление.
<li>(*2) Перепишите функцию get_token() (п.3.12) так, чтобы она читала
       целую строку в буфер, а затем выдавала лексемы, читая по
       символу из буфера.
<li>(*2) Введите в программу калькулятора из 
       п.<a href="#calc">3.1</a> такие функции, как
       sqrt(), log() и sin(). Подсказка: задайте предопределенные
       имена и вызывайте функции с помощью массива указателей на них.
       Не забывайте проверять параметры, передаваемые этим
       функциям.
<li>(*3) Введите в калькулятор возможность определять пользовательские
       функции. Подсказка: определите функцию как последовательность
       операторов, будто бы заданную самим пользователем. Эту
       последовательность можно хранить или как строку символов, или
       как список лексем. Когда вызывается функция, надо выбирать и
       выполнять операции. Если пользовательские функции могут
       иметь параметры, то придется придумать форму записи и для них.
<li>(*1.5) Переделайте программу калькулятора, используя структуру
       symbol вместо статических переменных name_string и number_value:
<pre>
              struct symbol {
                  token_value tok;
                  union {
                    double number_value;
                    char*  name_string;
                  };
              };
</pre>
<li><a name="#3.5.15"></a>(*2.5) Напишите программу, которая удаляет все комментарии из
      программы на С++. Это значит, надо читать символы из cin и
      удалять комментарии двух видов: // и /* */. Получившийся текст
      запишите в cout. Не заботьтесь о красивом виде получившегося
      текста (это уже другая, более сложная задача). Корректность
      программ неважна. Нужно учитывать возможность появления символов
      //, /* и */  в комментариях, строках и символьных константах.
<li>(*2) Исследуйте различные программы и выясните, какие способы
      выделения текста пробелами и какие комментарии используются.
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap4.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>