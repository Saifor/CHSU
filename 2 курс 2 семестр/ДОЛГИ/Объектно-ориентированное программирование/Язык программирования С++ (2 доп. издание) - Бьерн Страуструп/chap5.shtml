<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='Статьи' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 5<br>
Классы</h3>

<p align="right"><i>"Эти типы не абстрактные, они столь же реальны,<br>
как int и float"<br>
- Даг Макилрой</i></p>

<p>В этой главе описываются возможности определения новых типов,
   для которых доступ к данным ограничен заданным множеством
   функций, осуществляющих его. Объясняется, как можно использовать
   члены структуры данных, как ее защищать, инициализировать и,
   наконец, уничтожать. В примерах приведены простые классы для
   управления таблицей имен, работы со стеком, множеством и
   реализации дискриминирующего (т.е. надежного) объединения.
   Следующие три главы завершают описание возможностей С++ для
   построения новых типов, и в них содержится больше интересных
   примеров.</p>

<a name="#introduct"></a><h4>5.1 Введение и краткий обзор</h4>
<p>Понятие класса, которому посвящена эта и три следующих главы, служит
  в С++ для того, чтобы дать программисту инструмент построения новых
  типов. Ими пользоваться не менее удобно, чем встроенными.
  В идеале использование определенного пользователем типа не должно
  отличаться от использования встроенных типов. Различия возможны только
  в способе построения.</p>
<p>Тип есть вполне конкретное представление некоторого понятия.
  Например, в С++ тип float с операциями +, -, * и т.д. является
  хотя и ограниченным, но конкретным представлением математического
  понятия вещественного числа. Новый тип создается для того, чтобы
  стать специальным и конкретным представлением понятия, которое не находит
  прямого и естественного отражения среди встроенных типов. Например,
  в программе из области телефонной связи можно ввести тип
  trunk_module (линия-связи), в видеоигре - тип explosion (взрыв),
  а в программе, обрабатывающей текст, - тип list_of_paragraphs
  (список-параграфов). Обычно проще понимать и изменять программу,
  в которой типы хорошо представляют используемые в задаче понятия.
  Удачно подобранное множество пользовательских типов делает программу
  более ясной. Оно позволяет транслятору обнаруживать недопустимое
  использование объектов, которое в противном случае останется
  невыявленным до отладки программы.</p>
<p>Главное в определении нового типа - это отделить несущественные
  детали реализации (например, расположение данных в объекте нового
  типа) от тех его характеристик, которые существенны для правильного
  его использования (например, полный список функций, имеющих доступ
  к данным). Такое разделение обеспечивается тем, что вся работа со
  структурой данных и внутрение, служебные операции над нею доступны
  только через специальный интерфейс (через "одно горло").</p>
<p>Глава состоит из четырех частей:</p>
<p>п.<a href="#members">5.2</a> Классы и члены. Здесь вводится основное понятие
           пользовательского типа, называемого классом. Доступ к объектам
           класса может ограничиваться множеством функций, описания
           которых входят в описание класса. Эти функции называются
           функциями-членами и друзьями. Для создания объектов класса
           используются специальные функции-члены, называемые
           конструкторами. Можно описать специальную функцию-член
           для удаления объектов класса при его уничтожении. Такая
           функция называется деструктором.</p>
<p>п.<a href="#iterf">5.3</a> Интерфейсы и реализации. Здесь приводятся два примера
           разработки, реализации и использования классов.</p>
<p>п.<a href="#elseclass">5.4</a> Дополнительные свойства классов. Здесь приводится много
           дополнительных подробностей о классах. Показано, как
           функции, не являющейся членом класса, предоставить доступ
           к его частной части. Такую функцию называют другом класса.
           Вводятся понятия статических членов класса и указателей
           на члены класса. Здесь же показано, как определить
           дискриминирующее объединение.</p>
<p>п.<a href="#constr">5.5</a> Конструкторы и деструкторы. Объект может создаваться как
           автоматический, статический или как объект в свободной
           памяти. Кроме того, объект может быть членом некоторого
           агрегата (массива или другого класса), который тоже
           можно размещать одним из этих трех способов. Подробно
           объясняется использование конструкторов и деструкторов,
           описывается применение определяемых пользователем функций
           размещения в свободной памяти и функций освобождения памяти.</p>

<a name="#members"></a><h4>5.2 Классы и члены</h4>
<p>Класс - это пользовательский тип. Этот раздел знакомит с основными
  средствами определения класса, создания его объектов, работы с
  такими объектами и, наконец, удаления этих объектов после
  использования.</p>

<a name="#func"></a><h5>5.2.1 Функции-члены</h5>
<p>Посмотрим, как можно представить в языке понятие даты, используя
  для этого тип структуры и набор функций, работающих с переменными
  этого типа:<p>
<pre>
         struct date { int month, day, year; };
         date today;
         void set_date(date*, int, int, int);
         void next_date(date*);
         void print_date(const date*);
         // ...
</pre>
<p>Никакой явной связи между функциями и структурой date нет. Ее можно
  установить, если описать функции как члены структуры:</p>
<pre>
         struct date {
             int month, day, year;

             void set(int, int, int);
             void get(int*, int* int*);
             void next();
             void print();
         };
</pre>
<p>Описанные таким образом функции называются функциями-членами. Их можно
  вызывать только через переменные соответствующего типа, используя
  стандартную запись обращения к члену структуры:</p>
<pre>
           date today;
           date my_birthday;

           void f()
           {
             my_birthday.set(30,12,1950);
             today.set(18,1,1991);

             my_birthday.print();
             today.next();
            }
</pre>
<p>Поскольку разные структуры могут иметь функции-члены с одинаковыми
  именами, при определении функции-члена нужно указывать имя структуры:</p>
<pre>
           void date::next()
           {
             if (++day > 28 ) {
                // здесь сложный вариант
             }
           }
</pre>
<p>В теле функции-члена имена членов можно использовать без указания
  имени объекта. В таком случае имя относится к члену того объекта,
  для которого была вызвана функция.</p>

<a name="#class"></a><h5>5.2.2 Классы</h5>
<p>Мы определили несколько функций для работы со структурой date, но из ее
  описания не следует, что это единственные функции, которые
  предоставляют доступ к объектам типа date. Можно установить такое
  ограничение, описав класс вместо структуры:</p>
<pre>
             class date {
                int month, day, year;
             public:
                void set(int, int, int);
                void get(int*, int*, int*);
                void next();
                void print()
             };
</pre>
<p>Служебное слово public (общий) разбивает описание класса на две части.
  Имена, описанные в первой частной (private) части класса, могут
  использоваться только в функциях-членах. Вторая - общая часть -
  представляет собой интерфейс с объектами класса. Поэтому структура - это
  такой класс, в котором по определению все члены являются общими.
  Функции-члены класса определяются и используются точно так же, как
  было показано в предыдущем разделе:</p>
<pre>
       void date::print()     // печать даты  в принятом в США виде
       {
         cout << month << '/' << day << '/' << year ;
       }
</pre>
<p>Однако от функций не членов частные члены класса date уже ограждены:</p>
<pre>
       void backdate()
       {
         today.day--;    // ошибка
       }
</pre>
<p>Есть ряд преимуществ в том, что доступ к структуре данных ограничен
  явно указанным списком функций. Любая ошибка в дате (например,
  December, 36, 1985) могла быть внесена только функцией-членом,
  поэтому первая стадия отладки - локализация ошибки - происходит
  даже до первого пуска программы. Это только частный случай общего
  правила: любое изменение в поведении типа date может и должно
  вызываться изменениями в его членах. Другое преимущество в том, что
  потенциальному пользователю класса для работы с ним достаточно
  знать только определения функций-членов.</p>
<p>Защита частных данных основывается только на ограничении
  использования имен членов класса. Поэтому ее можно обойти с
  помощью манипуляций с адресами или явных преобразований типа,
  но это уже можно считать мошенничеством.</p>

<a name="#refitself"></a><h5>5.2.3 Ссылка на себя</h5>
<p>В функции-члене можно непосредственно использовать имена членов
  того объекта, для которого она была вызвана:</p>
<pre>
          class X {
            int m;
          public:
            int readm() { return m; }
          };

          void f(X aa, X bb)
          {
            int a = aa.readm();
            int b = bb.readm();
            // ...
          }
</pre>
<p>При первом вызове readm() m обозначает aa.m, а при втором - bb.m.<br>
      У функции-члена есть дополнительный скрытый параметр, являющийся
  указателем на объект, для которого вызывалась функция. Можно явно
  использовать этот скрытый параметр под именем this. Считается, что
  в каждой функции-члене класса X указатель this описан неявно как</p>
<pre>
          X *const this;
</pre>
<p>и инициализируется, чтобы указывать на объект, для которого
  функция-член вызывалась. Этот указатель нельзя изменять, поскольку
  он постоянный (*const). Явно описать его тоже нельзя, т.к. this -
  это служебное слово. Можно дать эквивалентное описание класса X:</p>
<pre>
         class X {
            int m;
         public:
            int readm() { return this->m; }
         };
</pre>
<p>Для обращения к членам использовать this излишне. В основном this
  используется в функциях-членах, непосредственно работающих с
  указателями. Типичный пример - функция, которая вставляет элемент
  в список с двойной связью:</p>
<pre>
           class dlink {
              dlink* pre;  // указатель на предыдущий элемент
              dlink* suc;  // указатель на следующий элемент
           public:
              void append(dlink*);
              // ...
           };

           void dlink::append(dlink* p)
           {
             p->suc = suc;    // т.е. p->suc = this->suc
             p->pre = this;   // явное использование "this"
             suc->pre = p;    // т.е. this->suc->pre = p
             suc = p;         // т.е. this->suc = p
           }

           dlink* list_head;

           void f(dlink* a, dlink* b)
           {
             // ...
             list_head->append(a);
             list_head->append(b);
           }
</pre>
<p>Списки с такой общей структурой служат фундаментом списочных классов,
   описываемых в главе 8. Чтобы присоединить звено к списку, нужно
   изменить объекты, на которые настроены указатели this, pre и suc.
   Все они имеют тип dlink, поэтому функция-член dlink::append() имеет
   к ним доступ. Защищаемой единицей в С++ является класс, а не отдельный
   объект класса.</p>
<p>Можно описать функцию-член таким образом, что объект, для которого
   она вызывается, будет доступен ей только по чтению. Тот факт, что
   функция не будет изменять объект, для которого она вызывается
   (т.е. this*), обозначается служебным словом const в конце списка
   параметров:</p>
<pre>
              class X {
                 int m;
              public:
                 readme() const { return m; }
                 writeme(int i) { m = i; }
              };
</pre>
<p>Функцию-член со спецификацией const можно вызывать для постоянных
    объектов, а функцию-член без такой спецификации - нельзя:</p>
<pre>
              void f(X& mutable, const X& constant)
              {
                mutable.readme();    // нормально
                mutable.writeme(7);  // нормально
                constant.readme();   // нормально
                constant.writeme(7); // ошибка
              }
</pre>
<p>В этом примере разумный транслятор смог бы обнаружить, что
     функция X::writeme() пытается изменить постоянный объект. Однако,
     это непростая задача для транслятора. Из-за раздельной
     трансляции он в общем случае не может гарантировать "постоянство"
     объекта, если нет соответствующего описания со спецификацией
     const. Например, определения readme() и writeme() могли быть в
     другом файле:</p>
<pre>
              class X {
                 int m;
              public:
                 readme() const;
                 writeme(int i);
              };
</pre>
<p>В таком случае описание readme() со спецификацией const существенно.</p>
<p>Тип указателя this в постоянной функции-члене класса X есть
    const X *const. Это значит, что без явного приведения с помощью this
    нельзя изменить значение объекта:</p>
<pre>
              class X {
                 int m;
              public:
                 // ...
                 void implicit_cheat() const { m++; }  // ошибка
                 void explicit_cheat() const { ((X*)this)->m++; }
                      // нормально
             };
</pre>
<p>Отбросить спецификацию const можно потому, что понятие
    "постоянства" объекта имеет два значения. Первое, называемое
    "физическим постоянством" состоит в том, что объект хранится
    в защищенной от записи памяти. Второе, называемое "логическим
    постоянством" заключается в том, что объект выступает как
    постоянный (неизменяемый) по отношению к пользователям. Операция
    над логически постоянным объектом может изменить часть данных
    объекта, если при этом не нарушается его постоянство
    с точки зрения пользователя. Операциями, ненарушающими логическое
    постоянство объекта, могут быть буферизация значений, ведение
    статистики, изменение переменных-счетчиков в постоянных
    функциях-членах.</p>
<p>Логического постоянства можно достигнуть приведением, удаляющим
    спецификацию const:</p>
<pre>
             class calculator1 {
                int cache_val;
                int cache_arg;
                // ...
             public:
                int compute(int i) const;
                // ...
             };

             int calculator1::compute(int i) const
             {
               if (i == cache_arg) return cache_val;
               // нелучший способ
               ((calculator1*)this)->cache_arg = i;
               ((calculator1*)this)->cache_val = val;
               return val;
             }
</pre>
<p>Этого же результата можно достичь, используя указатель на данные
    без const:</p>
<pre>
             struct cache {
                 int val;
                 int arg;
             };

             class calculator2 {
                 cache* p;
                 // ...
             public:
                 int compute(int i) const;
                 // ...
             };

             int calculator2::compute(int i) const
             {
               if (i == p->arg) return p->val;
               // нелучший способ
               p->arg = i;
               p->val = val;
               return val;
             }
</pre>
<p>Отметим, что const нужно указывать как в описании, так и в определении
   постоянной функции-члена. Физическое постоянство обеспечивается
   помещением объекта в защищенную по записи память, только если в классе
   нет конструктора (п.7.1.6).</p>

<a name="#init"></a><h5>5.2.4 Инициализация</h5>
<p>Инициализация объектов класса с помощью таких функций как set_date()
   - неэлегантное и чреватое ошибками решение. Поскольку явно не было
   указано, что объект требует инициализации, программист может либо забыть
   это сделать, либо сделать дважды, что может привести к столь же
   катастрофическим последствиям. Лучше дать программисту возможность
   описать функцию, явно предназначенную для инициализации объектов.
   Поскольку такая функция конструирует значение данного типа, она
   называется конструктором. Эту функцию легко распознать - она имеет
   то же имя, что и ее класс:</p>
<pre>
              class date {
                 // ...
                 date(int, int, int);
              };
</pre>
<p>Если в классе есть конструктор, все объекты этого класса будут
   проинициализированы. Если конструктору требуются параметры, их
   надо указывать:</p>
<pre>
              date today = date(23,6,1983);
              date xmas(25,12,0);  // краткая форма
              date my_birthday;    // неправильно, нужен инициализатор
</pre>
<p>Часто бывает удобно указать несколько способов инициализации
   объекта. Для этого нужно описать несколько конструкторов:</p>
<pre>
        class date {
           int month, day, year;
        public:
           // ...
           date(int, int, int);  // день, месяц, год
           date(int, int);       // день, месяц и текущий год
           date(int);            // день и текущие год и месяц
           date();               // стандартное значение: текущая дата
           date(const char*);    // дата в строковом представлении
        };
</pre>
<p>Параметры конструкторов подчиняются тем же правилам о типах
   параметров, что и все остальные функции 
   (п.<a href="chap4.shtml#tranship">4.6.6</a>). Пока конструкторы
   достаточно различаются по типам своих параметров, транслятор
   способен правильно выбрать конструктор:</p>
<pre>
           date today(4);
           date july4("July 4, 1983");
           date guy("5 Nov");
           date now;       // инициализация стандартным значением
</pre>
<p>Размножение конструкторов в примере c date типично. При разработке
   класса всегда есть соблазн добавить еще одну возможность, - а вдруг
   она кому-нибудь пригодится. Чтобы определить действительно нужные
   возможности, надо поразмышлять, но зато в результате, как правило,
   получается более компактная и понятная программа. Сократить число
   сходных функций можно с помощью стандартного значения параметра.
   В примере с date для каждого параметра можно задать стандартное
   значение, что означает: "взять значение из текущей даты".</p>
<pre>
                 class date {
                   int month, day, year;
                 public:
                   // ...
                   date(int d =0, int m =0, y=0);
                   // ...
                 };

                 date::date(int d, int m, int y)
                 {
                   day = d ? d : today.day;
                   month = m ? m : today.month;
                   year = y ? y : today.year;
                   // проверка правильности даты
                   // ...
                 }
</pre>
<p>Когда используется стандартное значение параметра, оно должно
   отличаться от всех допустимых значений параметра. В случае месяца и
   дня очевидно, что при значении нуль - это так, но неочевидно,
   что нуль подходит для значения года. К счастью, в европейском
   календаре нет нулевого года, т.к. сразу после 1 г. до р.х.
   (year==-1) идет 1 г. р.х. (year==1). Однако для обычной программы
   это, возможно, слишком тонкий момент.</p>
<p>Объект класса без конструктора может инициализироваться
   присваиванием ему другого объекта этого же класса. Это незапрещено и
   в том случае, когда конструкторы описаны:</p>
<pre>
              date d = today;  // инициализация присваиванием
</pre>
<p>На самом деле, имеется стандартный конструктор копирования,
   определенный как поэлементное копирование объектов одного класса.
   Если такой конструктор для класса X не нужен, можно переопределить
   его как конструктор копирования X::X(const X&). Подробнее поговорим
   об этом в п.<a href="chap7.shtml#assign">7.6.</a></p>

<a name="#del"></a><h5>5.2.5 Удаление</h5>
<p>Пользовательские типы чаще имеют, чем не имеют, конструкторы, которые
   проводят надлежащую инициализацию. Для многих типов требуется и
   обратная операция - деструктор, гарантирующая правильное удаление
   объектов этого типа. Деструктор класса X обозначается ~X ("дополнение
   конструктора"). В частности, для многих классов используется
   свободная память (см. п.<a href="chap3.shtml#freemem">3.2.6</a>), выделяемая конструктором и
   освобождаемая деструктором. Вот, например, традиционное определение
   типа стек, из которого для краткости полностью выброшена обработка
   ошибок:
<pre>
              class char_stack {
                 int size;
                 char* top;
                 char* s;
              public:
                 char_stack(int sz) { top=s=new char[size=sz]; }
                 ~char_stack()  { delete[] s; }  // деструктор
                 void push(char c) { *top++ = c; }
                 void pop()   { return *--top; }
             };
</pre>
<p>Когда объект типа char_stack выходит из текущей области видимости,
   вызывается деструктор:</p>
<pre>
             void f()
             {
               char_stack s1(100);
               char_stack s2(200);
               s1.push('a');
               s2.push(s1.pop());
               char ch = s2.pop();
               cout << ch << '\n';
             }
</pre>
<p>Когда начинает выполняться f(), вызывается конструктор char_stack,
   который размещает массив из 100 символов s1 и массив из 200
   символов s2. При возврате из f() память, которая была занята обоими
   массивами, будет освобождена.</p>

<a name="#sub"></a><h5>5.2.6 Подстановка</h5>
<p>Программирование с классами предполагает, что в программе появится
   множество маленьких функций. По сути, всюду, где в программе с
   традиционной организацией стояло бы обычное обращение к структуре
   данных, используется функция. То, что было соглашением, стало
   стандартом, проверяемым транслятором. В результате программа
   может стать крайне неэффективной. Хотя вызов функции в C++
   и не столь дорогостоящая операция по сравнению с другими
   языками, все-таки цена ее много выше, чем у пары обращений к памяти,
   составляющих тело тривиальной функции.</p>
<p>Преодолеть эту трудность помогают функции-подстановки (inline).
   Если в описании класса функция-член определена, а не только описана,
   то она считается подстановкой. Это значит, например, что при
   трансляции функций, использующих char_stack из предыдущего примера,
   не будет использоваться никаких операций вызова функций, кроме
   реализации операций вывода! Другими словами, при разработке такого
   класса не нужно принимать во внимание затраты на вызов функций.
   Любое, даже самое маленькое действие, можно смело определять как
   функцию без потери эффективности. Это замечание
   снимает наиболее часто приводимый довод в пользу общих членов
   данных.</p>
<p>Функцию-член можно описать со спецификацией inline и вне описания
   класса:</p>
<pre>
             class char_stack {
                int size;
                char* top;
                char* s;
             public:
                char pop();
                // ...
             };

             inline char char_stack::pop()
             {
               return *--top;
             }
</pre>
<p>Отметим, что недопустимо описывать разные определения функции-члена,
   являющейся подстановкой, в различных исходных файлах (п.<a href="referenc.shtml#R.7.1.2">R.7.1.2</a>).
   Это нарушило бы понятие о классе как о цельном типе.</p>

<a name="#iterf"></a><h4>5.3 Интерфейсы и реализации</h4>
<p>Что представляет собой хороший класс? Это нечто, обладающее хорошо
   определенным множеством операций. Нечто, рассматриваемое как
   "черный ящик", управлять которым можно только посредством этих
   операций. Нечто, чье фактическое представление можно изменить любым
   мыслимым способом, но не изменяя при этом способа использования
   операций. Нечто, что может потребоваться в нескольких экземплярах.</p>
<p>Очевидные примеры хороших классов дают контейнеры разных видов:
   таблицы, множества, списки, вектора, словари и т.д. Такой
   класс имеет операцию занесения в контейнер. Обычно имеется и
   операция проверки: был ли данный член занесен в контейнер?
   Могут быть операции упорядочивания всех членов и просмотра их
   в определенном порядке. Наконец, может быть операция удаления
   члена. Обычно контейнерные классы имеют конструкторы и деструкторы.</p>

<a name="#altern"></a><h5>5.3.1 Альтернативные реализации</h5>
<p>Пока описание общей части класса и функций-членов остается неизменным,
   можно, не влияя на пользователей класса, менять его реализацию.
   В подтверждение этого рассмотрим таблицу имен из программы
   калькулятора, приведенной в главе 3. Структура ее такова:</p>
<pre>
              struct name {
                char* string;
                name* next;
                double value;
              };
</pre>
<p>А вот вариант класса table (таблица имен):</p>
<pre>
              // файл table.h
              class table {
                 name* tbl;
              public:
                 table() { tbl = 0; }

                 name* look(char*, int = 0);
                 name* insert(char* s) { return look(s,1); }
              };
</pre>
<p>Эта таблица отличается от определенной в главе 3 тем, что это
   настоящий тип. Можно описать несколько таблиц, завести указатель
   на таблицу и т.д. Например:</p>
<pre>
              #include "table.h"

              table globals;
              table keywords;
              table* locals;

              main()
              {
                locals = new table;
                // ...
              }
</pre>
<p>Приведем реализацию функции table::look(), в которой используется
   линейный поиск в списке имен таблицы:</p>
<pre>
              #include <string.h>

              name* table::look(char* p, int ins)
              {
                for (name* n = tbl; n; n=n->next)
                    if (strcmp(p,n->string) == 0) return n;
                if (ins == 0) error("имя не найдено");

                name* nn = new name;
                nn->string = new char[strlen(p)+1];
                strcpy(nn->string,p);
                nn->value = 1;
                nn->next = tbl;
                tbl = nn;
                return nn;
              }
</pre>
<p>Теперь усовершенствуем класс table так, чтобы поиск имени шел
   по ключу (хэш-функции от имени), как это и было сделано в примере
   с калькулятором. Сделать это труднее, если соблюдать ограничение,
   требующее, чтобы не все программы, использующие приведенную версию
   класса table, надо было изменять:</p>
<pre>
               class table {
                  name** tbl;
                  int size;
               public:
                  table(int sz = 15);
                  ~table();

                  name* look(char*, int = 0);
                  name* insert(char* s) { return look(s,1); }
               };
</pre>
<p>Изменения в структуре данных и конструкторе произошли потому,
   что для хэширования таблица должна иметь определенный размер.
   Задание конструктора со стандартным значением параметра гарантирует,
   что старые программы, в которых не использовался размер таблицы,
   останутся верными. Стандартные значения параметров полезны
   в таких случаях, когда нужно изменить класс, не влияя на программы
   пользователей класса. Теперь конструктор и деструктор создают и
   уничтожают хэшированные таблицы:</p>
<pre>
               table::table(int sz)
               {
                 if (sz < 0) error("размер таблицы отрицателен");
                 tbl = new name*[size = sz];
                 for ( int i = 0; i<sz; i++) tbl[i] = 0;
               }

               table::~table()
               {
                 for (int i = 0; i<size; i++) {
                     name* nx;
                     for (name* n = tbl[i]; n; n=nx) {
                         nx = n->next;
                         delete n->string;
                         delete n;
                     }
                 }
                 delete tbl;
               }
</pre>
<p>Описав деструктор для класса name, можно получить более ясный и
   простой вариант table::~table(). Функция поиска практически
   совпадает с приведенной в примере калькулятора (п.<a href="chap3.shtml#calc">3.1</a>):</p>
<pre>
               name* table::look(const char* p, int ins)
               {
                 int ii = 0;
                 char* pp = p;
                 while (*pp) ii = ii<<1 ^ *pp++;
                 if (ii < 0) ii = -ii;
                 ii %= size;

                 for (name* n=tbl[ii]; n; n=n->next)
                     if (strcmp(p,n->string) == 0) return n;

                  name* nn = new name;
                  nn->string = new char[strlen(p)+1];
                  strcpy(nn->string,p);
                  nn->value = 1;
                  nn->next = tbl[ii];
                  tbl[ii] = nn;
                  return nn;
                }
</pre>
<p>Очевидно, что функции-члены класса должны перетранслироваться всякий
   раз, когда в описание класса вносится какое-либо изменение. В идеале
   такое изменение никак не должно отражаться на пользователях класса.
   К сожалению, обычно бывает не так. Для размещения переменной, имеющей
   тип класса, транслятор должен знать размер объекта класса. Если
   размер объекта изменится, нужно перетранслировать файлы, в которых
   использовался класс. Можно написать системную программу (и она даже
   уже написана), которая будет определять минимальное множество файлов,
   подлежащих перетрансляции после изменения класса. Но такая программа
   еще не получила широкого распространения.</p>
<p>Возможен вопрос: почему С++ был спроектирован таким образом,
   что после изменения частной части класса требуется перетрансляция
   программ пользователя? Почему вообще частная часть класса
   присутствует в описании класса? Иными словами, почему описания
   частных членов присутствуют в заголовочных файлах, доступных
   пользователю, если все равно недоступны для него в программе?
   Ответ один - эффективность. Во многих системах программирования
   процесс трансляции и последовательность команд, производящая
   вызов функции, будет проще, если размер автоматических (т.е.
   размещаемых в стеке) объектов известен на стадии трансляции.</p>
<p>Можно не знать определения всего класса, если представлять каждый
   объект как указатель на "настоящий" объект. Это позволяет решить
   задачу, поскольку все указатели будут иметь одинаковый размер, а
   размещение настоящих объектов будет проводиться только в одном файле,
   в котором доступны частные части классов. Однако, такое решение
   приводит к дополнительному расходу памяти на каждый объект и
   дополнительному обращению к памяти при каждом использовании члена.
   Еще хуже, что каждый вызов функции с автоматическим объектом
   класса требует вызовов функций выделения и освобождения памяти.
   К тому же становится невозможной реализация подстановкой
   функций-членов, работающих с частными членами класса. Наконец,
   такое изменение сделает невозможным связывание программ на С++ и на
   С, поскольку транслятор С будет по другому обрабатывать структуры
   (struct). Поэтому такое решение было сочтено неприемлемым для С++.</p>
<p>С другой стороны, С++ предоставляет средство для создания
  абстрактных типов, в которых связь между интерфейсом пользователя
  и реализацией довольно слабая. В главе 6 вводятся производные
  классы и описываются абстрактные базовые классы, а в 
  п.<a href="chap13.shtml#abstr">13.3</a> поясняется,
  как с помощью этих средств реализовать абстрактные типы. Цель этого -
  дать возможность определять пользовательские типы столь же эффективные
  и конкретные, как и стандартные, и дать основные средства определения
  более гибких вариантов типов, которые могут оказаться и не столь
  эффективными.</p>

<a name="#example"></a><h5>5.3.2 Законченный пример класса</h5>
<p>Программирование без упрятывания данных (в расчете на структуры)
  требует меньшего предварительного обдумывания задачи, чем
  программирование с упрятыванием данных (в расчете на классы).
  Структуру можно определить не очень задумываясь о том, как ее
  будут использовать. Когда определяется класс, внимание концентрируется
  на том, чтобы обеспечить для нового типа полный набор операций.
  Это важное смещение акцента в проектировании программ. Обычно
  время, затраченное на разработку нового типа, многократно окупается
  в процессе отладки и развития программы.</p>
<p>Вот пример законченного определения типа intset, представляющего
  понятие "множество целых":</p>
<pre>
             class intset {
               int cursize, maxsize;
               int  *x;
             public:
               intset(int m, int n);    // не более m целых из 1..n
               ~intset();

               int member(int t) const; // является ли t членом?
               void insert(int t);      // добавить к множеству t

               void start(int& i) const { i = 0; }
               void ok(int& i) const    { return i&lt;cursize; }
               void next(int& i) const  { return x[i++]; }
            };
</pre>
<p>Для проверки этого класса вначале создадим, а затем распечатаем
  множество случайных целых чисел. Это простое множество целых
  можно использовать для проверки, есть ли повторения в их
  последовательности. Но для большинства задач нужен, конечно,
  более развитый тип множества. Как всегда возможны ошибки, поэтому
  нужна функция:</p>
<pre>
            #include <iostream.h>

            void error(const char *s)
            {
              cerr << "set: " << s << '\n';
              exit(1);
            }
</pre>
<p>Класс intset используется в функции main(), для которой должно
  быть задано два параметра: первый определяет число создаваемых
  случайных чисел, а второй - диапазон их значений:</p>
<pre>
            int main(int argc, char* argv[])
            {
              if (argc != 3) error("нужно задавать два параметра");
              int count = 0;
              int m = atoi(argv[1]);    // число элементов множества
              int n = atoi(argv[2]);    // из диапазона 1..n
              intset s(m,n);

              while (count&lt;m) {
                int t = randint(n);
                if (s.member(t)==0) {
                    s.insert(t);
                    count++;
                }
              }

              print_in_order(&s);
            }
</pre>
<p>Значение счетчика параметров программы argc равно 3, хотя
   программа имеет только два параметра. Дело в том, что в argv[0]
   всегда передается дополнительный параметр, содержащий имя программы.
   Функция</p>
<pre>
            extern "C" int atoi(const char*)
</pre>
<p>является стандартной библиотечной функцией, преобразующей целое из
   строкового представления во внутреннюю двоичную форму. Как обычно,
   если вы не хотите иметь такое описание в своей программе, то вам
   надо включить в нее соответствующий заголовочный файл, содержащий
   описания стандартных библиотечных функций. Случайные числа
   генерируются с помощью стандартной функции rand:</p>
<pre>
              extern "C" int rand();  // будьте осторожны:
                                      // числа не совсем случайные
              int randint(int u)      // диапазон 1..u
              {
                int r = rand();
                if (r < 0) r = -r;
                return 1 + r%u;
              }
</pre>
<p>Подробности реализации класса мало интересны для пользователя,
   но в любом случае будут использоваться функции-члены.
   Конструктор размещает массив целых с размером, равным заданному
   максимальному размеру множества, а деструктор удаляет этот массив:</p>
<pre>
            intset::intset(int m, int n)  // не более m целых в 1..n
            {
              if (m&lt;1 || n&lt;m) error("недопустимый размер intset");
              cursize = 0;
              maxsize = m;
              x = new int[maxsize];
            }

            intset::~intset()
            {
              delete x;
            }
</pre>
<p>Целые добавляются таким образом, что они хранятся во множестве
   в возрастающем порядке:</p>
<pre>
         void intset::insert(int t)
         {
           if (++cursize > maxsize) error("слишком много элементов");
           int i = cursize-1;
           x[i] = t;

           while (i>0 && x[i-1]>x[i]) {
              int t = x[i];     // поменять местами x[i] и x[i-1]
              x[i] = x[i-1];
              x[i-1] = t;
              i--;
           }
         }
</pre>
<p>Чтобы найти элемент, используется простой двоичный поиск:</p>
<pre>
            int intset::member(int t) const  // двоичный поиск
            {
              int l = 0;
              int u = cursize-1;

              while (l <= u) {
                int m = (l+u)/2;
                if (t < x[m])
                   u = m-1;
                else if (t > x[m])
                   l = m+1;
                else
                   return 1;   // найден
              }
              return 0;        // не найден
            }
</pre>
<p>Наконец, нужно предоставить пользователю набор операций, с помощью
   которых он мог бы организовать итерацию по множеству в некотором
   порядке (ведь порядок, используемый в представлении intset,
   от него скрыт). Множество по своей сути не является внутренне
   упорядоченным, и нельзя позволить просто выбирать элементы массива
   (а вдруг завтра intset будет реализовано в виде связанного списка?).</p>
<p>Пользователь получает три функции: start() - для инициализации
   итерации, ok() - для проверки, есть ли следующий элемент, и next() -
   для получения следующего элемента:</p>

<a name="#elseclass"></a><h4>5.4 Еще о классах</h4>
<p>В этом разделе описаны дополнительные свойства класса. Описан
   способ обеспечить доступ к частным членам в функциях, не являющихся
   членами (п.<a href="#friend">5.4.1</a>). Описано, как разрешить коллизии имен членов
   (п.<a href="#clarific">5.4.2</a>) и как сделать описания классов 
   вложенными (п.<a href="#enclose">5.4.3</a>), но
   при этом избежать нежелательной вложенности (
   п.<a href="#static">5.4.4</a>). Вводится понятие
   статических членов (static), которые используются для представления
   операций и данных, относящихся к самому классу, а не к отдельным
   его объектам (
   п.<a href="#pointer">5.4.5</a>). Раздел завершается примером, показывающим,
   как можно построить дискриминирующее (надежное) объединение (
   п.<a href="#structco">5.4.6</a>).
</p>

<a name="#friend"></a><h5>5.4.1 Друзья</h5>
<p>Пусть определены два класса: vector (вектор) и matrix (матрица).
   Каждый из них скрывает свое представление, но дает полный набор операций
   для работы с объектами его типа. Допустим, надо определить функцию,
   умножающую матрицу на вектор. Для простоты предположим, что
   вектор имеет четыре элемента с индексами от 0 до 3, а в матрице
   четыре вектора тоже с индексами от 0 до 3. Доступ к элементам
   вектора обеспечивается функцией elem(), и аналогичная функция есть
   для матрицы. Можно определить глобальную функцию multiply
   (умножить) следующим образом:</p>
<pre>
             vector multiply(const matrix& m, const vector& v);
             {
               vector r;
               for (int i = 0; i&lt;3; i++) { // r[i] = m[i] * v;
                   r.elem(i) = 0;
                   for (int j = 0; j&lt;3; j++)
                       r.elem(i) +=m.elem(i,j) * v.elem(j);
               }
               return r;
             }
</pre>
<p>Это вполне естественное решение, но оно может оказаться очень
   неэффективным. При каждом вызове multiply() функция elem() будет
   вызываться 4*(1+4*3) раз. Если в elem() проводится настоящий
   контроль границ массива, то на такой контроль будет потрачено
   значительно больше времени, чем на выполнение самой функции, и в
   результате она окажется непригодной для пользователей. С другой
   стороны, если elem() есть некий специальный вариант доступа без
   контроля, то тем самым мы засоряем интерфейс с вектором и матрицей
   особой функцией доступа, которая нужна только для обхода контроля.</p>
<p>Если можно было бы сделать multiply членом обоих классов
   vector и matrix, мы могли бы обойтись без контроля индекса при
   обращении к элементу матрицы, но в то же время не вводить специальной
   функции elem(). Однако, функция не может быть членом двух классов.
   Надо иметь в языке возможность предоставлять функции, не являющейся
   членом, право доступа к частным членам класса. Функция - не член
   класса, - имеющая доступ к его закрытой части, называется другом
   этого класса. Функция может стать другом класса, если в его
   описании она описана как friend (друг). Например:</p>
<pre>
              class matrix;

              class vector {
                float v[4];
                // ...
                friend vector multiply(const matrix&, const vector&);
              };

              class matrix {
                vector v[4];
                // ...
                friend vector multiply(const matrix&, const vector&);
              };
</pre>
<p>Функция-друг не имеет никаких особенностей, за исключением права
   доступа к закрытой части класса. В частности, в такой функции
   нельзя использовать указатель this, если только она действительно
   не является членом класса. Описание friend является настоящим
   описанием. Оно вводит имя функции в область видимости класса,
   в котором она была описана, и при этом происходят обычные проверки
   на наличие других описаний такого же имени в этой области
   видимости. Описание friend может находится как в общей, так и в
   частной частях класса, это не имеет значения.</p>
<p>Теперь можно написать функцию multiply, используя элементы
   вектора и матрицы непосредственно:</p>
<pre>
             vector multiply(const matrix& m, const vector& v)
             {
               vector r;
               for (int i = 0; i&lt;3; i++) {  // r[i] = m[i] * v;
                   r.v[i] = 0;
                   for ( int j = 0; j&lt;3; j++)
                       r.v[i] +=m.v[i][j] * v.v[j];
               }
               return r;
             }
</pre>
<p>Отметим, что подобно функции-члену дружественная функция
   явно описывается в описании класса, с которым дружит. Поэтому она
   является неотъемлемой частью интерфейса класса наравне с
   функцией-членом.</p>
<p>Функция-член одного класса может быть другом другого класса:</p>
<pre>
        class x {
           // ...
           void f();
        };

        class y {
           // ...
           friend void x::f();
        };
</pre>
<p>Вполне возможно, что все функции одного класса являются друзьями
   другого класса. Для этого есть краткая форма записи:</p>
<pre>
          class x {
            friend class y;
            // ...
          };
</pre>
<p>В результате такого описания все функции-члены y становятся друзьями
   класса x.</p>

<a name="#clarific"></a><h5>5.4.2 Уточнение имени члена</h5>
<p>Иногда полезно делать явное различие между именами членов классов
   и прочими именами. Для этого используется операция :: (разрешения
   области видимости):</p>
<pre>
               class X {
                  int m;
               public:
                  int readm() const { return m; }
                  void setm(int m)  { X::m = m; }
              };
</pre>
<p>В функции X::setm() параметр m скрывает член m, поэтому к члену</p>

<a name="#enclose"></a><h5>5.4.3 Вложенные классы</h5>
<p>Описание класса может быть вложенным. Например:</p>
<pre>
             class set {
                struct setmem {
                   int mem;
                   setmem* next;
                   setmem(int m, setmem* n) { mem=m; next=n; }
                };
                setmem* first;
             public:
                set() { first=0; }
                insert(int m) { first = new setmem(m,first); }
                // ...
             };
</pre>
<p>Доступность вложенного класса ограничивается областью видимости
   лексически объемлющего класса:</p>
<pre>
            setmem m1(1,0);  // ошибка: setmem не находится
                             // в глобальной области видимости
</pre>
<p>Если только описание вложенного класса не является совсем простым,
   то лучше описывать этот класс отдельно, поскольку вложенные описания
   могут стать очень запутанными:</p>
<pre>
           class setmem {
           friend class set;  // доступно только для членов set
             int mem;
             setmem* next;
             setmem(int m, setmem* n) { mem=m; next=n; }

             // много других полезных членов
          };

          class set {
             setmem* first;
          public:
             set() { first=0; }
             insert(int m) { first = new setmem(m,first); }
             // ...
          };
</pre>
<p>Полезное свойство вложенности - это сокращение числа глобальных имен,
   а недостаток его в том, что оно нарушает свободу использования
   вложенных типов (см. п.<a href="chap12.shtml#component">12.3</a>).</p>
<p>Имя класса-члена (вложенного класса) можно использовать вне
   описания объемлющего его класса так же, как имя любого другого
   члена:</p>
<pre>
           class X {
              struct M1 { int m; };
           public:
              struct M2 { int m; };

              M1 f(M2);
          };

          void f()
          {   M1 a;      // ошибка: имя `M1' вне области видимости
              M2 b;      // ошибка: имя `M1' вне области видимости
              X::M1 c;   // ошибка: X::M1 частный член
              X::M2 d;   // нормально
          }
</pre>
<p>Отметим, что контроль доступа происходит и для имен вложенных
   классов.</p>
<p>В функции-члене область видимости класса начинается после
   уточнения X:: и простирается до конца описания функции. Например:</p>
<pre>
     M1 X::f(M2 a)    // ошибка: имя `M1' вне области видимости
        { /* ... */ }

    X::M1 X::f(M2 a)  // нормально
        { /* ... */ }

    X::M1 X::f(X::M2 a) // нормально, но третье уточнение X:: излишне
        { /* ... */ }
</pre>

<a name="#static"></a><h5>5.4.4 Статические члены</h5>
<p>Класс - это тип, а не некоторое данное, и для каждого объекта
   класса создается своя копия членов, представляющих данные. Однако,
   наиболее удачная реализация некоторых типов требует, чтобы все
   объекты этого типа имели некоторые общие данные. Лучше, если эти
   данные можно описать как часть класса. Например, в операционных
   системах или при моделировании управления задачами часто нужен
   список задач:</p>
<pre>
          class task {
             // ...
             static task* chain;
             // ...
          };
</pre>
</p>   Описав член chain как статический, мы получаем гарантию, что
   он будет создан в единственном числе, т.е. не будет создаваться
   для каждого объекта task. Но он находится в области видимости
   класса task, и может быть доступен вне этой области, если только
   описан в общей части. В этом случае имя члена должно уточняться
   именем класса:</p>
<pre>
           if (task::chain == 0)  // какие-то операторы
</pre>
<p>В функции-члене его можно обозначать просто chain. Использование
   статических членов класса может заметно сократить потребность в
   глобальных переменных.</p>
<p>Описывая член как статический, мы ограничиваем его область
   видимости и делаем его независимым от отдельных объектов его
   класса. Это свойство полезно как для функций-членов, так и для
   членов, представляющих данные:</p>
<pre>
           class task {
              // ...
              static task* task_chain;
              static void shedule(int);
              // ...
          };
</pre>
<p>Но описание статического члена - это только описание, и где-то
   в программе должно быть единственное определение для описываемого
   объекта или функции, например, такое:</p>
<pre>
             task* task::task_chain = 0;
             void task::shedule(int p) { /* ... */ }
</pre>
<p>Естественно, что и частные члены могут определяться подобным образом.</p>
<p>Отметим, что служебное слово static не нужно и даже нельзя
   использовать в определении статического члена класса. Если бы оно
   присутствовало, возникла бы неоднозначность: указывает ли оно на то,
   что член класса является статическим, или используется для
   описания глобального объекта или функции?</p>
<p>Слово static одно из самых перегруженных служебных слов в С
   и С++. К статическому члену, представляющему данные, относятся
   оба основных его значения: "статически размещаемый" , т.е.
   противоположный объектам, размещаемым в стеке или свободной памяти,
   и "статический" в смысле с ограниченной областью видимости, т.е.
   противоположный объектам, подлежащим внешнему связыванию. К
   функциям-членам относится только второе значение static.</p>

<a name="#pointer"></a><h5>5.4.5 Указатели на члены</h5>
<p>Можно брать адрес члена класса. Операция взятия адреса функции-члена
   часто оказывается полезной, поскольку цели и способы применения
   указателей на функции, о которых мы говорили в 
   п.<a href="chap4.shtml#pointer">4.6.9</a>, в равной
   степени относятся и к таким функциям. Указатель на член можно получить,
   применив операцию взятия адреса & к полностью уточненному имени
   члена класса, например, &class_name::member_name. Чтобы описать
   переменную типа "указатель на член класса X", надо использовать
   описатель вида X::*. Например:</p>
<pre>
             #include &lt;iostream.h>

             struct cl
             {
                char* val;
                void print(int x) { cout << val << x << '\n'; }
                cl(char* v) { val = v; }
             };
</pre>
<p>Указатель на член можно описать и использовать так:</p>
<pre>
            typedef void (cl::*PMFI)(int);

            int main()
            {
              cl z1("z1 ");
              cl z2("z2 ");
              cl* p = &z2;
              PMFI pf = &cl::print;
              z1.print(1);
              (z1.*pf)(2);
              z2.print(3);
              (p->*pf)(4);
            }
</pre>
<p>Использование typedef для замены трудно воспринимаемого описателя
   в С достаточно типичный случай. Операции .* и ->* настраивают
   указатель на конкретный объект, выдавая в результате функцию,
   которую можно вызывать. Приоритет операции () выше, чем у операций
   .* и ->*, поэтому нужны скобки.</p>
<p>Во многих случаях виртуальные функции (
   п.<a href="chap6.shtml#virt">6.2.5</a>) успешно
   заменяют указатели на функции.</p>

<a name="#structco"></a><h5>5.4.6 Структуры и объединения</h5>
<p>По определению структура - это класс, все члены которого общие,
   т.е. описание</p>
<pre>
           struct s { ...
</pre>
<p>это просто краткая форма описания</p>
<pre>
           class s { public: ...
</pre>
<p>Поименованное объединение определяется как структура, все члены
   которой имеют один и тот же адрес (п.<a href="referenc.shtml#R.9.5">R.9.5</a>). Если известно, что
   в каждый момент времени используется значение только одного члена
   структуры, то объявив ее объединением, можно сэкономить память.
   Например, можно использовать объединение для хранения лексем
   транслятора С:</p>
<pre>
            union tok_val {
               char* p;      // строка
               char v[8];    // идентификатор (не более 8 символов)
               long i;       // значения целых
               double d;     // значения чисел с плавающей точкой
            };
</pre>
<p>Проблема с объединениями в том, что транслятор в общем случае
   не знает, какой член используется в данный момент, и поэтому
   контроль типа невозможен. Например:</p>
<pre>
             void strange(int i)
             {
               tok_val x;
               if (i)
                  x.p = "2";
               else
                  x.d = 2;
               sqrt(x.d);     // ошибка, если i != 0
             }
</pre>
<p>Кроме того, определенное таким образом объединение нельзя
   инициализировать таким кажущимся вполне естественным способом:</p>
<pre>
          tok_val val1 = 12;   // ошибка: int присваивается  tok_val
          tok_val val2 = "12"; // ошибка: char* присваивается tok_val
</pre>
<p>Для правильной инициализации надо использовать конструкторы:</p>
<pre>
             union tok_val {
               char* p;    // строка
               char v[8];  // идентификатор (не более 8 символов)
               long i;     // значения целых
               double d;   // значения чисел с плавающей точкой

               tok_val(const char*);  // нужно выбирать между p и v
               tok_val(int ii)    { i = ii; }
               tok_val(double dd) { d = dd; }
             };
</pre>
<p>Эти описания позволяют разрешить с помощью типа членов неоднозначность
   при перегрузке имени функции (см. п.<a href="chap4.shtml#tranship">4.6.6</a>
   и п.<a href="chap7.shtml#useroper">7.3</a>). Например:</p>
<pre>
             void f()
             {
               tok_val a = 10;    // a.i = 10
               tok_val b = 10.0;  // b.d = 10.0
             }
</pre>
<p>Если это невозможно (например, для типов char* и char[8] или int
   и char и т.д.), то определить, какой член инициализируется, можно,
   изучив инициализатор при выполнении программы, или введя
   дополнительный параметр. Например:</p>
<pre>
             tok_val::tok_val(const char* pp)
             {
               if (strlen(pp) <= 8)
                  strncpy(v,pp,8);    // короткая строка
               else
                  p = pp;            // длинная строка
             }
</pre>
<p>Но лучше подобной неоднозначности избегать.</p>
<p>Стандартная функция strncpy() подобно strcpy() копирует
   строки, но у нее есть дополнительный параметр, задающий
   максимальное число копируемых символов.</p>
<p>То, что для инициализации объединения используются конструкторы,
   еще не гарантирует от случайных ошибок при работе с объединением, когда
   присваивается значение одного типа, а выбирается значение другого
   типа. Такую гарантию можно получить, если заключить объединение
   в класс, в котором будет отслеживаться тип заносимого значения :</p>
<pre>
            class tok_val {
            public:
               enum Tag { I, D, S, N };

            private:
               union {
                 const char* p;
                 char v[8];
                 long i;
                 double d;
               };

               Tag tag;

               void check(Tag t) { if (tag != t) error(); }
             public:
               Tag get_tag() { return tag; }

               tok_val(const char* pp);
               tok_val(long ii)   { i = ii; tag = I; }
               tok_val(double dd) { d = dd; tag = D; }

               long& ival()        { check(I); return i; }
               double& fval()      { check(D); return d; }
               const char*& sval() { check(S); return p; }
               char* id()          { check(N); return v; }
            };

            tok_val::tok_val(const char* pp)
            {
              if (strlen(pp) <= 8)  { // короткая строка
                 tag = N;
                 strncpy(v,pp,8);
              }
              else {                  // длинная строка
                 tag = S;
                 p = pp;              // записывается только указатель
              }
            }
</pre>
<p>Использовать класс tok_val можно так:</p>
<pre>
            void f()
            {
              tok_val t1("короткая");       // присваивается v
              tok_val t2("длинная строка"); // присваивается p
              char s[8];
              strncpy(s,t1.id(),8);         // нормально
              strncpy(s,t2.id(),8);         // check() выдаст ошибку
            }
</pre>
<p>Описав тип Tag и функцию get_tag() в общей части, мы гарантируем,
   что тип tok_val можно использовать как тип параметра. Таким образом,
   появляется надежная в смысле типов альтернатива описанию параметров
   с эллипсисом. Вот, например, описание функции обработки ошибок,
   которая может иметь один, два, или три параметра с типами char*,
   int или double:</p>
<pre>
             extern tok_val no_arg;

             void error(
                 const char* format,
                 tok_val a1 = no_arg,
                 tok_val a2 = no_arg,
                 tok_val a3 = no_arg);
</pre>

<a name="#constr"></a><h4>5.5 Конструкторы и деструкторы</h4>
<p>Если у класса есть конструктор, он вызывается всякий раз при
   создании объекта этого класса. Если у класса есть деструктор,
   он вызывается всякий раз, когда уничтожается объект этого класса.
   Объект может создаваться как:</p>
<ol>
<li>автоматический, который создается каждый раз, когда его
         описание встречается при выполнении программы, и уничтожается
         по выходе из блока, в котором он описан;
<li>статический, который создается один раз при запуске программы
         и уничтожается при ее завершении;
<li>объект в свободной памяти, который создается операцией new
         и уничтожается операцией delete;
<li>объект-член, который создается в процессе создания другого
         класса или при создании массива, элементом которого он
         является.
</ol>
<p>Кроме этого объект может создаваться, если в выражении явно
   используется его конструктор (п.<a href="chap7.shtml#useroper">7.3</a>) или 
   как временный объект
   (п.<a href="referenc.shtml#R.12.2">R.12.2</a>). В обоих случаях такой объект не имеет имени. В следующих
   подразделах предполагается, что объекты относятся к классу с
   конструктором и деструктором. В качестве примера используется
   класс table из п.<a href="#altern">5.3.1</a>.</p>

<a name="#locvar"></a><h5>5.5.1 Локальные переменные</h5>
<p>Конструктор локальной переменной вызывается каждый раз, когда при
   выполнении программы встречается ее описание. Деструктор локальной
   переменной вызывается всякий раз по выходе из блока, где она
   была описана. Деструкторы для локальных переменных вызываются в
   порядке, обратном вызову конструкторов при их создании:</p>
<pre>
            void f(int i)
            {
              table aa;
              table bb;
              if (i>0) {
                  table cc;
                  // ...
              }
              // ...
            }
</pre>
<p>Здесь aa и bb создаются (именно в таком порядке) при каждом вызове
   f(), а уничтожаются они при возврате из f() в обратном порядке -
   bb, затем aa. Если в текущем вызове f() i больше нуля, то cc
   создается после bb и уничтожается прежде него.</p>
<p>Поскольку aa и bb - объекты класса table, присваивание aa=bb
   означает копирование по членам bb в aa (см. 
   п.<a href="chap2.shtml#struct">2.3.8</a>). Такая
   интерпретация присваивания может привести к неожиданному (и обычно
   нежелательному) результату, если присваиваются объекты класса,
   в котором определен конструктор:</p>
<pre>
             void h()
             {
                table t1(100);
                table t2 = t1;   // неприятность
                table t3(200);

                t3 = t2;         // неприятность
             }
</pre>
   В этом примере конструктор table вызывается дважды: для t1 и t3.
   Он не вызывается для t2, поскольку этот объект инициализируется
   присваиванием. Тем не менее, деструктор для table вызывается три
   раза: для t1, t2 и t3! Далее, стандартная интерпретация
   присваивания - это копирование по членам, поэтому перед выходом
   из h() t1, t2 и t3 будут содержать указатель на массив имен, память
   для которого была выделена в свободной памяти при создании t1.
   Указатель на память, выделенную для массива имен при создании
   t3, будет потерян. Этих неприятностей можно избежать (см. 
   п.<a href="chap1.shtml#pattern">1.4.2</a> и п.<a href="chap7.shtml#assign">7.6</a>).
</p>

<a name="#statmem"></a><h5>5.5.2 Статическая память</h5>
<p>Рассмотрим такой пример:</p>
<pre>
          table tbl(100);

          void f(int i)
          {
             static table tbl2(i);
          }

          int main()
          {
            f(200);
            // ...
          }
</pre>
<p>Здесь конструктор, определенный в 
   п.<a href="#altern">5.3.1</a>, будет вызываться дважды:
   один раз для tbl и один раз для tbl2. Деструктор table::~table()
   также будет вызван дважды: для уничтожения tbl и tbl2 по выходе
   из main(). Конструкторы глобальных статических объектов в файле
   вызываются в том же порядке, в каком встречаются в файле
   описания объектов, а деструкторы для них вызываются в обратном
   порядке. Конструктор локального статического объекта вызывается,
   когда при выполнении программы первый раз встречается определение
   объекта.</p>
<p>Традиционно выполнение main() рассматривалось как выполнение
   всей программы. На самом деле, это не так даже для С. Уже
   размещение статического объекта класса с конструктором и (или)
   деструктором позволяет программисту задать действия, которые
   будут выполняться до вызова main()  и (или) по выходе из main().</p>
<p>Вызов конструкторов и деструкторов для статических объектов
   играет в С++ чрезвычайно важную роль. С их помощью можно обеспечить
   соответствующую инициализацию и удаление структур данных,
   используемых в библиотеках. Рассмотрим &lt;iostream.h>. Откуда
   берутся cin, cout и cerr? Когда они инициализируются? Более
   существенный вопрос: поскольку для выходных потоков используются
   внутренние буфера символов, то происходит выталкивание этих
   буферов, но когда? Есть простой и очевидный ответ: все действия
   выполняются соответствующими конструкторами и деструкторами до
   запуска main() и по выходе из нее (см. 
   п.<a href="chap10.shtml#close">10.5.1</a>). Существуют альтернативы
   использованию конструкторов и деструкторов для инициализации и
   уничтожения библиотечных структур данных, но все они или очень
   специализированы, или неуклюжи, или и то и другое вместе.</p>
<p>Если программа завершается обращение к функции exit(), то
   вызываются деструкторы для всех построенных статических объектов.
   Однако, если программа завершается обращением к abort(), этого
   не происходит. Заметим, что exit() не завершает
   программу немедленно. Вызов exit() в деструкторе может привести
   к бесконечной рекурсии. Если нужна гарантия, что будут уничтожены
   как статические, так и автоматические объекты, можно воспользоваться
   особыми ситуациями (п.<a href="chap9.shtml">9</a>).</p>
<p>Иногда при разработке библиотеки бывает необходимо или просто
   удобно создать тип с конструктором и деструктором только для
   одной цели: инициализации и уничтожения объектов. Такой тип
   используется только один раз для размещения статического объекта,
   чтобы вызвать конструкторы и деструкторы.</p>

<a name="#freemem"></a><h5>5.5.3 Свободная память</h5>
<p>Рассмотрим пример:</p>
<pre>
            main()
            {
               table* p = new table(100);
               table* q = new table(200);
               delete p;
               delete p;  // вероятно, вызовет ошибку при выполнении
             }
</pre>
<p>Конструктор table::table() будет вызываться дважды, как и деструктор
   table::~table(). Но это ничего не значит, т.к. в С++ не
   гарантируется, что деструктор будет вызываться только для объекта,
   созданного операцией new. В этом примере q не уничтожается вообще,
   зато p уничтожается дважды! В зависимости от типа p и q программист
   может считать или не считать это ошибкой. То, что объект не
   удаляется, обычно бывает не ошибкой, а просто потерей памяти. В то же
   время повторное удаление p - серьезная ошибка. Повторное применение
   delete к тому же самому указателю может привести к бесконечному
   циклу в подпрограмме, управляющей свободной памятью. Но в языке
   результат повторного удаления не определен, и он зависит от
   реализации.</p>
<p>Пользователь может определить свою реализацию операций new и
   delete (см. п.<a href="chap3.shtml#freemem">3.2.6</a> и 
   п.<a href="chap6.shtml#freemem">6.7</a>). Кроме того, можно установить
   взаимодействие конструктора или деструктора с операциями new и
   delete (см. п.<a href="#litlobj">5.5.6</a> и 
   п.<a href="chap6.shtml#intruct">6.7.2</a>). Размещение массивов в свободной
   памяти обсуждается в п.<a href="#arrayobj">5.5.5</a>.</p>

<a name="#objmember"></a><h5>5.5.4 Объекты класса как члены</h5>
<p>Рассмотрим пример:</p>
<pre>
            class classdef {
               table members;
               int no_of_members;
               // ...
               classdef(int size);
               ~classdef();
            };
</pre>
<p>Цель этого определения, очевидно, в том, чтобы classdef содержал
   член, являющийся таблицей размером size, но есть сложность: надо
   обеспечить вызов конструктора table::table() с параметром size. Это
   можно сделать, например, так:</p>
<pre>
           classdef::classdef(int size)
              :members(size)
           {
              no_of_members = size;
              // ...
            }

</pre>
<p>Параметр для конструктора члена (т.е. для table::table()) указывается
   в определении (но не в описании) конструктора класса, содержащего
   член (т.е. в определении classdef::classdef()). Конструктор для
   члена будет вызываться до выполнения тела того конструктора, который
   задает для него список параметров.</p>
<p>Аналогично можно задать параметры для конструкторов других членов
   (если есть еще другие члены):</p>
<pre>
             class classdef {
               table members;
               table friends;
               int no_of_members;
               // ...
               classdef(int size);
               ~classdef();
             };
</pre>
<p>Списки параметров для членов отделяются друг от друга запятыми (а не
   двоеточиями), а список инициализаторов для членов можно задавать в
   произвольном порядке:</p>
<pre>
             classdef::classdef(int size)
                 : friends(size), members(size), no_of_members(size)
             {
               // ...
             }
</pre>
<p>Конструкторы вызываются в том порядке, в котором они заданы в
   описании класса.</p>
<p>Подобные описания конструкторов существенны для типов,
   инициализация и присваивание которых отличны друг от друга, иными
   словами, для объектов, являющихся членами класса с конструктором,
   для постоянных членов или для членов типа ссылки. Однако, как
   показывает член no_of_members из приведенного примера, такие
   описания конструкторов можно использовать для членов любого
   типа.</p>
<p>Если конструктору члена не требуется параметров, то и не нужно
   задавать никаких списков параметров. Так, поскольку конструктор
   table::table() был определен со стандартным значением параметра,
   равным 15, достаточно такого определения:</p>
<pre>
            classdef::classdef(int size)
                : members(size), no_of_members(size)
            {
               // ...
            }
</pre>
<p>Тогда размер таблицы friends будет равен 15.</p>
<p>Если уничтожается объект класса, который сам содержит объекты
   класса (например, classdef), то вначале выполняется тело
   деструктора объемлющего класса, а затем деструкторы членов в порядке,
   обратном их описанию.</p>
<p>Рассмотрим вместо вхождения объектов класса в качестве членов
   традиционное альтернативное ему решение: иметь в классе указатели
   на члены и инициализировать члены в конструкторе:</p>
<pre>
             class classdef {
                table* members;
                table* friends;
                int no_of_members;
                // ...
             };

            classdef::classdef(int size)
            {
               members = new table(size);
               friends = new table;  // используется стандартный
                                     // размер table
               no_of_members = size;
               // ...
             }
</pre>
<p>Поскольку таблицы создавались с помощью операции new, они должны
   уничтожаться операцией delete:</p>
<pre>
            classdef::~classdef()
            {
              // ...
              delete members;
              delete friends;
            }
</pre>
<p>Такие отдельно создаваемые объекты могут оказаться полезными, но
   учтите, что members и friends указывают на независимые от них
   объекты, каждый из которых надо явно размещать и удалять. Кроме
   того, указатель и объект в свободной памяти суммарно занимают
   больше места, чем объект-член.</p>

<a name="#arrayobj"></a><h5>5.5.5 Массивы объектов класса</h5>
<p>Чтобы можно было описать массив объектов класса с конструктором,
   этот класс должен иметь стандартный конструктор, т.е. конструктор,
   вызываемый без параметров. Например, в соответствии с определением</p>
<pre>
            table tbl[10];
</pre>
<p>будет создан массив из 10 таблиц, каждая из которых инициализируется
   вызовом table::table(15), поскольку вызов table::table() будет
   происходить с фактическим параметром 15.</p>
<p>В описании массива объектов не предусмотрено возможности указать
   параметры для конструктора. Если члены массива обязательно надо
   инициализировать разными значениями, то начинаются трюки с
   глобальными или статическими членами.</p>
<p>Когда уничтожается массив, деструктор должен вызываться для
   каждого элемента массива. Для массивов, которые размещаются не
   с помощью new, это делается неявно. Однако для размещенных в свободной
   памяти массивов неявно вызывать деструктор нельзя, поскольку транслятор
   не отличит указатель на отдельный объект массива от указателя на начало
   массива, например:</p>
<pre>
            void f()
            {
              table* t1 = new table;
              table* t2 = new table[10];
              delete t1;  // удаляется одна таблица
              delete t2;  // неприятность:
                          // на самом деле удаляется 10 таблиц
            }
</pre>
<p>В данном случае программист должен указать, что t2 - указатель
   на массив:</p>
<pre>
            void g(int sz)
            {
              table* t1 = new table;
              table* t2 = new table[sz];
              delete t1;
              delete[] t2;
            }
</pre>
<p>Функция размещения хранит число элементов для каждого размещаемого
   массива. Требование использовать для удаления массивов только операцию
   delete[] освобождает функцию размещения от обязанности хранить счетчики
   числа элементов для каждого массива. Исполнение такой обязанности в
   реализациях С++ вызывало бы существенные потери времени и памяти
   и нарушило совместимость с С.</p>

<a name="#litlobj"></a><h5>5.5.6 Небольшие объекты</h5>
<p>Если в вашей программе много небольших объектов, размещаемых в
   свободной памяти, то может оказаться, что много времени тратится
   на размещение и удаление таких объектов. Для выхода из этой
   ситуации можно определить более оптимальный распределитель памяти
   общего назначения, а можно передать обязанность распределения
   свободной памяти создателю класса, который должен будет
   определить соответствующие функции размещения и удаления.</p>
<p>Вернемся к классу name, который использовался в примерах с
   table. Он мог бы определяться так:</p>
<pre>
            struct name {
               char* string;
               name* next;
               double value;

               name(char*, double, name*);
               ~name();

               void* operator new(size_t);
               void operator delete(void*, size_t);
             private:
               enum { NALL = 128 };
               static name* nfree;
             };
</pre>
<p>Функции name::operator new() и name::operator delete() будут
   использоваться (неявно) вместо глобальных функций operator new()
   и operator delete(). Программист может для конкретного типа написать
   более эффективные по времени и памяти функции размещения и
   удаления, чем универсальные функции operator new() и
   operator delete(). Можно, например, разместить заранее "куски"
   памяти, достаточной для объектов типа name, и связать их в список;
   тогда операции размещения и удаления сводятся к простым операциям
   со списком. Переменная nfree используется как начало списка
   неиспользованных кусков памяти:</p>
<pre>
              void* name::operator new(size_t)
              {
                register name* p = nfree;  // сначала выделить

                if (p)
                   nfree = p->next;
                else {                // выделить и связать в список
                   name* q = (name*) new char[NALL*sizeof(name) ];
                   for (p=nfree=&q[NALL-1]; q<p; p--) p->next = p-1;
                   (p+1)->next = 0;
                }

                return p;
              }
</pre>
<p>Распределитель памяти, вызываемый new, хранит вместе с объектом его
   размер, чтобы операция delete выполнялась правильно. Этого
   дополнительного расхода памяти можно легко избежать, если
   использовать распределитель, рассчитанный на конкретный тип. Так,
   на машине автора функция name::operator new() для хранения объекта
   name использует 16 байтов, тогда как стандартная глобальная
   функция operator new() использует 20 байтов.</p>
<p>Отметим, что в самой функции name::operator new() память нельзя
   выделять таким простым способом:</p>
<pre>
            name* q= new name[NALL];
</pre>
<p>Это вызовет бесконечную рекурсию, т.к. new будет вызывать
   name::name().</p>
<p>Освобождение памяти обычно тривиально:</p>
<pre>
            void name::operator delete(void* p, size_t)
            {
               ((name*)p)->next = nfree;
               nfree = (name*) p;
            }
</pre>
<p>Приведение параметра типа void* к типу name* необходимо, поскольку
   функция освобождения вызывается после уничтожения объекта, так что
   больше нет реального объекта типа name, а есть только кусок
   памяти размером sizeof(name). Параметры типа size_t в приведенных
   функциях name::operator new() и name::operator delete() не
   использовались. Как можно их использовать, будет показано в 
   п.<a href="chap6.shtml#freemem">6.7</a>.
   Отметим, что наши функции размещения и удаления используются
   только для объектов типа name, но не для массивов names.</p>

<a name="#exercise"></a><h4>5.6 Упражнения</h4>
<ol>
<li>(*1) Измените программу калькулятора из главы 3 так, чтобы
      можно было воспользоваться классом table.
<li>(*1) Определите tnode (п.<a href="referenc.shtml#R.9">R.9</a>) как класс с конструкторами и
      деструкторами и т.п., определите дерево из объектов типа
      tnode как класс с конструкторами и деструкторами и т.п.
<li>(*1) Определите класс intset (п.<a href="#example">5.3.2</a>) 
      как множество строк.
<li>(*1) Определите класс intset как множество узлов типа tnode.
      Структуру tnode придумайте сами.
<li>(*3) Определите класс для разбора, хранения, вычисления и печати
      простых арифметических выражений, состоящих из целых констант и
      операций +, -, * и /. Общий интерфейс класса должен выглядеть
      примерно так:
<pre>
              class expr {
                // ...
              public:
                expr(char*);
                int eval();
                void print();
              };
</pre>
<p>Конструктор expr::expr() имеет параметр-строку, задающую выражение.
      Функция expr::eval() возвращает значение выражения, а expr::print()
      выдает представление выражения в cout. Использовать эти функции
      можно так:</p>
<pre>
              expr("123/4+123*4-3");
              cout << "x = " << x.eval() << "\n";
              x.print();
</pre>
<p>Дайте два определения класса expr: пусть в первом для представления
       используется связанный список узлов, а во втором - строка
       символов. Поэкспериментируйте с разными форматами печати
       выражения, а именно: с полностью расставленными скобками,
       в постфиксной записи, в ассемблерном коде и т.д.</p>
<li>(*1) Определите класс char_queue (очередь символов) так, чтобы
      его общий интерфейс не зависел от представления. Реализуйте
      класс как: (1) связанный список и (2) вектор. О параллельности
      не думайте.
<li>(*2) Определите класс histogram (гистограмма), в котором ведется
      подсчет чисел в определенных интервалах, задаваемых в виде
      параметров конструктору этого класса. Определите функцию
      выдачи гистограммы. Сделайте обработку значений, выходящих за
      интервал. Подсказка: обратитесь к <task.h>.
<li>(*2) Определите несколько классов, порождающих случайные числа
      с определенными распределениями. Каждый класс должен иметь
      конструктор, задающий параметры распределения и функцию draw,
      возвращающую "следующее" значение. Подсказка: обратитесь к
      <task.h> и классу intset.
<li>(*2) Перепишите примеры date (п.<a href="#class">5.2.2</a> и 
      п.<a href="chap5.shtml#init">5.2.4</a>), char_stack
      (п.<a href="chap5.shtml#del">5.2.5</a>) и intset (
      п.<a href="#example">5.3.2</a>), не используя никаких функций-членов
      (даже конструкторов и деструкторов).  Используйте только class
      и friend. Проверьте каждую из новых версий и сравните их
      с версиями, в которых используются функции-члены.
<li>(*3) Для некоторого языка составьте определения класса для таблицы
      имен и класса, представляющего запись в этой таблице. Исследуйте
      транслятор для этого языка, чтобы узнать, какой должна быть настоящая
      таблица имен.
<li>(*2) Измените класс expr из упражнения 5 так, чтобы в выражении
      можно было использовать переменные и операцию присваивания =.
      Используйте класс для таблицы имен из упражнения 10.
<li>(*1) Пусть есть программа:
<pre>
             #include <iostream.h>

             main()
             {
                cout << "Всем привет\n";
             }
</pre>
<p>Измените ее так, чтобы она выдавала:</p>
<pre>
             Инициализация
             Всем привет
             Удаление
</pre>
<p>Саму функцию main() менять нельзя.</p>
</ol>


<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="chap6.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>