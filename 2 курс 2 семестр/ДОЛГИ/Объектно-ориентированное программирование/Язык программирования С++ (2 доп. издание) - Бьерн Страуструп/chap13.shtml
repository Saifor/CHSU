<HTML>
<HEAD>
<TITLE>Инфор Текнолоджи</TITLE>
<META NAME='description' CONTENT='Фирма Инфор Текнолоджи занимается разработкой информационных систем и приложений как для Интернет, так и для внутренних сетей организаций.'>
<META NAME='keywords' CONTENT=''>
<style type='text/css'>
.menu { position:absolute; 
		visibility:hidden; 
		background-color: white; 
		color: black;
		border-style: solid; 
		border-color: black; 
		border-width: 2px; 
		padding: 2px;
		font-size : 10px;
		font-family: 'arial', 'helvetica'; }
.menu A:hover {color: red;}
.menu A {text-decoration: none; color: black;}
</style>
<script type='text/javascript' language='JavaScript' Src='/js/bratt.js'></script>
<SCRIPT type='text/javascript' LANGUAGE='JavaScript' Src='/js/menu.js'></SCRIPT>
<LINK REL=STYLESHEET HREF='/css/main.css' TYPE='text/css'>

</HEAD>
<BODY BACKGROUND="#FFFFFF" TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0" onLoad="init()">
 <A NAME="top"></A>
 <SCRIPT LANGUAGE="javascript1.2" Src='/js/mkmenu.js'></SCRIPT>
 <TABLE BORDER='0' CELLPADDING='0' CELLSPACING='0' Class='Top' Width='100%'>
  <TR><TD><A HRef='/'><IMG SRC='/images/logo2.jpg' Width='454' Height='70' Alt='Инфор Текнолоджи' BORDER='0'></A></TD></TR>
 </TABLE>

 <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" Class='TMenu'><TR>
  <TD Height='20'><A HREF="/" onMouseOver="showButton('img_1', 'On_1'); activateMenu(1,10);" onMouseOut="showButton('img_1','Off_1'); return true;"><IMG SRC="/images/menu/m010.gif" ALT="О компании" Width='111' Height='18' BORDER="0" NAME="img_1"></A></TD>
  <TD Height='20'><A HREF="/job/" onMouseOver="showButton('img_3', 'On_3'); activateMenu(3,120);" onMouseOut="showButton('img_3','Off_3'); return true;"><IMG SRC="/images/menu/m050.gif" ALT="Работа" Width='73' Height='18' BORDER="0" NAME="img_3"></A></TD>
  <TD Height='20'><A HREF="/prj/" onMouseOver="showButton('img_5', 'On_5'); activateMenu(5,193);" onMouseOut="showButton('img_5','Off_5'); return true;"><IMG SRC="/images/menu/mprj0.gif" ALT="Проекты" Width='89' Height='18' BORDER="0" NAME="img_5"></A></TD>
  <TD Height='20'><A HREF="/dl/" onMouseOver="showButton('img_4', 'On_4'); activateMenu(4,282);" onMouseOut="showButton('img_4','Off_4'); return true;"><IMG SRC="/images/menu/m040.gif" ALT="Download" Width='100' Height='18' BORDER="0" NAME="img_4"></A></TD>
  <TD Width='100%'>&nbsp;</TD>
 </TR></TABLE>

<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
 <TR><td width="100%" height="12" colspan="2" valign="top">&nbsp;</td></TR>
 <TR VAlign='Top'><TD><table width='200' height='700' border='0' cellspacing='0' cellpadding='0' background='/images/left/sol.gif'>
<TR><TD WIDTH='10'>&nbsp;</TD><td valign='top'>
</td></TR></TABLE>
</TD>		
  <td width="100%" valign="top">
   <table width="540" border="0" cellspacing="0" cellpadding="0">
    <tr><td colspan="2"><img src="/images/shdrs/shdr703.gif" Width='220' Height='60' Alt='TЄрЄ№ш' border="0"></td></tr>
    <tr><td width="10">&nbsp;</td>
     <td>
<!----- START MAIN CONTENT ----->

<h3>Глава 13<br>
Проектирование библиотек</h3>

<p align="right"><i>Проект библиотеки - это проект языка,<br>
(фольклор фирмы Bell Laboratories)<br>
... и наоборот.<br>
- А. Кениг
</i></p>

<p>Эта глава содержит описание различных приемов, оказавшихся полезными
при создании библиотек для языка С++. В частности, в ней
рассматриваются конкретные типы, абстрактные типы, узловые классы,
управляющие классы и интерфейсные классы. Помимо этого обсуждаются
понятия обширного интерфейса и структуры области приложения,
использование динамической информации о типах и методы управления
памятью. Внимание акцентируется на том, какими свойствами должны
обладать библиотечные классы, а не на специфике языковых средств,
которые используются для реализации таких классов, и не на
определенных полезных функциях, которые должна предоставлять библиотека.</p>

<a name="introduct"></a><h4>13.1 Введение</h4>

<p>Разработка библиотеки общего назначения - это гораздо более трудная
  задача, чем создание обычной программы. Программа - это решение
  конкретной задачи для конкретной области приложения, тогда как
  библиотека должна предоставлять возможность решение для множества задач,
  связанных с многими областями приложения. В обычной программе
  позволительны сильные допущения об ее окружении, тогда как хорошую
  библиотеку можно успешно использовать в разнообразных окружениях,
  создаваемых множеством различных программ. Чем более общей и полезной
  окажется библиотека, тем в большем числе окружений она будет
  проверяться, и тем жестче будут требования к ее корректности, гибкости,
  эффективности, расширяемости, переносимости, непротиворечивости,
  простоте, полноте, легкости использования и т.д. Все же библиотека
  не может дать вам все, поэтому нужен определенный компромисс.
  Библиотеку можно рассматривать как специальный, интересный вариант
  того, что в предыдущей главе мы называли компонентом. Каждый
  совет по проектированию и сопровождению компонентов становится
  предельно важным для библиотек, и, наоборот, многие методы
  построения библиотек находят применение при проектировании различных
  компонентов.</p>
<p>Было бы слишком самонадеянно указывать как следует
  конструировать библиотеки. В прошлом оказались успешными несколько
  различных методов, а сам предмет остается полем активных дискуссий
  и экспериментов. Здесь только обсуждаются некоторые важные аспекты
  этой задачи и предлагаются некоторые приемы, оказавшиеся полезными
  при создании библиотек. Не следует забывать, что библиотеки предназначены
  для совершенно разных областей программирования, поэтому не приходится
  рассчитывать, что какой-то один метод окажется наиболее приемлемым для
  всех библиотек. Действительно, нет никаких причин полагать, что методы,
  оказавшиеся полезными при реализации средств параллельного
  программирования для ядра многопроцессорной операционной системы,
  окажутся наиболее приемлемыми при создании библиотеки, предназначенной
  для решения научных задач, или библиотеки, представляющей графический
  интерфейс.</p>
<p>Понятие класса С++ может использоваться самыми разными
  способами, поэтому разнообразие стилей программирования может
  привести к беспорядку. Хорошая библиотека для сведения такого
  беспорядка к минимуму обеспечивает согласованный стиль программирования,
  или, по крайней мере, несколько таких стилей. Этот подход делает
  библиотеку более "предсказуемой", а значит позволяет легче и быстрее
  изучить ее и правильно использовать. Далее описываются пять
  "архитипичных" классов, и обсуждаются присущие им сильные и слабые
  стороны: конкретные типы (п.<a href='#concret'>13.2</a>), абстрактные 
типы (п.<a href='#abstr'>13.3</a>), узловые классы (п.<a href='#nodal'>13.4</a>), 
интерфейсные классы (п.<a href='#infclass'>13.8</a>), управляющие
  классы (п.<a href='#manager'>13.9</a>). Все эти виды классов относятся к 
области понятий,  а не являются конструкциями языка. Каждое понятие 
воплощается  с помощью основной конструкции - класса. В идеале надо иметь
  минимальный набор простых и ортогональных видов классов, исходя из
  которого можно построить любой полезный и разумно-определенный класс.
  Идеал нами не достигнут и, возможно, недостижим вообще. Важно понять,
  что любой из перечисленных видов классов играет свою роль при
  проектировании библиотеки и, если рассчитывать на общее применение,
  никакой из них не является по своей сути лучше других.</p>
<p>В этой главе вводится понятие обширного интерфейса 
(п.<a href='#interf'>13.6</a>), чтобы выделить некоторый общий случай всех 
этих видов классов. С помощью него определяется понятие каркаса области 
приложения (п.<a href='#frame'>13.7</a>).<p>
<p>Здесь рассматриваются прежде всего классы, относящиеся строго к
  одному из перечисленных видов, хотя, конечно, используются
  классы и гибридного вида. Но использование класса гибридного вида
  должно быть результатом осознанного решения, возникшего при оценке
  плюсов и минусов различных видов, а не результатом пагубного стремления
  уклониться от выбора вида класса (слишком часто "отложим пока выбор"
  означает просто нежелание думать). Неискушенным разработчикам
  библиотеки лучше всего держаться подальше от классов гибридного
  вида. Им можно посоветовать следовать стилю программирования той из
  существующих библиотек, которая обладает возможностями, необходимыми для
  проектируемой библиотеки. Отважиться на создание библиотеки общего
  назначения может только искушенный программист, и каждый создатель
  библиотеки впоследствии будет "осужден" на долгие годы использования,
  документирования и сопровождения своего собственного создания.<p>
<p>В языке С++ используются статические типы. Однако, иногда
  возникает необходимость в дополнение к возможностям, непосредственно
  предоставляемым виртуальными функциями, получать динамическую информацию
  о типах. Как это сделать, описано в п.<a href='#dinamic'>13.5</a>. Наконец, 
перед всякой нетривиальной библиотекой встает задача управления памятью. 
Приемы ее  решения рассматриваются в п.<a href='#memory'>13.10</a>. 
Естественно, в этой главе 
невозможно  рассмотреть все методы, оказавшиеся полезными при создании 
библиотеки.  Поэтому можно отослать к другим местам книги, где рассмотрены
  следующие вопросы: работа с ошибками и устойчивость к ошибкам 
(п.<a href="chap9.shtml#method">9.8</a>),
  использование функциональных объектов  и обратных вызовов 
(п.<a href='chap10.shtml#manipul'>10.4.2</a> и 
п.<a href='chap9.shtml#exhaust'>9.4.3</a>) , 
использование шаблонов типа для построения классов
  (п.<a href='chap8.shtml#pattfunc'>8.4</a>).</p>
<p>Многие темы этой главы связаны с классами, являющимися контейнерами,
  (например, массивы и списки). Конечно, такие контейнерные классы
  являются шаблонами типа (как было сказано в 
  п.<a href='chap1.shtml'>1</a> и <a href='chap4.shtml#headfile'>4.3</a> 
  п.<a href='chap8.shtml'>8</a>). Но
  здесь для упрощения изложения в примерах используются классы,
  содержащие указатели на объекты типа класс. Чтобы получить настоящую
  программу, надо использовать шаблоны типа, как показано в главе 
<a href='chap8.shtml'>8</a>.</p>

<a name="concret"></a><h4>13.2 Конкретные типы</h4>

<p>Такие классы как vector (п.<a href='chap1.shtml#support'>1.4</a>), 
Slist (п.<a href='chap8.shtml#pattlist'>8.3</a>), 
date (п.<a href='chap5.shtml#class'>5.2.2</a>) и
  complex (п.<a href='chap7.shtml#useroper'>7.3</a>) являются конкретными в том смысле, что каждый из
  них представляет довольно простое понятие и обладает необходимым
  набором операций. Имеется взаимнооднозначное соответствие между
  интерфейсом класса и его реализацией. Ни один из них  (изначально)
  не предназначался в качестве базового для получения производных классов.
  Обычно в иерархии классов конкретные типы стоят особняком. Каждый
  конкретный тип можно понять изолированно, вне связи с другими классами.
  Если реализация конкретного типа удачна, то работающие с ним программы
  сравнимы по размеру и скорости со сделанными вручную программами,
  в которых используется некоторая специальная версия общего понятия.
  Далее, если произошло значительное изменение реализации, обычно
  модифицируется и интерфейс, чтобы отразить эти изменения. Интерфейс,
  по своей сути, обязан показать какие изменения оказались существенными
  в данном контексте. Интерфейс более высокого уровня оставляет
  больше свободы для изменения реализации, но может ухудшить
  характеристики программы. Более того, хорошая реализация зависит
  только от минимального числа действительно существенных классов.
  Любой из этих классов можно использовать без накладных расходов,
  возникающих на этапе трансляции или выполнения, и вызванных
  приспособлением к другим, "сходным" классам программы.</p>
<p>Подводя итог, можно указать такие условия, которым должен
  удовлетворять конкретный тип:
<ol>
<li>полностью отражать данное понятие и метод его реализации;
<li>с помощью подстановок и операций, полностью использующих
         полезные свойства понятия и его реализации, обеспечивать
         эффективность по скорости и памяти, сравнимую
         с "ручными программами";
<li>иметь минимальную зависимость от других классов;
<li>быть понятным и полезным даже изолированно.
</ol>
  Все это должно привести к тесной связи между пользователем и
  программой, реализующей конкретный тип. Если в реализации произошли
  изменения, программу пользователя придется перетранслировать,
  поскольку в ней наверняка содержатся вызовы функций, реализуемые
  подстановкой, а также локальные переменные конкретного типа.</p>
<p>Для некоторых областей приложения конкретные типы обеспечивают
  основные типы, прямо не представленные в С++, например:
  комплексные числа, вектора, списки, матрицы, даты, ассоциативные
  массивы, строки символов и символы, из другого (не английского)
  алфавита. В мире, состоящем из конкретных понятий, на самом деле
  нет такой вещи как список. Вместо этого есть множество списочных
  классов, каждый из которых специализируется на представлении
  какой-то версии понятия список. Существует дюжина списочных
  классов, в том числе: список с односторонней связью; список с
  двусторонней связью; список с односторонней связью, в котором
  поле связи не принадлежит объекту; список с двусторонней связью,
  в котором поля связи не принадлежат объекту; список с односторонней
  связью, для которого можно просто и эффективно определить входит
  ли в него данный объект; список с двусторонней связью, для
  которого можно просто и эффективно определить входит ли в него данный
  объект и т.д.</p>
<p>Название "конкретный тип" (CDT - concrete data type, т.е.
  конкретный тип данных) , было выбрано по контрасту с термином
  "абстрактный тип" (ADT - abstract data type, т.е. абстрактный тип
  данных). Отношения между CDT и ADT обсуждаются в 
п.<a href='#abstr'>13.3</a>.</p>
<p>Существенно, что конкретные типы не предназначены для явного
  выражения некоторой общности. Так, типы slist и vector можно
  использовать в качестве альтернативной реализации понятия
  множества, но в языке это явно не отражается. Поэтому, если
  программист хочет работать с множеством, использует конкретные
  типы и не имеет определения класса множество, то он должен выбирать
  между типами slist и vector. Тогда программа записывается в
  терминах выбранного класса, скажем, slist, и если потом предпочтут
  использовать другой класс, программу придется переписывать.</p>
<p>Это потенциальное неудобство компенсируется наличием всех
  "естественных" для данного класса операций, например таких, как
  индексация для массива и удаление элемента для списка. Эти
  операции представлены в оптимальном варианте, без "неестественных"
  операций типа индексации списка или удаления массива, что могло
  бы вызвать путаницу. Приведем пример:</p>
<pre>
           void my(slist& sl)
           {
             for (T* p = sl.first(); p; p = sl.next())
             {
                // мой код
             }
             // ...
           }

           void your(vector& v)
           {
             for (int i = 0; i<v.size(); i++)
             {
               // ваш код
             }
             // ...
           }

<p>
</pre>
Существование таких "естественных" для выбранного метода реализации
  операций обеспечивает эффективность программы и значительно облегчает
  ее написание. К тому же, хотя реализация вызова подстановкой обычно
  возможна только для простых операций типа индексации массива или
  получения следующего элемента списка, она оказывает значительный
  эффект на скорость выполнения программы. Загвоздка здесь состоит в том,
  что фрагменты программы, использующие по своей сути эквивалентные операции,
  как, например, два приведенных выше цикла, могут выглядеть непохожими
  друг на друга, а фрагменты программы, в которых для эквивалентных
  операций используются разные конкретные типы, не могу заменять друг
  друга. Обычно, вообще, невозможно свести сходные фрагменты программы
  в один.</p>
<p>Пользователь, обращающийся к некоторой функции, должен точно
  указать тип объекта, с которым работает функция, например:</p>
<pre>
          void user()
          {
            slist sl;
            vector v(100);

            my(sl);
            your(v);

            my(v);    // ошибка: несоответствие типа
            your(sl); // ошибка: несоответствие типа
          }
</pre>
<p>Чтобы компенсировать жесткость этого требования, разработчик некоторой
  полезной функции должен предоставить несколько ее версий, чтобы у
  пользователя был выбор:</p>
<pre>
          void my(slist&);
          void my(vector&);

          void your(slist&);
          void your(vector&);

          void user()
          {
            slist sl;
            vector v(100);

            my(sl);
            your(v);

            my(v);     // теперь нормально: вызов my(vector&)
            your(sl);  // теперь нормально: вызов your(slist&)
          }
</pre>
<p>Поскольку тело функции существенно зависит от типа ее параметра,
  надо написать каждую версию функций my() и your() независимо друг
  от друга, что может быть хлопотно.</p>
<p>С учетом всего изложенного конкретный тип, можно сказать, походит
  на встроенные типы. Положительной стороной этого является тесная
  связь между пользователем типа и его создателем, а также между
  пользователями, которые создают объекты данного типа, и пользователями,
  которые пишут функции, работающие с этими объектами. Чтобы
  правильно использовать конкретный тип, пользователь должен
  разбираться в нем детально. Обычно не существует каких-то
  универсальных свойств, которыми обладали бы все конкретные типы
  библиотеки, и что позволило бы пользователю, рассчитывая на эти
  свойства, не тратить силы на изучение отдельных классов. Такова
  плата за компактность программы и эффективность ее выполнения.
  Иногда это вполне разумная плата, иногда нет. Кроме того, возможен
  такой случай, когда отдельный конкретный класс проще понять и
  использовать, чем более общий (абстрактный) класс. Именно так
  бывает с классами, представляющими хорошо известные типы данных,
  такие как массивы или списки.</p>
<p>Тем не менее, укажем, что в идеале надо скрывать, насколько
  возможно, детали реализации, пока это не ухудшает характеристики
  программы. Большую помощь здесь оказывают функции-подстановки.
  Если сделать открытыми переменные, являющиеся членами, с помощью описания
  public, или непосредственно работать с ними с помощью функций, которые
  устанавливают и получают значения этих переменных, то почти всегда
  это приводит к плохому результату. Конкретные типы должны быть все-таки
  настоящими типами, а не просто программной кучей с нескольким функциями,
  добавленными ради удобства.</p>

<a name="abstr"></a><h4>13.3 Абстрактные типы</h4>

<p>Самый простой способ ослабить связь между пользователем класса
  и его создателем, а также между программами, в которых объекты
  создаются, и программами, в которых они используются, состоит в введении
  понятия абстрактных базовых классов. Эти классы представляют
  интерфейс со множеством реализаций одного понятия. Рассмотрим
  класс set, содержащий множество объектов типа T:</p>
<pre>
            class set {
            public:
               virtual void insert(T*) = 0;
               virtual void remove(T*) = 0;

               virtual int is_member(T*) = 0;

               virtual T* first() = 0;
               virtual T* next() = 0;

               virtual ~set() { }
            };

</pre>
<p>Этот класс определяет интерфейс с произвольным множеством (set),
  опираясь на встроенное понятие итерации по элементам множества.
  Здесь типично отсутствие конструктора и наличие виртуального
  деструктора, см. также п.<a href="chap6.shtml#freemem">6.7</a>. Рассмотрим 
пример:</p>
<pre>
            class slist_set : public set, private slist {
                slink* current_elem;
            public:
                void insert(T*);
                void remove(T*);

                int is_member(T*);

                virtual T* first();
                virtual T* next();

                slist_set() : slist(), current_elem(0) { }
            };

            class vector_set : public set, private vector {
               int current_index;
            public:
               void insert(T*);
               void remove(T*);

               int is_member(T*);

               T* first() { current_index = 0; return next(); }
               T* next();

               vector_set(int initial_size)
                 : array(initial_size), current_index(0) { }
            };
</pre>
<p>Реализация конкретного типа используется как частный базовый
  класс, а не член класса. Это сделано и для удобства записи, и потому,
  что некоторые конкретные типы могут иметь защищенный интерфейс
  с целью предоставить более прямой доступ к своим членам из производных
  классов. Кроме того, подобным образом в реализации могут использоваться
  некоторые классы, которые имеют виртуальные функции и не являются
  конкретными типами. Только с помощью образования производных классов
  можно в новом классе изящно переопределить (подавить) виртуальную
  функцию класса реализации. Интерфейс определяется абстрактным классом.</p>
<p>Теперь пользователь может записать свои функции из 
п.<a href='#concret'>13.2</a> таким образом:</p>
<pre>
             void my(set& s)
             {
               for (T* p = s.first(); p; p = s.next())
               {
                  // мой код
               }
               // ...
             }

             void your(set& s)
             {
               for (T* p = s.first(); p; p = s.next())
               {
                 // ваш код
               }
               // ...
             }
</pre>
<p>Стало очевидным сходство между двумя функциями, и теперь достаточно
  иметь только одну версию для каждой из функций my() или your(),
  поскольку для общения с slist_set и vector_set обе версии  используют
  интерфейс, определяемый классом set:</p>
<pre>
             void user()
             {
               slist_set sl;
               vector_set v(100);

               my(sl);
               your(v);

               my(v);
               your(sl);
             }
</pre>
<p>Более того, создатели функций my() и your() не обязаны знать описаний
  классов slist_set и vector_set, и функции my() и your() никоим
  образом не зависят от этих описаний. Их не надо перетранслировать
  или как-то изменять, ни если изменились классы slist_set или
  vector_set ни даже, если предложена новая реализация этих классов.
  Изменения отражаются лишь на функциях, которые непосредственно
  используют эти классы, допустим vector_set. В частности, можно
  воспользоваться традиционным применением заголовочных файлов и
  включить в программы с функциями my() или your() файл определений
  set.h, а не файлы slist_set.h или vector_set.h.</p>
<p>В обычной ситуации операции абстрактного класса задаются как
  чистые виртуальные функции, и такой класс не имеет членов,
  представляющих данные (не считая скрытого указателя на таблицу
  виртуальных функций). Это объясняется тем, что добавление невиртуальной
  функции или члена, представляющего данные, потребует определенных
  допущений о классе, которые будут ограничивать возможные реализации.
  Изложенный здесь подход к абстрактным классам близок по духу традиционным
  методам, основанным на строгом разделении интерфейса и его реализаций.
  Абстрактный тип служит в качестве интерфейса, а конкретные типы
  представляют его реализации.</p>
<p>Такое разделение интерфейса и его реализаций предполагает
  недоступность операций, являющихся "естественными" для какой-то
  одной реализации, но не достаточно общими, чтобы войти в
  интерфейс. Например, поскольку в произвольном множестве нет
  упорядоченности, в интерфейс set нельзя включать операцию
  индексирования, даже если для реализации конкретного множества
  используется массив. Это приводит к ухудшению характеристик программы
  из-за отсутствия ручной оптимизации. Далее, становится как правило
  невозможной реализация функций подстановкой (если не считать каких-то
  конкретных ситуаций, когда настоящий тип известен транслятору), поэтому
  все полезные операции интерфейса, задаются как вызовы
  виртуальных функций. Как и для конкретных типов здесь плата за
  абстрактные типы иногда приемлема, иногда слишком высока.</p>
<p>Подводя итог, перечислим каким целям должен служить абстрактный тип:
<ol>
<li>определять некоторое понятие таким образом, что в программе
        могут сосуществовать для него несколько реализаций;
<li>применяя виртуальные функции, обеспечивать достаточно высокую
        степень компактности и эффективности выполнения программы;
<li>сводить к минимуму зависимость любой реализации от других
        классов;
<li>представлять само по себе осмысленное понятие.
</ol>
<p>Нельзя сказать, что абстрактные типы лучше конкретных типов, это
  просто другие типы. Какие из них предпочесть - это, как правило,
  трудный и важный вопрос для пользователя. Создатель библиотеки может
  уклониться от ответа на него и предоставить варианты с обеими типами,
  тем самым выбор перекладывается на пользователя. Но здесь важно ясно
  понимать, с классом какого вида имеешь дело. Обычно неудачей
  заканчивается попытка ограничить общность абстрактного типа, чтобы
  скорость программ, работающих с ним, приблизилась к скорости программ,
  рассчитанных на конкретный тип. В этом случае нельзя
  использовать взаимозаменяемые реализации без большой перетрансляции
  программы после внесения изменений. Столь же неудачна бывает
  попытка дать "общность" в конкретных типах, чтобы они могли по
  мощности понятий приблизиться к абстрактным типам. Это снижает
  эффективность и применимость простых классов. Классы этих двух видов
  могут сосуществовать, и они должны мирно сосуществовать в программе.
  Конкретный класс воплощает реализацию абстрактного типа, и смешивать
  его с абстрактным классом не следует.</p>
<p>Отметим, что ни конкретные, ни абстрактные типы не создаются
  изначально как базовые классы для построения в дальнейшем производных
  классов. Построение производных к абстрактным типам классов
  скорее нужно для задания реализаций, чем для развития самого понятия
  интерфейса. Всякий конкретный или абстрактный тип предназначен для четкого
  и эффективного представления в программе отдельного понятия. Классы,
  которым это удается, редко бывают хорошими кандидатами для создания
  на их базе новых, но связанных с ними, классов. Действительно, попытки
  построить производные, "более развитые" классы на базе конкретных или
  абстрактных типов, таких как, строки, комплексные числа, списки или
  ассоциативные массивы приводят обычно к громоздким конструкциям.
  Как правило эти классы следует использовать как члены или частные базовые
  классы, тогда их можно эффективно применять, не вызывая путаницы и
  противоречий в интерфейсах и реализациях этих и новых классов.</p>
<p>Когда создается конкретный или абстрактный тип, акцент следует
  сделать на том, чтобы предложить простой, реализующий хорошо
  продуманное понятие, интерфейс. Попытки расширить область приложения
  класса, нагружая его описание всевозможными "полезными" свойствами,
  приводят только к беспорядку и неэффективности. Этим же кончаются
  напрасные усилия гарантировать повторное использование класса, когда
  каждую функцию-член объявляют виртуальной, не подумав зачем и как
  эти функции будут переопределяться.</p>
<p>Почему мы не стали определять классы slist и vector как прямые
  производные от класса set, обойдясь тем самым без классов slist_set
  и vector_set? Другими словами зачем нужны конкретные типы, когда уже
  определены абстрактные типы? Можно предложить три ответа:</p>
<ol>
<li>Эффективность: такие типы, как vector или slist надо создавать
         без накладных расходов, вызванных отдалением реализаций
         от интерфейсов (разделения интерфейса и реализации требует
         концепция абстрактного типа).
<li>Множественный интерфейс: часто разные понятия лучше всего
         реализовать как производные от одного класса.
<li>Повторное использование: нужен механизм, который позволит
         приспособить для нашей библиотеки типы, разработанные
         "где-то в другом месте".
</ol>
<p>Конечно, все эти ответы связаны. В качестве примера [<a href="chap0.shtml#book2">2</a>] рассмотрим
  понятие генератора итераций. Требуется определить генератор
  итераций (в дальнейшем итератор) для любого типа так, чтобы с его
  помощью можно было порождать последовательность объектов этого типа.
  Естественно для этого нужно использовать уже упоминавшийся класс slist.
  Однако, нельзя просто определить общий итератор над slist, или даже
  над set, поскольку общий итератор должен допускать итерации и более
  сложных объектов, не являющихся множествами, например, входные потоки
  или функции, которые при очередном вызове дают следующее значение итерации.
  Значит нам нужны и множество и итератор, и в тоже время
  нежелательно дублировать конкретные типы, которые являются очевидными
  реализациями различных видов множеств и итераторов. Можно графически
  представить желательную структуру классов так:</p>

<p>Здесь классы set и iter предоставляют интерфейсы, а slist и stream
  являются частными классами и представляют реализации. Очевидно,
  нельзя перевернуть эту иерархию классов и, предоставляя общие
  интерфейсы, строить производные конкретные типы от абстрактных классов.
  В такой иерархии каждая полезная операция над каждым полезным абстрактным
  понятием должна представляться в общем абстрактном базовом классе.
  Дальнейшее обсуждение этой темы содержится в п.<a href='#interf'>13.6</a>.</p>
<p>Приведем пример простого абстрактного типа, являющегося
  итератором объектов типа T:</p>
<pre>
           class iter {
              virtual T* first() = 0;
              virtual T* next() = 0;
              virtual ~iter() { }
           };

           class slist_iter : public iter, private slist {
              slink* current_elem;
           public:
              T* first();
              T* next();

              slist_iter() : current_elem(0) { }
           };

           class input_iter : public iter {
              isstream& is;
           public:
              T* first();
              T* next();

              input_iter(istream& r) : is(r) { }
           };
</pre>
<p>Можно таким образом использовать определенные нами типы:</p>
<pre>
           void user(const iter& it)
           {
             for (T* p = it.first(); p; p = it.next()) {
                 // ...
             }
           }

           void caller()
           {
             slist_iter sli;
             input_iter ii(cin);

             // заполнение sli

             user(sli);
             user(ii);
           }
</pre>
<p>Мы применили конкретный тип для реализации абстрактного типа, но
  можно использовать его и независимо от абстрактных типов или просто
  вводить такие типы для повышения эффективности программы,
  см. также п.<a href='#dinamic'>13.5</a>. Кроме того, можно использовать один 
конкретный тип для реализации нескольких абстрактных типов.</p>
<p>В разделе п.<a href='#manager'>13.9</a> описывается более гибкий итератор. 
Для него зависимость от реализации, которая поставляет подлежащие итерации
  объекты, определяется в момент инициализации и может изменяться в ходе
  выполнения программы.</p>

<a name="nodal"></a><h4>13.4 Узловые классы</h4>

<p>В действительности иерархия классов строится, исходя из совсем другой
  концепции производных классов, чем концепция интерфейс-реализация,
  которая использовалась для абстрактных типов. Класс рассматривается
  как фундамент строения. Но даже, если в основании находится абстрактный
  класс, он допускает некоторое представление в программе и сам предоставляет
  для производных классов какие-то полезные функции. Примерами узловых
  классов могут служить классы rectangle 
(п.<a href="chap6.shtml#figlib">6.4.2</a>) и satellite 
(п.<a href="chap6.shtml#multentry">6.5.1</a>).
  Обычно в иерархии класс представляет некоторое общее понятие, а
  производные классы представляют конкретные варианты этого понятия.
  Узловой класс является неотъемлемой частью иерархии классов. Он пользуется
  сервисом, представляемым базовыми классами, сам обеспечивает определенный
  сервис и предоставляет виртуальные функции и (или) защищенный
  интерфейс, чтобы позволить дальнейшую детализацию своих операций в
  производных классах.</p>
<p>Типичный узловой класс не только предоставляет реализацию
  интерфейса, задаваемого его базовым классом (как это делает класс
  реализации по отношению к абстрактному типу), но и сам расширяет
  интерфейс, добавляя новые функции. Рассмотрим в качестве примера
  класс dialog_box, который представляет окно некоторого вида на экране.
  В этом окне появляются вопросы пользователю и в нем он задает свой
  ответ с помощью нажатия клавиши или "мыши":</p>
<pre>
       class dialog_box : public window {
          // ...
       public:
          dialog_box(const char* ...); // заканчивающийся нулем список
                                       // обозначений клавиш
          // ...
       virtual int ask();
      };
</pre>
<p>Здесь важную роль играет функция ask() и конструктор, с помощью которого
  программист указывает используемые клавиши и задает их числовые значения.
  Функция ask() изображает на экране окно и возвращает номер нажатой в ответ
  клавиши. Можно представить такой вариант использования:</p>
<pre>
          void user()
          {
            for (;;) {
                // какие-то команды

                dialog_box cont("continue",
                                "try again",
                                "abort",
                                (char*) 0);
                switch (cont.ask()) {
                case 0:  return;
                case 1:  break;
                case 2:  abort();
                }
              }
            }
</pre>
<p>Обратим внимание на использование конструктора. Конструктор, как
  правило, нужен для узлового класса и часто это нетривиальный
  конструктор. Этим узловые классы отличаются от абстрактных классов,
  для которых редко нужны конструкторы.</p>
<p>Пользователь класса dialog_box ( а не только создатель этого
  класса) рассчитывает на сервис, представляемый его базовыми классами.
  В рассматриваемом примере предполагается, что существует
  некоторое стандартное размещение нового окна на экране. Если
  пользователь захочет управлять размещением окна, базовый для
  dialog_box класс window (окно) должен предоставлять такую возможность,
  например:</p>
<pre>
            dialog_box cont("continue","try again","abort",(char*)0);
            cont.move(some_point);
</pre>
<p>Здесь функция движения окна move() рассчитывает на определенные
  функции базовых классов.</p>
<p>Сам класс dialog_box является хорошим кандидатом для построения
  производных классов. Например, вполне разумно иметь такое окно,
  в котором, кроме нажатия клавиши или ввода с мышью, можно задавать
  строку символов (скажем, имя файла). Такое окно dbox_w_str строится
  как производный класс от простого окна dialog_box:</p>
<pre>
            class dbox_w_str : public dialog_box {
                // ...
            public:
               dbox_w_str (
                const char* sl,  // строка запроса пользователю
                const char* ...  // список обозначений клавиш
               );
               int ask();
               virtual char* get_string();
               //...
            };
</pre>
<p>Функция get_string() является той операцией, с помощью
  которой программист получает заданную пользователем строку. Функция
  ask() из класса dbox_w_str гарантирует, что строка введена правильно,
  а если пользователь не стал вводить строку, то тогда в программу
  возвращается соответствующее значение (0).</p>
<pre>
            void user2()
            {
              // ...
              dbox_w_str file_name("please enter file name",
                                   "done",
                                   (char*)0);
              file_name.ask();
              char* p = file_name.get_string();
              if (p) {
                 // используем имя файла
              }
              else {
                // имя файла не задано
              }
              //
            }
</pre>
<p>Подведем итог - узловой класс должен:
<ol>
<li>рассчитывать на свои базовые классы как для их реализации,
         так и для представления сервиса пользователям этих классов;
<li>представлять более полный интерфейс (т.е. интерфейс с большим
         числом функций-членов) пользователям, чем базовые классы;
<li>основывать в первую очередь (но не исключительно) свой
         общий интерфейс на виртуальных функциях;
<li>зависеть от всех своих (прямых и косвенных) базовых классов;
<li>иметь смысл только в контексте своих базовых классов;
<li>служить базовым классом для построения производных классов;
<li>воплощаться в объекте.
</ol>
<p>Не все, но многие, узловые классы будут удовлетворять условиям
  1, 2, 6 и 7. Класс, который не удовлетворяет условию 6, походит
  на конкретный тип и может быть назван конкретным узловым классом.
  Класс, который не удовлетворяет условию 7, походит на абстрактный
  тип и может быть назван абстрактным узловым классом. У многих
  узловых классов есть защищенные члены, чтобы предоставить для
  производных классов менее ограниченный интерфейс.</p>
<p>Укажем на следствие условия 4: для трансляции своей программы
  пользователь узлового класса должен включить описания всех его
  прямых и косвенных базовых классов, а также описания
  всех тех классов, от которых, в свою очередь, зависят базовые классы.
  В этом узловой класс опять представляет контраст с абстрактным типом.
  Пользователь абстрактного типа не зависит от всех классов,
  использующихся для реализации типа и для трансляции своей программы
  не должен включать их описания.</p>


<a name="dinamic"></a><h4>13.5 Динамическая информация о типе</h4>

<p>Иногда бывает полезно знать истинный тип объекта до его использования
  в каких-либо операциях. Рассмотрим функцию my(set&) из 
п.<a href='#abstr'>13.3</a>.</p>
<pre>
             void my_set(set& s)
             {
                for ( T* p = s.first(); p; p = s.next()) {
                    // мой код
                }
                // ...
             }
</pre>    
<p>Она хороша в общем случае, но представим,- стало известно,
  что многие параметры множества представляют собой объекты типа
  slist. Возможно также стал известен алгоритм перебора элементов, который
  значительно эффективнее для списков, чем для произвольных
  множеств. В результате эксперимента удалось выяснить, что именно
  этот перебор является узким местом в системе. Тогда, конечно, имеет
  смысл учесть в программе отдельно вариант с slist. Допустив возможность
  определения истинного типа параметра, задающего множество, функцию
  my(set&) можно записать так:</p>
<pre>
           void my(set& s)
           {
              if (ref_type_info(s) == static_type_info(slist_set)) {
                 // сравнение двух представлений типа

                 // s типа slist

                 slist& sl = (slist&)s;
                 for (T* p = sl.first(); p; p = sl.next()) {

                    // эффективный вариант в расчете на list

                 }
            }
            else {

               for ( T* p = s.first(); p; p = s.next()) {

                    // обычный вариант для произвольного множества

                }
            }
            // ...
         }
</pre>
<p>Как только стал известен конкретный тип slist, стали
  доступны определенные операции со списками, и даже стала возможна
  реализация основных операций подстановкой.</p>
<p>Приведенный вариант функции действует отлично, поскольку
  slist - это конкретный класс, и действительно имеет смысл отдельно
  разбирать вариант, когда параметр является slist_set. Рассмотрим
  теперь такую ситуацию, когда желательно отдельно разбирать вариант как
  для класса, так и для всех его производных классов. Допустим, мы
  имеем класс dialog_box из п.<a href='#nodal'>13.4</a> и хотим узнать, 
является ли он
  классом dbox_w_str. Поскольку может существовать много производных
  классов от dbox_w_str, простую проверку на совпадение с ним
  нельзя считать хорошим решением. Действительно, производные классы
  могут представлять самые разные варианты запроса строки. Например,
  один производный от dbox_w_str класс может предлагать пользователю
  варианты строк на выбор, другой может обеспечить поиск в каталоге
  и т.д. Значит, нужно проверять и на совпадение со всеми производными
  от dbox_w_str классами. Это так же типично для узловых классов, как
  проверка на вполне определенный тип типична для абстрактных классов,
  реализуемых конкретными типами.</p>
<pre>
           void f(dialog_box& db)
           {
              dbox_w_str* dbws = ptr_cast(dbox_w_str, &db);
              if (dbws) {  // dbox_w_str
                 // здесь можно использовать dbox_w_str::get_string()
              }
              else {

                // ``обычный'' dialog_box
              }

              // ...
            }
</pre>
<p>Здесь "операция" приведения ptr_cast() свой второй параметр
  (указатель) приводит к своему первому параметру (типу) при условии, что
  указатель настроен на объект тип, которого совпадает с заданным
  (или является производным классом от заданного типа). Для проверки
  типа dialog_box используется указатель, чтобы после приведения его
  можно было сравнить с нулем.</p>
<p>Возможно альтернативное решение с помощью ссылки на dialog_box:</p>
<pre>
            void g(dialog_box& db)
            {
              try {
                  dbox_w_str& dbws = ref_cast(dialog_box,db);

                  // здесь можно использовать dbox_w_str::get_string()

               }
               catch (Bad_cast) {

                  // ``обычный'' dialog_box

               }

               // ...
            }
</pre>
<p>Поскольку нет приемлемого представления нулевой ссылки, с которой
  можно сравнивать, используется особая ситуация, обозначающая ошибку
  приведения (т.е. случай, когда тип не есть dbox_w_str). Иногда
  лучше избегать сравнения с результатом приведения.</p>
<p>Различие функций ref_cast() и ptr_cast() служит хорошей
  иллюстрацией различий между ссылками и указателями: ссылка обязательно
  ссылается на объект, тогда как указатель может и не ссылаться,
  поэтому для указателя часто нужна проверка.</p>

<a name="inftype"></a><h5>13.5.1 Информация о типе</h5>

<p>В С++ нет иного стандартного средства получения динамической информации
  о типе, кроме вызовов виртуальных функций+.</p>

<p>+ Хотя было сделано несколько предложений по расширению С++ в этом
  направлении.</p>

<p>Смоделировать такое средство довольно просто и в большинстве
  больших библиотек есть возможности динамических запросов о типе.
  Здесь предлагается решение, обладающее тем полезным свойством,
  что объем информации о типе можно произвольно расширять. Его можно
  реализовать с помощью вызовов виртуальных функций, и оно может
  входить в расширенные реализации С++.</p>
<p>Достаточно удобный интерфейс с любым средством, поставляющим
  информацию о типе, можно задать с помощью следующих операций:</p>
<pre>
       typeid static_type_info(type) // получить typeid для имени типа
       typeid ptr_type_info(pointer) // получить typeid для указателя
       typeid ref_type_info(reference) // получить typeid для ссылки
       pointer ptr_cast(type,pointer)  // преобразование указателя
       reference ref_cast(type,reference)  // преобразование ссылки
</pre>
<p>Пользователь класса может обойтись этими операциями, а создатель
  класса должен предусмотреть в описаниях классов определенные
  "приспособления", чтобы согласовать операции с реализацией
  библиотеки.</p>
<p>Большинство пользователей, которым вообще нужна динамическая
  идентификация типа, может ограничиться операциями приведения
  ptr_cast() и ref_cast(). Таким образом пользователь отстраняется от
  дальнейших сложностей, связанных с динамической идентификацией
  типа. Кроме того, ограниченное использование динамической информации
  о типе меньше всего чревато ошибками.</p>
<p>Если недостаточно знать, что операция приведения прошла успешно,
  а нужен истинный тип (например, объектно-ориентированный
  ввод-вывод), то можно использовать операции динамических запросов о типе:
  static_type_info(), ptr_type_info() и ref_type_info(). Эти операции
  возвращают объект класса typeid. Как было показано в примере с
  set и slist_set, объекты класса typeid можно сравнивать. Для
  большинства задач этих сведений о классе typeid достаточно. Но для
  задач, которым нужна более полная информация о типе, в классе
  typeid есть функция get_type_info():</p>
<pre>
            class typeid {
                friend class Type_info;
            private:
                const Type_info* id;
            public:
                typeid(const Type_info* p) : id(p) { }
                const Type_info* get_type_info() const { return id; }
                int operator==(typeid i) const ;
            };
</pre>
<p>Функция get_type_info() возвращает указатель на неменяющийся (const)
  объект класса Type_info из typeid. Существенно, что объект
  не меняется: это должно гарантировать, что динамическая информация
  о типе отражает статические типы исходной программы. Плохо, если
  при выполнении программы некоторый тип может изменяться.</p>
<p>С помощью указателя на объект класса Type_info пользователь
  получает доступ к информации о типе из typeid и, теперь его
  программа начинает зависеть от конкретной системы динамических
  запросов о типе и от структуры динамической информации о нем.
  Но эти средства не входят в стандарт языка, а задать их с помощью
  хорошо продуманных макроопределений непросто.</p>

<a name="classtype"></a><h5>13.5.2 Класс Type_info</h5>

<p>В классе Type_info есть минимальный объем информации для реализации
  операции ptr_cast(); его можно определить следующим образом:</p>
<pre>
            class Type_info {
                const char* n;       // имя
                const Type_info** b; // список базовых классов
            public:
                Type_info(const char* name, const Type_info* base[]);

                const char* name() const;
                Base_iterator bases(int direct=0) const;
                int same(const Type_info* p) const;
                int has_base(const Type_info*, int direct=0) const;
                int can_cast(const Type_info* p) const;

                static const Type_info info_obj;
                virtual typeid get_info() const;
                static typeid info();
            };
</pre>
<p>Две последние функции должны быть определены в каждом производном
  от Type_info классе.</p>
<p>Пользователь не должен заботиться о структуре объекта Type_info, и
  она приведена здесь только для полноты изложения. Строка, содержащая
  имя типа, введена для того, чтобы дать возможность поиска информации
  в таблицах имен, например, в таблице отладчика. С помощью нее а также
  информации из объекта Type_info можно выдавать более осмысленные
  диагностические сообщения. Кроме того, если возникнет потребность
  иметь несколько объектов типа Type_info, то имя может служить уникальным
  ключом этих объектов.</p>
<pre>
            const char* Type_info::name() const
            {
              return n;
            }

            int Type_info::same(const Type_info* p) const
            {
              return this==p || strcmp(n,p->n)==0;
            }

            int Type_info::can_cast(const Type_info* p) const
            {
              return same(p) || p->has_base(this);
            }
</pre>
<p>Доступ к информации о базовых классах обеспечивается функциями
  bases() и has_base(). Функция bases() возвращает итератор, который
  порождает указатели на базовые классы объектов Type_info, а с
  помощью функции has_base() можно определить является ли заданный класс
  базовым для другого класса. Эти функции имеют необязательный параметр
  direct, который показывает, следует ли рассматривать все базовые классы
  (direct=0), или только прямые базовые классы (direct=1). Наконец,
  как описано ниже, с помощью функций get_info() и info() можно
  получить динамическую информацию о типе для самого класса Type_info.</p>
<p>Здесь средство динамических запросов о типе сознательно
  реализуется с помощью совсем простых классов. Так можно избежать
  привязки к определенной библиотеке. Реализация в расчете на
  конкретную библиотеку может быть иной. Можно, как всегда, посоветовать
  пользователям избегать излишней зависимости от деталей реализации.</p>
<p>Функция has_base() ищет базовые классы с помощью имеющегося в
  Type_info списка базовых классов. Хранить информацию о том, является
  ли базовый класс частным или виртуальным, не нужно, поскольку
  все ошибки, связанные с ограничениями доступа или неоднозначностью,
  будут выявлены при трансляции.</p>
<pre>
          class base_iterator {
            short i;
            short alloc;
            const Type_info* b;
          public:
            const Type_info* operator() ();
            void reset() { i = 0; }

            base_iterator(const Type_info* bb, int direct=0);
            ~base_iterator() { if (alloc) delete[] (Type_info*)b; }
         };
</pre>
<p>В следующем примере используется необязательный параметр для указания,
  следует ли рассматривать все базовые классы (direct==0) или только прямые
  базовые классы (direct==1).</p>
<pre>
        base_iterator::base_iterator(const Type_info* bb, int direct)
        {
          i = 0;

          if (direct) { // использование списка прямых базовых классов
             b = bb;
             alloc = 0;
             return;
          }

          // создание списка прямых базовых классов:

          // int n = число базовых
          b = new const Type_info*[n+1];
          // занести базовые классы в b

          alloc = 1;
          return;
        }

        const Type_info* base_iterator::operator() ()
        {
          const Type_info* p = &b[i];
          if (p) i++;
          return p;
        }
</pre>
<p>Теперь можно  задать операции запросов о типе с помощью макроопределений:</p>
<pre>
        #define static_type_info(T)  T::info()

        #define ptr_type_info(p)   ((p)->get_info())
        #define ref_type_info(r)   ((r).get_info())

        #define ptr_cast(T,p) \
           (T::info()->can_cast((p)->get_info()) ? (T*)(p) : 0)
        #define ref_cast(T,r) \
           (T::info()->can_cast((r).get_info()) \
               ? 0 : throw Bad_cast(T::info()->name()), (T&)(r))
</pre>
<p>Предполагается, что тип особой ситуации Bad_cast (Ошибка_приведения)
  описан так:</p>
<pre>
        class Bad_cast {
          const char* tn;
          // ...
        public:
          Bad_cast(const char* p) : tn(p) { }
          const char* cast_to() { return tn; }
          //  ...
        };
</pre>
<p>В разделе п.4.7</a> было сказано, что появление макроопределений
  служит сигналом возникших проблем. Здесь проблема в том, что только
  транслятор имеет непосредственный доступ к литеральным типам,
  а макроопределения скрывают специфику реализации. По сути для хранения
  информации для динамических запросов о типах предназначена таблица
  виртуальных функций. Если реализация непосредственно поддерживает
  динамическую идентификацию типа, то рассматриваемые операции можно
  реализовать более естественно, эффективно и элегантно. В частности,
  очень просто реализовать функцию ptr_cast(), которая преобразует
  указатель на виртуальный базовый класс в указатель на его производные
  классы.</p>

<a name="howcreate"></a><h5>13.5.3 Как создать систему динамических запросов 
о типе</h5>

<p>Здесь показано, как можно прямо реализовать динамические запросы
  о типе, когда в трансляторе таких возможностей нет. Это достаточно
  утомительная задача и можно пропустить этот раздел, так как в нем
  есть только детали конкретного решения.</p>
<p>Классы set и slist_set из п.<a href='#abstr'>13.3</a> следует изменить так, 
чтобы  с ними могли работать операции запросов о типе. Прежде всего, в
  базовый класс set нужно ввести функции-члены, которые используют
  операции запросов о типе:</p>
<pre>
         class set {
           public:
             static const Type_info info_obj;
             virtual typeid get_info() const;
             static typeid info();

             // ...
        };
</pre>
<p>При выполнении программы единственным представителем объекта типа
  set является set::info_obj, который определяется так:</p>
<pre>
        const Type_info set::info_obj("set",0);
</pre>
<p>С учетом этого определения функции тривиальны:</p>
<pre>
       typeid set::get_info() const { return &info_obj; }
       typeid set::info() { return &info_obj; }
       typeid slist_set::get_info() const { return &info_obj; }
       typeid slist_set::info() { return &info_obj; }
</pre>
<p>Виртуальная функция get_info() будет предоставлять операции
  ref_type_info() и ptr_type_info(), а статическая функция info()
  - операцию static_type_info().</p>
<p>При таком построении системы запросов о типе основная трудность
  на практике состоит в том, чтобы для каждого класса объект типа
  Type_info и две функции, возвращающие указатель на этот объект,
  определялись только один раз.</p>
<p>Нужно несколько изменить класс slist_set:</p>
<pre>
         class slist_set : public set, private slist {
            // ...
         public:
            static const Type_info info_obj;
            virtual typeid get_info() const;
            static typeid info();

            // ...
         };

         static const Type_info* slist_set_b[]
            = { &set::info_obj, &slist::info_obj, 0 };
         const Type_info slist_set::info_obj("slist_set",slist_set_b);

         typeid slist_set::get_info() const { return &info_obj; }
         typeid slist_set::info() { return &info_obj; }
</pre>
<p>
<a name="extendinf"></a><h5>13.5.4 Расширенная динамическая информация о 
типе</h5>

<p>В классе Type_info содержится только минимум информации, необходимой
  для идентификации типа и безопасных операций приведения. Но поскольку
  в самом классе Type_info есть функции-члены info() и get_info(),
  можно построить производные от него классы, чтобы в динамике
  определять, какие объекты Type_info возвращают эти функции. Таким
  образом, не меняя класса Type_info, пользователь может получать
  больше информации о типе с помощью объектов, возвращаемых функциями
  dynamic_type() и static_type(). Во многих случаях дополнительная
  информация должна содержать таблицу членов объекта:</p>
<pre>
             struct Member_info {
               char* name;
               Type_info* tp;
               int offset;
             };

             class Map_info : public Type_info {
                Member_info** mi;
             public:
                static const Type_info info_obj;
                virtual typeid get_info() const;
                static typeid info();

                // функции доступа
             };
</pre>
<p>Класс Type_info вполне подходит для стандартной библиотеки. Это
  базовый класс с минимумом необходимой информации, из которого
  можно получать производные классы, предоставляющие больше информации.
  Эти производные классы могут определять или сами пользователи, или
  какие-то служебные программы, работающие с текстом на С++, или сами
  трансляторы языка.</p>


<a name="usinginf"></a><h5>13.5.5 Правильное и неправильное использование 
динамической информации о типе</h5>

<p>Динамическая информация о типе может использоваться во многих
  ситуациях, в том числе для: объектного ввода-вывода,
  объектно-ориентированных баз данных,  отладки. В тоже время
  велика вероятность ошибочного использования такой информации.
  Известно,что в языке Симула использование таких средств,
  как правило, приводит к ошибкам. Поэтому эти средства не были
  включены в С++. Слишком велик соблазн воспользоваться динамической
  информацией о типе, тогда как правильнее вызвать виртуальную
  функцию. Рассмотрим в качестве примера класс Shape из 
п.<a href="chap1.shtml#objprog">1.2.5</a>.
  Функцию rotate можно было задать так:</p>
<pre>
          void rotate(const Shape& s)
              // неправильное использование динамической
              // информации о типе

          {
            if (ref_type_info(s)==static_type_info(Circle)) {
               // для этой фигуры ничего не надо
            }
            else if (ref_type_info(s)==static_type_info(Triangle)) {
               // вращение треугольника
            }
            else if (ref_type_info(s)==static_type_info(Square)) {
               // вращение квадрата
            }
            // ...
          }
</pre>
<p>Если для переключателя по типу поля мы используем динамическую
  информацию о типе, то тем самым нарушаем в программе принцип
  модульности и отрицаем сами цели объектно-ориентированного программирования.
  К тому же это решение чревато ошибками: если в качестве
  параметра функции будет передан объект производного от Circle класса,
  то она сработает неверно (действительно, вращать круг (Circle)
  нет смысла, но для объекта, представляющего производный класс, это
  может потребоваться). Опыт показывает, что программистам, воспитанным
  на таких языках как С или Паскаль, трудно избежать этой ловушки.
  Стиль программирования этих языков требует меньше предусмотрительности,
  а при создании библиотеки такой стиль можно просто считать
  небрежностью.</p>
<p>Может возникнуть вопрос, почему в интерфейс с системой динамической
  информации о типе включена условная операция приведения ptr_cast(), а не
  операция is_base(), которая непосредственно определяется с помощью
  операции has_base() из класса Type_info. Рассмотрим такой пример:</p>
<pre>
            void f(dialog_box& db)
            {
              if (is_base(&db,dbox_w_str)) { // является ли db базовым
                                             // для  dbox_w-str?
                 dbox_w_str* dbws = (dbox_w_str*) &db;
                 // ...
              }

              // ...
            }
</pre>
<p>Решение с помощью ptr_cast (п.<a href='#dinamic'>13.5</a>) более короткое, 
к тому же здесь явная и безусловная операция приведения отделена от проверки в 
операторе if, значит появляется возможность ошибки, неэффективности и даже
  неверного результата. Неверный результат может возникнуть в тех
  редких случаях, когда система динамической идентификации типа
  распознает, что один тип является производным от другого, но
  транслятору этот факт неизвестен, например:</p>
<pre>
              class D;
              class B;

              void g(B* pb)
              {
                if (is_base(pb,D)) {
                   D* pb = (D*)pb;

                   // ...
                }

                // ...
              }
</pre>
<p>Если транслятору пока неизвестно следующее описание класса D:</p>
<pre>
              class D : public A, public B {
                 // ...
              };
</pre>
<p>то возникает ошибка, т.к. правильное приведение указателя pb к D*
  требует изменения значения указателя. Решение с операцией ptr_cast()
  не сталкивается с этой трудностью, поскольку эта операция применима
  только при условии, что в области видимости находятся описания
  обеих ее параметров. Приведенный пример показывает, что операция
  приведения для неописанных классов по сути своей ненадежна, но
  запрещение ее существенно ухудшает совместимость с языком С.</p>

<a name="interf"></a><h4>13.6 Обширный интерфейс</h4>

<p>Когда обсуждались абстрактные типы (п.<a href='#abstr'>13.3</a>) и узловые 
классы (п.<a href='#nodal'>13.4</a>),
  было подчеркнуто, что все функции базового класса реализуются
  в самом базовом или в производном классе. Но существует и другой
  способ построения классов. Рассмотрим, например, списки, массивы,
  ассоциативные массивы, деревья и т.д. Естественно желание для всех
  этих типов, часто называемых контейнерами, создать обобщающий их
  класс, который можно использовать в качестве интерфейса с любым
  из перечисленных типов. Очевидно, что пользователь не должен
  знать детали, касающиеся конкретного контейнера. Но задача
  определения интерфейса для обобщенного контейнера нетривиальна.
  Предположим, что такой контейнер будет определен как абстрактный
  тип, тогда какие операции он должен предоставлять? Можно предоставить
  только те операции, которые есть в каждом контейнере, т.е.
  пересечение множеств операций, но такой интерфейс будет слишком
  узким. На самом деле, во многих, имеющих смысл случаях такое
  пересечение пусто. В качестве альтернативного решения можно
  предоставить объединение всех множеств операций и предусмотреть
  динамическую ошибку, когда в этом интерфейсе к объекту
  применяется "несуществующая" операция. Объединение интерфейсов классов,
  представляющих  множество понятий, называется обширным интерфейсом.
  Опишем "общий" контейнер объектов типа T:</p>
<pre>
            class container {
            public:
              struct Bad_operation { // класс особых ситуаций
                  const char* p;
                  Bad_operation(const char* pp) : p(pp) { }
              };

              virtual void put(const T*)
                 { throw Bad_operation("container::put"); }
              virtual T* get()
                 { throw Bad_operation("container::get"); }

              virtual T*& operator[](int)
                 { throw Bad_operation("container::[](int)"); }
              virtual T*& operator[](const char*)
                 { throw Bad_operation("container::[](char*)"); }
              // ...
            };
</pre>
<p>Все-таки существует мало реализаций, где удачно представлены как
  индексирование, так и операции типа списочных, и, возможно, не стоит
  совмещать их в одном классе.</p>
<p>Отметим такое различие: для гарантии проверки на этапе
  трансляции в абстрактном типе используются чистые виртуальные
  функции, а для обнаружения ошибок на этапе выполнения используются
  функции обширного интерфейса, запускающие особые ситуации.</p>
<p>Можно следующим образом описать контейнер, реализованный
  как простой список с односторонней связью:</p>
<pre>
       class slist_container : public container, private slist {
       public:
         void put(const T*);
         T* get();

         T*& operator[](int)
             { throw Bad_operation("slist::[](int)"); }
         T*& operator[](const* char)
             { throw Bad_operation("slist::[](char*)"); }
         // ...
       };
</pre>
<p>Чтобы упростить обработку динамических ошибок для списка
  введены операции индексирования. Можно было не вводить эти
  нереализованные для списка операции и ограничиться менее полной
  информацией, которую предоставляют особые ситуации, запущенные
  в классе container:</p>
<pre>
        class vector_container : public container, private vector {
        public:
           T*& operator[](int);
           T*& operator[](const char*);
           // ...
        };
</pre>
<p>Если быть осторожным, то все работает нормально:</p>
<pre>
        void f()
        {
          slist_container sc;
          vector_container vc;
          // ...
        }

        void user(container& c1, container& c2)
        {
          T* p1 = c1.get();
          T* p2 = c2[3];
          // нельзя использовать c2.get() или c1[3]
          // ...
        }
</pre>
<p>Все же для избежания ошибок при выполнении программы часто приходится
  использовать динамическую информацию о типе (п.<a href='#dinamic'>13.5</a>) 
или особые  ситуации (п.<a href="chap9.shtml">9</a>). Приведем пример:</p>
<pre>
         void user2(container& c1, container& c2)
         /*
            обнаружение ошибки просто, восстановление - трудная задача
         */
         {
           try {
               T* p1 = c1.get();
               T* p2 = c2[3];
               // ...
            }
            catch(container::Bad_operation& bad) {
              // Приехали!
              // А что теперь делать?
            }
          }
</pre>
<p>или другой пример:</p>
<pre>
          void user3(container& c1, container& c2)
          /*
            обнаружение ошибки непросто,
            а восстановление по прежнему трудная задача
          */
          {
            slist* sl = ptr_cast(slist_container,&c1);
            vector* v = ptr_cast(vector_container, &c2);

            if (sl && v) {
               T* p1 = c1.get();
               T* p2 = c2[3];
               // ...
            }
            else {
               // Приехали!
               // А что теперь делать?
            }
          }
</pre>
<p>Оба способа обнаружения ошибки, показанные на этих примерах,
  приводят к программе с "раздутым" кодом и низкой скоростью
  выполнения. Поэтому обычно просто игнорируют возможные ошибки
  в надежде, что пользователь на них не натолкнется. Но задача от этого
  не упрощается, ведь полное тестирование затруднительно и требует
  многих усилий.</p>
<p>Поэтому, если целью является программа с хорошими характеристиками,
  или требуются высокие гарантии корректности программы, или, вообще,
  есть хорошая альтернатива, лучше не использовать обширные интерфейсы.
  Кроме того, использование обширного интерфейса нарушает
  взаимнооднозначное соответствие между классами и понятиями, и тогда
  начинают вводить новые производные классы просто для удобства
  реализации.</p>

<a name="frame"></a><h4>13.7 Каркас области приложения</h4>

<p>Мы перечислили виды классов, из которых можно создать библиотеки,
  нацеленные на проектирование и повторное использование прикладных
  программ. Они предоставляют определенные "строительные блоки" и
  объясняют как из них строить. Разработчик прикладного обеспечения создает
  каркас, в который должны вписаться универсальные строительные блоки. Задача
  проектирования прикладных программ может иметь иное, более обязывающее
  решение: написать программу, которая сама будет создавать общий каркас
  области приложения. Разработчик прикладного обеспечения
  в качестве строительных блоков будет встраивать в этот каркас
  прикладные программы. Классы, которые образуют каркас области
  приложения, имеют настолько обширный интерфейс, что их трудно
  назвать типами в обычном смысле слова. Они приближаются к тому
  пределу, когда становятся чисто прикладными классами, но при этом
  в них фактически есть только описания, а все действия задаются
  функциями, написанными прикладными программистами.</p>
<p>Для примера рассмотрим фильтр, т.е. программу, которая может
  выполнять следующие действия: читать входной поток, производить
  над ним некоторые операции, выдавать выходной поток и определять
  конечный результат. Примитивный каркас для фильтра будет состоять
  из определения множества операций, которые должен реализовать
  прикладной программист:</p>
<pre>
           class filter {
           public:
             class Retry {
             public:
               virtual const char* message() { return 0; }
             };

           virtual void start() { }
           virtual int retry() { return 2; }
           virtual int read() = 0;
           virtual void write() { }
           virtual void compute() { }
           virtual int result() = 0;
         };
</pre>
<p>Нужные для производных классов функции описаны как чистые виртуальные,
  остальные функции просто пустые. Каркас содержит основной цикл
  обработки и зачаточные средства обработки ошибок:</p>
<pre>
         int main_loop(filter* p)
         {
           for (;;) {
               try {
                   p->start();
                   while (p->read()) {
                         p->compute();
                         p->write();
                   }
                   return p->result();
               }
               catch (filter::Retry& m) {
                 cout << m.message() << '\n';
                 int i = p->retry();
                 if (i) return i;
               }
               catch (...) {
                 cout << "Fatal filter error\n";
                 return 1;
               }
             }
           }
</pre>
<p>Теперь прикладную программу можно написать так:</p>
<pre>
           class myfilter : public filter {
              istream& is;
              ostream& os;
              char c;
              int nchar;

           public:
              int read() { is.get(c); return is.good(); }
              void compute() { nchar++; };
              int result()
                  { os << nchar
                       << "characters read\n";
                       return 0;
                  }

              myfilter(istream& ii, ostream& oo)
                : is(ii), os(oo), nchar(0) { }
           };
</pre>
<p>и вызывать ее следующим образом:</p>
<pre>
          int main()
          {
            myfilter f(cin,cout);
            return main_loop(&f);
          }
</pre>
<p>Настоящий каркас, чтобы рассчитывать на применение в реальных задачах,
  должен создавать более развитые структуры и предоставлять больше
  полезных функций, чем в нашем простом примере. Как правило, каркас
  образует дерево узловых классов. Прикладной программист поставляет
  только классы, служащие листьями в этом многоуровневом дереве,
  благодаря чему достигается общность между различными прикладными
  программами и упрощается повторное использование полезных функций,
  предоставляемых каркасом. Созданию каркаса могут способствовать
  библиотеки, в которых определяются некоторые полезные классы, например,
  такие как scrollbar (п.<a href="chap12.shtml#membship">12.2.5</a>) и 
dialog_box (п.<a href='#nodal'>13.4</a>). После определения
  своих прикладных классов программист может использовать эти классы.</p>

<a name="infclass"></a><h4>13.8 Интерфейсные классы</h4>

<p>Про один из самых важных видов классов обычно забывают - это "скромные"
  интерфейсные классы. Такой класс не выполняет какой-то большой
  работы, ведь иначе, его не называли бы интерфейсным. Задача
  интерфейсном класса приспособить некоторую полезную функцию к
  определенному контексту. Достоинство интерфейсных классов в том,
  что они позволяют совместно использовать полезную функцию, не загоняя
  ее в жесткие рамки. Действительно, невозможно рассчитывать, что функция
  сможет сама по себе одинаково хорошо удовлетворить самые разные запросы.</p>
<p>Интерфейсный класс в чистом виде даже не требует генерации кода.
  Вспомним описание шаблона типа Splist из 
п.<a href="chap8.shtml#outforce">8.3.2</a>:</p>
<pre>
            template<class T>
            class Splist : private Slist<void*> {
            public:
              void insert(T* p) { Slist<void*>::insert(p); }
              void append(T* p) { Slist<void*>::append(p); }
              T* get() { return (T*) Slist<void*>::get(); }
            };
</pre>
<p>Класс Splist преобразует список ненадежных обобщенных указателей
  типа void* в более удобное семейство надежных классов, представляющих
  списки. Чтобы применение интерфейсных классов не было слишком накладно,
  нужно использовать функции-подстановки. В примерах, подобных
  приведенному, где задача функций-подстановок только подогнать
  тип, накладные расходы в памяти и скорости выполнения программы
  не возникают.</p>
<p>Естественно, можно считать интерфейсным абстрактный
  базовый класс, который представляет абстрактный тип, реализуемый
  конкретными типами (п.<a href='#abstr'>13.3</a>), также как и управляющие 
классы из раздела <a href='#manager'>13.9</a>. Но здесь мы рассматриваем классы, 
у которых нет иных назначений - только задача адаптации интерфейса.</p>
<p>Рассмотрим задачу слияния двух иерархий классов с помощью
  множественного наследования. Как быть в случае коллизии
  имен, т.е. ситуации, когда в двух классах используются виртуальные
  функции с одним именем, производящие совершенно разные операции?
  Пусть есть видеоигра под названием "Дикий запад", в которой диалог
  с пользователем организуется с помощью окна общего вида (класс
  Window):</p>
<pre>
            class Window {
               // ...
               virtual void draw();
            };

            class Cowboy {
               // ...
               virtual void draw();
           };

           class CowboyWindow : public Cowboy, public Window {
              // ...
           };
</pre>
<p>В этой игре класс CowboyWindow представляет движение ковбоя на экране
  и управляет взаимодействием игрока с ковбоем. Очевидно, появится
  много полезных функций, определенных в классе Window и
  Cowboy, поэтому предпочтительнее использовать множественное наследование,
  чем описывать Window или Cowboy как члены. Хотелось бы передавать
  этим функциям в качестве параметра объект типа CowboyWindow, не требуя
  от программиста указания каких-то спецификаций объекта. Здесь
  как раз и возникает вопрос, какую функции выбрать для CowboyWindow:
  Cowboy::draw() или Window::draw().</p>
<p>В классе CowboyWindow может быть только одна функция с именем
  draw(), но поскольку полезная функция работает с объектами Cowboy
  или Window и ничего не знает о CowboyWindow, в классе CowboyWindow
  должны подавляться (переопределяться) и функция Cowboy::draw(), и
  функция Window_draw(). Подавлять обе функции с помощью одной -
  draw() неправильно, поскольку, хотя используется одно имя, все же
  все функции draw() различны и не могут переопределяться одной.</p>
<p>Наконец, желательно, чтобы в классе CowboyWindow наследуемые
  функции Cowboy::draw() и Window::draw() имели различные однозначно
  заданные имена.</p>
<p>Для решения этой задачи нужно ввести дополнительные классы для
  Cowboy и Window. Вводится два новых имени
  для функций draw() и гарантируется, что их вызов
  в классах Cowboy и Window приведет к вызову функций с новыми именами:</p>
<pre>
        class CCowboy : public Cowboy {
           virtual int cow_draw(int) = 0;
           void draw() { cow_draw(i); } // переопределение Cowboy::draw
        };

        class WWindow : public Window {
           virtual int win_draw() = 0;
           void draw() { win_draw(); } // переопределение Window::draw
        };
</pre>
<p>Теперь с помощью интерфейсных классов CCowboy и WWindow можно
  определить класс CowboyWindow и сделать требуемые переопределения
  функций cow_draw() и win_draw:</p>
<pre>
           class CowboyWindow : public CCowboy, public WWindow {
             // ...
             void cow_draw();
             void win_draw();
           };
</pre>
<p>Отметим, что в действительности трудность возникла лишь потому, что
  у обеих функций draw()  одинаковый тип параметров. Если бы типы
  параметров различались, то обычные правила разрешения неоднозначности
  при перегрузке гарантировали бы, что трудностей не возникнет, несмотря на
  наличие различных функций с одним именем.</p>
<p>Для каждого случая использования интерфейсного класса можно
  предложить такое расширение языка, чтобы требуемая адаптация
  проходила более эффективно или задавалась более элегантным способом.
  Но такие случаи являются достаточно редкими, и нет смысла чрезмерно
  перегружать язык, предоставляя специальные средства для каждого
  отдельного случая. В частности, случай коллизии имен при слиянии иерархий
  классов довольно редки, особенно если сравнивать с
  тем, насколько часто программист создает классы. Такие случаи
  могут возникать при слиянии иерархий классов из разных
  областей (как в нашем примере: игры и операционные системы).
  Слияние таких разнородных структур классов всегда непростая задача,
  и разрешение коллизии имен является в ней далеко не самой трудной
  частью. Здесь возникают проблемы из-за разных стратегий обработки
  ошибок, инициализации, управления памятью. Пример, связанный
  с коллизией имен, был приведен потому, что предложенное решение:
  введение интерфейсных классов с функциями-переходниками, - имеет
  много других применений. Например, с их помощью можно менять
  не только имена, но и типы параметров и возвращаемых значений,
  вставлять определенные динамические проверки и т.д.</p>
<p>Функции-переходники CCowboy::draw() и WWindow_draw являются
  виртуальными, и простая оптимизация с помощью подстановки невозможна.
  Однако, есть возможность, что транслятор распознает такие функции
  и удалит их из цепочки вызовов.</p>
<p>Интерфейсные функции служат для приспособления интерфейса к
  запросам пользователя. Благодаря им в интерфейсе собираются операции,
  разбросанные по всей программе. Обратимся к классу vector из 
п.<a href="chap1.shtml#support">1.4</a>.
  Для таких векторов, как и для массивов, индекс
  отсчитывается от нуля. Если пользователь хочет работать с
  диапазоном индексов, отличным от диапазона 0..size-1, нужно сделать
  соответствующие приспособления, например, такие:</p>
<pre>
            void f()
            {
              vector v(10);  // диапазон [0:9]

              // как будто v в диапазоне [1:10]:

              for (int i = 1; i<=10; i++) {
                 v[i-1] = ... // не забыть пересчитать индекс

              }
              // ...
            }
</pre>
<p>Лучшее решение дает класс vec c произвольными границами индекса:</p>
<pre>
            class vec : public vector {
              int lb;
            public:
              vec(int low, int high)
                 : vector(high-low+1) { lb=low; }

              int& operator[](int i)
                 { return vector::operator[](i-lb); }

              int low() { return lb; }
              int high() { return lb+size() - 1; }
            };
</pre>
<p>Класс vec можно использовать без дополнительных операций, необходимых
  в первом примере:</p>
<pre>
            void g()
            {
              vec v(1,10);  // диапазон [1:10]

              for (int i = 1; i<=10; i++) {
                  v[i] = ...

              }
              // ...
            }
</pre>
<p>Очевидно, вариант с классом vec нагляднее и безопаснее.</p>
<p>Интерфейсные классы имеют и другие важные области применения,
  например, интерфейс между программами на С++ и программами на другом
  языке (п.<a href="chap12.shtml#hybrid">12.1.4</a>) или интерфейс с особыми 
библиотеками С++.</p>

<a name="manager"></a><h4>13.9 Управляющие классы</h4>

<p>Концепция абстрактного класса дает эффективное средство для разделения
  интерфейса и его реализации. Мы применяли эту концепцию и получали
  постоянную связь между интерфейсом, заданным абстрактным типом,
  и реализацией, представленной конкретным типом. Так, невозможно
  переключить абстрактный итератор с одного класса-источника на
  другой, например, если исчерпано множество (класс set), невозможно
  перейти на потоки.</p>
<p>Далее, пока мы работаем с объектами абстрактного типа с помощью
  указателей или ссылок, теряются все преимущества виртуальных
  функций. Программа пользователя начинает зависеть от конкретных классов
  реализации. Действительно, не зная размера объекта, даже при
  абстрактном типе нельзя разместить объект в стеке, передать как параметр
  по значению или разместить как статический. Если работа с объектами
  организована через указатели или ссылки, то задача распределения
  памяти перекладывается на пользователя (п.<a href='#memory'>13.10</a>).</p>
<p>Существует и другое ограничение, связанное с использованием абстрактных
  типов. Объект такого класса всегда имеет определенный размер,
  но классы, отражающие реальное понятие, могут требовать память
  разных размеров.</p>
<p>Есть распространенный прием преодоления этих трудностей, а именно,
  разбить отдельный объект на две части: управляющую, которая определяет
  интерфейс объекта, и содержательную, в которой находятся все
  или большая часть атрибутов объекта. Связь между двумя частями
  реализуется с помощью указателя в управляющей части на содержательную
  часть. Обычно в управляющей части кроме указателя есть
  и другие данные, но их немного. Суть в том, что состав управляющей
  части не меняется при изменении содержательной части, и она
  настолько мала, что можно свободно работать с самими объектами,
  а не с указателями или ссылками на них.</p>
<pre>
          управляющая часть           содержательная часть
</pre>
<p>Простым примером управляющего класса может служить класс string из
  п.<a href="chap7.shtml#assign">7.6</a>. В нем содержится интерфейс, контроль 
доступа и управление
  памятью для содержательной части. В этом примере управляющая и
  содержательная части представлены конкретными типами, но чаще
  содержательная часть представляется абстрактным классом.</p>
<p>Теперь вернемся к абстрактному типу set из п.<a href='#abstr'>13.3</a>. 
Как можно  определить управляющий класс для этого типа, и какие это даст плюсы
  и минусы? Для данного класса set можно определить управляющий
  класс просто перегрузкой операции ->:</p>
<pre>
           class set_handle {
              set* rep;
           public:
              set* operator->() { return rep; }

              set_handler(set* pp) : rep(pp) { }
           };
</pre>
<p>Это не слишком влияет на работу с множествами, просто передаются
  объекты типа set_handle вместо объектов типа set& или set*,
  например:</p>
<pre>
           void my(set_handle s)
           {
             for (T* p = s->first(); p; p = s->next())
             {
                // ...
             }
             // ...
           }

           void your(set_handle s)
           {
             for (T* p = s->first(); p; p = s->next())
             {
               // ...
             }
             // ...
           }

           void user()
           {
             set_handle sl(new slist_set);
             set_handle v(new vector_set v(100));

             my(sl);
             your(v);

             my(v);
             your(sl);
           }
</pre>
<p>Если классы set и set_handle разрабатывались совместно,легко
  реализовать подсчет числа создаваемых множеств:</p>
<pre>
           class set {
           friend class set_handle;
           protected:
             int handle_count;
           public:
             virtual void insert(T*) = 0;
             virtual void remove(T*) = 0;

             virtual int is_member(T*) = 0;

             virtual T* first() = 0;
             virtual T* next() = 0;

             set() : handle_count(0) { }
           };
</pre>
<p>Чтобы подсчитать число объектов данного типа set, в управляющем
  классе нужно увеличивать или уменьшать значение счетчика
  set_handle:</p>
<pre>
           class set_handle {
             set* rep;
           public:
             set* operator->() { return rep; }

           set_handle(set* pp)
              : rep(pp) { pp->handle_count++; }
           set_handle(const set_handle& r)
              : rep(r.rep) { rep->handle_count++; }

           set_handle& operator=(const set_handle& r)
           {
              rep->handle_count++;
              if (--rep->handle_count == 0) delete rep;
              rep = r.rep;
              return *this;
            }

            ~set_handle()
               { if (--rep->handle_count == 0) delete rep; }
          };
</pre>
<p>Если все обращения к классу set обязательно идут через
  set_handle, пользователь может не беспокоиться о распределении
  памяти под объекты типа set.</p>
<p>На практике иногда приходится извлекать указатель на содержательную
  часть из управляющего класса и пользоваться непосредственно им.
  Можно, например, передать такой указатель функции, которая ничего
  не знает об управляющем классе. Если функция не уничтожает объект,
  на который она получила указатель, и если она не сохраняет указатель
  для дальнейшего использования после возврата, никаких ошибок быть
  не должно. Может оказаться полезным переключение управляющего класса
  на другую содержательную часть:</p>
<pre>
            class set_handle {
              set* rep;
            public:
              // ...

            set* get_rep() { return rep; }

            void bind(set* pp)
            {
              pp->handle_count++;
              if (--rep->handle_count == 0) delete rep;
              rep = pp;
            }
         };
</pre>
<p>Создание новых производных от set_handle классов обычно не имеет
  особого смысла, поскольку это - конкретный тип без виртуальных
  функций. Другое дело - построить управляющий класс для семейства
  классов, определяемых одним базовым. Полезным приемом будет
  создание производных от такого управляющего класса. Этот прием можно
  применять как для узловых классов, так и для абстрактных типов.</p>
<p>Естественно задавать управляющий класс как шаблон типа:</p>
<pre>
          template<class T> class handle {
             T* rep;
          public:
             T* operator->() { return rep; }
             // ...
          };
</pre>
<p>Но при таком подходе требуется взаимодействие между
  управляющим и "управляемым" классами. Если управляющий и управляемые
  классы разрабатываются совместно, например, в процессе создания
  библиотеки, то это может быть допустимо. Однако, существуют и другие
  решения (п.<a href='#memory'>13.10</a>).</p>
<p>За счет перегрузки операции -> управляющий класс получает
  возможность контроля и выполнения каких-то операций при каждом
  обращении к объекту. Например, можно вести подсчет частоты
  использования объектов через управляющий класс:</p>
<pre>
          template<class T>
             class Xhandle {
               T* rep;
               int count;
             public:
               T* operator->() { count++; return rep; }

               // ...
             };
</pre>
<p>Нужна более сложная техника, если требуется выполнять операции как
  перед, так и после обращения к объекту. Например, может потребоваться
  множество с блокировкой при выполнении операций добавления к
  множеству и удаления из него. Здесь, по сути, в управляющем классе
  приходится дублировать интерфейс с объектами содержательной части:</p>
<pre>
             class set_controller {
               set* rep;
               // ...
             public:

               lock();
               unlock();

               virtual void insert(T* p)
                 { lock(); rep->insert(p); unlock(); }
               virtual void remove(T* p)
                 { lock(); rep->remove(p); unlock(); }

               virtual int is_member(T* p)
                 { return rep->is_member(p); }

               virtual T* first() { return rep->first(); }
               virtual T* next() { return rep->next(); }

               // ...
             };
</pre>
<p>Писать функции-переходники для всего интерфейса утомительно (а значит
  могут появляться ошибки), но не трудно и это не ухудшает
  характеристик  программы.</p>
<p>Заметим, что не все функции из set следует блокировать. Как
  показывает опыт автора, типичный случай, когда операции до и после
  обращения к объекту надо выполнять не для всех, а только для некоторых
  функций-членов. Блокировка всех операций, как это делается в
  мониторах некоторых операционных систем, является избыточной и может
  существенно ухудшить параллельный режим выполнения.</p>
<p>Переопределив все функции интерфейса в управляющем классе, мы
  получили по сравнению с приемом перегрузки операции ->, то
  преимущество, что теперь можно строить производные
  от set_controller классы. К сожалению, мы можем потерять и некоторые
  достоинства управляющего класса, если к производным классам будут
  добавляться члены, представляющие данные. Можно сказать, что
  программный объем, который разделяется между управляемыми классами
  уменьшается по мере роста программного объема управляющего класса.</p>


<a name="memory"></a><h4>13.10 Управление памятью</h4>

<p>При проектировании библиотеки или просто программы с большим временем
  счета один из ключевых вопросов связан с управлением памятью.
  В общем случае создатель библиотеки не знает, в каком окружении она
  будет работать. Будет ли там ресурс памяти настолько критичен, что ее
  нехватка станет серьезной проблемой, или же серьезной помехой станут
  накладные расходы, связанные с управлением памятью?</p>
<p>Один из  основных вопросов управления памятью можно сформулировать
  так: если функция f() передает или возвращает указатель на объект, то
  кто должен уничтожать этот объект?  Необходимо ответить и на связанный
  с ним вопрос: в какой момент объект может быть уничтожен? Ответы на эти
  вопросы особенно важны для создателей и пользователей таких контейнеров,
  как списки, массивы и ассоциативные массивы. С точки зрения
  создателя библиотеки идеальными будут ответы: "Система" и "В тот момент,
  когда объект больше никто не использует". Когда система уничтожает
  объект, обычно говорят, что она занимается сборкой мусора, а та часть
  системы, которая определяет, что объект больше никем не используется,
  и уничтожает его, называется сборщиком мусора.</p>
<p>К сожалению, использование сборщика мусора может повлечь за собой
  накладные расходы на время счета и память, прерывания полезных
  функций, определенную аппаратную поддержку, трудности связывания
  частей программы на разных языках или просто усложнение системы.
  Многие пользователи не могут позволить себе этого.+</p>

<p>+ Говорят, что программисты на Лиспе знают, насколько важно управление
  памятью, и поэтому не могут отдать его пользователю. Программисты
  на С тоже знают, насколько важно управление памятью, и поэтому не
  могут оставить его системе.</p>

<p>Поэтому в большинстве программ на С++ не приходится рассчитывать
  на сборщик мусора и нужно предложить свою стратегию размещения
  объектов в свободной памяти, не обращаясь к системе. Но реализации
  С++ со сборщиком мусора все-таки существуют.</p>
<p>Рассмотрим самую простую схему управления памятью для программ
  на С++. Для этого заменим operator new() на тривиальную функцию
  размещения, а operator delete() - на пустую функцию:</p>
<pre>
   inline size_t align(size_t s)
   /*
      Даже в простой функции размещения нужно
      выравнивание памяти, чтобы на объект
      можно было настроить указатель
      произвольного типа
   */
   {
     union Word { void* p; long double d; long l; }

     int x = s + sizeof(Word) - 1;
     x -= x%sizeof(Word);
     return x;
   }

   static void* freep; // настроим start на свободную память

   void* operator  new(size_t s) // простая линейная функция размещения
   {
     void* p = freep;
     s = align(s);
     freep += s;
     return p;
   }

   void operator delete(void*) { }  // пусто
</pre>
<p>Если память бесконечна, то наше решение дает сборщик мусора без
  всяких сложностей и накладных расходов. Такой подход не применим
  для библиотек, когда заранее неизвестно, каким образом будет
  использоваться память, и когда программа, пользующаяся библиотекой,
  будет иметь большое время счета. Такой способ выделения памяти
  идеально подходит для программ, которым требуется ограниченный объем
  памяти или объем, пропорциональный размеру входного потока данных.</p>

<a name="garbage"></a><h5>13.10.1 Сборщик мусора</h5>

<p>Сборку мусора можно рассматривать как моделирование бесконечной
  памяти на памяти ограниченного размера. Помня об этом, можно
  ответить на типичный вопрос: должен ли сборщик мусора вызывать
  деструктор для тех объектов, память которых он использует? Правильный
  ответ - нет, поскольку, если размещенный в свободной памяти объект
  не был удален, то он не будет и уничтожен. Исходя из этого, операцию
  delete можно рассматривать как запрос на вызов деструктора (и еще это
  - сообщение системе, что память объекта можно использовать). Но как
  быть, если действительно требуется уничтожить размещенный в свободной
  памяти объект, который не был удален? Заметим, что для
  статических и автоматических объектов такой вопрос не встает, -
  деструкторы для них неявно вызываются всегда. Далее, уничтожение
  объекта "во время сборки мусора" по сути является
  операцией с непредсказуемым результатом. Она может совершиться
  в любое время между последним использованием объекта и "концом
  программы"+, а значит, в каком состоянии будет программа в этот момент
  неизвестно.</p>

<p>+ Здесь использованы кавычки, потому что трудно точно определить,
  что такое конец программы. (прим. перев.)</p>

<p>Трудно правильно запрограммировать такие операции и они не так полезны,
  как кажется.</p>
<p>Задачу уничтожения объектов, если время этой операции точно не задано,
  можно решить с помощью программы обслуживания заявок на уничтожение. Назовем
  ее сервером заявок. Если объект необходимо уничтожить в конце программы,
  то надо записать в глобальный ассоциативный массив его адрес и
  указатель на функцию "очистки". Если объект удален явной операцией,
  заявка аннулируется. При уничтожении самого сервера (в конце
  программы) вызываются функции очистки для всех оставшихся заявок.
  Это решение подходит и для сборки мусора, поскольку мы рассматриваем
  ее как моделирование бесконечной памяти. Для сборщика мусора нужно
  выбрать одно из двух решений: либо удалять объект, когда единственной
  оставшейся ссылкой на него будет ссылка, находящаяся в массиве самого
  сервера, либо (стандартное решение) не удалять объект до конца
  программы, поскольку все-таки ссылка на него есть.</p>
<p>Сервер заявок можно реализовать как ассоциативный массив 
(п.<a href="chap8.shtml#associad">8.8</a>):</p>
<pre>
           class Register {
               Map<void*, void (*) (void*)> m;
           public:
               insert(void* po, void(*pf)()) { m[po]=pf; }
               remove(void* po) { m.remove(po); }
           };

           Register cleanup_register;
</pre>
<p>Класс, постоянно обращающийся к серверу, может выглядеть так:</p>
<pre>
           class X {
             // ...
             static void cleanup(void*);
           public:


            X()
            {
              cleanup_register.insert(this,&cleanup);
              // ...
            }


            ~X() { cleanup(this); }

             // ...
           };

           void X::cleanup(void* pv)
           {
             X* px = (X*)pv;
             cleanup_register.remove(pv);
             // очистка
           }
</pre>
<p>Чтобы в классе Register не иметь дела с типами, мы использовали
  статическую функцию-член с указателем типа void*.</p>

<a name="contain"></a><h5>13.10.2 Контейнеры и удаление</h5>

<p>Допустим, что у нас нет бесконечной памяти и сборщика мусора. На какие
  средства управления памятью может рассчитывать создатель
  контейнера, например, класса Vector? Для случая таких простых элементов,
  как int, очевидно, надо просто копировать их в контейнер. Столь же
  очевидно, что для других типов, таких, как абстрактный класс Shape,
  в контейнере следует хранить указатель. Создатель библиотеки
  должен предусмотреть оба варианта. Приведем набросок очевидного
  решения:</p>
<pre>
             template<class T> Vector {
                T* p;
                int sz;
             public:
                Vector(int s) { p = new T[sz=s]; }
                // ...
             };
</pre>
<p>Если пользователь не будет заносить в контейнер вместо указателей на
  объекты сами объекты типа Shape, то это решение подходит для обоих
  вариантов.</p>
<pre>
             Vector<Shape*> vsp(200);  // нормально
             Vector<Shape> vs(200);    // ошибка при трансляции
</pre>
<p>К счастью, транслятор отслеживает попытку создать массив объектов
  абстрактного базового класса Shape.
     Однако, если используются указатели, создатель библиотеки и
  пользователь должны договориться, кто будет удалять хранимые
  в контейнере объекты. Рассмотрим пример:</p>
<pre>
             void f()
                  // противоречивое использование средств
                  // управления памятью
             {
               Vector<Shape*> v(10);
               Circle* cp = new Circle;
               v[0] = cp;
               v[1] = new Triangle;
               Square s;
               v[2] = &s;
               delete cp; // не удаляет объекты, на которые настроены
                          // указатели, находящиеся в контейнере
              }
</pre>
<p>Если использовать реализацию класса Vector из 
п.<a href="chap1.shtml#except">1.4.3</a>, объект
  Triangle в этом примере навсегда останется в подвешенном состоянии
  (на него нет указателей), если только нет сборщика мусора.
  Главное в управлении памятью это - это корректность. Рассмотрим такой
  пример:</p>
<pre>
              void g()
              // корректное использование средств управления памятью
              {
                Vector<Shape*> v(10);
                Circle* cp = new Circle;
                v[0] = cp;
                v[1] = new Triangle;
                Square s;
                v[2] = &s;
                delete cp;
                delete v[1];
              }
</pre>
<p>Рассмотрим теперь такой векторный класс,который следит за удалением
  занесенных в него указателей:</p>
<pre>
             template<class T> MVector {
               T* p;
               int sz;
             public:
               MVector(int s);
               ~MVector();
               // ...
             };

             template<class T> MVector<T>::MVector(int s)
             {
               // проверка s
               p = new T[sz=s];
               for (int i = 0; i<s; i++) p[i] = 0;
             }

             template<class T> MVector<T>::~MVector()
             {
               for (int i = 0; i<s; i++) delete p[i];
               delete p;
             }
<p>
</pre>
Пользователь может рассчитывать, что содержащиеся в MVector указатели
  будут удалены. Отсюда следует, что после удаления MVector пользователь
  не должен обращаться с помощью указателей к объектам, заносившимся в этот
  контейнер. В момент уничтожения MVector в нем не должно быть
  указателей на статические или автоматические объекты, например:</p>
<pre>
             void h()
             // корректное использование средств управления памятью
            {
               MVector<Shape*> v(10);
               Circle* cp = new circle();
               v[0] = cp;
               v[1] = new Triangle;
               Square s;
               v[2] = &s;
               v[2] = 0;  // предотвращает удаление s

               // все оставшиеся указатели
               // автоматически удаляются при выходе
             }
</pre>
<p>Естественно, такое решение годится только для контейнеров, в
  которых не содержатся копии объектов, а для класса Map 
(п.<a href="chap8.shtml#associad">8.8</a>),
  например, оно не годится. Здесь приведен простой вариант деструктора
  для MVector, но содержится ошибка, поскольку один и тот же указатель,
  дважды занесенный в контейнер, будет удаляться тоже два раза.</p>
<p>Построение и уничтожение таких контейнеров, которые следят
  за удалением содержащихся в них объектах, довольно дорогостоящая
  операция. Копирование же этих контейнеров следует запретить
  или, по крайней мере, сильно ограничить (действительно, кто
  будет отвечать за удаление контейнер или его копия?):</p>
<pre>
            template<class T> MVector {
               // ...
            private:
               MVector(const MVector&); //предотвращает копирование
               MVector& operator=(const MVector&); //то же самое
               // ...
            };
</pre>
<p>Отсюда следует, что такие контейнеры надо передавать по ссылке
  или указателю (если, вообще, это следует делать), но тогда в управлении
  памятью возникает трудность другого рода.</p>
<p>Часто бывает полезно уменьшить число указателей, за которыми
  должен следить пользователь. Действительно, намного проще следить
  за 100 объектами первого уровня, которые, в свою очередь, управляют
  1000 объектов нулевого уровня, чем непосредственно работать с
  1100 объектами. Собственно, приведенные в этом разделе приемы,
  как и другие приемы, используемые для управления памятью, сводятся
  к стандартизации и универсализации за счет применения  конструкторов
  и деструкторов. Это позволяет свести задачу
  управления памятью для практически невообразимого числа объектов,
  скажем 100 000, до вполне управляемого числа, скажем 100.</p>
<p>Можно ли  таким образом определить класс контейнера, чтобы
  программист, создающий объект типа контейнера, мог выбрать
  стратегию управления памятью из нескольких возможных, хотя определен
  контейнер только одного типа? Если это возможно, то будет ли оправдано?
  На второй вопрос ответ положительный, поскольку большинство функций
  в системе вообще не должны заботиться о распределении памяти.
  Существование же нескольких разных типов для каждого контейнерного
  класса является для пользователя ненужным усложнением. В библиотеке должен
  быть или один вид контейнеров (Vector или MVector), или же оба, но
  представленные как варианты одного типа, например:</p>
<pre>
             template<class T> PVector {
                T** p;
                int sz;
                int managed;
             public:
                PVector(int s, int managed = 0 );
                ~PVector();
                // ...
             };

             template<class T> PVector<T>::PVector(int s, int m)
             {
               // проверка s
               p = new T*[sz=s];
               if (managed = m)
                  for (int i = 0; i<s; i++) p[i] = 0;
             }

             template<class T> PVector<T>::~PVector()
             {
               if (managed) {
                  for (int i = 0; i<s; i++) delete p[i];
               }
               delete p;
             }
<p>
</pre>
Примером класса, который может предложить библиотека для облегчения
  управления памятью, является управляющий класс из 
п.<a href='#manager'>13.9</a>. Раз в
  управляющем классе ведется подсчет ссылок на него, можно спокойно
  передавать объект этого класса, не думая о том, кто будет
  удалять доступные через него объекты. Это сделает сам объект управляющего
  класса. Но такой подход требует, чтобы в управляемых объектах было поле
  для подсчета числа использований. Введя дополнительный объект, можно
  просто снять это жесткое требование:</p>
<pre>
             template<class T>
             class Handle {
                T* rep;
                int* pcount;
             public:
                T* operator->() { return rep; }

                Handle(const T* pp)
                  : rep(pp), pcount(new int) { (*pcount) = 0; }
                Handle(const Handle& r)
                  : rep(r.rep), pcount(r.count) { (*pcount)++; }

                void bind(const Handle& r)
                {
                  if (rep == r.rep) return;
                  if (--(*pcount) == 0) { delete rep; delete pcount; }
                  rep = r.rep;
                  pcount = r.pcount;
                  (*pcount)++;
                }

                Handle& operator=(const Handle& r)
                {
                  bind(r);
                  return *this;
                }

                ~Handle()
                {
                  if (--(*pcount) == 0) { delete rep; delete pcount; }
                }
              };
</pre>
<p>
<a name="func"></a><h5>13.10.3 Функции размещения и освобождения</h5>

<p>Во всех приведенных примерах память рассматривалась как нечто данное.
  Однако, обычная функция общего назначения для распределения свободной
  памяти оказывается до удивления менее эффективной, чем функция размещения
  специального назначения. Вырожденным случаем таких функций можно
  считать приведенный пример с размещением в "бесконечной" памяти и
  с пустой функцией освобождения. В библиотеке могут быть более
  содержательные функции размещения, и бывает, что с их помощью
  удается удвоить скорость выполнения программы. Но прежде, чем пытаться
  с их помощью оптимизировать программу, запустите для нее профилировщик,
  чтобы выявить накладные расходы, связанные с выделением памяти.</p>
<p>В разделах п.<a href="chap5.shtml#litlobj">5.5.6</a> и 
п.<a href="chap6.shtml#freemem">6.7</a> было показано как с помощью определения
  функций X::operator new() и X::operator delete() можно использовать
  функцию размещения для объектов класса X. Здесь есть определенная
  трудность. Для двух классов X и Y функции размещения могут быть
  настолько сходными, что желательно иметь одну такую функцию.
  Иными словами, желательно иметь в библиотеке такой класс, который
  предоставляет функции размещения и освобождения, пригодные для размещения
  объектов данного класса. Если такой класс есть, то функции размещения
  и освобождения для данного класса получаются за счет привязки к нему
  общих функций размещения и освобождения:</p>
<pre>
             class X {
                static Pool my_pool;
                // ...
             public:
                // ...
               void* operator new(size_t) { return my_pool.alloc(); }
               void operator delete(void* p) { my_pool.free(p); }
             };

             Pool X::my_pool(sizeof(X));
</pre>
<p>С помощью класса Pool память распределяется блоками одного размера.
  В приведенном примере объект my_pool отводит память блоками
  размером sizeof(X).</p>
<p>Составляется описание класса X и используется Pool с учетом оптимизации
  скорости программы и компактности представления. Обратите внимание,
  что размер выделяемых блоков памяти является для класса "встроенным",
  поэтому задающий размер параметр функции X::operator new() не
  используется. Используется вариант функции X::operator delete()
  без параметра. Если класс Y является производным класса X, и
  sizeof(Y)>sizeof(X), то для класса Y должны быть свои функции
  размещения и освобождения. Наследование функций класса X приведет
  к катастрофе. К счастью, задать такие функции для Y очень просто.</p>
<p>Класс Pool предоставляет связанный список элементов требуемого
  размера. Элементы выделяются из блока памяти фиксированного размера
  и по мере надобности запрашиваются новые блоки памяти. Элементы
  группируются большими блоками, чтобы минимизировать число обращений
  за памятью к функции размещения общего назначения. До тех пор пока
  не будет уничтожен сам объект PooL, память никогда не возвращается
  функции размещения общего назначения.</p>
<p>Приведем описание класса Pool:</p>
<pre>
           class Pool {

              struct Link { Link* next; }

              const unsigned esize;
              Link* head;

              Pool(Pool&);            // защита от копирования
              void operator= (Pool&); // защита от копирования
              void grow();
            public:
              Pool(unsigned n);
              ~Pool();

              void* alloc();
              void free(void* b);
            };

            inline void* Pool::alloc()
            {
              if (head==0) grow();
              Link* p = head;
              head = p->next;
              return p;
            }

            inline void Pool::free(void* b)
            {
              Link* p = (Link*) b;
              p->next = head;
              head = p;
            }
</pre>
<p>Приведенные описания логично поместить в заголовочный файл Pool.h.
  Следующие определения могут находиться в любом месте программе и
  завершают наш пример. Объект Pool должен инициализироваться
  конструктором:</p>
<pre>
            Pool::Pool(unsigned sz)
              : esize(sz)
            {
              head = 0;
            }
</pre>
<p>Функция Pool::grow() будет связывать все элементы в список квантов
  свободной памяти head, образуя из них новый блок. Определения
  остальных функций-членов оставлены в качестве упражнений 5 и 6 в
  п.<a href='#exercise'>13.11</a>.</p>
<pre>
            void Pool::grow()
            {
              const int overhead = 12;
              const int chunk_size = 8*1024-overhead;
              const int nelem = (chunk_size-esize)/esize;

              char* start = new char[chunk_size];
              char* last = &start[(nelem-1)*esize];

              for (char* p = start; p<last; p+=esize)
                  ((Link*)p)->next = ((Link*)p)+1;
              ((Link*)last)->next = 0;
              head = (Link*)start;
            }
</pre>
<p>
<a name="exercise"></a><h4>13.11 Упражнения</h4>

<ol>
<li>(*3) Завершите определения функций-членов класса Type_info.
<li>(*3) Предложите такую структуру объекта Type_info, чтобы функция
     Type_info::get_info() стала лишней, и перепишите с учетом этого
     функции-члены Type_info.
<li>(*2.5) Насколько наглядно вы сможете записать примеры с Dialog_box,
     не используя макроопределения (а также расширения языка)? Насколько
     наглядно вам удастся записать их, используя расширения языка?
<li>(*4) Исследуйте две широко распространенные библиотеки.
     Классифицируйте все библиотечные классы, разбив их на: конкретные
     типы, абстрактные типы, узловые классы, управляющие классы и
     интерфейсные классы. Используются ли абстрактные узловые классы
     и конкретные узловые классы? Можно ли предложить более подходящее
     разбиение классов этих библиотек? Используется ли обширный
     интерфейс? Какие имеются средства  динамической информации о типе
     (если они есть)? Какова стратегия управления памятью?
<li>(*3) Определите шаблонный вариант класса Pool из 
п.<a href='#func'>13.10.3</a>. Пусть
     размер выделяемого элемента памяти будет параметром шаблона
     типа, а не конструктора.
<li>(*2.5) Усовершенствуйте шаблон типа Pool из предыдущего упражнения
     так, чтобы некоторые элементы размещались во время работы конструктора.
     Сформулируйте в чем будет проблема переносимости, если использовать
     Pool с типом элементов char, покажите как ее устранить.
<li>(*3) Если ваша версия С++ прямо не поддерживает динамические
     запросы о типе, обратитесь к своей основной библиотеке. Реализован
     ли там механизм динамических запросов о типе? Если это так,
     задайте операции из п.<a href='#dinamic'>13.5</a> как надстройку над этим 
механизмом.
<li>(*2.5) Определите такой строковый класс, в котором нет никакого
     динамического контроля, и второй производный от него строковый
     класс, который только проводит динамический контроль и обращается
     к первому. Укажите плюсы и минусы такого решения по сравнению
     с решением,в котором делается выборочный динамический контроль,
     сравните с подходом, использующим инварианты, как было предложено
     в п.<a href="chap12.shtml#invar">12.2.7.1</a>. 
Насколько можно совмещать эти подходы?
<li>(*4) Определите класс Storable как абстрактный базовый класс с
     виртуальными функциями writeout() и readin(). Для простоты
     допустим, что для задания нужного адресного пространства достаточно
     строки символов. С помощью класса Storable реализуйте
     обмен объектами с диском. Проверьте его на объектах нескольких
     классов по своему усмотрению.
<li>(*4) Определите базовый класс Persistent с операциями save()
     и nosave(), который будет проверять, что деструктор создал объект
     в определенной памяти. Какие еще полезные операции можно предложить?
     Проверьте класс Persistent на нескольких классах по своему выбору.
     Является ли класс Persistent узловым классом, конкретным или
     абстрактным типом? Аргументируйте ответ.
<li>(*3) Составьте только описание класса stack, который реализует
     стек с помощью операций create() (создать стек), delete()
     (уничтожить стек), push() (записать в стек) и pop() (читать из
     стека). Используйте только статические члены. Для привязки и
     обозначения стеков определите класс id. Гарантируйте, что
     пользователь сможет копировать объекты stack::id, но не сможет
     работать с ними иным способом. Сравните это определение стека
     с классом stack из п.<a href="chap8.shtml#simple">8.2</a>.
<li>(*3) Составьте описание класса stack, который является абстрактным
     типом (п.<a href='#abstr'>13.3</a>). Предложите две различные реализации 
для интерфейса,
     заданного stack. Напишите небольшую программу, работающую с
     этими классами. Сравните это решение с классами, определяющими
     стек, из предыдущего упражнения и из 
п.<a href="chap8.shtml#simple">8.2</a>.
<li>(*3) Составьте такое описание класса stack, для которого можно
     в динамике менять реализацию. Подсказка: "Всякую задачу можно
      решить, введя еще одну косвенность".
<li>(*3.5) Определите класс Oper, содержащий идентификатор (некоторого
     подходящего типа) и операцию (некоторый указатель на функцию).
     Определите класс cat_object, содержащий список объектов Oper и
     объект типа void*. Задайте в классе cat_object операции:
     add_oper(), которая добавляет объект к списку; remove_oper(id),
     которая удаляет из списка объект Oper c идентификатором id;
     operator() (id,arg), которая вызывает функцию из объекта Oper c
     идентификатором id. Реализуйте с помощью класса cat_object
     стек объектов Oper. Напишите небольшую программу, работающую
     с этими классами.
<li>(*3) Определите шаблон типа Object, служащий базовым классом
     для cat_object. С помощью Object реализуйте стек для объектов
     класса String. Напишите небольшую программу, использующую этот
     шаблон типа.
<li>(*3) Определите вариант класса Object под именем Class, в котором
     объекты с одинаковым идентификатором имеют общий список операций.
     Напишите небольшую программу, использующую этот шаблон типа.
<li>(*3) Определите шаблон типа Stack, который задает традиционный
     и надежный интерфейс со стеком, реализуемым объектом шаблона
     типа Object. Сравните это определение стека с классами, задающими
     стек, из предыдущих упражнений. Напишите небольшую программу,
     использующую этот шаблон типа.
</ol>

<p align=center>
<A HREF="#" onclick="history.back(); return false;">Назад</a>
<A HREF="index.shtml">Оглавление</a>
<A HREF="crossref.shtml">Вперед</a>
</p>

<!----- END MAIN CONTENT ------->
     </td>
    </tr>
   </table>			
  </TD>
 </TR>
 <TR><TD WIDTH="161"></td><TD><br><br>
<table width='100%' border='0' cellspacing='0' cellpadding='0' bgcolor='#ffffff'>
<TR><td><Center><A HRef='#top'><Img Src='/images/2top.gif' Border='0'></A><Br><Br>
<P class=tiny>&#169; 2000 Инфор Текнолоджи. All Rights Reserved.<P></Center>
</td></TR></TABLE><BR>

</TD></TR>
</TABLE>
</BODY>
</HTML>